; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?cw_memcpy@@YAHPEADPEB_WH@Z			; cw_memcpy
PUBLIC	?cw_memcpy@@YAHPEA_WPEBDH@Z			; cw_memcpy
PUBLIC	?cw_memcpy@@YAHPEADPEBDH@Z			; cw_memcpy
PUBLIC	?cw_memcpy@@YAHPEA_WPEB_WH@Z			; cw_memcpy
PUBLIC	?cw_memset@@YAXPEADDH@Z				; cw_memset
PUBLIC	?cw_memset@@YAXPEA_W_WH@Z			; cw_memset
PUBLIC	?cw_strlen@@YAHPEBD@Z				; cw_strlen
PUBLIC	?cw_strlen@@YAHPEB_W@Z				; cw_strlen
PUBLIC	?cw_strcpy@@YAHPEADPEB_W@Z			; cw_strcpy
PUBLIC	?cw_strcpy@@YAHPEA_WPEBD@Z			; cw_strcpy
PUBLIC	?cw_strcpy@@YAHPEADPEBD@Z			; cw_strcpy
PUBLIC	?cw_strcpy@@YAHPEA_WPEB_W@Z			; cw_strcpy
PUBLIC	?cw_strcat@@YAHPEADPEB_W@Z			; cw_strcat
PUBLIC	?cw_strcat@@YAHPEA_WPEBD@Z			; cw_strcat
PUBLIC	?cw_strcat@@YAHPEADPEBD@Z			; cw_strcat
PUBLIC	?cw_strcat@@YAHPEA_WPEB_W@Z			; cw_strcat
PUBLIC	?cw_dup@@YAXPEBDAEAHAEAPEA_W1@Z			; cw_dup
PUBLIC	?cw_dup@@YAXPEB_WAEAHAEAPEAD1@Z			; cw_dup
PUBLIC	?DupChar@_CW@@AEAAXXZ				; _CW::DupChar
PUBLIC	?DupWide@_CW@@AEAAXXZ				; _CW::DupWide
PUBLIC	?GetCharsMbcs@_CW@@QEAAHXZ			; _CW::GetCharsMbcs
PUBLIC	?GetCharsWide@_CW@@QEAAHXZ			; _CW::GetCharsWide
EXTRN	??_U@YAPEAX_K@Z:PROC				; operator new[]
EXTRN	__imp_MultiByteToWideChar:PROC
EXTRN	__imp_WideCharToMultiByte:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_memcpy@@YAHPEADPEB_WH@Z DD imagerel $LN16
	DD	imagerel $LN16+95
	DD	imagerel $unwind$?cw_memcpy@@YAHPEADPEB_WH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_memcpy@@YAHPEA_WPEBDH@Z DD imagerel $LN16
	DD	imagerel $LN16+76
	DD	imagerel $unwind$?cw_memcpy@@YAHPEA_WPEBDH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_memcpy@@YAHPEA_WPEB_WH@Z DD imagerel $LN14
	DD	imagerel $LN14+64
	DD	imagerel $unwind$?cw_memcpy@@YAHPEA_WPEB_WH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_strcpy@@YAHPEADPEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$?cw_strcpy@@YAHPEADPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_strcpy@@YAHPEA_WPEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$?cw_strcpy@@YAHPEA_WPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_strcpy@@YAHPEADPEBD@Z DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$?cw_strcpy@@YAHPEADPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_strcpy@@YAHPEA_WPEB_W@Z DD imagerel $LN4
	DD	imagerel $LN4+20
	DD	imagerel $unwind$?cw_strcpy@@YAHPEA_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_strcat@@YAHPEADPEB_W@Z DD imagerel $LN13
	DD	imagerel $LN13+53
	DD	imagerel $unwind$?cw_strcat@@YAHPEADPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_strcat@@YAHPEA_WPEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+60
	DD	imagerel $unwind$?cw_strcat@@YAHPEA_WPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_strcat@@YAHPEADPEBD@Z DD imagerel $LN13
	DD	imagerel $LN13+53
	DD	imagerel $unwind$?cw_strcat@@YAHPEADPEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_strcat@@YAHPEA_WPEB_W@Z DD imagerel $LN13
	DD	imagerel $LN13+60
	DD	imagerel $unwind$?cw_strcat@@YAHPEA_WPEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_dup@@YAXPEBDAEAHAEAPEA_W1@Z DD imagerel $LN31
	DD	imagerel $LN31+224
	DD	imagerel $unwind$?cw_dup@@YAXPEBDAEAHAEAPEA_W1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cw_dup@@YAXPEB_WAEAHAEAPEAD1@Z DD imagerel $LN31
	DD	imagerel $LN31+222
	DD	imagerel $unwind$?cw_dup@@YAXPEB_WAEAHAEAPEAD1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DupChar@_CW@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$?DupChar@_CW@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DupWide@_CW@@AEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+39
	DD	imagerel $unwind$?DupWide@_CW@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCharsMbcs@_CW@@QEAAHXZ DD imagerel $LN16
	DD	imagerel $LN16+65
	DD	imagerel $unwind$?GetCharsMbcs@_CW@@QEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetCharsWide@_CW@@QEAAHXZ DD imagerel $LN17
	DD	imagerel $LN17+67
	DD	imagerel $unwind$?GetCharsWide@_CW@@QEAAHXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCharsWide@_CW@@QEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetCharsMbcs@_CW@@QEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DupWide@_CW@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DupChar@_CW@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_dup@@YAXPEB_WAEAHAEAPEAD1@Z DD 0a1901H
	DD	0d7419H
	DD	0c6419H
	DD	0b5419H
	DD	0a3419H
	DD	0e0157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_dup@@YAXPEBDAEAHAEAPEA_W1@Z DD 0a1901H
	DD	0b7419H
	DD	0a6419H
	DD	095419H
	DD	083419H
	DD	0e0155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_strcat@@YAHPEA_WPEB_W@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_strcat@@YAHPEADPEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_strcat@@YAHPEA_WPEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_strcat@@YAHPEADPEB_W@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_strcpy@@YAHPEA_WPEB_W@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_strcpy@@YAHPEADPEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_strcpy@@YAHPEA_WPEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_strcpy@@YAHPEADPEB_W@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_memcpy@@YAHPEA_WPEB_WH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_memcpy@@YAHPEA_WPEBDH@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cw_memcpy@@YAHPEADPEB_WH@Z DD 010401H
	DD	08204H
xdata	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?GetCharsWide@_CW@@QEAAHXZ
_TEXT	SEGMENT
this$ = 48
?GetCharsWide@_CW@@QEAAHXZ PROC				; _CW::GetCharsWide, COMDAT

; 438  : {

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 439  :     if (m_pWide == (wchar_t*)-1)

  00006	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 83 fa ff	 cmp	 rdx, -1
  00011	75 0a		 jne	 SHORT $LN2@GetCharsWi

; 440  :         DupWide();

  00013	e8 00 00 00 00	 call	 ?DupWide@_CW@@AEAAXXZ	; _CW::DupWide
  00018	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  0001b	eb 20		 jmp	 SHORT $LN4@GetCharsWi
$LN2@GetCharsWi:

; 441  :     else if ( m_nCharsWide < 0 )

  0001d	8b 41 14	 mov	 eax, DWORD PTR [rcx+20]
  00020	33 c9		 xor	 ecx, ecx
  00022	85 c0		 test	 eax, eax
  00024	79 17		 jns	 SHORT $LN4@GetCharsWi

; 127  :     int nCount = 0;

  00026	8b c1		 mov	 eax, ecx

; 128  :     if ( pChar && *pChar )

  00028	48 85 d2	 test	 rdx, rdx
  0002b	74 0d		 je	 SHORT $LN8@GetCharsWi
  0002d	eb 06		 jmp	 SHORT $LN15@GetCharsWi
$LL9@GetCharsWi:

; 129  :     {
; 130  :         do nCount++;

  0002f	ff c0		 inc	 eax

; 131  :         while (*++pChar);

  00031	48 8d 52 02	 lea	 rdx, QWORD PTR [rdx+2]
$LN15@GetCharsWi:
  00035	66 39 0a	 cmp	 WORD PTR [rdx], cx
  00038	75 f5		 jne	 SHORT $LL9@GetCharsWi
$LN8@GetCharsWi:

; 442  :         m_nCharsWide = cw_strlen( m_pWide );

  0003a	89 43 14	 mov	 DWORD PTR [rbx+20], eax
$LN4@GetCharsWi:

; 443  :     return m_nCharsWide;
; 444  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
?GetCharsWide@_CW@@QEAAHXZ ENDP				; _CW::GetCharsWide
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?GetCharsMbcs@_CW@@QEAAHXZ
_TEXT	SEGMENT
this$ = 48
?GetCharsMbcs@_CW@@QEAAHXZ PROC				; _CW::GetCharsMbcs, COMDAT

; 429  : {

$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 430  :     if (m_pChar == (char*)-1)

  00006	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	48 83 fa ff	 cmp	 rdx, -1
  00010	75 0a		 jne	 SHORT $LN2@GetCharsMb

; 431  :         DupChar();

  00012	e8 00 00 00 00	 call	 ?DupChar@_CW@@AEAAXXZ	; _CW::DupChar
  00017	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  0001a	eb 1f		 jmp	 SHORT $LN4@GetCharsMb
$LN2@GetCharsMb:

; 432  :     else if ( m_nChars < 0 )

  0001c	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  0001f	85 c0		 test	 eax, eax
  00021	79 18		 jns	 SHORT $LN4@GetCharsMb

; 115  :     int nCount = 0;

  00023	33 c0		 xor	 eax, eax

; 116  :     if ( pChar && *pChar )

  00025	48 85 d2	 test	 rdx, rdx
  00028	74 0e		 je	 SHORT $LN8@GetCharsMb
  0002a	38 02		 cmp	 BYTE PTR [rdx], al
  0002c	74 0a		 je	 SHORT $LN8@GetCharsMb
$LL9@GetCharsMb:

; 117  :     {
; 118  :         do nCount++;
; 119  :         while (*++pChar);

  0002e	48 ff c2	 inc	 rdx
  00031	ff c0		 inc	 eax
  00033	80 3a 00	 cmp	 BYTE PTR [rdx], 0
  00036	75 f6		 jne	 SHORT $LL9@GetCharsMb
$LN8@GetCharsMb:

; 433  :         m_nChars = cw_strlen( m_pChar );

  00038	89 41 10	 mov	 DWORD PTR [rcx+16], eax
$LN4@GetCharsMb:

; 434  :     return m_nChars;
; 435  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
?GetCharsMbcs@_CW@@QEAAHXZ ENDP				; _CW::GetCharsMbcs
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?DupWide@_CW@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?DupWide@_CW@@AEAAXXZ PROC				; _CW::DupWide, COMDAT

; 423  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 424  :     cw_dup(m_pChar, m_nChars, m_pWide, m_nCharsWide);

  00009	4c 8d 49 14	 lea	 r9, QWORD PTR [rcx+20]
  0000d	4c 8d 41 08	 lea	 r8, QWORD PTR [rcx+8]
  00011	48 8d 51 10	 lea	 rdx, QWORD PTR [rcx+16]
  00015	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00018	e8 00 00 00 00	 call	 ?cw_dup@@YAXPEBDAEAHAEAPEA_W1@Z ; cw_dup

; 425  :     m_nDupFlag = 'w';

  0001d	c6 43 18 77	 mov	 BYTE PTR [rbx+24], 119	; 00000077H

; 426  : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
?DupWide@_CW@@AEAAXXZ ENDP				; _CW::DupWide
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?DupChar@_CW@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?DupChar@_CW@@AEAAXXZ PROC				; _CW::DupChar, COMDAT

; 417  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 418  :     cw_dup(m_pWide, m_nCharsWide, m_pChar, m_nChars);

  00009	4c 8d 49 10	 lea	 r9, QWORD PTR [rcx+16]
  0000d	48 8d 51 14	 lea	 rdx, QWORD PTR [rcx+20]
  00011	4c 8b c1	 mov	 r8, rcx
  00014	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00018	e8 00 00 00 00	 call	 ?cw_dup@@YAXPEB_WAEAHAEAPEAD1@Z ; cw_dup

; 419  :     m_nDupFlag = 'c';

  0001d	c6 43 18 63	 mov	 BYTE PTR [rbx+24], 99	; 00000063H

; 420  : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
?DupChar@_CW@@AEAAXXZ ENDP				; _CW::DupChar
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_dup@@YAXPEB_WAEAHAEAPEAD1@Z
_TEXT	SEGMENT
pSrc$ = 80
nSrcChars$ = 88
pTarget$ = 96
nTargetChars$ = 104
?cw_dup@@YAXPEB_WAEAHAEAPEAD1@Z PROC			; cw_dup, COMDAT

; 382  : {

$LN31:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 383  :     if ( pSrc == 0 )

  00019	33 ed		 xor	 ebp, ebp
  0001b	4d 8b f1	 mov	 r14, r9
  0001e	49 8b f0	 mov	 rsi, r8
  00021	48 8b fa	 mov	 rdi, rdx
  00024	48 8b d9	 mov	 rbx, rcx
  00027	48 85 c9	 test	 rcx, rcx
  0002a	75 0d		 jne	 SHORT $LN2@cw_dup

; 384  :     {
; 385  :         nSrcChars = nTargetChars = 0;

  0002c	41 89 29	 mov	 DWORD PTR [r9], ebp
  0002f	89 2a		 mov	 DWORD PTR [rdx], ebp

; 386  :         pTarget = 0;

  00031	49 89 28	 mov	 QWORD PTR [r8], rbp

; 387  :         return;

  00034	e9 8a 00 00 00	 jmp	 $LN4@cw_dup
$LN2@cw_dup:

; 388  :     }
; 389  : 
; 390  :     if ( nSrcChars < 0 )

  00039	8b 02		 mov	 eax, DWORD PTR [rdx]
  0003b	85 c0		 test	 eax, eax
  0003d	79 11		 jns	 SHORT $LN3@cw_dup

; 127  :     int nCount = 0;

  0003f	8b c5		 mov	 eax, ebp
  00041	eb 06		 jmp	 SHORT $LN28@cw_dup
$LL9@cw_dup:

; 129  :     {
; 130  :         do nCount++;

  00043	ff c0		 inc	 eax

; 131  :         while (*++pChar);

  00045	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
$LN28@cw_dup:
  00049	66 39 29	 cmp	 WORD PTR [rcx], bp
  0004c	75 f5		 jne	 SHORT $LL9@cw_dup

; 391  :         nSrcChars = cw_strlen( pSrc );

  0004e	89 02		 mov	 DWORD PTR [rdx], eax
$LN3@cw_dup:

; 392  :     /* ==> Implementation one -- minimize memory.
; 393  :     nTargetChars = cw_memcpy( (char*) NULL, pSrc, nSrcChars );
; 394  :         // Determine how many characters are needed.
; 395  :         //   Can't assume one-to-one (some wide chars may need 2 multibyte chars),
; 396  :         //   but don't want to waste a bunch of bytes either.
; 397  :     pTarget = new char[nTargetChars+1];
; 398  :     */
; 399  :     /* ==> Implementation two -- maximize speed, with side effect of allocating up
; 400  :     **      to twice the memory needed (worst case when no multibyte chars needed).
; 401  :     **     Chose this because most converted strings will be short-lived.
; 402  :     */
; 403  :     pTarget = new char[(nSrcChars+1)*2];

  00050	8d 04 45 02 00
	00 00		 lea	 eax, DWORD PTR [rax*2+2]
  00057	48 63 c8	 movsxd	 rcx, eax
  0005a	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  0005f	48 89 06	 mov	 QWORD PTR [rsi], rax
  00062	48 8b c8	 mov	 rcx, rax

; 404  :     if (pTarget)

  00065	48 85 c0	 test	 rax, rax
  00068	74 59		 je	 SHORT $LN4@cw_dup

; 405  :     {
; 406  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  0006a	44 8b 0f	 mov	 r9d, DWORD PTR [rdi]

; 208  :     if ( nCount == 0 )

  0006d	45 85 c9	 test	 r9d, r9d
  00070	75 04		 jne	 SHORT $LN29@cw_dup

; 209  :         return 0;

  00072	8b c5		 mov	 eax, ebp
  00074	eb 40		 jmp	 SHORT $LN12@cw_dup
$LN29@cw_dup:

; 210  :     if ( nCount < 0 )

  00076	79 1a		 jns	 SHORT $LN14@cw_dup

; 211  :         nCount = cw_strlen( pSrc ) + 1;

  00078	48 8b c3	 mov	 rax, rbx

; 127  :     int nCount = 0;

  0007b	44 8b cd	 mov	 r9d, ebp

; 128  :     if ( pChar && *pChar )

  0007e	66 39 2b	 cmp	 WORD PTR [rbx], bp
  00081	74 0c		 je	 SHORT $LN18@cw_dup
$LL19@cw_dup:

; 129  :     {
; 130  :         do nCount++;

  00083	41 ff c1	 inc	 r9d

; 131  :         while (*++pChar);

  00086	48 8d 40 02	 lea	 rax, QWORD PTR [rax+2]
  0008a	66 39 28	 cmp	 WORD PTR [rax], bp
  0008d	75 f4		 jne	 SHORT $LL19@cw_dup
$LN18@cw_dup:

; 211  :         nCount = cw_strlen( pSrc ) + 1;

  0008f	41 ff c1	 inc	 r9d
$LN14@cw_dup:

; 212  : 
; 213  : #if defined(_M_IX86) || defined(_M_X64)
; 214  :     return WideCharToMultiByte(

  00092	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00097	43 8d 04 09	 lea	 eax, DWORD PTR [r9+r9]
  0009b	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  000a0	4c 8b c3	 mov	 r8, rbx
  000a3	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000a7	33 d2		 xor	 edx, edx
  000a9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000ae	33 c9		 xor	 ecx, ecx
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte
$LN12@cw_dup:

; 405  :     {
; 406  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  000b6	41 89 06	 mov	 DWORD PTR [r14], eax

; 407  :         pTarget[nTargetChars] = 0;

  000b9	48 63 c8	 movsxd	 rcx, eax
  000bc	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000bf	40 88 2c 01	 mov	 BYTE PTR [rcx+rax], bpl
$LN4@cw_dup:

; 408  :     }
; 409  : }

  000c3	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000c8	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000cd	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000d2	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  000d7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000db	41 5e		 pop	 r14
  000dd	c3		 ret	 0
?cw_dup@@YAXPEB_WAEAHAEAPEAD1@Z ENDP			; cw_dup
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_dup@@YAXPEBDAEAHAEAPEA_W1@Z
_TEXT	SEGMENT
pSrc$ = 64
nSrcChars$ = 72
pTarget$ = 80
nTargetChars$ = 88
?cw_dup@@YAXPEBDAEAHAEAPEA_W1@Z PROC			; cw_dup, COMDAT

; 359  : {

$LN31:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 360  :     if ( pSrc == 0 )

  00019	33 ed		 xor	 ebp, ebp
  0001b	4d 8b f1	 mov	 r14, r9
  0001e	49 8b f0	 mov	 rsi, r8
  00021	48 8b fa	 mov	 rdi, rdx
  00024	48 8b d9	 mov	 rbx, rcx
  00027	48 85 c9	 test	 rcx, rcx
  0002a	75 0d		 jne	 SHORT $LN2@cw_dup

; 361  :     {
; 362  :         nSrcChars = nTargetChars = 0;

  0002c	41 89 29	 mov	 DWORD PTR [r9], ebp
  0002f	89 2a		 mov	 DWORD PTR [rdx], ebp

; 363  :         pTarget = 0;

  00031	49 89 28	 mov	 QWORD PTR [r8], rbp

; 364  :         return;

  00034	e9 8c 00 00 00	 jmp	 $LN4@cw_dup
$LN2@cw_dup:

; 365  :     }
; 366  : 
; 367  :     if ( nSrcChars < 0 )

  00039	8b 02		 mov	 eax, DWORD PTR [rdx]
  0003b	85 c0		 test	 eax, eax
  0003d	79 10		 jns	 SHORT $LN3@cw_dup

; 115  :     int nCount = 0;

  0003f	8b c5		 mov	 eax, ebp
  00041	eb 05		 jmp	 SHORT $LN28@cw_dup
$LL9@cw_dup:

; 117  :     {
; 118  :         do nCount++;

  00043	ff c0		 inc	 eax

; 119  :         while (*++pChar);

  00045	48 ff c1	 inc	 rcx
$LN28@cw_dup:
  00048	40 38 29	 cmp	 BYTE PTR [rcx], bpl
  0004b	75 f6		 jne	 SHORT $LL9@cw_dup

; 368  :         nSrcChars = cw_strlen( pSrc );

  0004d	89 02		 mov	 DWORD PTR [rdx], eax
$LN3@cw_dup:

; 369  :     pTarget = new wchar_t[nSrcChars+1];

  0004f	ff c0		 inc	 eax
  00051	48 63 c8	 movsxd	 rcx, eax
  00054	b8 02 00 00 00	 mov	 eax, 2
  00059	48 f7 e1	 mul	 rcx
  0005c	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  00063	48 0f 40 c1	 cmovo	 rax, rcx
  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  0006f	48 89 06	 mov	 QWORD PTR [rsi], rax
  00072	48 8b c8	 mov	 rcx, rax

; 370  :         // We allow one wide char for each multibyte char;
; 371  :         //   this may be too many for some countries, but no harm.
; 372  :     if (pTarget)

  00075	48 85 c0	 test	 rax, rax
  00078	74 4b		 je	 SHORT $LN4@cw_dup

; 373  :     {
; 374  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  0007a	44 8b 0f	 mov	 r9d, DWORD PTR [rdi]

; 163  :     if ( nCount == 0 )

  0007d	45 85 c9	 test	 r9d, r9d
  00080	75 04		 jne	 SHORT $LN29@cw_dup

; 164  :         return 0;

  00082	8b c5		 mov	 eax, ebp
  00084	eb 32		 jmp	 SHORT $LN12@cw_dup
$LN29@cw_dup:

; 165  :     if ( nCount < 0 )

  00086	79 19		 jns	 SHORT $LN14@cw_dup

; 166  :         nCount = cw_strlen( pSrc ) + 1;

  00088	48 8b c3	 mov	 rax, rbx

; 115  :     int nCount = 0;

  0008b	44 8b cd	 mov	 r9d, ebp

; 116  :     if ( pChar && *pChar )

  0008e	40 38 2b	 cmp	 BYTE PTR [rbx], bpl
  00091	74 0b		 je	 SHORT $LN18@cw_dup
$LL19@cw_dup:

; 119  :         while (*++pChar);

  00093	48 ff c0	 inc	 rax
  00096	41 ff c1	 inc	 r9d
  00099	40 38 28	 cmp	 BYTE PTR [rax], bpl
  0009c	75 f5		 jne	 SHORT $LL19@cw_dup
$LN18@cw_dup:

; 166  :         nCount = cw_strlen( pSrc ) + 1;

  0009e	41 ff c1	 inc	 r9d
$LN14@cw_dup:

; 167  : 
; 168  : #if defined(_M_IX86) || defined(_M_X64)
; 169  :     return MultiByteToWideChar(

  000a1	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  000a6	4c 8b c3	 mov	 r8, rbx
  000a9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000ae	33 d2		 xor	 edx, edx
  000b0	33 c9		 xor	 ecx, ecx
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar
$LN12@cw_dup:

; 373  :     {
; 374  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  000b8	41 89 06	 mov	 DWORD PTR [r14], eax

; 375  :         pTarget[nTargetChars] = 0;

  000bb	48 63 c8	 movsxd	 rcx, eax
  000be	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000c1	66 89 2c 48	 mov	 WORD PTR [rax+rcx*2], bp
$LN4@cw_dup:

; 376  :     }
; 377  : }

  000c5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ca	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000cf	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000d4	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000d9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dd	41 5e		 pop	 r14
  000df	c3		 ret	 0
?cw_dup@@YAXPEBDAEAHAEAPEA_W1@Z ENDP			; cw_dup
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcat@@YAHPEA_WPEB_W@Z
_TEXT	SEGMENT
pszTarget$ = 48
pszSrc$ = 56
?cw_strcat@@YAHPEA_WPEB_W@Z PROC			; cw_strcat, COMDAT

; 347  : {

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 127  :     int nCount = 0;

  00004	45 33 c9	 xor	 r9d, r9d

; 348  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00007	48 8b c1	 mov	 rax, rcx

; 127  :     int nCount = 0;

  0000a	45 8b c1	 mov	 r8d, r9d

; 128  :     if ( pChar && *pChar )

  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 13		 je	 SHORT $LN5@cw_strcat
  00012	66 44 39 09	 cmp	 WORD PTR [rcx], r9w
  00016	74 0d		 je	 SHORT $LN5@cw_strcat
$LL6@cw_strcat:

; 129  :     {
; 130  :         do nCount++;

  00018	41 ff c0	 inc	 r8d

; 131  :         while (*++pChar);

  0001b	48 8d 40 02	 lea	 rax, QWORD PTR [rax+2]
  0001f	66 44 39 08	 cmp	 WORD PTR [rax], r9w
  00023	75 f3		 jne	 SHORT $LL6@cw_strcat
$LN5@cw_strcat:

; 348  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00025	49 63 c0	 movsxd	 rax, r8d
  00028	41 83 c8 ff	 or	 r8d, -1
  0002c	48 8d 0c 41	 lea	 rcx, QWORD PTR [rcx+rax*2]
  00030	e8 00 00 00 00	 call	 ?cw_memcpy@@YAHPEA_WPEB_WH@Z ; cw_memcpy
  00035	ff c8		 dec	 eax

; 349  : }       //   Return chars copied (not including NUL).

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
?cw_strcat@@YAHPEA_WPEB_W@Z ENDP			; cw_strcat
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcat@@YAHPEADPEBD@Z
_TEXT	SEGMENT
pszTarget$ = 48
pszSrc$ = 56
?cw_strcat@@YAHPEADPEBD@Z PROC				; cw_strcat, COMDAT

; 342  : {

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 343  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00004	48 8b c1	 mov	 rax, rcx
  00007	4c 8b c1	 mov	 r8, rcx

; 115  :     int nCount = 0;

  0000a	33 c9		 xor	 ecx, ecx

; 116  :     if ( pChar && *pChar )

  0000c	48 85 c0	 test	 rax, rax
  0000f	74 0e		 je	 SHORT $LN5@cw_strcat
  00011	38 08		 cmp	 BYTE PTR [rax], cl
  00013	74 0a		 je	 SHORT $LN5@cw_strcat
$LL6@cw_strcat:

; 117  :     {
; 118  :         do nCount++;
; 119  :         while (*++pChar);

  00015	48 ff c0	 inc	 rax
  00018	ff c1		 inc	 ecx
  0001a	80 38 00	 cmp	 BYTE PTR [rax], 0
  0001d	75 f6		 jne	 SHORT $LL6@cw_strcat
$LN5@cw_strcat:

; 343  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  0001f	48 63 c9	 movsxd	 rcx, ecx
  00022	49 03 c8	 add	 rcx, r8
  00025	41 83 c8 ff	 or	 r8d, -1
  00029	e8 00 00 00 00	 call	 ?cw_memcpy@@YAHPEADPEBDH@Z ; cw_memcpy
  0002e	ff c8		 dec	 eax

; 344  : }       //   Return chars copied (not including NUL).

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
?cw_strcat@@YAHPEADPEBD@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcat@@YAHPEA_WPEBD@Z
_TEXT	SEGMENT
pszTarget$ = 48
pszSrc$ = 56
?cw_strcat@@YAHPEA_WPEBD@Z PROC				; cw_strcat, COMDAT

; 337  : {

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 127  :     int nCount = 0;

  00004	45 33 c9	 xor	 r9d, r9d

; 338  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00007	48 8b c1	 mov	 rax, rcx

; 127  :     int nCount = 0;

  0000a	45 8b c1	 mov	 r8d, r9d

; 128  :     if ( pChar && *pChar )

  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 13		 je	 SHORT $LN5@cw_strcat
  00012	66 44 39 09	 cmp	 WORD PTR [rcx], r9w
  00016	74 0d		 je	 SHORT $LN5@cw_strcat
$LL6@cw_strcat:

; 129  :     {
; 130  :         do nCount++;

  00018	41 ff c0	 inc	 r8d

; 131  :         while (*++pChar);

  0001b	48 8d 40 02	 lea	 rax, QWORD PTR [rax+2]
  0001f	66 44 39 08	 cmp	 WORD PTR [rax], r9w
  00023	75 f3		 jne	 SHORT $LL6@cw_strcat
$LN5@cw_strcat:

; 338  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00025	49 63 c0	 movsxd	 rax, r8d
  00028	41 83 c8 ff	 or	 r8d, -1
  0002c	48 8d 0c 41	 lea	 rcx, QWORD PTR [rcx+rax*2]
  00030	e8 00 00 00 00	 call	 ?cw_memcpy@@YAHPEA_WPEBDH@Z ; cw_memcpy
  00035	ff c8		 dec	 eax

; 339  : }       //   Return chars copied (not including NUL).

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
?cw_strcat@@YAHPEA_WPEBD@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcat@@YAHPEADPEB_W@Z
_TEXT	SEGMENT
pszTarget$ = 48
pszSrc$ = 56
?cw_strcat@@YAHPEADPEB_W@Z PROC				; cw_strcat, COMDAT

; 332  : {

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 333  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00004	48 8b c1	 mov	 rax, rcx
  00007	4c 8b c1	 mov	 r8, rcx

; 115  :     int nCount = 0;

  0000a	33 c9		 xor	 ecx, ecx

; 116  :     if ( pChar && *pChar )

  0000c	48 85 c0	 test	 rax, rax
  0000f	74 0e		 je	 SHORT $LN5@cw_strcat
  00011	38 08		 cmp	 BYTE PTR [rax], cl
  00013	74 0a		 je	 SHORT $LN5@cw_strcat
$LL6@cw_strcat:

; 117  :     {
; 118  :         do nCount++;
; 119  :         while (*++pChar);

  00015	48 ff c0	 inc	 rax
  00018	ff c1		 inc	 ecx
  0001a	80 38 00	 cmp	 BYTE PTR [rax], 0
  0001d	75 f6		 jne	 SHORT $LL6@cw_strcat
$LN5@cw_strcat:

; 333  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  0001f	48 63 c9	 movsxd	 rcx, ecx
  00022	49 03 c8	 add	 rcx, r8
  00025	41 83 c8 ff	 or	 r8d, -1
  00029	e8 00 00 00 00	 call	 ?cw_memcpy@@YAHPEADPEB_WH@Z ; cw_memcpy
  0002e	ff c8		 dec	 eax

; 334  : }       //   Return chars copied (not including NUL).

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
?cw_strcat@@YAHPEADPEB_W@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcpy@@YAHPEA_WPEB_W@Z
_TEXT	SEGMENT
pszTarget$ = 48
pszSrc$ = 56
?cw_strcpy@@YAHPEA_WPEB_W@Z PROC			; cw_strcpy, COMDAT

; 322  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 323  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00004	41 83 c8 ff	 or	 r8d, -1
  00008	e8 00 00 00 00	 call	 ?cw_memcpy@@YAHPEA_WPEB_WH@Z ; cw_memcpy
  0000d	ff c8		 dec	 eax

; 324  : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
?cw_strcpy@@YAHPEA_WPEB_W@Z ENDP			; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcpy@@YAHPEADPEBD@Z
_TEXT	SEGMENT
pszTarget$ = 48
pszSrc$ = 56
?cw_strcpy@@YAHPEADPEBD@Z PROC				; cw_strcpy, COMDAT

; 317  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 318  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00004	41 83 c8 ff	 or	 r8d, -1
  00008	e8 00 00 00 00	 call	 ?cw_memcpy@@YAHPEADPEBDH@Z ; cw_memcpy
  0000d	ff c8		 dec	 eax

; 319  : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
?cw_strcpy@@YAHPEADPEBD@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcpy@@YAHPEA_WPEBD@Z
_TEXT	SEGMENT
pszTarget$ = 48
pszSrc$ = 56
?cw_strcpy@@YAHPEA_WPEBD@Z PROC				; cw_strcpy, COMDAT

; 312  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 313  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00004	41 83 c8 ff	 or	 r8d, -1
  00008	e8 00 00 00 00	 call	 ?cw_memcpy@@YAHPEA_WPEBDH@Z ; cw_memcpy
  0000d	ff c8		 dec	 eax

; 314  : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
?cw_strcpy@@YAHPEA_WPEBD@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcpy@@YAHPEADPEB_W@Z
_TEXT	SEGMENT
pszTarget$ = 48
pszSrc$ = 56
?cw_strcpy@@YAHPEADPEB_W@Z PROC				; cw_strcpy, COMDAT

; 307  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 308  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00004	41 83 c8 ff	 or	 r8d, -1
  00008	e8 00 00 00 00	 call	 ?cw_memcpy@@YAHPEADPEB_WH@Z ; cw_memcpy
  0000d	ff c8		 dec	 eax

; 309  : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
?cw_strcpy@@YAHPEADPEB_W@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strlen@@YAHPEB_W@Z
_TEXT	SEGMENT
pChar$ = 8
?cw_strlen@@YAHPEB_W@Z PROC				; cw_strlen, COMDAT

; 126  : #if defined(_M_IX86) || defined(_M_X64)
; 127  :     int nCount = 0;

  00000	33 d2		 xor	 edx, edx
  00002	8b c2		 mov	 eax, edx

; 128  :     if ( pChar && *pChar )

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 0d		 je	 SHORT $LN3@cw_strlen
  00009	eb 06		 jmp	 SHORT $LN10@cw_strlen
$LL4@cw_strlen:

; 129  :     {
; 130  :         do nCount++;

  0000b	ff c0		 inc	 eax

; 131  :         while (*++pChar);

  0000d	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
$LN10@cw_strlen:
  00011	66 39 11	 cmp	 WORD PTR [rcx], dx
  00014	75 f5		 jne	 SHORT $LL4@cw_strlen
$LN3@cw_strlen:

; 132  :     }
; 133  :     return nCount;
; 134  : 
; 135  : #else
; 136  :     int nCount = 0;
; 137  :     const char* pNChar = (const char*) pChar;
; 138  :     if ( pNChar && ( pNChar[0] | pNChar[1] ) != 0 )
; 139  :     {
; 140  :         do
; 141  :         {
; 142  :             nCount++;
; 143  :             pNChar += 2;
; 144  :         }
; 145  :         while ( ( pNChar[0] | pNChar[1] ) != 0 );
; 146  :     }
; 147  :     return nCount;
; 148  : #endif
; 149  : }

  00016	c3		 ret	 0
?cw_strlen@@YAHPEB_W@Z ENDP				; cw_strlen
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strlen@@YAHPEBD@Z
_TEXT	SEGMENT
pChar$ = 8
?cw_strlen@@YAHPEBD@Z PROC				; cw_strlen, COMDAT

; 115  :     int nCount = 0;

  00000	33 c0		 xor	 eax, eax

; 116  :     if ( pChar && *pChar )

  00002	48 85 c9	 test	 rcx, rcx
  00005	74 0e		 je	 SHORT $LN3@cw_strlen
  00007	38 01		 cmp	 BYTE PTR [rcx], al
  00009	74 0a		 je	 SHORT $LN3@cw_strlen
$LL4@cw_strlen:

; 117  :     {
; 118  :         do nCount++;
; 119  :         while (*++pChar);

  0000b	48 ff c1	 inc	 rcx
  0000e	ff c0		 inc	 eax
  00010	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00013	75 f6		 jne	 SHORT $LL4@cw_strlen
$LN3@cw_strlen:

; 120  :     }
; 121  :     return nCount;
; 122  : }

  00015	c3		 ret	 0
?cw_strlen@@YAHPEBD@Z ENDP				; cw_strlen
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memset@@YAXPEA_W_WH@Z
_TEXT	SEGMENT
pTarget$ = 8
cChar$ = 16
nCount$ = 24
?cw_memset@@YAXPEA_W_WH@Z PROC				; cw_memset, COMDAT

; 80   :     // If Intel x86, resort to assembly...
; 81   : #if defined(_M_IX86)
; 82   :     _asm
; 83   :     {
; 84   :         mov ecx, nCount                 // Get count.
; 85   :         jcxz L2                         //   If zero, then jump: Nothing to do.
; 86   : 
; 87   :         mov edi, pTarget                // Get pointer to destination.
; 88   :         mov ax, cChar                   // Get wide character to set.
; 89   :         rep stosw                       // Set wide character for ECX times.
; 90   : 
; 91   :     L2:
; 92   :     }
; 93   : 
; 94   :     // If not Intel or alignment required, then set low and high bytes separately.
; 95   : #else
; 96   :     if ( nCount > 0 )

  00000	45 85 c0	 test	 r8d, r8d
  00003	7e 16		 jle	 SHORT $LN3@cw_memset
  00005	0f b7 c2	 movzx	 eax, dx
  00008	66 c1 e8 08	 shr	 ax, 8
$LL4@cw_memset:

; 97   :     {
; 98   :         int n = nCount;
; 99   :         char* pCharTarget = (char*) pTarget;
; 100  :         do {
; 101  :             *pCharTarget++ = LOBYTE(cChar);

  0000c	88 11		 mov	 BYTE PTR [rcx], dl

; 102  :             *pCharTarget++ = HIBYTE(cChar);

  0000e	88 41 01	 mov	 BYTE PTR [rcx+1], al
  00011	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]

; 103  :         } while ( --n );

  00015	41 83 e8 01	 sub	 r8d, 1
  00019	75 f1		 jne	 SHORT $LL4@cw_memset
$LN3@cw_memset:

; 104  :     }
; 105  : #endif
; 106  : }

  0001b	c3		 ret	 0
?cw_memset@@YAXPEA_W_WH@Z ENDP				; cw_memset
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memset@@YAXPEADDH@Z
_TEXT	SEGMENT
pTarget$ = 8
cChar$ = 16
nCount$ = 24
?cw_memset@@YAXPEADDH@Z PROC				; cw_memset, COMDAT

; 52   :     // If Intel x86, resort to assembly...
; 53   : #if defined(_M_IX86)
; 54   :     _asm
; 55   :     {
; 56   :         mov ecx, nCount                 // Get count.
; 57   :         jcxz L2                         //   If zero, then jump: Nothing to do.
; 58   : 
; 59   :         mov edi, pTarget                // Get pointer to destination.
; 60   :         mov al, cChar                   // Get character to set.
; 61   :         rep stosb                       // Set character for ECX times.
; 62   : 
; 63   :     L2:
; 64   :     }
; 65   : 
; 66   :     // If not Intel, use tight loop.
; 67   : #else
; 68   :     if ( nCount > 0 )

  00000	45 85 c0	 test	 r8d, r8d
  00003	7e 0b		 jle	 SHORT $LN3@cw_memset
$LL4@cw_memset:

; 69   :     {
; 70   :         int n = nCount;
; 71   :         do {
; 72   :             *pTarget++ = cChar;

  00005	88 11		 mov	 BYTE PTR [rcx], dl
  00007	48 ff c1	 inc	 rcx

; 73   :         } while ( --n );

  0000a	41 83 e8 01	 sub	 r8d, 1
  0000e	75 f5		 jne	 SHORT $LL4@cw_memset
$LN3@cw_memset:

; 74   :     }
; 75   : #endif
; 76   : }

  00010	c3		 ret	 0
?cw_memset@@YAXPEADDH@Z ENDP				; cw_memset
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memcpy@@YAHPEA_WPEB_WH@Z
_TEXT	SEGMENT
pTarget$ = 48
pSrc$ = 56
nCount$ = 64
?cw_memcpy@@YAHPEA_WPEB_WH@Z PROC			; cw_memcpy, COMDAT

; 294  : {

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	41 8b d8	 mov	 ebx, r8d

; 295  :     if ( nCount < 0 )

  00009	45 33 c0	 xor	 r8d, r8d
  0000c	85 db		 test	 ebx, ebx
  0000e	79 1f		 jns	 SHORT $LN2@cw_memcpy

; 296  :         nCount = cw_strlen(pSrc) + 1;

  00010	48 8b c2	 mov	 rax, rdx

; 127  :     int nCount = 0;

  00013	41 8b d8	 mov	 ebx, r8d

; 128  :     if ( pChar && *pChar )

  00016	48 85 d2	 test	 rdx, rdx
  00019	74 12		 je	 SHORT $LN6@cw_memcpy
  0001b	66 44 39 02	 cmp	 WORD PTR [rdx], r8w
  0001f	74 0c		 je	 SHORT $LN6@cw_memcpy
$LL7@cw_memcpy:

; 129  :     {
; 130  :         do nCount++;

  00021	ff c3		 inc	 ebx

; 131  :         while (*++pChar);

  00023	48 8d 40 02	 lea	 rax, QWORD PTR [rax+2]
  00027	66 44 39 00	 cmp	 WORD PTR [rax], r8w
  0002b	75 f4		 jne	 SHORT $LL7@cw_memcpy
$LN6@cw_memcpy:

; 296  :         nCount = cw_strlen(pSrc) + 1;

  0002d	ff c3		 inc	 ebx
$LN2@cw_memcpy:

; 297  :     cw_memcpy( (char*) pTarget, (const char*) pSrc, nCount * sizeof(wchar_t) );

  0002f	44 8d 04 1b	 lea	 r8d, DWORD PTR [rbx+rbx]
  00033	e8 00 00 00 00	 call	 ?cw_memcpy@@YAHPEADPEBDH@Z ; cw_memcpy

; 298  :     return nCount;

  00038	8b c3		 mov	 eax, ebx

; 299  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
?cw_memcpy@@YAHPEA_WPEB_WH@Z ENDP			; cw_memcpy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memcpy@@YAHPEADPEBDH@Z
_TEXT	SEGMENT
pTarget$ = 8
pSrc$ = 16
nCount$ = 24
?cw_memcpy@@YAHPEADPEBDH@Z PROC				; cw_memcpy, COMDAT

; 258  :     if ( nCount < 0 )

  00000	45 85 c0	 test	 r8d, r8d
  00003	79 1e		 jns	 SHORT $LN5@cw_memcpy

; 115  :     int nCount = 0;

  00005	45 33 c0	 xor	 r8d, r8d

; 259  :         nCount = cw_strlen(pSrc) + 1;

  00008	48 8b c2	 mov	 rax, rdx

; 116  :     if ( pChar && *pChar )

  0000b	48 85 d2	 test	 rdx, rdx
  0000e	74 10		 je	 SHORT $LN10@cw_memcpy
  00010	44 38 02	 cmp	 BYTE PTR [rdx], r8b
  00013	74 0b		 je	 SHORT $LN10@cw_memcpy
$LL11@cw_memcpy:

; 117  :     {
; 118  :         do nCount++;
; 119  :         while (*++pChar);

  00015	48 ff c0	 inc	 rax
  00018	41 ff c0	 inc	 r8d
  0001b	80 38 00	 cmp	 BYTE PTR [rax], 0
  0001e	75 f5		 jne	 SHORT $LL11@cw_memcpy
$LN10@cw_memcpy:

; 259  :         nCount = cw_strlen(pSrc) + 1;

  00020	41 ff c0	 inc	 r8d
$LN5@cw_memcpy:

; 260  :     if ( pTarget && nCount )

  00023	48 85 c9	 test	 rcx, rcx
  00026	74 19		 je	 SHORT $LN3@cw_memcpy
  00028	45 85 c0	 test	 r8d, r8d
  0002b	74 14		 je	 SHORT $LN3@cw_memcpy

; 261  :     {
; 262  :         // If Intel x86, resort to assembly...
; 263  : #if defined(_M_IX86)
; 264  :         _asm
; 265  :         {
; 266  :             mov ecx, nCount                 // Get count.
; 267  :             jcxz L2                         //   If zero, then jump: Nothing to do.
; 268  : 
; 269  :             mov esi, pSrc                   // Get pointer to source.
; 270  :             mov edi, pTarget                // Get pointer to destination.
; 271  :             rep movsb                       // Move characters from ESI to EDI for ECX times.
; 272  : 
; 273  :         L2:
; 274  :         }
; 275  : 
; 276  :         // If not Intel, use tight loop.
; 277  : #else
; 278  :         int n = nCount;

  0002d	45 8b c8	 mov	 r9d, r8d
  00030	48 2b ca	 sub	 rcx, rdx
$LL4@cw_memcpy:

; 279  :         do {
; 280  :             *pTarget++ = *pSrc++;

  00033	8a 02		 mov	 al, BYTE PTR [rdx]
  00035	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00038	48 ff c2	 inc	 rdx

; 281  :         } while ( --n );

  0003b	41 83 e9 01	 sub	 r9d, 1
  0003f	75 f2		 jne	 SHORT $LL4@cw_memcpy
$LN3@cw_memcpy:

; 282  : #endif
; 283  :     }
; 284  :     return nCount;

  00041	41 8b c0	 mov	 eax, r8d

; 285  : }

  00044	c3		 ret	 0
?cw_memcpy@@YAHPEADPEBDH@Z ENDP				; cw_memcpy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memcpy@@YAHPEA_WPEBDH@Z
_TEXT	SEGMENT
pTarget$ = 64
pSrc$ = 72
nCount$ = 80
?cw_memcpy@@YAHPEA_WPEBDH@Z PROC			; cw_memcpy, COMDAT

; 162  : {

$LN16:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 163  :     if ( nCount == 0 )

  00004	45 85 c0	 test	 r8d, r8d
  00007	75 04		 jne	 SHORT $LN14@cw_memcpy

; 164  :         return 0;

  00009	33 c0		 xor	 eax, eax
  0000b	eb 3a		 jmp	 SHORT $LN1@cw_memcpy
$LN14@cw_memcpy:

; 165  :     if ( nCount < 0 )

  0000d	79 1e		 jns	 SHORT $LN3@cw_memcpy

; 115  :     int nCount = 0;

  0000f	45 33 c0	 xor	 r8d, r8d

; 166  :         nCount = cw_strlen( pSrc ) + 1;

  00012	48 8b c2	 mov	 rax, rdx

; 116  :     if ( pChar && *pChar )

  00015	48 85 d2	 test	 rdx, rdx
  00018	74 10		 je	 SHORT $LN7@cw_memcpy
  0001a	44 38 02	 cmp	 BYTE PTR [rdx], r8b
  0001d	74 0b		 je	 SHORT $LN7@cw_memcpy
$LL8@cw_memcpy:

; 117  :     {
; 118  :         do nCount++;
; 119  :         while (*++pChar);

  0001f	48 ff c0	 inc	 rax
  00022	41 ff c0	 inc	 r8d
  00025	80 38 00	 cmp	 BYTE PTR [rax], 0
  00028	75 f5		 jne	 SHORT $LL8@cw_memcpy
$LN7@cw_memcpy:

; 166  :         nCount = cw_strlen( pSrc ) + 1;

  0002a	41 ff c0	 inc	 r8d
$LN3@cw_memcpy:

; 167  : 
; 168  : #if defined(_M_IX86) || defined(_M_X64)
; 169  :     return MultiByteToWideChar(

  0002d	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00032	45 8b c8	 mov	 r9d, r8d
  00035	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003a	4c 8b c2	 mov	 r8, rdx
  0003d	33 d2		 xor	 edx, edx
  0003f	33 c9		 xor	 ecx, ecx
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar
$LN1@cw_memcpy:

; 170  :         CP_ACP,         // code page
; 171  :         0,              // character-type options
; 172  :         pSrc,           // address of string to map
; 173  :         nCount,         // number of characters in string
; 174  :         pTarget,        // address of wide-character buffer
; 175  :         nCount );       // size of buffer.
; 176  :                         //   This is worst case (no multi-byte chars).
; 177  :                         //   We assume that the caller passed a big enough buffer.
; 178  : 
; 179  : #else
; 180  :     wchar_t* pWide = pTarget;
; 181  :     if ( (DWORD) pWide & 1 )
; 182  :         pWide = new wchar_t[nCount];
; 183  :     nCount = MultiByteToWideChar(
; 184  :         CP_ACP,         // code page
; 185  :         0,              // character-type options
; 186  :         pSrc,           // address of string to map
; 187  :         nCount,         // number of characters in string
; 188  :         pWide,          // address of wide-character buffer
; 189  :         nCount );       // size of buffer.
; 190  :                         //   This is worst case (no multi-byte chars).
; 191  :                         //   We assume that the caller passed a big enough buffer.
; 192  :     if ( pTarget != pWide )
; 193  :     {
; 194  :         cw_memcpy( (char*) pTarget, (const char*) pWide, nCount * sizeof(wchar_t) );
; 195  :         delete [] pWide;
; 196  :     }
; 197  :     return nCount;
; 198  : #endif
; 199  : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
?cw_memcpy@@YAHPEA_WPEBDH@Z ENDP			; cw_memcpy
_TEXT	ENDS
; Function compile flags: /Ogspy
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memcpy@@YAHPEADPEB_WH@Z
_TEXT	SEGMENT
pTarget$ = 80
pSrc$ = 88
nCount$ = 96
?cw_memcpy@@YAHPEADPEB_WH@Z PROC			; cw_memcpy, COMDAT

; 207  : {

$LN16:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 208  :     if ( nCount == 0 )

  00004	45 33 c9	 xor	 r9d, r9d
  00007	45 85 c0	 test	 r8d, r8d
  0000a	75 04		 jne	 SHORT $LN14@cw_memcpy

; 209  :         return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	eb 4a		 jmp	 SHORT $LN1@cw_memcpy
$LN14@cw_memcpy:

; 210  :     if ( nCount < 0 )

  00010	79 21		 jns	 SHORT $LN3@cw_memcpy

; 211  :         nCount = cw_strlen( pSrc ) + 1;

  00012	48 8b c2	 mov	 rax, rdx

; 127  :     int nCount = 0;

  00015	45 8b c1	 mov	 r8d, r9d

; 128  :     if ( pChar && *pChar )

  00018	48 85 d2	 test	 rdx, rdx
  0001b	74 13		 je	 SHORT $LN7@cw_memcpy
  0001d	66 44 39 0a	 cmp	 WORD PTR [rdx], r9w
  00021	74 0d		 je	 SHORT $LN7@cw_memcpy
$LL8@cw_memcpy:

; 129  :     {
; 130  :         do nCount++;

  00023	41 ff c0	 inc	 r8d

; 131  :         while (*++pChar);

  00026	48 8d 40 02	 lea	 rax, QWORD PTR [rax+2]
  0002a	66 44 39 08	 cmp	 WORD PTR [rax], r9w
  0002e	75 f3		 jne	 SHORT $LL8@cw_memcpy
$LN7@cw_memcpy:

; 211  :         nCount = cw_strlen( pSrc ) + 1;

  00030	41 ff c0	 inc	 r8d
$LN3@cw_memcpy:

; 212  : 
; 213  : #if defined(_M_IX86) || defined(_M_X64)
; 214  :     return WideCharToMultiByte(

  00033	4c 89 4c 24 38	 mov	 QWORD PTR [rsp+56], r9
  00038	43 8d 04 00	 lea	 eax, DWORD PTR [r8+r8]
  0003c	4c 89 4c 24 30	 mov	 QWORD PTR [rsp+48], r9
  00041	45 8b c8	 mov	 r9d, r8d
  00044	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00048	4c 8b c2	 mov	 r8, rdx
  0004b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00050	33 d2		 xor	 edx, edx
  00052	33 c9		 xor	 ecx, ecx
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte
$LN1@cw_memcpy:

; 215  :         CP_ACP,         // code page
; 216  :         0,              // performance and mapping flags
; 217  :         pSrc,           // address of wide character string
; 218  :         nCount,         // number of characters in string
; 219  :         pTarget,        // address of buffer for new string
; 220  :         nCount*2,       // size of buffer
; 221  :                         //   This is worst case (every wide -> multi-byte char).
; 222  :                         //   We assume that the caller passed a big enough buffer.
; 223  :         NULL,           // address of default for unmappable characters
; 224  :         NULL );         // address of flag set when default char.
; 225  : 
; 226  : #else
; 227  :     wchar_t* pWide = (wchar_t*) pSrc;
; 228  :     if ( (DWORD) pWide & 1 )
; 229  :     {
; 230  :         pWide = new wchar_t[nCount];
; 231  :         cw_memcpy( (char*) pWide, (const char*) pSrc, nCount * sizeof(wchar_t) );
; 232  :     }
; 233  :     nCount = WideCharToMultiByte(
; 234  :         CP_ACP,         // code page
; 235  :         0,              // performance and mapping flags
; 236  :         pWide,          // address of wide character string
; 237  :         nCount,         // number of characters in string
; 238  :         pTarget,        // address of buffer for new string
; 239  :         nCount*2,       // size of buffer
; 240  :                         //   This is worst case (every wide -> multi-byte char).
; 241  :                         //   We assume that the caller passed a big enough buffer.
; 242  :         NULL,           // address of default for unmappable characters
; 243  :         NULL );         // address of flag set when default char.
; 244  :     if ( pSrc != pWide )
; 245  :         delete [] pWide;
; 246  :     return nCount;
; 247  : #endif
; 248  : }

  0005a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005e	c3		 ret	 0
?cw_memcpy@@YAHPEADPEB_WH@Z ENDP			; cw_memcpy
_TEXT	ENDS
END
