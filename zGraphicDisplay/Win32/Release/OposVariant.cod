; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Develop\OPOS-CCO\Common\OposVariant.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?WM_ATLGETHOST@ATL@@3IA				; ATL::WM_ATLGETHOST
PUBLIC	?WM_ATLGETCONTROL@ATL@@3IA			; ATL::WM_ATLGETCONTROL
PUBLIC	_LIBID_ATLLib
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl@ ; `string'
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM@ ; `string'
PUBLIC	??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI@ ; `string'
PUBLIC	??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr@ ; `string'
PUBLIC	??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn@ ; `string'
PUBLIC	??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi@ ; `string'
PUBLIC	??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl@ ; `string'
PUBLIC	??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg@ ; `string'
PUBLIC	??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi@ ; `string'
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn@ ; `string'
PUBLIC	??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl@ ; `string'
PUBLIC	??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt@ ; `string'
PUBLIC	??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi@ ; `string'
PUBLIC	??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe@ ; `string'
PUBLIC	??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl@ ; `string'
PUBLIC	??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg@ ; `string'
PUBLIC	??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp@ ; `string'
PUBLIC	??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl@ ; `string'
PUBLIC	??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt@ ; `string'
PUBLIC	??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc@ ; `string'
PUBLIC	??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI@ ; `string'
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	??_C@_13HADIAKP@?$AAS@				; `string'
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	??_C@_13LHMFKAAD@?$AAM@				; `string'
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	??_C@_13MKMNOPIJ@?$AAD@				; `string'
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	??_C@_13OPKGLAFF@?$AAB@				; `string'
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl@		; `string'
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ ; `string'
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ ; `string'
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe@ ; `string'
PUBLIC	_CLSID_Registrar
PUBLIC	_IID_IRegistrar
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	___ImageBase:BYTE
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?WM_ATLGETHOST@ATL@@3IA
_BSS	SEGMENT
?WM_ATLGETHOST@ATL@@3IA DD 01H DUP (?)			; ATL::WM_ATLGETHOST
_BSS	ENDS
;	COMDAT ?WM_ATLGETCONTROL@ATL@@3IA
_BSS	SEGMENT
?WM_ATLGETCONTROL@ATL@@3IA DD 01H DUP (?)		; ATL::WM_ATLGETCONTROL
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe@
CONST	SEGMENT
??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe@ DB 'D', 00H, 'e', 00H, 'l'
	DB	00H, 'e', 00H, 't', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe@ ; ATL::szDelete
CONST	ENDS
;	COMDAT ??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@
CONST	SEGMENT
??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ DB 'N', 00H, 'o'
	DB	00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ ; ATL::szNoRemove
CONST	ENDS
;	COMDAT ??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@
CONST	SEGMENT
??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ DB 'F'
	DB	00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ ; ATL::szForceRemove
CONST	ENDS
;	COMDAT ??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl@
CONST	SEGMENT
??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl@ DB 'V', 00H, 'a', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl@ ; ATL::szValToken
CONST	ENDS
;	COMDAT ??_C@_13OPKGLAFF@?$AAB@
CONST	SEGMENT
??_C@_13OPKGLAFF@?$AAB@ DB 'B', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:??_C@_13OPKGLAFF@?$AAB@ ; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ??_C@_13MKMNOPIJ@?$AAD@
CONST	SEGMENT
??_C@_13MKMNOPIJ@?$AAD@ DB 'D', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:??_C@_13MKMNOPIJ@?$AAD@	; ATL::szDwordVal
CONST	ENDS
;	COMDAT ??_C@_13LHMFKAAD@?$AAM@
CONST	SEGMENT
??_C@_13LHMFKAAD@?$AAM@ DB 'M', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:??_C@_13LHMFKAAD@?$AAM@ ; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ??_C@_13HADIAKP@?$AAS@
CONST	SEGMENT
??_C@_13HADIAKP@?$AAS@ DB 'S', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:??_C@_13HADIAKP@?$AAS@	; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT ??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI@
CONST	SEGMENT
??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc@
CONST	SEGMENT
??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt@
CONST	SEGMENT
??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl@
CONST	SEGMENT
??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp@
CONST	SEGMENT
??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl@
CONST	SEGMENT
??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'i'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe@
CONST	SEGMENT
??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe@
CONST	SEGMENT
??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi@
CONST	SEGMENT
??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt@
CONST	SEGMENT
??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl@
CONST	SEGMENT
??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm', 00H, 'p'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn@
CONST	SEGMENT
??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi@
CONST	SEGMENT
??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'v'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn@
CONST	SEGMENT
??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl@
CONST	SEGMENT
??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o'
	DB	00H, 'l', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi@
CONST	SEGMENT
??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn@
CONST	SEGMENT
??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr@
CONST	SEGMENT
??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI@
CONST	SEGMENT
??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM@
CONST	SEGMENT
??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl@
CONST	SEGMENT
??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??_I@YGXPAXIIP6EX0@Z@Z				; `vector destructor iterator'
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
PUBLIC	??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
PUBLIC	?SetVARIANT_BOOL@OposVariant@@QAEXF@Z		; OposVariant::SetVARIANT_BOOL
PUBLIC	?SetVARIANT_BOOL_Ptr@OposVariant@@QAEXPAFAAJ@Z	; OposVariant::SetVARIANT_BOOL_Ptr
PUBLIC	?GetLONG@OposVariant@@QAEJXZ			; OposVariant::GetLONG
PUBLIC	?ChangeLONG@OposVariant@@QAEXPAJAAJ@Z		; OposVariant::ChangeLONG
PUBLIC	?SetLONG@OposVariant@@QAEXJ@Z			; OposVariant::SetLONG
PUBLIC	?SetLONG_Ptr@OposVariant@@QAEXPAJAAJ@Z		; OposVariant::SetLONG_Ptr
PUBLIC	?ChangeCURRENCY@OposVariant@@QAEXPATtagCY@@AAJ@Z ; OposVariant::ChangeCURRENCY
PUBLIC	?SetCURRENCY@OposVariant@@QAEXTtagCY@@@Z	; OposVariant::SetCURRENCY
PUBLIC	?SetCURRENCY_Ptr@OposVariant@@QAEXPATtagCY@@AAJ@Z ; OposVariant::SetCURRENCY_Ptr
PUBLIC	?ChangeBSTR@OposVariant@@QAEXPAPA_WAAJ@Z	; OposVariant::ChangeBSTR
PUBLIC	?SetBSTR@OposVariant@@QAEXPA_WAAJ@Z		; OposVariant::SetBSTR
PUBLIC	?SetBSTR_Copy@OposVariant@@QAEXPA_WAAJ@Z	; OposVariant::SetBSTR_Copy
PUBLIC	?SetBSTR_OutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z	; OposVariant::SetBSTR_OutPtr
PUBLIC	?SetBSTR_InOutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z	; OposVariant::SetBSTR_InOutPtr
PUBLIC	?SetVARIANT@OposVariant@@QAEXAAUtagVARIANT@@GAAJ@Z ; OposVariant::SetVARIANT
PUBLIC	?SetVARIANT_Ptr@OposVariant@@QAEXAAPAUtagVARIANT@@GAAJ@Z ; OposVariant::SetVARIANT_Ptr
PUBLIC	?SetString@OposVariant@@QAEXPB_WAAJ@Z		; OposVariant::SetString
PUBLIC	?SetDispatch_Ptr@OposVariant@@QAEXPAUIDispatch@@AAJ@Z ; OposVariant::SetDispatch_Ptr
PUBLIC	??0OposDispParms@@QAE@PAVOposVariant@@H@Z	; OposDispParms::OposDispParms
PUBLIC	??1OposDispParms@@QAE@XZ			; OposDispParms::~OposDispParms
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	??_C@_11LOCGONAA@@				; `string'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	_free:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__SysAllocString@4:PROC
EXTRN	__imp__SysAllocStringLen@8:PROC
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	__imp__SysStringLen@4:PROC
EXTRN	__imp__VariantClear@4:PROC
EXTRN	__imp__VariantCopyInd@8:PROC
EXTRN	__imp__VariantChangeType@16:PROC
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_BSS	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 028H DUP (?)	; ATL::_AtlComModule
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ??1OposDispParms@@QAE@XZ
_TEXT	SEGMENT
??1OposDispParms@@QAE@XZ PROC				; OposDispParms::~OposDispParms, COMDAT
; _this$ = ecx

; 428  :     // If we allocated some variables, delete them.
; 429  :     if (rgvarg)

  00000	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00003	74 08		 je	 SHORT $LN2@OposDispPa

; 430  :         delete [] rgvarg;

  00005	ff 31		 push	 DWORD PTR [ecx]
  00007	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0000c	59		 pop	 ecx
$LN2@OposDispPa:

; 431  : }

  0000d	c3		 ret	 0
??1OposDispParms@@QAE@XZ ENDP				; OposDispParms::~OposDispParms
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ??0OposDispParms@@QAE@PAVOposVariant@@H@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_pVars$ = 8						; size = 4
_nVars$ = 12						; size = 4
??0OposDispParms@@QAE@PAVOposVariant@@H@Z PROC		; OposDispParms::OposDispParms, COMDAT
; _this$ = ecx

; 396  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 397  :     // Initialize the DISPPARAMS to empty.
; 398  :     rgvarg = 0;
; 399  :     rgdispidNamedArgs = 0;
; 400  :     cArgs = 0;
; 401  :     cNamedArgs = 0;
; 402  : 
; 403  :     // If some variables and we successfully allocate memory...
; 404  :     if ( nVars != 0 && ( rgvarg = new VARIANT[nVars] ) != 0 )

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _nVars$[ebp]
  00008	33 c0		 xor	 eax, eax
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 75 fc	 mov	 DWORD PTR _this$1$[ebp], esi
  00010	89 06		 mov	 DWORD PTR [esi], eax
  00012	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00015	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00018	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0001b	85 db		 test	 ebx, ebx
  0001d	74 4a		 je	 SHORT $LN3@OposDispPa
  0001f	33 c9		 xor	 ecx, ecx
  00021	8b c3		 mov	 eax, ebx
  00023	6a 10		 push	 16			; 00000010H
  00025	5a		 pop	 edx
  00026	f7 e2		 mul	 edx
  00028	0f 90 c1	 seto	 cl
  0002b	f7 d9		 neg	 ecx
  0002d	0b c8		 or	 ecx, eax
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00035	89 06		 mov	 DWORD PTR [esi], eax
  00037	59		 pop	 ecx
  00038	85 c0		 test	 eax, eax
  0003a	74 2d		 je	 SHORT $LN3@OposDispPa

; 405  :     {
; 406  :         // Set variable count.
; 407  :         cArgs = nVars;

  0003c	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0003f	83 eb 01	 sub	 ebx, 1

; 408  :         // Copy OposVariant array elements to the VARIANT array.
; 409  :         //  - For [in] arguments, this will copy the type (VT_BOOL, VT_I4, VT_CY, VT_BSTR) and
; 410  :         //      its corresponding data. Note that for VT_BSTR, the data is a system string pointer.
; 411  :         //  - For [out] or [in,out] arguments, this will copy the type (VT_BYREF ORed with one
; 412  :         //      of the above 4 types) and the corresponding pointer to data.
; 413  :         //       * For VT_BYREF|VT_BOOL, VT_BYREF|VT_I4, and VT_BYREF|VT_CY, the pointer is to a primitive type.
; 414  :         //       * For VT_BYREF|VT_BSTR, the pointer is to a system string pointer.
; 415  :         //      If the function that is called (in a SO method or App event) changes the VARIANT,
; 416  :         //      it does so by updating the data that is pointed to -- which is the pointer that
; 417  :         //      was set by the OposVariant::Set...Ptr call.
; 418  :         // Because of the above, we must not call VariantClear on destruction of our class instance,
; 419  :         //   since that would delete the original OposVariant's data for VT_BSTR ([in]) and for
; 420  :         //   the VT_BYREF types ([out] and [in,out]).
; 421  :         while ( --nVars >= 0 )

  00042	78 25		 js	 SHORT $LN3@OposDispPa

; 405  :     {
; 406  :         // Set variable count.
; 407  :         cArgs = nVars;

  00044	6b cb 18	 imul	 ecx, ebx, 24
  00047	8b c3		 mov	 eax, ebx
  00049	c1 e0 04	 shl	 eax, 4
  0004c	57		 push	 edi
  0004d	03 4d 08	 add	 ecx, DWORD PTR _pVars$[ebp]
$LL2@OposDispPa:

; 422  :             rgvarg[nVars] = pVars[nVars];

  00050	8b 3e		 mov	 edi, DWORD PTR [esi]
  00052	8b f1		 mov	 esi, ecx
  00054	03 f8		 add	 edi, eax
  00056	83 e9 18	 sub	 ecx, 24			; 00000018H
  00059	83 e8 10	 sub	 eax, 16			; 00000010H
  0005c	83 eb 01	 sub	 ebx, 1
  0005f	a5		 movsd
  00060	a5		 movsd
  00061	a5		 movsd
  00062	a5		 movsd
  00063	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  00066	79 e8		 jns	 SHORT $LL2@OposDispPa
  00068	5f		 pop	 edi
$LN3@OposDispPa:

; 423  :     }
; 424  : }

  00069	8b c6		 mov	 eax, esi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	c9		 leave
  0006e	c2 08 00	 ret	 8
??0OposDispParms@@QAE@PAVOposVariant@@H@Z ENDP		; OposDispParms::OposDispParms
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetDispatch_Ptr@OposVariant@@QAEXPAUIDispatch@@AAJ@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?SetDispatch_Ptr@OposVariant@@QAEXPAUIDispatch@@AAJ@Z PROC ; OposVariant::SetDispatch_Ptr, COMDAT
; _this$ = ecx

; 373  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 377  :     if ( pSrc == 0 )

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  00014	85 c9		 test	 ecx, ecx
  00016	75 0b		 jne	 SHORT $LN2@SetDispatc

; 378  :         hr = E_POINTER;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  0001b	c7 00 03 40 00
	80		 mov	 DWORD PTR [eax], -2147467261 ; 80004003H
  00021	eb 13		 jmp	 SHORT $LN3@SetDispatc
$LN2@SetDispatc:

; 379  : 
; 380  :     // Set the variant, plus set flag so that the pointer is released by destructor.
; 381  :     else
; 382  :     {
; 383  :         vt = VT_DISPATCH;

  00023	6a 09		 push	 9
  00025	58		 pop	 eax
  00026	66 89 06	 mov	 WORD PTR [esi], ax

; 384  :         pdispVal = pSrc;

  00029	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 385  :         pSrc->AddRef();

  0002c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002e	51		 push	 ecx
  0002f	ff 50 04	 call	 DWORD PTR [eax+4]

; 386  :         _bNeedClear = true;

  00032	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
$LN3@SetDispatc:
  00036	5e		 pop	 esi

; 387  :     }
; 388  : }

  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?SetDispatch_Ptr@OposVariant@@QAEXPAUIDispatch@@AAJ@Z ENDP ; OposVariant::SetDispatch_Ptr
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetString@OposVariant@@QAEXPB_WAAJ@Z
_TEXT	SEGMENT
_lpszSrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?SetString@OposVariant@@QAEXPB_WAAJ@Z PROC		; OposVariant::SetString, COMDAT
; _this$ = ecx

; 350  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 354  :     bstrVal = SysAllocString(

  00011	83 7d 08 00	 cmp	 DWORD PTR _lpszSrc$[ebp], 0
  00015	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_11LOCGONAA@@
  0001a	0f 45 45 08	 cmovne	 eax, DWORD PTR _lpszSrc$[ebp]
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocString@4
  00025	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 355  :         lpszSrc ? lpszSrc : L"" );  // Source string, or empty string if NULL.
; 356  : 
; 357  :     // Set HRESULT if failed.
; 358  :     if ( NULL == bstrVal )

  00028	85 c0		 test	 eax, eax
  0002a	75 0b		 jne	 SHORT $LN2@SetString

; 359  :         hr = E_OUTOFMEMORY;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  0002f	c7 00 0e 00 07
	80		 mov	 DWORD PTR [eax], -2147024882 ; 8007000eH
  00035	eb 0a		 jmp	 SHORT $LN3@SetString
$LN2@SetString:

; 360  :     // Otherwise set variant type, plus set flag so that the BSTR is deleted by destructor.
; 361  :     else
; 362  :     {
; 363  :         vt = VT_BSTR;

  00037	6a 08		 push	 8
  00039	58		 pop	 eax
  0003a	66 89 06	 mov	 WORD PTR [esi], ax

; 364  :         _bNeedClear = true;

  0003d	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1
$LN3@SetString:
  00041	5e		 pop	 esi

; 365  :     }
; 366  : }

  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?SetString@OposVariant@@QAEXPB_WAAJ@Z ENDP		; OposVariant::SetString
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetVARIANT_Ptr@OposVariant@@QAEXAAPAUtagVARIANT@@GAAJ@Z
_TEXT	SEGMENT
_pvar$ = 8						; size = 4
_Type$ = 12						; size = 2
_hr$ = 16						; size = 4
?SetVARIANT_Ptr@OposVariant@@QAEXAAPAUtagVARIANT@@GAAJ@Z PROC ; OposVariant::SetVARIANT_Ptr, COMDAT
; _this$ = ecx

; 323  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 327  :     if ( pvar->vt == VT_EMPTY )

  00011	8b 45 08	 mov	 eax, DWORD PTR _pvar$[ebp]
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00019	66 85 c0	 test	 ax, ax
  0001c	74 2b		 je	 SHORT $LN5@SetVARIANT

; 328  :         ;
; 329  : 
; 330  :     // If type matches (ignoring the BYREF flag), then copy the variant.
; 331  :     //   Strips the BYREF if present.
; 332  :     else if ( ( pvar->vt & ~VT_BYREF ) == Type )

  0001e	25 ff bf ff ff	 and	 eax, -16385		; ffffbfffH
  00023	66 3b 45 0c	 cmp	 ax, WORD PTR _Type$[ebp]
  00027	75 17		 jne	 SHORT $LN4@SetVARIANT

; 333  :     {
; 334  :         HRESULT hrTmp = VariantCopyInd( this, pvar );

  00029	51		 push	 ecx
  0002a	56		 push	 esi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantCopyInd@8

; 335  :         if ( FAILED(hrTmp) )

  00031	85 c0		 test	 eax, eax
  00033	79 05		 jns	 SHORT $LN6@SetVARIANT

; 336  :             hr = hrTmp;

  00035	8b 4d 10	 mov	 ecx, DWORD PTR _hr$[ebp]
  00038	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@SetVARIANT:

; 337  :         _bNeedClear = true;

  0003a	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1

; 338  :     }

  0003e	eb 09		 jmp	 SHORT $LN5@SetVARIANT
$LN4@SetVARIANT:

; 339  : 
; 340  :     // If type doesn't match, then return failure.
; 341  :     else
; 342  :         hr = E_INVALIDARG;

  00040	8b 45 10	 mov	 eax, DWORD PTR _hr$[ebp]
  00043	c7 00 57 00 07
	80		 mov	 DWORD PTR [eax], -2147024809 ; 80070057H
$LN5@SetVARIANT:
  00049	5e		 pop	 esi

; 343  : }

  0004a	5d		 pop	 ebp
  0004b	c2 0c 00	 ret	 12			; 0000000cH
?SetVARIANT_Ptr@OposVariant@@QAEXAAPAUtagVARIANT@@GAAJ@Z ENDP ; OposVariant::SetVARIANT_Ptr
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetVARIANT@OposVariant@@QAEXAAUtagVARIANT@@GAAJ@Z
_TEXT	SEGMENT
_var$ = 8						; size = 4
_Type$ = 12						; size = 2
_hr$ = 16						; size = 4
?SetVARIANT@OposVariant@@QAEXAAUtagVARIANT@@GAAJ@Z PROC	; OposVariant::SetVARIANT, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 310  :     if ( ( var.vt & ~VT_BYREF ) == Type )

  00011	8b 4d 08	 mov	 ecx, DWORD PTR _var$[ebp]
  00014	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00017	25 ff bf ff ff	 and	 eax, -16385		; ffffbfffH
  0001c	66 3b 45 0c	 cmp	 ax, WORD PTR _Type$[ebp]
  00020	75 17		 jne	 SHORT $LN2@SetVARIANT

; 311  :     {
; 312  :         HRESULT hrTmp = VariantCopyInd( this, &var );

  00022	51		 push	 ecx
  00023	56		 push	 esi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantCopyInd@8

; 313  :         if ( FAILED(hrTmp) )

  0002a	85 c0		 test	 eax, eax
  0002c	79 05		 jns	 SHORT $LN4@SetVARIANT

; 314  :             hr = hrTmp;

  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _hr$[ebp]
  00031	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@SetVARIANT:

; 315  :         _bNeedClear = true;

  00033	c6 46 10 01	 mov	 BYTE PTR [esi+16], 1

; 316  :     }

  00037	eb 09		 jmp	 SHORT $LN3@SetVARIANT
$LN2@SetVARIANT:

; 317  :     // If type doesn't match, then return failure.
; 318  :     else
; 319  :         hr = E_INVALIDARG;

  00039	8b 45 10	 mov	 eax, DWORD PTR _hr$[ebp]
  0003c	c7 00 57 00 07
	80		 mov	 DWORD PTR [eax], -2147024809 ; 80070057H
$LN3@SetVARIANT:
  00042	5e		 pop	 esi

; 320  : }

  00043	5d		 pop	 ebp
  00044	c2 0c 00	 ret	 12			; 0000000cH
?SetVARIANT@OposVariant@@QAEXAAUtagVARIANT@@GAAJ@Z ENDP	; OposVariant::SetVARIANT
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetBSTR_InOutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z
_TEXT	SEGMENT
_pbstrSrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?SetBSTR_InOutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z PROC	; OposVariant::SetBSTR_InOutPtr, COMDAT
; _this$ = ecx

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 288  :     if ( pbstrSrc == 0 )

  00011	8b 45 08	 mov	 eax, DWORD PTR _pbstrSrc$[ebp]
  00014	85 c0		 test	 eax, eax
  00016	75 0d		 jne	 SHORT $LN2@SetBSTR_In

; 289  :     {
; 290  :         hr = E_POINTER;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  0001b	c7 00 03 40 00
	80		 mov	 DWORD PTR [eax], -2147467261 ; 80004003H

; 291  :         return false;

  00021	32 c0		 xor	 al, al
  00023	eb 0d		 jmp	 SHORT $LN1@SetBSTR_In
$LN2@SetBSTR_In:

; 292  :     }
; 293  : 
; 294  :     // Set the variant.
; 295  :     vt = VT_BYREF | VT_BSTR;

  00025	b9 08 40 00 00	 mov	 ecx, 16392		; 00004008H

; 296  :     pbstrVal = pbstrSrc;

  0002a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002d	66 89 0e	 mov	 WORD PTR [esi], cx

; 297  :     return true;

  00030	b0 01		 mov	 al, 1
$LN1@SetBSTR_In:
  00032	5e		 pop	 esi

; 298  : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
?SetBSTR_InOutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z ENDP	; OposVariant::SetBSTR_InOutPtr
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetBSTR_OutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z
_TEXT	SEGMENT
_pbstrSrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?SetBSTR_OutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z PROC	; OposVariant::SetBSTR_OutPtr, COMDAT
; _this$ = ecx

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 271  :     // Perform the in/out work first.
; 272  :     bool bRC = SetBSTR_InOutPtr( pbstrSrc, hr );

  00004	ff 75 0c	 push	 DWORD PTR _hr$[ebp]
  00007	8b 75 08	 mov	 esi, DWORD PTR _pbstrSrc$[ebp]
  0000a	56		 push	 esi
  0000b	e8 00 00 00 00	 call	 ?SetBSTR_InOutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z ; OposVariant::SetBSTR_InOutPtr

; 273  : 
; 274  :     // If succeeded, then ensure that the BSTR* points to zero:
; 275  :     //   This relieves subsequent code from needing to know out vs. in/out,
; 276  :     //   so that they won't wrongly try to reallocate an out.
; 277  :     if (bRC)

  00010	84 c0		 test	 al, al
  00012	74 03		 je	 SHORT $LN2@SetBSTR_Ou

; 278  :         *pbstrSrc = 0;

  00014	83 26 00	 and	 DWORD PTR [esi], 0
$LN2@SetBSTR_Ou:

; 279  : 
; 280  :     return bRC;

  00017	5e		 pop	 esi

; 281  : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
?SetBSTR_OutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z ENDP	; OposVariant::SetBSTR_OutPtr
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetBSTR_Copy@OposVariant@@QAEXPA_WAAJ@Z
_TEXT	SEGMENT
_bstrSrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?SetBSTR_Copy@OposVariant@@QAEXPA_WAAJ@Z PROC		; OposVariant::SetBSTR_Copy, COMDAT
; _this$ = ecx

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	57		 push	 edi
  00007	c6 47 10 00	 mov	 BYTE PTR [edi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 252  :     bstrVal = SysAllocStringLen(

  00011	ff 75 08	 push	 DWORD PTR _bstrSrc$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysStringLen@4
  0001a	83 7d 08 00	 cmp	 DWORD PTR _bstrSrc$[ebp], 0
  0001e	50		 push	 eax
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_11LOCGONAA@@
  00024	0f 45 45 08	 cmovne	 eax, DWORD PTR _bstrSrc$[ebp]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocStringLen@8
  0002f	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 253  :            bstrSrc ? bstrSrc : L"",     // Source string, or empty string if NULL.
; 254  :            SysStringLen(bstrSrc) );     // Length of string; will return zero if NULL.
; 255  : 
; 256  :     // Set HRESULT if failed.
; 257  :     if ( NULL == bstrVal )

  00032	85 c0		 test	 eax, eax
  00034	75 0b		 jne	 SHORT $LN2@SetBSTR_Co

; 258  :         hr = E_OUTOFMEMORY;

  00036	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  00039	c7 00 0e 00 07
	80		 mov	 DWORD PTR [eax], -2147024882 ; 8007000eH
  0003f	eb 0a		 jmp	 SHORT $LN3@SetBSTR_Co
$LN2@SetBSTR_Co:

; 259  :     // Otherwise set variant type, plus set flag so that the BSTR is deleted by destructor.
; 260  :     else
; 261  :     {
; 262  :         vt = VT_BSTR;

  00041	6a 08		 push	 8
  00043	58		 pop	 eax
  00044	66 89 07	 mov	 WORD PTR [edi], ax

; 263  :         _bNeedClear = true;

  00047	c6 47 10 01	 mov	 BYTE PTR [edi+16], 1
$LN3@SetBSTR_Co:
  0004b	5f		 pop	 edi

; 264  :     }
; 265  : }

  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?SetBSTR_Copy@OposVariant@@QAEXPA_WAAJ@Z ENDP		; OposVariant::SetBSTR_Copy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetBSTR@OposVariant@@QAEXPA_WAAJ@Z
_TEXT	SEGMENT
_bstrSrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?SetBSTR@OposVariant@@QAEXPA_WAAJ@Z PROC		; OposVariant::SetBSTR, COMDAT
; _this$ = ecx

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 228  :     // If non-NULL BSTR, then just pass BSTR in the variant.
; 229  :     //   _bNeedClear flag remains off because we are not responsible
; 230  :     //   for deleting the BSTR.
; 231  :     if ( bstrSrc != 0 )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _bstrSrc$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	74 16		 je	 SHORT $LN2@SetBSTR
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  0000e	56		 push	 esi
  0000f	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 234  :         vt = VT_BSTR;

  00019	6a 08		 push	 8
  0001b	58		 pop	 eax
  0001c	66 89 06	 mov	 WORD PTR [esi], ax

; 235  :         bstrVal = bstrSrc;

  0001f	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 236  :     }

  00022	eb 0a		 jmp	 SHORT $LN3@SetBSTR
$LN2@SetBSTR:

; 237  : 
; 238  :     // If NULL BSTR, call function so that zero-length BSTR is passed.
; 239  :     //   This may prevent a lazy/bad service objects from causing GPF,
; 240  :     //   in case they don't check each BSTR for NULL.
; 241  :     else
; 242  :         SetBSTR_Copy( 0, hr );

  00024	ff 75 0c	 push	 DWORD PTR _hr$[ebp]
  00027	6a 00		 push	 0
  00029	e8 00 00 00 00	 call	 ?SetBSTR_Copy@OposVariant@@QAEXPA_WAAJ@Z ; OposVariant::SetBSTR_Copy
$LN3@SetBSTR:

; 243  : }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
?SetBSTR@OposVariant@@QAEXPA_WAAJ@Z ENDP		; OposVariant::SetBSTR
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?ChangeBSTR@OposVariant@@QAEXPAPA_WAAJ@Z
_TEXT	SEGMENT
_var$1 = -16						; size = 16
_pbstrSrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?ChangeBSTR@OposVariant@@QAEXPAPA_WAAJ@Z PROC		; OposVariant::ChangeBSTR, COMDAT
; _this$ = ecx

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 207  :     // Validate that the parameter is not NULL.
; 208  :     if ( pbstrSrc == 0 )

  00007	8b 75 08	 mov	 esi, DWORD PTR _pbstrSrc$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	75 0b		 jne	 SHORT $LN2@ChangeBSTR

; 209  :         hr = E_POINTER;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  00011	c7 00 03 40 00
	80		 mov	 DWORD PTR [eax], -2147467261 ; 80004003H
  00017	eb 23		 jmp	 SHORT $LN3@ChangeBSTR
$LN2@ChangeBSTR:

; 210  : 
; 211  :     // If pointer OK, set it after trying to coerce variant.
; 212  :     else
; 213  :     {
; 214  :         // Try to coerce variant to a new variant of type BSTR.
; 215  :         VARIANT var;
; 216  :         var.vt = VT_EMPTY;

  00019	33 c0		 xor	 eax, eax

; 217  :         hr = VariantChangeType(

  0001b	6a 08		 push	 8
  0001d	50		 push	 eax
  0001e	66 89 45 f0	 mov	 WORD PTR _var$1[ebp], ax
  00022	8d 45 f0	 lea	 eax, DWORD PTR _var$1[ebp]
  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantChangeType@16
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _hr$[ebp]
  00030	89 01		 mov	 DWORD PTR [ecx], eax

; 218  :             &var, static_cast<VARIANT*>(this), 0, VT_BSTR );
; 219  :         // If coercion was successful, then update to the BSTR; else set to NULL.
; 220  :         *pbstrSrc = ( hr == S_OK ) ? var.bstrVal : 0;

  00032	33 c9		 xor	 ecx, ecx
  00034	85 c0		 test	 eax, eax
  00036	0f 44 4d f8	 cmove	 ecx, DWORD PTR _var$1[ebp+8]
  0003a	89 0e		 mov	 DWORD PTR [esi], ecx
$LN3@ChangeBSTR:
  0003c	5e		 pop	 esi

; 221  :     }
; 222  : }

  0003d	c9		 leave
  0003e	c2 08 00	 ret	 8
?ChangeBSTR@OposVariant@@QAEXPAPA_WAAJ@Z ENDP		; OposVariant::ChangeBSTR
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetCURRENCY_Ptr@OposVariant@@QAEXPATtagCY@@AAJ@Z
_TEXT	SEGMENT
_pcySrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?SetCURRENCY_Ptr@OposVariant@@QAEXPATtagCY@@AAJ@Z PROC	; OposVariant::SetCURRENCY_Ptr, COMDAT
; _this$ = ecx

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 189  :     if ( pcySrc == 0 )

  00011	8b 45 08	 mov	 eax, DWORD PTR _pcySrc$[ebp]
  00014	85 c0		 test	 eax, eax
  00016	75 0b		 jne	 SHORT $LN2@SetCURRENC

; 190  :         hr = E_POINTER;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  0001b	c7 00 03 40 00
	80		 mov	 DWORD PTR [eax], -2147467261 ; 80004003H
  00021	eb 0b		 jmp	 SHORT $LN3@SetCURRENC
$LN2@SetCURRENC:

; 191  : 
; 192  :     // Set the variant.
; 193  :     else
; 194  :     {
; 195  :         vt = VT_BYREF | VT_CY;

  00023	b9 06 40 00 00	 mov	 ecx, 16390		; 00004006H

; 196  :         pcyVal = pcySrc;

  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	66 89 0e	 mov	 WORD PTR [esi], cx
$LN3@SetCURRENC:
  0002e	5e		 pop	 esi

; 197  :     }
; 198  : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?SetCURRENCY_Ptr@OposVariant@@QAEXPATtagCY@@AAJ@Z ENDP	; OposVariant::SetCURRENCY_Ptr
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetCURRENCY@OposVariant@@QAEXTtagCY@@@Z
_TEXT	SEGMENT
_cySrc$ = 8						; size = 8
?SetCURRENCY@OposVariant@@QAEXTtagCY@@@Z PROC		; OposVariant::SetCURRENCY, COMDAT
; _this$ = ecx

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 179  :     cyVal = cySrc;

  00011	8b 55 0c	 mov	 edx, DWORD PTR _cySrc$[ebp+4]
  00014	6a 06		 push	 6
  00016	58		 pop	 eax
  00017	66 89 06	 mov	 WORD PTR [esi], ax
  0001a	8b 45 08	 mov	 eax, DWORD PTR _cySrc$[ebp]
  0001d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00020	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  00023	5e		 pop	 esi

; 180  : }

  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
?SetCURRENCY@OposVariant@@QAEXTtagCY@@@Z ENDP		; OposVariant::SetCURRENCY
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?ChangeCURRENCY@OposVariant@@QAEXPATtagCY@@AAJ@Z
_TEXT	SEGMENT
_var$1 = -16						; size = 16
_pcySrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?ChangeCURRENCY@OposVariant@@QAEXPATtagCY@@AAJ@Z PROC	; OposVariant::ChangeCURRENCY, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 153  :     // Validate that the parameter is not NULL.
; 154  :     if ( pcySrc == 0 )

  00007	8b 75 08	 mov	 esi, DWORD PTR _pcySrc$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	75 0b		 jne	 SHORT $LN2@ChangeCURR

; 155  :         hr = E_POINTER;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  00011	c7 00 03 40 00
	80		 mov	 DWORD PTR [eax], -2147467261 ; 80004003H
  00017	eb 31		 jmp	 SHORT $LN5@ChangeCURR
$LN2@ChangeCURR:

; 156  : 
; 157  :     // If pointer OK, set it after trying to coerce variant.
; 158  :     else
; 159  :     {
; 160  :         // Try to coerce variant to a new variant of type CURRENCY (CY).
; 161  :         VARIANT var;
; 162  :         var.vt = VT_EMPTY;

  00019	33 c0		 xor	 eax, eax

; 163  :         hr = VariantChangeType(

  0001b	6a 06		 push	 6
  0001d	50		 push	 eax
  0001e	66 89 45 f0	 mov	 WORD PTR _var$1[ebp], ax
  00022	8d 45 f0	 lea	 eax, DWORD PTR _var$1[ebp]
  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantChangeType@16
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _hr$[ebp]
  00030	89 01		 mov	 DWORD PTR [ecx], eax

; 164  :             &var, static_cast<VARIANT*>(this), 0, VT_CY );
; 165  :         // If coercion was successful, then update to the CURRENCY; else set to zero.
; 166  :         if ( hr == S_OK )

  00032	85 c0		 test	 eax, eax
  00034	75 0d		 jne	 SHORT $LN4@ChangeCURR

; 167  :             *pcySrc = var.cyVal;

  00036	8b 45 f8	 mov	 eax, DWORD PTR _var$1[ebp+8]
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _var$1[ebp+12]
  0003c	89 06		 mov	 DWORD PTR [esi], eax
  0003e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00041	eb 07		 jmp	 SHORT $LN5@ChangeCURR
$LN4@ChangeCURR:

; 168  :         else
; 169  :             pcySrc->int64 = 0;

  00043	83 26 00	 and	 DWORD PTR [esi], 0
  00046	83 66 04 00	 and	 DWORD PTR [esi+4], 0
$LN5@ChangeCURR:
  0004a	5e		 pop	 esi

; 170  :     }
; 171  : }

  0004b	c9		 leave
  0004c	c2 08 00	 ret	 8
?ChangeCURRENCY@OposVariant@@QAEXPATtagCY@@AAJ@Z ENDP	; OposVariant::ChangeCURRENCY
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetLONG_Ptr@OposVariant@@QAEXPAJAAJ@Z
_TEXT	SEGMENT
_pnSrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?SetLONG_Ptr@OposVariant@@QAEXPAJAAJ@Z PROC		; OposVariant::SetLONG_Ptr, COMDAT
; _this$ = ecx

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 136  :     if ( pnSrc == 0 )

  00011	8b 45 08	 mov	 eax, DWORD PTR _pnSrc$[ebp]
  00014	85 c0		 test	 eax, eax
  00016	75 0b		 jne	 SHORT $LN2@SetLONG_Pt

; 137  :         hr = E_POINTER;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  0001b	c7 00 03 40 00
	80		 mov	 DWORD PTR [eax], -2147467261 ; 80004003H
  00021	eb 0b		 jmp	 SHORT $LN3@SetLONG_Pt
$LN2@SetLONG_Pt:

; 138  : 
; 139  :     // Set the variant.
; 140  :     else
; 141  :     {
; 142  :         vt = VT_BYREF | VT_I4;

  00023	b9 03 40 00 00	 mov	 ecx, 16387		; 00004003H

; 143  :         plVal = pnSrc;

  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	66 89 0e	 mov	 WORD PTR [esi], cx
$LN3@SetLONG_Pt:
  0002e	5e		 pop	 esi

; 144  :     }
; 145  : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?SetLONG_Ptr@OposVariant@@QAEXPAJAAJ@Z ENDP		; OposVariant::SetLONG_Ptr
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetLONG@OposVariant@@QAEXJ@Z
_TEXT	SEGMENT
_nSrc$ = 8						; size = 4
?SetLONG@OposVariant@@QAEXJ@Z PROC			; OposVariant::SetLONG, COMDAT
; _this$ = ecx

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 125  :     vt = VT_I4;

  00011	6a 03		 push	 3
  00013	58		 pop	 eax
  00014	66 89 06	 mov	 WORD PTR [esi], ax

; 126  :     lVal = nSrc;

  00017	8b 45 08	 mov	 eax, DWORD PTR _nSrc$[ebp]
  0001a	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001d	5e		 pop	 esi

; 127  : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?SetLONG@OposVariant@@QAEXJ@Z ENDP			; OposVariant::SetLONG
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?ChangeLONG@OposVariant@@QAEXPAJAAJ@Z
_TEXT	SEGMENT
_var$1 = -16						; size = 16
_pLong$ = 8						; size = 4
_hr$ = 12						; size = 4
?ChangeLONG@OposVariant@@QAEXPAJAAJ@Z PROC		; OposVariant::ChangeLONG, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 103  :     // Validate that the parameter is not NULL.
; 104  :     if ( pLong == 0 )

  00007	8b 75 08	 mov	 esi, DWORD PTR _pLong$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	75 0b		 jne	 SHORT $LN2@ChangeLONG

; 105  :         hr = E_POINTER;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  00011	c7 00 03 40 00
	80		 mov	 DWORD PTR [eax], -2147467261 ; 80004003H
  00017	eb 23		 jmp	 SHORT $LN3@ChangeLONG
$LN2@ChangeLONG:

; 106  : 
; 107  :     // If pointer OK, set it after trying to coerce variant.
; 108  :     else
; 109  :     {
; 110  :         // Try to coerce variant to a new variant of type LONG (I4).
; 111  :         VARIANT var;
; 112  :         var.vt = VT_EMPTY;

  00019	33 c0		 xor	 eax, eax

; 113  :         hr = VariantChangeType(

  0001b	6a 03		 push	 3
  0001d	50		 push	 eax
  0001e	66 89 45 f0	 mov	 WORD PTR _var$1[ebp], ax
  00022	8d 45 f0	 lea	 eax, DWORD PTR _var$1[ebp]
  00025	51		 push	 ecx
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantChangeType@16
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _hr$[ebp]
  00030	89 01		 mov	 DWORD PTR [ecx], eax

; 114  :             &var, static_cast<VARIANT*>(this), 0, VT_I4 );
; 115  :         // If coercion was successful, then update to the LONG; else set to zero.
; 116  :         *pLong = ( hr == S_OK ) ? var.lVal : 0;

  00032	33 c9		 xor	 ecx, ecx
  00034	85 c0		 test	 eax, eax
  00036	0f 44 4d f8	 cmove	 ecx, DWORD PTR _var$1[ebp+8]
  0003a	89 0e		 mov	 DWORD PTR [esi], ecx
$LN3@ChangeLONG:
  0003c	5e		 pop	 esi

; 117  :     }
; 118  : }

  0003d	c9		 leave
  0003e	c2 08 00	 ret	 8
?ChangeLONG@OposVariant@@QAEXPAJAAJ@Z ENDP		; OposVariant::ChangeLONG
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?GetLONG@OposVariant@@QAEJXZ
_TEXT	SEGMENT
_hr$ = -8						; size = 4
_nLong$ = -4						; size = 4
?GetLONG@OposVariant@@QAEJXZ PROC			; OposVariant::GetLONG, COMDAT
; _this$ = ecx

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 93   :     LONG nLong = 0;

  00005	83 65 fc 00	 and	 DWORD PTR _nLong$[ebp], 0

; 94   :     HRESULT hr;
; 95   :     ChangeLONG( &nLong, hr );

  00009	8d 45 f8	 lea	 eax, DWORD PTR _hr$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 fc	 lea	 eax, DWORD PTR _nLong$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?ChangeLONG@OposVariant@@QAEXPAJAAJ@Z ; OposVariant::ChangeLONG

; 96   :     return nLong;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _nLong$[ebp]

; 97   : }

  00019	c9		 leave
  0001a	c3		 ret	 0
?GetLONG@OposVariant@@QAEJXZ ENDP			; OposVariant::GetLONG
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetVARIANT_BOOL_Ptr@OposVariant@@QAEXPAFAAJ@Z
_TEXT	SEGMENT
_pbSrc$ = 8						; size = 4
_hr$ = 12						; size = 4
?SetVARIANT_BOOL_Ptr@OposVariant@@QAEXPAFAAJ@Z PROC	; OposVariant::SetVARIANT_BOOL_Ptr, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 76   :     if ( pbSrc == 0 )

  00011	8b 45 08	 mov	 eax, DWORD PTR _pbSrc$[ebp]
  00014	85 c0		 test	 eax, eax
  00016	75 0b		 jne	 SHORT $LN2@SetVARIANT

; 77   :         hr = E_POINTER;

  00018	8b 45 0c	 mov	 eax, DWORD PTR _hr$[ebp]
  0001b	c7 00 03 40 00
	80		 mov	 DWORD PTR [eax], -2147467261 ; 80004003H
  00021	eb 0b		 jmp	 SHORT $LN3@SetVARIANT
$LN2@SetVARIANT:

; 78   : 
; 79   :     // Set the variant.
; 80   :     else
; 81   :     {
; 82   :         vt = VT_BYREF | VT_BOOL;

  00023	b9 0b 40 00 00	 mov	 ecx, 16395		; 0000400bH

; 83   :         pboolVal = pbSrc;

  00028	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0002b	66 89 0e	 mov	 WORD PTR [esi], cx
$LN3@SetVARIANT:
  0002e	5e		 pop	 esi

; 84   :     }
; 85   : }

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?SetVARIANT_BOOL_Ptr@OposVariant@@QAEXPAFAAJ@Z ENDP	; OposVariant::SetVARIANT_BOOL_Ptr
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp
;	COMDAT ?SetVARIANT_BOOL@OposVariant@@QAEXF@Z
_TEXT	SEGMENT
_bSrc$ = 8						; size = 2
?SetVARIANT_BOOL@OposVariant@@QAEXF@Z PROC		; OposVariant::SetVARIANT_BOOL, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	56		 push	 esi
  00007	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\OposVariant.cpp

; 65   :     vt = VT_BOOL;

  00011	6a 0b		 push	 11			; 0000000bH
  00013	58		 pop	 eax
  00014	66 89 06	 mov	 WORD PTR [esi], ax

; 66   :     boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;

  00017	33 c0		 xor	 eax, eax
  00019	66 39 45 08	 cmp	 WORD PTR _bSrc$[ebp], ax
  0001d	0f 94 c0	 sete	 al
  00020	48		 dec	 eax
  00021	66 89 46 08	 mov	 WORD PTR [esi+8], ax
  00025	5e		 pop	 esi

; 67   : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?SetVARIANT_BOOL@OposVariant@@QAEXF@Z ENDP		; OposVariant::SetVARIANT_BOOL
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z PROC	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	f6 45 08 02	 test	 BYTE PTR ___flags$[ebp], 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 40		 je	 SHORT $LN2@vector
  0000d	53		 push	 ebx
  0000e	57		 push	 edi
  0000f	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00012	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00014	6b c3 0c	 imul	 eax, ebx, 12
  00017	03 c6		 add	 eax, esi
  00019	85 db		 test	 ebx, ebx
  0001b	74 15		 je	 SHORT $LN19@vector
  0001d	8b f8		 mov	 edi, eax
$LL7@vector:
  0001f	8d 7f f4	 lea	 edi, DWORD PTR [edi-12]

; 1674 :     ::SysFreeString(m_str);

  00022	ff 37		 push	 DWORD PTR [edi]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  0002a	83 eb 01	 sub	 ebx, 1
  0002d	75 f0		 jne	 SHORT $LL7@vector
  0002f	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
$LN19@vector:
  00032	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00036	74 0f		 je	 SHORT $LN3@vector
  00038	6b 0f 0c	 imul	 ecx, DWORD PTR [edi], 12
  0003b	83 c1 04	 add	 ecx, 4
  0003e	51		 push	 ecx
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx
$LN3@vector:
  00047	8b c7		 mov	 eax, edi
  00049	5f		 pop	 edi
  0004a	5b		 pop	 ebx
  0004b	eb 1a		 jmp	 SHORT $LN1@vector
$LN2@vector:
  0004d	ff 36		 push	 DWORD PTR [esi]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  00055	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00059	74 0a		 je	 SHORT $LN4@vector
  0005b	6a 0c		 push	 12			; 0000000cH
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00063	59		 pop	 ecx
  00064	59		 pop	 ecx
$LN4@vector:
  00065	8b c6		 mov	 eax, esi
$LN1@vector:
  00067	5e		 pop	 esi
  00068	c9		 leave
  00069	c2 04 00	 ret	 4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ENDP	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ PROC	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid, COMDAT
; _this$ = ecx

; 1674 :     ::SysFreeString(m_str);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  00008	c3		 ret	 0
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ ENDP	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2957 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

  00000	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00006	68 00 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  0000b	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 311  : 	RemoveAll();

  00010	b9 20 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00015	e9 00 00 00 00	 jmp	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2972 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00005	e8 00 00 00 00	 call	 ??0CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::CAtlWinModule
  0000a	68 00 00 00 00	 push	 OFFSET ??__F_AtlWinModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlWinModule''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2937 : 	CAtlWinModule()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00003	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2937 : 	CAtlWinModule()

  00005	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00006	6a 06		 push	 6
  00008	59		 pop	 ecx
  00009	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0000c	f3 ab		 rep stosd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  0000e	33 ff		 xor	 edi, edi
  00010	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  00013	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  00016	89 7e 28	 mov	 DWORD PTR [esi+40], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2940 : 		HRESULT hr = AtlWinModuleInit(this);

  00019	56		 push	 esi
  0001a	c7 06 2c 00 00
	00		 mov	 DWORD PTR [esi], 44	; 0000002cH
  00020	e8 00 00 00 00	 call	 ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit

; 2941 : 		if (FAILED(hr))

  00025	85 c0		 test	 eax, eax
  00027	79 09		 jns	 SHORT $LN2@CAtlWinMod

; 2942 : 		{
; 2943 : 			ATLASSERT(0);
; 2944 : 			CAtlBaseModule::m_bInitFailed = true;

  00029	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2945 : 			cbSize = 0;

  00030	89 3e		 mov	 DWORD PTR [esi], edi
$LN2@CAtlWinMod:

; 2946 : 			return;
; 2947 : 		}
; 2948 : 	}

  00032	5f		 pop	 edi
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c3		 ret	 0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT

; 2608 : 		Term();

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00005	e9 00 00 00 00	 jmp	 ?Term@CAtlComModule@ATL@@QAEXXZ ; ATL::CAtlComModule::Term
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
text$yd	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT

; 2716 : __declspec(selectany) CAtlComModule _AtlComModule;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00005	e8 00 00 00 00	 call	 ??0CAtlComModule@ATL@@QAE@XZ ; ATL::CAtlComModule::CAtlComModule
  0000a	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2613 : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2614 : 		if (cbSize == 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 40		 je	 SHORT $LN1@Term

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00008	57		 push	 edi
  00009	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0000c	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  0000f	73 29		 jae	 SHORT $LN3@Term
  00011	53		 push	 ebx
$LL4@Term:

; 2618 : 		{
; 2619 : 			if (*ppEntry != NULL)

  00012	8b 07		 mov	 eax, DWORD PTR [edi]
  00014	85 c0		 test	 eax, eax
  00016	74 19		 je	 SHORT $LN2@Term

; 2620 : 			{
; 2621 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  00018	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 2622 : 
; 2623 : 				if (pCache->pCF != NULL)

  0001b	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0001e	74 11		 je	 SHORT $LN2@Term

; 2624 : 				{
; 2625 : 					// Decode factory pointer if it's not null
; 2626 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  00020	ff 33		 push	 DWORD PTR [ebx]
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4

; 2627 : 					_Analysis_assume_(factory != nullptr);
; 2628 : 					factory->Release();

  00028	50		 push	 eax
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2629 : 					pCache->pCF = NULL;

  0002e	83 23 00	 and	 DWORD PTR [ebx], 0
$LN2@Term:

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00031	83 c7 04	 add	 edi, 4
  00034	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  00037	72 d9		 jb	 SHORT $LL4@Term
  00039	5b		 pop	 ebx
$LN3@Term:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  0003a	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2637 : 		cbSize = 0;

  00044	83 26 00	 and	 DWORD PTR [esi], 0
  00047	5f		 pop	 edi
$LN1@Term:

; 2638 : 	}

  00048	5e		 pop	 esi
  00049	c3		 ret	 0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2586 : 	CAtlComModule() throw()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00003	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2586 : 	CAtlComModule() throw()

  00005	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00006	6a 06		 push	 6
  00008	59		 pop	 ecx
  00009	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  0000c	f3 ab		 rep stosd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2588 : 		cbSize = 0;

  0000e	21 06		 and	 DWORD PTR [esi], eax

; 2589 : 
; 2590 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);
; 2591 : 
; 2592 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;
; 2593 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;
; 2594 : 
; 2595 : 		if (FAILED(m_csObjMap.Init()))

  00010	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], OFFSET ___ImageBase
  0001a	c7 46 08 04 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ___pobjMapEntryFirst+4
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET ___pobjMapEntryLast
  00028	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  0002d	85 c0		 test	 eax, eax
  0002f	79 09		 jns	 SHORT $LN2@CAtlComMod

; 2596 : 		{
; 2597 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2598 : 			ATLASSERT(0);
; 2599 : 			CAtlBaseModule::m_bInitFailed = true;

  00031	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2600 : 			return;

  00038	eb 06		 jmp	 SHORT $LN1@CAtlComMod
$LN2@CAtlComMod:

; 2601 : 		}
; 2602 : 		// Set cbSize on success.
; 2603 : 		cbSize = sizeof(_ATL_COM_MODULE);

  0003a	c7 06 28 00 00
	00		 mov	 DWORD PTR [esi], 40	; 00000028H
$LN1@CAtlComMod:

; 2604 : 	}

  00040	5f		 pop	 edi
  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	c3		 ret	 0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7652 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _pWinModule$[ebp]

; 7653 : 	if (pWinModule == NULL)

  00007	85 f6		 test	 esi, esi
  00009	74 4e		 je	 SHORT $LN16@AtlWinModu

; 7654 : 		return E_INVALIDARG;
; 7655 : 	if (pWinModule->cbSize == 0)

  0000b	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000e	75 04		 jne	 SHORT $LN6@AtlWinModu

; 7656 : 		return S_OK;

  00010	33 c0		 xor	 eax, eax
  00012	eb 4a		 jmp	 SHORT $LN1@AtlWinModu
$LN6@AtlWinModu:

; 7657 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00014	83 3e 2c	 cmp	 DWORD PTR [esi], 44	; 0000002cH
  00017	75 40		 jne	 SHORT $LN16@AtlWinModu

; 7659 : 
; 7660 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  00019	53		 push	 ebx
  0001a	57		 push	 edi
  0001b	33 ff		 xor	 edi, edi
  0001d	39 7e 24	 cmp	 DWORD PTR [esi+36], edi
  00020	7e 1c		 jle	 SHORT $LN14@AtlWinModu
$LL4@AtlWinModu:

; 7661 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  00022	57		 push	 edi
  00023	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00026	e8 00 00 00 00	 call	 ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
  0002b	ff 75 0c	 push	 DWORD PTR _hInst$[ebp]
  0002e	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassW@8
  00038	47		 inc	 edi
  00039	3b 7e 24	 cmp	 edi, DWORD PTR [esi+36]
  0003c	7c e4		 jl	 SHORT $LL4@AtlWinModu
$LN14@AtlWinModu:

; 7662 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

  0003e	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00041	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  00046	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7664 : 	pWinModule->cbSize = 0;

  00050	83 26 00	 and	 DWORD PTR [esi], 0

; 7665 : 	return S_OK;

  00053	33 c0		 xor	 eax, eax
  00055	5f		 pop	 edi
  00056	5b		 pop	 ebx
  00057	eb 05		 jmp	 SHORT $LN1@AtlWinModu
$LN16@AtlWinModu:

; 7658 : 		return E_INVALIDARG;

  00059	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN1@AtlWinModu:
  0005e	5e		 pop	 esi

; 7666 : }

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8396 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8397 : 	if (pWinModule == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN6@AtlWinModu

; 8398 : 		return E_INVALIDARG;
; 8399 : 
; 8400 : 	// check only in the DLL
; 8401 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0000a	83 39 2c	 cmp	 DWORD PTR [ecx], 44	; 0000002cH
  0000d	75 0e		 jne	 SHORT $LN6@AtlWinModu

; 8403 : 
; 8404 : 	pWinModule->m_pCreateWndList = NULL;

  0000f	83 61 1c 00	 and	 DWORD PTR [ecx+28], 0

; 8405 : 
; 8406 : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

  00013	83 c1 04	 add	 ecx, 4
  00016	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init

; 8407 : 	if (FAILED(hr))
; 8408 : 	{
; 8409 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));
; 8410 : 		ATLASSERT(0);
; 8411 : 	}
; 8412 : 	return hr;

  0001b	eb 05		 jmp	 SHORT $LN1@AtlWinModu
$LN6@AtlWinModu:

; 8402 : 		return E_INVALIDARG;

  0001d	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN1@AtlWinModu:

; 8413 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0e		 js	 SHORT $LN3@operator
  0000a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0000d	7d 09		 jge	 SHORT $LN3@operator

; 241  : 		}
; 242  : 		return m_aT[nIndex];

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 243  : 	}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00018	6a 01		 push	 1
  0001a	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0001f	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN5@operator:
  00024	cc		 int	 3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 216  : 		if(m_aT != NULL)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0b		 je	 SHORT $LN5@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 _free

; 221  : 			m_aT = NULL;

  0000f	83 26 00	 and	 DWORD PTR [esi], 0
  00012	59		 pop	 ecx
$LN5@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;

  00013	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 224  : 		m_nAllocSize = 0;

  00017	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  0001b	5e		 pop	 esi

; 225  :     }

  0001c	c3		 ret	 0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwinverapi.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\winerror.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 143  : 	{

  00000	56		 push	 esi

; 144  : 		HRESULT hRes = S_OK;

  00001	33 f6		 xor	 esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00003	56		 push	 esi
  00004	56		 push	 esi
  00005	51		 push	 ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 145  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  0000c	85 c0		 test	 eax, eax
  0000e	75 14		 jne	 SHORT $LN2@Init

; 146  : 		{
; 147  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\winerror.h

; 29051: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00016	0f b7 f0	 movzx	 esi, ax
  00019	81 ce 00 00 07
	80		 or	 esi, -2147024896	; 80070000H
  0001f	85 c0		 test	 eax, eax
  00021	0f 4e f0	 cmovle	 esi, eax
$LN2@Init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 150  : 		return hRes;

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi

; 151  : 	}

  00027	c3		 ret	 0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00003	ff 75 10	 push	 DWORD PTR _Flags$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _dwSpinCount$[ebp]
  00009	ff 75 08	 push	 DWORD PTR _lpCriticalSection$[ebp]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12

; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 736  : #endif
; 737  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	ff 75 0c	 push	 DWORD PTR _dwExceptionFlags$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _dwExceptionCode$[ebp]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 32   : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_I@YGXPAXIIP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_I@YGXPAXIIP6EX0@Z@Z PROC				; `vector destructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR ___s$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  0000a	0f af c6	 imul	 eax, esi
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
  00011	03 f8		 add	 edi, eax
  00013	85 f6		 test	 esi, esi
  00015	74 0d		 je	 SHORT $LN6@vector
$LL2@vector:
  00017	2b 7d 0c	 sub	 edi, DWORD PTR ___s$[ebp]
  0001a	8b cf		 mov	 ecx, edi
  0001c	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001f	83 ee 01	 sub	 esi, 1
  00022	75 f3		 jne	 SHORT $LL2@vector
$LN6@vector:
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 10 00	 ret	 16			; 00000010H
??_I@YGXPAXIIP6EX0@Z@Z ENDP				; `vector destructor iterator'
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 12		 je	 SHORT $LN6@vector
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  0000f	8b cf		 mov	 ecx, edi
  00011	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00014	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00017	83 ee 01	 sub	 esi, 1
  0001a	75 f3		 jne	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
$LN6@vector:
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
