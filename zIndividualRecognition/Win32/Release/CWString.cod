; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Develop\OPOS-CCO\Common\CWString.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?cw_memcpy@@YGHPADPB_WH@Z			; cw_memcpy
PUBLIC	?cw_memcpy@@YGHPA_WPBDH@Z			; cw_memcpy
PUBLIC	?cw_memcpy@@YGHPADPBDH@Z			; cw_memcpy
PUBLIC	?cw_memcpy@@YGHPA_WPB_WH@Z			; cw_memcpy
PUBLIC	?cw_memset@@YAXPADDH@Z				; cw_memset
PUBLIC	?cw_memset@@YAXPA_W_WH@Z			; cw_memset
PUBLIC	?cw_strlen@@YAHPBD@Z				; cw_strlen
PUBLIC	?cw_strlen@@YAHPB_W@Z				; cw_strlen
PUBLIC	?cw_strcpy@@YAHPADPB_W@Z			; cw_strcpy
PUBLIC	?cw_strcpy@@YAHPA_WPBD@Z			; cw_strcpy
PUBLIC	?cw_strcpy@@YAHPADPBD@Z				; cw_strcpy
PUBLIC	?cw_strcpy@@YAHPA_WPB_W@Z			; cw_strcpy
PUBLIC	?cw_strcat@@YAHPADPB_W@Z			; cw_strcat
PUBLIC	?cw_strcat@@YAHPA_WPBD@Z			; cw_strcat
PUBLIC	?cw_strcat@@YAHPADPBD@Z				; cw_strcat
PUBLIC	?cw_strcat@@YAHPA_WPB_W@Z			; cw_strcat
PUBLIC	?cw_dup@@YGXPBDAAHAAPA_W1@Z			; cw_dup
PUBLIC	?cw_dup@@YGXPB_WAAHAAPAD1@Z			; cw_dup
PUBLIC	?DupChar@_CW@@AAEXXZ				; _CW::DupChar
PUBLIC	?DupWide@_CW@@AAEXXZ				; _CW::DupWide
PUBLIC	?GetCharsMbcs@_CW@@QAEHXZ			; _CW::GetCharsMbcs
PUBLIC	?GetCharsWide@_CW@@QAEHXZ			; _CW::GetCharsWide
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?GetCharsWide@_CW@@QAEHXZ
_TEXT	SEGMENT
?GetCharsWide@_CW@@QAEHXZ PROC				; _CW::GetCharsWide, COMDAT
; _this$ = ecx

; 438  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 439  :     if (m_pWide == (wchar_t*)-1)

  00003	83 7e 04 ff	 cmp	 DWORD PTR [esi+4], -1
  00007	75 0a		 jne	 SHORT $LN2@GetCharsWi

; 440  :         DupWide();

  00009	e8 00 00 00 00	 call	 ?DupWide@_CW@@AAEXXZ	; _CW::DupWide
  0000e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 443  :     return m_nCharsWide;

  00011	5e		 pop	 esi

; 444  : }

  00012	c3		 ret	 0
$LN2@GetCharsWi:

; 441  :     else if ( m_nCharsWide < 0 )

  00013	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00016	85 c0		 test	 eax, eax
  00018	79 0c		 jns	 SHORT $LN4@GetCharsWi

; 442  :         m_nCharsWide = cw_strlen( m_pWide );

  0001a	ff 76 04	 push	 DWORD PTR [esi+4]
  0001d	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00022	59		 pop	 ecx
  00023	89 46 0c	 mov	 DWORD PTR [esi+12], eax
$LN4@GetCharsWi:

; 443  :     return m_nCharsWide;

  00026	5e		 pop	 esi

; 444  : }

  00027	c3		 ret	 0
?GetCharsWide@_CW@@QAEHXZ ENDP				; _CW::GetCharsWide
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?GetCharsMbcs@_CW@@QAEHXZ
_TEXT	SEGMENT
?GetCharsMbcs@_CW@@QAEHXZ PROC				; _CW::GetCharsMbcs, COMDAT
; _this$ = ecx

; 429  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 430  :     if (m_pChar == (char*)-1)

  00003	83 3e ff	 cmp	 DWORD PTR [esi], -1
  00006	75 0a		 jne	 SHORT $LN2@GetCharsMb

; 431  :         DupChar();

  00008	e8 00 00 00 00	 call	 ?DupChar@_CW@@AAEXXZ	; _CW::DupChar
  0000d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 434  :     return m_nChars;

  00010	5e		 pop	 esi

; 435  : }

  00011	c3		 ret	 0
$LN2@GetCharsMb:

; 432  :     else if ( m_nChars < 0 )

  00012	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00015	85 c0		 test	 eax, eax
  00017	79 0b		 jns	 SHORT $LN4@GetCharsMb

; 433  :         m_nChars = cw_strlen( m_pChar );

  00019	ff 36		 push	 DWORD PTR [esi]
  0001b	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00020	59		 pop	 ecx
  00021	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN4@GetCharsMb:

; 434  :     return m_nChars;

  00024	5e		 pop	 esi

; 435  : }

  00025	c3		 ret	 0
?GetCharsMbcs@_CW@@QAEHXZ ENDP				; _CW::GetCharsMbcs
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?DupWide@_CW@@AAEXXZ
_TEXT	SEGMENT
?DupWide@_CW@@AAEXXZ PROC				; _CW::DupWide, COMDAT
; _this$ = ecx

; 423  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 424  :     cw_dup(m_pChar, m_nChars, m_pWide, m_nCharsWide);

  00003	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00006	50		 push	 eax
  00007	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0000a	50		 push	 eax
  0000b	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0000e	50		 push	 eax
  0000f	ff 36		 push	 DWORD PTR [esi]
  00011	e8 00 00 00 00	 call	 ?cw_dup@@YGXPBDAAHAAPA_W1@Z ; cw_dup

; 425  :     m_nDupFlag = 'w';

  00016	c6 46 10 77	 mov	 BYTE PTR [esi+16], 119	; 00000077H
  0001a	5e		 pop	 esi

; 426  : }

  0001b	c3		 ret	 0
?DupWide@_CW@@AAEXXZ ENDP				; _CW::DupWide
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?DupChar@_CW@@AAEXXZ
_TEXT	SEGMENT
?DupChar@_CW@@AAEXXZ PROC				; _CW::DupChar, COMDAT
; _this$ = ecx

; 417  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 418  :     cw_dup(m_pWide, m_nCharsWide, m_pChar, m_nChars);

  00003	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  00006	50		 push	 eax
  00007	56		 push	 esi
  00008	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0000b	50		 push	 eax
  0000c	ff 76 04	 push	 DWORD PTR [esi+4]
  0000f	e8 00 00 00 00	 call	 ?cw_dup@@YGXPB_WAAHAAPAD1@Z ; cw_dup

; 419  :     m_nDupFlag = 'c';

  00014	c6 46 10 63	 mov	 BYTE PTR [esi+16], 99	; 00000063H
  00018	5e		 pop	 esi

; 420  : }

  00019	c3		 ret	 0
?DupChar@_CW@@AAEXXZ ENDP				; _CW::DupChar
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_dup@@YGXPB_WAAHAAPAD1@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_pTarget$1$ = 12					; size = 4
_nSrcChars$ = 12					; size = 4
_pTarget$ = 16						; size = 4
_nTargetChars$ = 20					; size = 4
?cw_dup@@YGXPB_WAAHAAPAD1@Z PROC			; cw_dup, COMDAT

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 383  :     if ( pSrc == 0 )

  00005	8b 75 08	 mov	 esi, DWORD PTR _pSrc$[ebp]
  00008	85 f6		 test	 esi, esi
  0000a	75 13		 jne	 SHORT $LN2@cw_dup

; 384  :     {
; 385  :         nSrcChars = nTargetChars = 0;

  0000c	8b 45 14	 mov	 eax, DWORD PTR _nTargetChars$[ebp]
  0000f	33 db		 xor	 ebx, ebx
  00011	89 18		 mov	 DWORD PTR [eax], ebx
  00013	8b 45 0c	 mov	 eax, DWORD PTR _nSrcChars$[ebp]
  00016	89 18		 mov	 DWORD PTR [eax], ebx

; 386  :         pTarget = 0;

  00018	8b 45 10	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0001b	89 18		 mov	 DWORD PTR [eax], ebx

; 387  :         return;

  0001d	eb 66		 jmp	 SHORT $LN4@cw_dup
$LN2@cw_dup:
  0001f	57		 push	 edi

; 388  :     }
; 389  : 
; 390  :     if ( nSrcChars < 0 )

  00020	8b 7d 0c	 mov	 edi, DWORD PTR _nSrcChars$[ebp]
  00023	8b 07		 mov	 eax, DWORD PTR [edi]
  00025	85 c0		 test	 eax, eax
  00027	79 09		 jns	 SHORT $LN3@cw_dup

; 391  :         nSrcChars = cw_strlen( pSrc );

  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  0002f	59		 pop	 ecx
  00030	89 07		 mov	 DWORD PTR [edi], eax
$LN3@cw_dup:

; 392  :     /* ==> Implementation one -- minimize memory.
; 393  :     nTargetChars = cw_memcpy( (char*) NULL, pSrc, nSrcChars );
; 394  :         // Determine how many characters are needed.
; 395  :         //   Can't assume one-to-one (some wide chars may need 2 multibyte chars),
; 396  :         //   but don't want to waste a bunch of bytes either.
; 397  :     pTarget = new char[nTargetChars+1];
; 398  :     */
; 399  :     /* ==> Implementation two -- maximize speed, with side effect of allocating up
; 400  :     **      to twice the memory needed (worst case when no multibyte chars needed).
; 401  :     **     Chose this because most converted strings will be short-lived.
; 402  :     */
; 403  :     pTarget = new char[(nSrcChars+1)*2];

  00032	8d 04 45 02 00
	00 00		 lea	 eax, DWORD PTR [eax*2+2]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0003f	89 45 0c	 mov	 DWORD PTR _pTarget$1$[ebp], eax
  00042	59		 pop	 ecx
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  00046	89 01		 mov	 DWORD PTR [ecx], eax

; 404  :     if (pTarget)

  00048	85 c0		 test	 eax, eax
  0004a	74 38		 je	 SHORT $LN10@cw_dup

; 405  :     {
; 406  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  0004c	8b 07		 mov	 eax, DWORD PTR [edi]

; 208  :     if ( nCount == 0 )

  0004e	85 c0		 test	 eax, eax
  00050	75 06		 jne	 SHORT $LN11@cw_dup

; 209  :         return 0;

  00052	33 db		 xor	 ebx, ebx
  00054	8b c3		 mov	 eax, ebx
  00056	eb 1f		 jmp	 SHORT $LN6@cw_dup
$LN11@cw_dup:

; 210  :     if ( nCount < 0 )

  00058	79 08		 jns	 SHORT $LN8@cw_dup

; 211  :         nCount = cw_strlen( pSrc ) + 1;

  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00060	59		 pop	 ecx
  00061	40		 inc	 eax
$LN8@cw_dup:

; 212  : 
; 213  : #if defined(_M_IX86) || defined(_M_X64)
; 214  :     return WideCharToMultiByte(

  00062	33 db		 xor	 ebx, ebx
  00064	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  00067	53		 push	 ebx
  00068	53		 push	 ebx
  00069	51		 push	 ecx
  0006a	ff 75 0c	 push	 DWORD PTR _pTarget$1$[ebp]
  0006d	50		 push	 eax
  0006e	56		 push	 esi
  0006f	53		 push	 ebx
  00070	53		 push	 ebx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
$LN6@cw_dup:

; 405  :     {
; 406  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  00077	8b 4d 14	 mov	 ecx, DWORD PTR _nTargetChars$[ebp]
  0007a	89 01		 mov	 DWORD PTR [ecx], eax

; 407  :         pTarget[nTargetChars] = 0;

  0007c	8b 4d 10	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0007f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00081	88 1c 08	 mov	 BYTE PTR [eax+ecx], bl
$LN10@cw_dup:
  00084	5f		 pop	 edi
$LN4@cw_dup:
  00085	5e		 pop	 esi

; 408  :     }
; 409  : }

  00086	5b		 pop	 ebx
  00087	5d		 pop	 ebp
  00088	c2 10 00	 ret	 16			; 00000010H
?cw_dup@@YGXPB_WAAHAAPAD1@Z ENDP			; cw_dup
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_dup@@YGXPBDAAHAAPA_W1@Z
_TEXT	SEGMENT
_pSrc$ = 8						; size = 4
_nSrcChars$ = 12					; size = 4
_pTarget$ = 16						; size = 4
_nTargetChars$ = 20					; size = 4
?cw_dup@@YGXPBDAAHAAPA_W1@Z PROC			; cw_dup, COMDAT

; 359  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 360  :     if ( pSrc == 0 )

  00004	8b 75 08	 mov	 esi, DWORD PTR _pSrc$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 13		 jne	 SHORT $LN2@cw_dup

; 361  :     {
; 362  :         nSrcChars = nTargetChars = 0;

  0000b	8b 45 14	 mov	 eax, DWORD PTR _nTargetChars$[ebp]
  0000e	33 c9		 xor	 ecx, ecx
  00010	89 08		 mov	 DWORD PTR [eax], ecx
  00012	8b 45 0c	 mov	 eax, DWORD PTR _nSrcChars$[ebp]
  00015	89 08		 mov	 DWORD PTR [eax], ecx

; 363  :         pTarget = 0;

  00017	8b 45 10	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0001a	89 08		 mov	 DWORD PTR [eax], ecx

; 364  :         return;

  0001c	eb 65		 jmp	 SHORT $LN4@cw_dup
$LN2@cw_dup:
  0001e	57		 push	 edi

; 365  :     }
; 366  : 
; 367  :     if ( nSrcChars < 0 )

  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _nSrcChars$[ebp]
  00022	8b 07		 mov	 eax, DWORD PTR [edi]
  00024	85 c0		 test	 eax, eax
  00026	79 09		 jns	 SHORT $LN3@cw_dup

; 368  :         nSrcChars = cw_strlen( pSrc );

  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  0002e	59		 pop	 ecx
  0002f	89 07		 mov	 DWORD PTR [edi], eax
$LN3@cw_dup:

; 369  :     pTarget = new wchar_t[nSrcChars+1];

  00031	53		 push	 ebx
  00032	33 c9		 xor	 ecx, ecx
  00034	40		 inc	 eax
  00035	6a 02		 push	 2
  00037	5a		 pop	 edx
  00038	f7 e2		 mul	 edx
  0003a	0f 90 c1	 seto	 cl
  0003d	f7 d9		 neg	 ecx
  0003f	0b c8		 or	 ecx, eax
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00047	8b d8		 mov	 ebx, eax
  00049	8b 45 10	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0004c	59		 pop	 ecx
  0004d	89 18		 mov	 DWORD PTR [eax], ebx

; 370  :         // We allow one wide char for each multibyte char;
; 371  :         //   this may be too many for some countries, but no harm.
; 372  :     if (pTarget)

  0004f	85 db		 test	 ebx, ebx
  00051	74 2e		 je	 SHORT $LN11@cw_dup

; 373  :     {
; 374  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  00053	8b 07		 mov	 eax, DWORD PTR [edi]

; 163  :     if ( nCount == 0 )

  00055	85 c0		 test	 eax, eax
  00057	74 18		 je	 SHORT $LN6@cw_dup
$LN12@cw_dup:

; 164  :         return 0;
; 165  :     if ( nCount < 0 )

  00059	79 08		 jns	 SHORT $LN8@cw_dup

; 166  :         nCount = cw_strlen( pSrc ) + 1;

  0005b	56		 push	 esi
  0005c	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00061	59		 pop	 ecx
  00062	40		 inc	 eax
$LN8@cw_dup:

; 167  : 
; 168  : #if defined(_M_IX86) || defined(_M_X64)
; 169  :     return MultiByteToWideChar(

  00063	50		 push	 eax
  00064	53		 push	 ebx
  00065	50		 push	 eax
  00066	56		 push	 esi
  00067	33 c9		 xor	 ecx, ecx
  00069	51		 push	 ecx
  0006a	51		 push	 ecx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
$LN6@cw_dup:

; 373  :     {
; 374  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  00071	8b 4d 14	 mov	 ecx, DWORD PTR _nTargetChars$[ebp]

; 375  :         pTarget[nTargetChars] = 0;

  00074	33 d2		 xor	 edx, edx
  00076	89 01		 mov	 DWORD PTR [ecx], eax
  00078	8b 4d 10	 mov	 ecx, DWORD PTR _pTarget$[ebp]
  0007b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007d	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
$LN11@cw_dup:
  00081	5b		 pop	 ebx
  00082	5f		 pop	 edi
$LN4@cw_dup:
  00083	5e		 pop	 esi

; 376  :     }
; 377  : }

  00084	5d		 pop	 ebp
  00085	c2 10 00	 ret	 16			; 00000010H
?cw_dup@@YGXPBDAAHAAPA_W1@Z ENDP			; cw_dup
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcat@@YAHPA_WPB_W@Z
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcat@@YAHPA_WPB_W@Z PROC				; cw_strcat, COMDAT

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 348  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00004	8b 75 08	 mov	 esi, DWORD PTR _pszTarget$[ebp]
  00007	6a ff		 push	 -1
  00009	ff 75 0c	 push	 DWORD PTR _pszSrc$[ebp]
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00012	59		 pop	 ecx
  00013	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPA_WPB_WH@Z ; cw_memcpy
  0001c	48		 dec	 eax
  0001d	5e		 pop	 esi

; 349  : }       //   Return chars copied (not including NUL).

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?cw_strcat@@YAHPA_WPB_W@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcat@@YAHPADPBD@Z
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcat@@YAHPADPBD@Z PROC				; cw_strcat, COMDAT

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 343  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00003	6a ff		 push	 -1
  00005	ff 75 0c	 push	 DWORD PTR _pszSrc$[ebp]
  00008	ff 75 08	 push	 DWORD PTR _pszTarget$[ebp]
  0000b	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00010	03 45 08	 add	 eax, DWORD PTR _pszTarget$[ebp]
  00013	59		 pop	 ecx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPBDH@Z ; cw_memcpy
  0001a	48		 dec	 eax

; 344  : }       //   Return chars copied (not including NUL).

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?cw_strcat@@YAHPADPBD@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcat@@YAHPA_WPBD@Z
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcat@@YAHPA_WPBD@Z PROC				; cw_strcat, COMDAT

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 338  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00004	8b 75 08	 mov	 esi, DWORD PTR _pszTarget$[ebp]
  00007	6a ff		 push	 -1
  00009	ff 75 0c	 push	 DWORD PTR _pszSrc$[ebp]
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00012	59		 pop	 ecx
  00013	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPA_WPBDH@Z ; cw_memcpy
  0001c	48		 dec	 eax
  0001d	5e		 pop	 esi

; 339  : }       //   Return chars copied (not including NUL).

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?cw_strcat@@YAHPA_WPBD@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcat@@YAHPADPB_W@Z
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcat@@YAHPADPB_W@Z PROC				; cw_strcat, COMDAT

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00003	6a ff		 push	 -1
  00005	ff 75 0c	 push	 DWORD PTR _pszSrc$[ebp]
  00008	ff 75 08	 push	 DWORD PTR _pszTarget$[ebp]
  0000b	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00010	03 45 08	 add	 eax, DWORD PTR _pszTarget$[ebp]
  00013	59		 pop	 ecx
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPB_WH@Z ; cw_memcpy
  0001a	48		 dec	 eax

; 334  : }       //   Return chars copied (not including NUL).

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?cw_strcat@@YAHPADPB_W@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcpy@@YAHPA_WPB_W@Z
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcpy@@YAHPA_WPB_W@Z PROC				; cw_strcpy, COMDAT

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00003	6a ff		 push	 -1
  00005	ff 75 0c	 push	 DWORD PTR _pszSrc$[ebp]
  00008	ff 75 08	 push	 DWORD PTR _pszTarget$[ebp]
  0000b	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPA_WPB_WH@Z ; cw_memcpy
  00010	48		 dec	 eax

; 324  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?cw_strcpy@@YAHPA_WPB_W@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcpy@@YAHPADPBD@Z
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcpy@@YAHPADPBD@Z PROC				; cw_strcpy, COMDAT

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 318  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00003	6a ff		 push	 -1
  00005	ff 75 0c	 push	 DWORD PTR _pszSrc$[ebp]
  00008	ff 75 08	 push	 DWORD PTR _pszTarget$[ebp]
  0000b	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPBDH@Z ; cw_memcpy
  00010	48		 dec	 eax

; 319  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?cw_strcpy@@YAHPADPBD@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcpy@@YAHPA_WPBD@Z
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcpy@@YAHPA_WPBD@Z PROC				; cw_strcpy, COMDAT

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00003	6a ff		 push	 -1
  00005	ff 75 0c	 push	 DWORD PTR _pszSrc$[ebp]
  00008	ff 75 08	 push	 DWORD PTR _pszTarget$[ebp]
  0000b	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPA_WPBDH@Z ; cw_memcpy
  00010	48		 dec	 eax

; 314  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?cw_strcpy@@YAHPA_WPBD@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strcpy@@YAHPADPB_W@Z
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcpy@@YAHPADPB_W@Z PROC				; cw_strcpy, COMDAT

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00003	6a ff		 push	 -1
  00005	ff 75 0c	 push	 DWORD PTR _pszSrc$[ebp]
  00008	ff 75 08	 push	 DWORD PTR _pszTarget$[ebp]
  0000b	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPB_WH@Z ; cw_memcpy
  00010	48		 dec	 eax

; 309  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?cw_strcpy@@YAHPADPB_W@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strlen@@YAHPB_W@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?cw_strlen@@YAHPB_W@Z PROC				; cw_strlen, COMDAT

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 126  : #if defined(_M_IX86) || defined(_M_X64)
; 127  :     int nCount = 0;
; 128  :     if ( pChar && *pChar )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pChar$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	8b c2		 mov	 eax, edx
  0000a	85 c9		 test	 ecx, ecx
  0000c	74 0b		 je	 SHORT $LN3@cw_strlen
  0000e	eb 04		 jmp	 SHORT $LN10@cw_strlen
$LL4@cw_strlen:

; 129  :     {
; 130  :         do nCount++;

  00010	40		 inc	 eax

; 131  :         while (*++pChar);

  00011	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
$LN10@cw_strlen:
  00014	66 39 11	 cmp	 WORD PTR [ecx], dx
  00017	75 f7		 jne	 SHORT $LL4@cw_strlen
$LN3@cw_strlen:

; 132  :     }
; 133  :     return nCount;
; 134  : 
; 135  : #else
; 136  :     int nCount = 0;
; 137  :     const char* pNChar = (const char*) pChar;
; 138  :     if ( pNChar && ( pNChar[0] | pNChar[1] ) != 0 )
; 139  :     {
; 140  :         do
; 141  :         {
; 142  :             nCount++;
; 143  :             pNChar += 2;
; 144  :         }
; 145  :         while ( ( pNChar[0] | pNChar[1] ) != 0 );
; 146  :     }
; 147  :     return nCount;
; 148  : #endif
; 149  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?cw_strlen@@YAHPB_W@Z ENDP				; cw_strlen
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_strlen@@YAHPBD@Z
_TEXT	SEGMENT
_pChar$ = 8						; size = 4
?cw_strlen@@YAHPBD@Z PROC				; cw_strlen, COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 115  :     int nCount = 0;
; 116  :     if ( pChar && *pChar )

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pChar$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 0b		 je	 SHORT $LN3@cw_strlen
  0000c	38 01		 cmp	 BYTE PTR [ecx], al
  0000e	74 07		 je	 SHORT $LN3@cw_strlen
$LL4@cw_strlen:

; 117  :     {
; 118  :         do nCount++;

  00010	40		 inc	 eax

; 119  :         while (*++pChar);

  00011	41		 inc	 ecx
  00012	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00015	75 f9		 jne	 SHORT $LL4@cw_strlen
$LN3@cw_strlen:

; 120  :     }
; 121  :     return nCount;
; 122  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?cw_strlen@@YAHPBD@Z ENDP				; cw_strlen
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memset@@YAXPA_W_WH@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_cChar$ = 12						; size = 2
_nCount$ = 16						; size = 4
?cw_memset@@YAXPA_W_WH@Z PROC				; cw_memset, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 83   :     {
; 84   :         mov ecx, nCount                 // Get count.

  00004	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]

; 85   :         jcxz L2                         //   If zero, then jump: Nothing to do.

  00007	67 e3 0a	 jcxz	 $L2$4

; 86   : 
; 87   :         mov edi, pTarget                // Get pointer to destination.

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _pTarget$[ebp]

; 88   :         mov ax, cChar                   // Get wide character to set.

  0000d	66 8b 45 0c	 mov	 ax, WORD PTR _cChar$[ebp]

; 89   :         rep stosw                       // Set wide character for ECX times.

  00011	f3 66 ab	 rep	  stosw
$L2$4:

; 80   :     // If Intel x86, resort to assembly...
; 81   : #if defined(_M_IX86)
; 82   :     _asm

  00014	5f		 pop	 edi

; 90   : 
; 91   :     L2:
; 92   :     }
; 93   : 
; 94   :     // If not Intel or alignment required, then set low and high bytes separately.
; 95   : #else
; 96   :     if ( nCount > 0 )
; 97   :     {
; 98   :         int n = nCount;
; 99   :         char* pCharTarget = (char*) pTarget;
; 100  :         do {
; 101  :             *pCharTarget++ = LOBYTE(cChar);
; 102  :             *pCharTarget++ = HIBYTE(cChar);
; 103  :         } while ( --n );
; 104  :     }
; 105  : #endif
; 106  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?cw_memset@@YAXPA_W_WH@Z ENDP				; cw_memset
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memset@@YAXPADDH@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_cChar$ = 12						; size = 1
_nCount$ = 16						; size = 4
?cw_memset@@YAXPADDH@Z PROC				; cw_memset, COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 55   :     {
; 56   :         mov ecx, nCount                 // Get count.

  00004	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]

; 57   :         jcxz L2                         //   If zero, then jump: Nothing to do.

  00007	67 e3 08	 jcxz	 $L2$4

; 58   : 
; 59   :         mov edi, pTarget                // Get pointer to destination.

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _pTarget$[ebp]

; 60   :         mov al, cChar                   // Get character to set.

  0000d	8a 45 0c	 mov	 al, BYTE PTR _cChar$[ebp]

; 61   :         rep stosb                       // Set character for ECX times.

  00010	f3 aa		 rep	  stosb
$L2$4:

; 52   :     // If Intel x86, resort to assembly...
; 53   : #if defined(_M_IX86)
; 54   :     _asm

  00012	5f		 pop	 edi

; 62   : 
; 63   :     L2:
; 64   :     }
; 65   : 
; 66   :     // If not Intel, use tight loop.
; 67   : #else
; 68   :     if ( nCount > 0 )
; 69   :     {
; 70   :         int n = nCount;
; 71   :         do {
; 72   :             *pTarget++ = cChar;
; 73   :         } while ( --n );
; 74   :     }
; 75   : #endif
; 76   : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?cw_memset@@YAXPADDH@Z ENDP				; cw_memset
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memcpy@@YGHPA_WPB_WH@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nCount$ = 16						; size = 4
?cw_memcpy@@YGHPA_WPB_WH@Z PROC				; cw_memcpy, COMDAT

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 295  :     if ( nCount < 0 )

  00004	8b 75 10	 mov	 esi, DWORD PTR _nCount$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	79 0c		 jns	 SHORT $LN2@cw_memcpy

; 296  :         nCount = cw_strlen(pSrc) + 1;

  0000b	ff 75 0c	 push	 DWORD PTR _pSrc$[ebp]
  0000e	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00013	59		 pop	 ecx
  00014	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LN2@cw_memcpy:

; 297  :     cw_memcpy( (char*) pTarget, (const char*) pSrc, nCount * sizeof(wchar_t) );

  00017	8d 0c 36	 lea	 ecx, DWORD PTR [esi+esi]
  0001a	51		 push	 ecx
  0001b	ff 75 0c	 push	 DWORD PTR _pSrc$[ebp]
  0001e	ff 75 08	 push	 DWORD PTR _pTarget$[ebp]
  00021	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPBDH@Z ; cw_memcpy

; 298  :     return nCount;

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi

; 299  : }

  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
?cw_memcpy@@YGHPA_WPB_WH@Z ENDP				; cw_memcpy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memcpy@@YGHPADPBDH@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nCount$ = 16						; size = 4
?cw_memcpy@@YGHPADPBDH@Z PROC				; cw_memcpy, COMDAT

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 258  :     if ( nCount < 0 )

  00003	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	79 0d		 jns	 SHORT $LN2@cw_memcpy

; 259  :         nCount = cw_strlen(pSrc) + 1;

  0000a	ff 75 0c	 push	 DWORD PTR _pSrc$[ebp]
  0000d	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00012	40		 inc	 eax
  00013	59		 pop	 ecx
  00014	89 45 10	 mov	 DWORD PTR _nCount$[ebp], eax
$LN2@cw_memcpy:

; 260  :     if ( pTarget && nCount )

  00017	83 7d 08 00	 cmp	 DWORD PTR _pTarget$[ebp], 0
  0001b	74 16		 je	 SHORT $LN3@cw_memcpy
  0001d	85 c0		 test	 eax, eax
  0001f	74 12		 je	 SHORT $LN3@cw_memcpy

; 261  :     {
; 262  :         // If Intel x86, resort to assembly...
; 263  : #if defined(_M_IX86)
; 264  :         _asm

  00021	56		 push	 esi
  00022	57		 push	 edi

; 265  :         {
; 266  :             mov ecx, nCount                 // Get count.

  00023	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]

; 267  :             jcxz L2                         //   If zero, then jump: Nothing to do.

  00026	67 e3 08	 jcxz	 $L2$6

; 268  : 
; 269  :             mov esi, pSrc                   // Get pointer to source.

  00029	8b 75 0c	 mov	 esi, DWORD PTR _pSrc$[ebp]

; 270  :             mov edi, pTarget                // Get pointer to destination.

  0002c	8b 7d 08	 mov	 edi, DWORD PTR _pTarget$[ebp]

; 271  :             rep movsb                       // Move characters from ESI to EDI for ECX times.

  0002f	f3 a4		 rep	  movsb
$L2$6:

; 261  :     {
; 262  :         // If Intel x86, resort to assembly...
; 263  : #if defined(_M_IX86)
; 264  :         _asm

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
$LN3@cw_memcpy:

; 272  : 
; 273  :         L2:
; 274  :         }
; 275  : 
; 276  :         // If not Intel, use tight loop.
; 277  : #else
; 278  :         int n = nCount;
; 279  :         do {
; 280  :             *pTarget++ = *pSrc++;
; 281  :         } while ( --n );
; 282  : #endif
; 283  :     }
; 284  :     return nCount;
; 285  : }

  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?cw_memcpy@@YGHPADPBDH@Z ENDP				; cw_memcpy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memcpy@@YGHPA_WPBDH@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nCount$ = 16						; size = 4
?cw_memcpy@@YGHPA_WPBDH@Z PROC				; cw_memcpy, COMDAT

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 163  :     if ( nCount == 0 )

  00003	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 1e		 je	 SHORT $LN1@cw_memcpy
$LN5@cw_memcpy:

; 164  :         return 0;
; 165  :     if ( nCount < 0 )

  0000a	79 0a		 jns	 SHORT $LN3@cw_memcpy

; 166  :         nCount = cw_strlen( pSrc ) + 1;

  0000c	ff 75 0c	 push	 DWORD PTR _pSrc$[ebp]
  0000f	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00014	59		 pop	 ecx
  00015	40		 inc	 eax
$LN3@cw_memcpy:

; 167  : 
; 168  : #if defined(_M_IX86) || defined(_M_X64)
; 169  :     return MultiByteToWideChar(

  00016	50		 push	 eax
  00017	ff 75 08	 push	 DWORD PTR _pTarget$[ebp]
  0001a	50		 push	 eax
  0001b	ff 75 0c	 push	 DWORD PTR _pSrc$[ebp]
  0001e	6a 00		 push	 0
  00020	6a 00		 push	 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
$LN1@cw_memcpy:

; 170  :         CP_ACP,         // code page
; 171  :         0,              // character-type options
; 172  :         pSrc,           // address of string to map
; 173  :         nCount,         // number of characters in string
; 174  :         pTarget,        // address of wide-character buffer
; 175  :         nCount );       // size of buffer.
; 176  :                         //   This is worst case (no multi-byte chars).
; 177  :                         //   We assume that the caller passed a big enough buffer.
; 178  : 
; 179  : #else
; 180  :     wchar_t* pWide = pTarget;
; 181  :     if ( (DWORD) pWide & 1 )
; 182  :         pWide = new wchar_t[nCount];
; 183  :     nCount = MultiByteToWideChar(
; 184  :         CP_ACP,         // code page
; 185  :         0,              // character-type options
; 186  :         pSrc,           // address of string to map
; 187  :         nCount,         // number of characters in string
; 188  :         pWide,          // address of wide-character buffer
; 189  :         nCount );       // size of buffer.
; 190  :                         //   This is worst case (no multi-byte chars).
; 191  :                         //   We assume that the caller passed a big enough buffer.
; 192  :     if ( pTarget != pWide )
; 193  :     {
; 194  :         cw_memcpy( (char*) pTarget, (const char*) pWide, nCount * sizeof(wchar_t) );
; 195  :         delete [] pWide;
; 196  :     }
; 197  :     return nCount;
; 198  : #endif
; 199  : }

  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
?cw_memcpy@@YGHPA_WPBDH@Z ENDP				; cw_memcpy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
;	COMDAT ?cw_memcpy@@YGHPADPB_WH@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nCount$ = 16						; size = 4
?cw_memcpy@@YGHPADPB_WH@Z PROC				; cw_memcpy, COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  :     if ( nCount == 0 )

  00003	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 23		 je	 SHORT $LN1@cw_memcpy
$LN5@cw_memcpy:

; 209  :         return 0;
; 210  :     if ( nCount < 0 )

  0000a	79 0a		 jns	 SHORT $LN3@cw_memcpy

; 211  :         nCount = cw_strlen( pSrc ) + 1;

  0000c	ff 75 0c	 push	 DWORD PTR _pSrc$[ebp]
  0000f	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00014	59		 pop	 ecx
  00015	40		 inc	 eax
$LN3@cw_memcpy:

; 212  : 
; 213  : #if defined(_M_IX86) || defined(_M_X64)
; 214  :     return WideCharToMultiByte(

  00016	33 d2		 xor	 edx, edx
  00018	8d 0c 00	 lea	 ecx, DWORD PTR [eax+eax]
  0001b	52		 push	 edx
  0001c	52		 push	 edx
  0001d	51		 push	 ecx
  0001e	ff 75 08	 push	 DWORD PTR _pTarget$[ebp]
  00021	50		 push	 eax
  00022	ff 75 0c	 push	 DWORD PTR _pSrc$[ebp]
  00025	52		 push	 edx
  00026	52		 push	 edx
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
$LN1@cw_memcpy:

; 215  :         CP_ACP,         // code page
; 216  :         0,              // performance and mapping flags
; 217  :         pSrc,           // address of wide character string
; 218  :         nCount,         // number of characters in string
; 219  :         pTarget,        // address of buffer for new string
; 220  :         nCount*2,       // size of buffer
; 221  :                         //   This is worst case (every wide -> multi-byte char).
; 222  :                         //   We assume that the caller passed a big enough buffer.
; 223  :         NULL,           // address of default for unmappable characters
; 224  :         NULL );         // address of flag set when default char.
; 225  : 
; 226  : #else
; 227  :     wchar_t* pWide = (wchar_t*) pSrc;
; 228  :     if ( (DWORD) pWide & 1 )
; 229  :     {
; 230  :         pWide = new wchar_t[nCount];
; 231  :         cw_memcpy( (char*) pWide, (const char*) pSrc, nCount * sizeof(wchar_t) );
; 232  :     }
; 233  :     nCount = WideCharToMultiByte(
; 234  :         CP_ACP,         // code page
; 235  :         0,              // performance and mapping flags
; 236  :         pWide,          // address of wide character string
; 237  :         nCount,         // number of characters in string
; 238  :         pTarget,        // address of buffer for new string
; 239  :         nCount*2,       // size of buffer
; 240  :                         //   This is worst case (every wide -> multi-byte char).
; 241  :                         //   We assume that the caller passed a big enough buffer.
; 242  :         NULL,           // address of default for unmappable characters
; 243  :         NULL );         // address of flag set when default char.
; 244  :     if ( pSrc != pWide )
; 245  :         delete [] pWide;
; 246  :     return nCount;
; 247  : #endif
; 248  : }

  0002d	5d		 pop	 ebp
  0002e	c2 0c 00	 ret	 12			; 0000000cH
?cw_memcpy@@YGHPADPB_WH@Z ENDP				; cw_memcpy
_TEXT	ENDS
END
