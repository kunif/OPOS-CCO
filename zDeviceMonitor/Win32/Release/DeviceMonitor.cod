; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{140}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{144}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{144}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{144}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{148}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{148}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{148}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{152}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{152}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{152}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{156}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{156}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{156}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{160}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{160}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{160}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{168}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{168}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{180}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{180}'
PUBLIC	??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::`vector deleting destructor'
PUBLIC	??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::`vector deleting destructor'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{112}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{112}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{112}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{116}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{116}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{116}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{120}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{120}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{120}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{124}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{124}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{124}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{128}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{128}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{128}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{132}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{132}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{132}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{136}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{136}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{136}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{140}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{140}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{140}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{144}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{144}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{144}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{148}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{148}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{148}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{152}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{152}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{152}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{156}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{156}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{156}'
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{160}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{160}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{160}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{168}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{168}'
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{180}'
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{180}'
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z ; ATL::CComClassFactory::CreateInstance
PUBLIC	?LockServer@CComClassFactory@ATL@@UAGJH@Z	; ATL::CComClassFactory::LockServer
PUBLIC	??_7CComClassFactory@ATL@@6B@			; ATL::CComClassFactory::`vftable'
PUBLIC	??_GCComClassFactory@ATL@@UAEPAXI@Z		; ATL::CComClassFactory::`scalar deleting destructor'
PUBLIC	?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComClassFactory::_GetEntries'::`2'::_entries
PUBLIC	__GUID_00000001_0000_0000_c000_000000000046
PUBLIC	?s_Claim@?7??GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z@4PA_WA ; `ATL::CComTypeInfoHolder::GetIDsOfNames'::`8'::s_Claim
PUBLIC	?s_Release@?7??GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z@4PA_WA ; `ATL::CComTypeInfoHolder::GetIDsOfNames'::`8'::s_Release
PUBLIC	?WM_ATLGETHOST@ATL@@3IA				; ATL::WM_ATLGETHOST
PUBLIC	?WM_ATLGETCONTROL@ATL@@3IA			; ATL::WM_ATLGETCONTROL
PUBLIC	_IID_IOPOSDeviceMonitor_1_16
PUBLIC	?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::GetWindowProc
PUBLIC	?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::StartWindowProc
PUBLIC	?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::OnFinalMessage
PUBLIC	_IID_IOPOSDeviceMonitor
PUBLIC	_LIBID_OposDeviceMonitor_CCO
PUBLIC	_DIID__IOPOSDeviceMonitorEvents
PUBLIC	_CLSID_OPOSDeviceMonitor
PUBLIC	??_C@_1BK@BIGILECK@?$AAA?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@ ; `string'
PUBLIC	?GetTypeInfoCount@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetTypeInfoCount
PUBLIC	?GetTypeInfo@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetTypeInfo
PUBLIC	__GUID_00000114_0000_0000_c000_000000000046
PUBLIC	?GetIDsOfNames@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPA_WIKPAJ@Z ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetIDsOfNames
PUBLIC	??_C@_0BI@MNCFCPFK@RegCreateKeyTransactedW@	; `string'
PUBLIC	?Invoke@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::Invoke
PUBLIC	?_tih@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::_tih
PUBLIC	_LIBID_ATLLib
PUBLIC	?CreateControlWindow@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEPAUHWND__@@PAU3@AAUtagRECT@@@Z ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::CreateControlWindow
PUBLIC	?ControlQueryInterface@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEJABU_GUID@@PAPAX@Z ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::ControlQueryInterface
PUBLIC	?GetClassID@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::GetClassID
PUBLIC	?IsDirty@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IsDirty
PUBLIC	?Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@@Z ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::Load
PUBLIC	?Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@H@Z ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::Save
PUBLIC	?GetSizeMax@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAT_ULARGE_INTEGER@@@Z ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::GetSizeMax
PUBLIC	?InitNew@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::InitNew
PUBLIC	?GetControlInfo@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCONTROLINFO@@@Z ; ATL::IOleControlImpl<COPOSDeviceMonitor>::GetControlInfo
PUBLIC	?OnMnemonic@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z ; ATL::IOleControlImpl<COPOSDeviceMonitor>::OnMnemonic
PUBLIC	?OnAmbientPropertyChange@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJ@Z ; ATL::IOleControlImpl<COPOSDeviceMonitor>::OnAmbientPropertyChange
PUBLIC	?SetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIOleClientSite@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetClientSite
PUBLIC	?GetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIOleClientSite@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetClientSite
PUBLIC	?SetHostNames@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPB_W0@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetHostNames
PUBLIC	__GUID_b196b287_bab4_101a_b69c_00aa00341d07
PUBLIC	?Close@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Close
PUBLIC	?SetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUIMoniker@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetMoniker
PUBLIC	___pobjMapEntryFirst
PUBLIC	___pobjMapEntryLast
PUBLIC	?GetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAPAUIMoniker@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetMoniker
PUBLIC	?InitFromData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIDataObject@@HK@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::InitFromData
PUBLIC	?GetClipboardData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIDataObject@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetClipboardData
PUBLIC	?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA	; ATL::_pPerfRegFunc
PUBLIC	?_pPerfUnRegFunc@ATL@@3P6AJXZA			; ATL::_pPerfUnRegFunc
PUBLIC	__GUID_b196b285_bab4_101a_b69c_00aa00341d07
PUBLIC	?_AtlRegisterPerUser@ATL@@3_NA			; ATL::_AtlRegisterPerUser
PUBLIC	?DoVerb@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJPAUtagMSG@@PAUIOleClientSite@@JPAUHWND__@@PBUtagRECT@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerb
PUBLIC	?EnumVerbs@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumOLEVERB@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::EnumVerbs
PUBLIC	?Update@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Update
PUBLIC	?IsUpToDate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::IsUpToDate
PUBLIC	?GetUserClassID@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetUserClassID
PUBLIC	?GetUserType@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPA_W@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetUserType
PUBLIC	?SetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetExtent
PUBLIC	?GetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetExtent
PUBLIC	?Advise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIAdviseSink@@PAK@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Advise
PUBLIC	?Unadvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Unadvise
PUBLIC	?EnumAdvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::EnumAdvise
PUBLIC	?GetMiscStatus@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAK@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetMiscStatus
PUBLIC	?SetColorScheme@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagLOGPALETTE@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetColorScheme
PUBLIC	?GetWindow@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::GetWindow
PUBLIC	?ContextSensitiveHelp@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::ContextSensitiveHelp
PUBLIC	?TranslateAcceleratorW@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::TranslateAcceleratorW
PUBLIC	?OnFrameWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::OnFrameWindowActivate
PUBLIC	?OnDocWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::OnDocWindowActivate
PUBLIC	?ResizeBorder@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@PAUIOleInPlaceUIWindow@@H@Z ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::ResizeBorder
PUBLIC	?EnableModeless@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::EnableModeless
PUBLIC	?Draw@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3P6GHK@ZK@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::Draw
PUBLIC	?GetColorSet@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@PAPAUtagLOGPALETTE@@@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetColorSet
PUBLIC	?Freeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAK@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::Freeze
PUBLIC	?Unfreeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::Unfreeze
PUBLIC	?SetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAUIAdviseSink@@@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::SetAdvise
PUBLIC	?GetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK0PAPAUIAdviseSink@@@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetAdvise
PUBLIC	?GetExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUtagSIZE@@@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetExtent
PUBLIC	?GetRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAU_RECTL@@@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetRect
PUBLIC	?GetViewStatus@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetViewStatus
PUBLIC	?QueryHitPoint@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@UtagPOINT@@JPAK@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::QueryHitPoint
PUBLIC	?QueryHitRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@0JPAK@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::QueryHitRect
PUBLIC	?GetNaturalExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUHDC__@@PAUtagExtentInfo@@PAUtagSIZE@@@Z ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetNaturalExtent
PUBLIC	?GetWindow@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::GetWindow
PUBLIC	?ContextSensitiveHelp@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::ContextSensitiveHelp
PUBLIC	?InPlaceDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::InPlaceDeactivate
PUBLIC	?UIDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::UIDeactivate
PUBLIC	?SetObjectRects@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@0@Z ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::SetObjectRects
PUBLIC	?ReactivateAndUndo@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::ReactivateAndUndo
PUBLIC	?OnWindowMessage@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJIIJPAJ@Z ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::OnWindowMessage
PUBLIC	?GetDropTarget@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIDropTarget@@@Z ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::GetDropTarget
PUBLIC	?EnumConnectionPoints@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::EnumConnectionPoints
PUBLIC	?FindConnectionPoint@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAUIConnectionPoint@@@Z ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::FindConnectionPoint
PUBLIC	?GetClassID@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::GetClassID
PUBLIC	?IsDirty@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IsDirty
PUBLIC	?InitNew@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::InitNew
PUBLIC	?Load@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::Load
PUBLIC	?Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::Save
PUBLIC	?SaveCompleted@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::SaveCompleted
PUBLIC	?HandsOffStorage@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::HandsOffStorage
PUBLIC	?GetPages@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCAUUID@@@Z ; ATL::ISpecifyPropertyPagesImpl<COPOSDeviceMonitor>::GetPages
PUBLIC	?QuickActivate@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z ; ATL::IQuickActivateImpl<COPOSDeviceMonitor>::QuickActivate
PUBLIC	?SetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z ; ATL::IQuickActivateImpl<COPOSDeviceMonitor>::SetContentExtent
PUBLIC	?GetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z ; ATL::IQuickActivateImpl<COPOSDeviceMonitor>::GetContentExtent
PUBLIC	?GetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::GetData
PUBLIC	?GetDataHere@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::GetDataHere
PUBLIC	?QueryGetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@@Z ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::QueryGetData
PUBLIC	?GetCanonicalFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@0@Z ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::GetCanonicalFormatEtc
PUBLIC	?SetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@H@Z ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::SetData
PUBLIC	?EnumFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIEnumFORMATETC@@@Z ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::EnumFormatEtc
PUBLIC	?DAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@KPAUIAdviseSink@@PAK@Z ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::DAdvise
PUBLIC	?DUnadvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::DUnadvise
PUBLIC	?EnumDAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::EnumDAdvise
PUBLIC	?GetClassInfoW@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAPAUITypeInfo@@@Z ; ATL::IProvideClassInfo2Impl<&CLSID_OPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetClassInfoW
PUBLIC	?GetGUID@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJKPAU_GUID@@@Z ; ATL::IProvideClassInfo2Impl<&CLSID_OPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetGUID
PUBLIC	?_tih@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A ; ATL::IProvideClassInfo2Impl<&CLSID_OPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::_tih
PUBLIC	?FAccessAllowed@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@MAEHXZ ; ATL::IObjectSafetyImpl<COPOSDeviceMonitor,3>::FAccessAllowed
PUBLIC	?GetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@PAK1@Z ; ATL::IObjectSafetyImpl<COPOSDeviceMonitor,3>::GetInterfaceSafetyOptions
PUBLIC	?SetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@KK@Z ; ATL::IObjectSafetyImpl<COPOSDeviceMonitor,3>::SetInterfaceSafetyOptions
PUBLIC	?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::_LocCPQueryInterface
PUBLIC	?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::GetConnectionInterface
PUBLIC	?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::GetConnectionPointContainer
PUBLIC	?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::Advise
PUBLIC	?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::Unadvise
PUBLIC	?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::EnumConnections
PUBLIC	?GetObjectDescription@?$CComCoClass@VCOPOSDeviceMonitor@@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B@ATL@@SGPB_WXZ ; ATL::CComCoClass<COPOSDeviceMonitor,&CLSID_OPOSDeviceMonitor>::GetObjectDescription
PUBLIC	?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::_LocCPQueryInterface
PUBLIC	?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::GetConnectionInterface
PUBLIC	?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::GetConnectionPointContainer
PUBLIC	?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::Advise
PUBLIC	?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::Unadvise
PUBLIC	?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::EnumConnections
PUBLIC	__GUID_a6bc3ac0_dbaa_11ce_9de3_00aa004bb851
PUBLIC	?UpdateRegistry@COPOSDeviceMonitor@@SGJH@Z	; COPOSDeviceMonitor::UpdateRegistry
PUBLIC	?ProcessWindowMessage@COPOSDeviceMonitor@@UAEHPAUHWND__@@IIJAAJK@Z ; COPOSDeviceMonitor::ProcessWindowMessage
PUBLIC	__GUID_0000010c_0000_0000_c000_000000000046
PUBLIC	?SOData@COPOSDeviceMonitor@@MAGJJ@Z		; COPOSDeviceMonitor::SOData
PUBLIC	?SODirectIO@COPOSDeviceMonitor@@MAGJJPAJPAPA_W@Z ; COPOSDeviceMonitor::SODirectIO
PUBLIC	?SOError@COPOSDeviceMonitor@@MAGJJJJPAJ@Z	; COPOSDeviceMonitor::SOError
PUBLIC	?SOOutputCompleteDummy@COPOSDeviceMonitor@@MAGJJ@Z ; COPOSDeviceMonitor::SOOutputCompleteDummy
PUBLIC	?SOStatusUpdate@COPOSDeviceMonitor@@MAGJJ@Z	; COPOSDeviceMonitor::SOStatusUpdate
PUBLIC	?_pAtlModule@ATL@@3PAVCAtlModule@1@A		; ATL::_pAtlModule
PUBLIC	?m_libid@CAtlModule@ATL@@2U_GUID@@A		; ATL::CAtlModule::m_libid
PUBLIC	?Lock@CAtlModule@ATL@@UAEJXZ			; ATL::CAtlModule::Lock
PUBLIC	?Unlock@CAtlModule@ATL@@UAEJXZ			; ATL::CAtlModule::Unlock
PUBLIC	?GetLockCount@CAtlModule@ATL@@UAEJXZ		; ATL::CAtlModule::GetLockCount
PUBLIC	?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z ; ATL::CAtlModule::GetGITPtr
PUBLIC	__GUID_00000146_0000_0000_c000_000000000046
PUBLIC	?_entries@?1??_GetEntries@COPOSDeviceMonitor@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B ; `COPOSDeviceMonitor::_GetEntries'::`2'::_entries
PUBLIC	??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl@ ; `string'
PUBLIC	?_pModule@ATL@@3PAVCComModule@1@A		; ATL::_pModule
PUBLIC	?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::AddCommonRGSReplacements
PUBLIC	__GUID_cf51ed10_62fe_11cf_bf86_00a0c9034836
PUBLIC	__GUID_0000010a_0000_0000_c000_000000000046
PUBLIC	??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM@ ; `string'
PUBLIC	__GUID_b196b283_bab4_101a_b69c_00aa00341d07
PUBLIC	__GUID_cb5bdc81_93c1_11cf_8f20_00805f2cd064
PUBLIC	?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B ; `COPOSDeviceMonitor::GetPropertyMap'::`2'::pPropMap
PUBLIC	??_C@_17DGDADEHL@?$AA_?$AAc?$AAx@		; `string'
PUBLIC	??_C@_17IOIMFDBO@?$AA_?$AAc?$AAy@		; `string'
PUBLIC	?_entries@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4QBU34@B ; `COPOSDeviceMonitor::GetConnMap'::`2'::_entries
PUBLIC	?$TSS0@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4HA ; `COPOSDeviceMonitor::GetConnMap'::`2'::$TSS0
PUBLIC	??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI@ ; `string'
PUBLIC	?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CComModule::UpdateRegistryFromResourceD
PUBLIC	?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CComModule::UpdateRegistryFromResourceD
PUBLIC	?UpdateRegistryFromResource@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CComModule::UpdateRegistryFromResource
PUBLIC	?UpdateRegistryFromResource@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CComModule::UpdateRegistryFromResource
PUBLIC	??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr@ ; `string'
PUBLIC	??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn@ ; `string'
PUBLIC	??_7CComModule@ATL@@6B@				; ATL::CComModule::`vftable'
PUBLIC	??_GCComModule@ATL@@UAEPAXI@Z			; ATL::CComModule::`scalar deleting destructor'
PUBLIC	?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComObjectCached<ATL::CComClassFactory> >::CreateInstance
PUBLIC	??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi@ ; `string'
PUBLIC	?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<COPOSDeviceMonitor> >,ATL::CComCreator<ATL::CComAggObject<COPOSDeviceMonitor> > >::CreateInstance
PUBLIC	??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl@ ; `string'
PUBLIC	__GUID_922eada0_3424_11cf_b670_00aa004cd6d8
PUBLIC	?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ ; ATL::CComObjectCached<ATL::CComClassFactory>::AddRef
PUBLIC	__GUID_9c2cad80_3424_11cf_b670_00aa004cd6d8
PUBLIC	?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ ; ATL::CComObjectCached<ATL::CComClassFactory>::Release
PUBLIC	?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObjectCached<ATL::CComClassFactory>::QueryInterface
PUBLIC	__GUID_00000119_0000_0000_c000_000000000046
PUBLIC	??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@ ; ATL::CComObjectCached<ATL::CComClassFactory>::`vftable'
PUBLIC	??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg@ ; `string'
PUBLIC	__GUID_b196b289_bab4_101a_b69c_00aa00341d07
PUBLIC	??_G?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z ; ATL::CComObjectCached<ATL::CComClassFactory>::`scalar deleting destructor'
PUBLIC	__GUID_00000000_0000_0000_c000_000000000046
PUBLIC	__GUID_00020400_0000_0000_c000_000000000046
PUBLIC	??_C@_1CE@PGFMOFKI@?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAE?$AAv?$AAe@ ; `string'
PUBLIC	??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn@ ; `string'
PUBLIC	??_C@_1BG@LODEBHDD@?$AAE?$AAr?$AAr?$AAo?$AAr?$AAE?$AAv?$AAe?$AAn?$AAt@ ; `string'
PUBLIC	??_C@_1BM@CBGEBBBJ@?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAI?$AAO?$AAE?$AAv?$AAe?$AAn?$AAt@ ; `string'
PUBLIC	??_C@_1BE@IEBMACEM@?$AAD?$AAa?$AAt?$AAa?$AAE?$AAv?$AAe?$AAn?$AAt@ ; `string'
PUBLIC	__GUID_b196b286_bab4_101a_b69c_00aa00341d07
PUBLIC	??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi@ ; `string'
PUBLIC	?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A ; ATL::_pAtlAutoThreadModule
PUBLIC	??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn@ ; `string'
PUBLIC	__GUID_00000117_0000_0000_c000_000000000046
PUBLIC	??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl@ ; `string'
PUBLIC	??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt@ ; `string'
PUBLIC	?vszContents@?6??Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z@4PB_WB ; `ATL::IPersistStorageImpl<COPOSDeviceMonitor>::Save'::`7'::vszContents
PUBLIC	??_C@_1BC@ENICKDH@?$AAC?$AAo?$AAn?$AAt?$AAe?$AAn?$AAt?$AAs@ ; `string'
PUBLIC	??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi@ ; `string'
PUBLIC	?Next@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJKPAPAUIConnectionPoint@@PAK@Z ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Next
PUBLIC	?Skip@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJK@Z ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Skip
PUBLIC	?Reset@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJXZ ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Reset
PUBLIC	??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe@ ; `string'
PUBLIC	?Clone@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Clone
PUBLIC	??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe@ ; `string'
PUBLIC	?AddRef@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::AddRef
PUBLIC	?Release@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::Release
PUBLIC	?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::QueryInterface
PUBLIC	??_7?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@ ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::`vftable'
PUBLIC	??_G?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::`scalar deleting destructor'
PUBLIC	??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl@ ; `string'
PUBLIC	??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg@ ; `string'
PUBLIC	??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp@ ; `string'
PUBLIC	??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl@ ; `string'
PUBLIC	??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt@ ; `string'
PUBLIC	??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc@ ; `string'
PUBLIC	??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI@ ; `string'
PUBLIC	??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD@	; `string'
PUBLIC	??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD@	; `string'
PUBLIC	?chDirSep@ATL@@3_WB				; ATL::chDirSep
PUBLIC	?chRightBracket@ATL@@3_WB			; ATL::chRightBracket
PUBLIC	?chLeftBracket@ATL@@3_WB			; ATL::chLeftBracket
PUBLIC	?chQuote@ATL@@3_WB				; ATL::chQuote
PUBLIC	?chEquals@ATL@@3_WB				; ATL::chEquals
PUBLIC	?szStringVal@ATL@@3QB_WB			; ATL::szStringVal
PUBLIC	??_C@_13HADIAKP@?$AAS@				; `string'
PUBLIC	?multiszStringVal@ATL@@3QB_WB			; ATL::multiszStringVal
PUBLIC	??_C@_13LHMFKAAD@?$AAM@				; `string'
PUBLIC	?szDwordVal@ATL@@3QB_WB				; ATL::szDwordVal
PUBLIC	??_C@_13MKMNOPIJ@?$AAD@				; `string'
PUBLIC	?szBinaryVal@ATL@@3QB_WB			; ATL::szBinaryVal
PUBLIC	??_C@_13OPKGLAFF@?$AAB@				; `string'
PUBLIC	?szValToken@ATL@@3QB_WB				; ATL::szValToken
PUBLIC	??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl@		; `string'
PUBLIC	?szForceRemove@ATL@@3QB_WB			; ATL::szForceRemove
PUBLIC	??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ ; `string'
PUBLIC	?szNoRemove@ATL@@3QB_WB				; ATL::szNoRemove
PUBLIC	??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ ; `string'
PUBLIC	?szDelete@ATL@@3QB_WB				; ATL::szDelete
PUBLIC	??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe@ ; `string'
PUBLIC	__GUID_0000010e_0000_0000_c000_000000000046
PUBLIC	__GUID_b196b288_bab4_101a_b69c_00aa00341d07
PUBLIC	?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB	; ATL::CRegParser::rgszNeverDelete
PUBLIC	?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CRegObject::QueryInterface
PUBLIC	?AddRef@CRegObject@ATL@@UAGKXZ			; ATL::CRegObject::AddRef
PUBLIC	?Release@CRegObject@ATL@@UAGKXZ			; ATL::CRegObject::Release
PUBLIC	?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z	; ATL::CRegObject::AddReplacement
PUBLIC	?ClearReplacements@CRegObject@ATL@@UAGJXZ	; ATL::CRegObject::ClearReplacements
PUBLIC	??_7CRegObject@ATL@@6B@				; ATL::CRegObject::`vftable'
PUBLIC	??_GCRegObject@ATL@@UAEPAXI@Z			; ATL::CRegObject::`scalar deleting destructor'
PUBLIC	__GUID_00000113_0000_0000_c000_000000000046
PUBLIC	__GUID_1c2056cc_5ef4_101b_8bc8_00aa003e3b29
PUBLIC	??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg@ ; `string'
PUBLIC	??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe@ ; `string'
PUBLIC	??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe@ ; `string'
PUBLIC	??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe@		; `string'
PUBLIC	??_C@_17OMAOINJK@?$AAS?$AAA?$AAM@		; `string'
PUBLIC	??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY@ ; `string'
PUBLIC	??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM@ ; `string'
PUBLIC	??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb@ ; `string'
PUBLIC	?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B ; `ATL::CRegParser::HKeyFromString'::`2'::map
PUBLIC	??_C@_19NCHLBIN@?$AAH?$AAK?$AAC?$AAR@		; `string'
PUBLIC	??_C@_19JAPAIJDE@?$AAH?$AAK?$AAC?$AAU@		; `string'
PUBLIC	??_C@_19PEALEEJB@?$AAH?$AAK?$AAL?$AAM@		; `string'
PUBLIC	??_C@_17PJOJPMPB@?$AAH?$AAK?$AAU@		; `string'
PUBLIC	??_C@_19PNBHMJPL@?$AAH?$AAK?$AAP?$AAD@		; `string'
PUBLIC	??_C@_19GFFAIJHG@?$AAH?$AAK?$AAD?$AAD@		; `string'
PUBLIC	??_C@_19OFICIBHH@?$AAH?$AAK?$AAC?$AAC@		; `string'
PUBLIC	??_C@_1CE@PACHPJFI@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAL?$AAA?$AAS?$AAS?$AAE?$AAS?$AA_?$AAR?$AAO@ ; `string'
PUBLIC	??_C@_1CE@HLHNCBPM@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAU?$AAR?$AAR?$AAE?$AAN?$AAT?$AA_?$AAU?$AAS@ ; `string'
PUBLIC	??_C@_1CG@GFBEANJL@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAL?$AAO?$AAC?$AAA?$AAL?$AA_?$AAM?$AAA?$AAC?$AAH@ ; `string'
PUBLIC	??_C@_1BG@BGODANIO@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAU?$AAS?$AAE?$AAR?$AAS@ ; `string'
PUBLIC	??_C@_1CM@KHNNAOIC@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC@ ; `string'
PUBLIC	??_C@_1BM@HAGMMHIA@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAD?$AAY?$AAN?$AA_?$AAD?$AAA?$AAT?$AAA@ ; `string'
PUBLIC	??_C@_1CI@BBJOACGG@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAU?$AAR?$AAR?$AAE?$AAN?$AAT?$AA_?$AAC?$AAO@ ; `string'
PUBLIC	__GUID_00000109_0000_0000_c000_000000000046
PUBLIC	__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
PUBLIC	__GUID_00000112_0000_0000_c000_000000000046
PUBLIC	__GUID_3af24292_0c96_11ce_a0cf_00aa00600ab8
PUBLIC	__GUID_00000127_0000_0000_c000_000000000046
PUBLIC	__GUID_0000010d_0000_0000_c000_000000000046
PUBLIC	??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr@ ; `string'
PUBLIC	??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6@ ; `string'
PUBLIC	??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD@	; `string'
PUBLIC	??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw@ ; `string'
PUBLIC	??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY@ ; `string'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	?AddRef@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComAggObject<COPOSDeviceMonitor>::AddRef
PUBLIC	?Release@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComAggObject<COPOSDeviceMonitor>::Release
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	?QueryInterface@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComAggObject<COPOSDeviceMonitor>::QueryInterface
PUBLIC	?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
PUBLIC	?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
PUBLIC	?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6BCComControlBase@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleControlImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleObjectImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDataObjectImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPropertyNotifySinkCP@VCOPOSDeviceMonitor@@VCComDynamicUnkArray@ATL@@@1@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@@ ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@6B@ ; ATL::CComAggObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_G?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z ; ATL::CComAggObject<COPOSDeviceMonitor>::`scalar deleting destructor'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6BCComControlBase@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleControlImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleObjectImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDataObjectImpl@VCOPOSDeviceMonitor@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPropertyNotifySinkCP@VCOPOSDeviceMonitor@@VCComDynamicUnkArray@ATL@@@1@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@@ ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
PUBLIC	_CLSID_Registrar
PUBLIC	_IID_IRegistrar
PUBLIC	??_C@_1O@GBFKGNEO@?$AAA?$AAT?$AAL?$AA?3?$AA?$CF?$AAp@ ; `string'
PUBLIC	_IID_IDocHostUIHandlerDispatch
PUBLIC	??_C@_1BA@PICGEGJB@?$AAD?$AAI?$AAS?$AAP?$AAL?$AAA?$AAY@ ; `string'
PUBLIC	_IID_IAxWinHostWindow
PUBLIC	__GUID_9bfbbc02_eff1_101a_84ed_00aa00341d07
PUBLIC	?wc@?1??GetWndClassInfo@?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@SAAAU_ATL_WNDCLASSINFOW@3@XZ@4U43@A ; `ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> >::GetWndClassInfo'::`2'::wc
PUBLIC	__GUID_b196b284_bab4_101a_b69c_00aa00341d07
PUBLIC	_IID_IAxWinHostWindowLic
PUBLIC	?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
PUBLIC	_IID_IAxWinAmbientDispatch
PUBLIC	__GUID_00020412_0000_0000_c000_000000000046
PUBLIC	__GUID_00020401_0000_0000_c000_000000000046
PUBLIC	?OnDrawAdvanced@CComControlBase@ATL@@UAEJAAUATL_DRAWINFO@@@Z ; ATL::CComControlBase::OnDrawAdvanced
PUBLIC	_IID_IAxWinAmbientDispatchEx
PUBLIC	_IID_IInternalConnection
PUBLIC	?Next@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJKPAUtagCONNECTDATA@@PAK@Z ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Next
PUBLIC	?Skip@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJK@Z ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Skip
PUBLIC	?Reset@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJXZ ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Reset
PUBLIC	?rcDefault@CWindow@ATL@@2UtagRECT@@A		; ATL::CWindow::rcDefault
PUBLIC	?Clone@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Clone
PUBLIC	?AddRef@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::AddRef
PUBLIC	?Release@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::Release
PUBLIC	?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::QueryInterface
PUBLIC	??_7?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@ ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::`vftable'
PUBLIC	??_G?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::`scalar deleting destructor'
PUBLIC	__GUID_55980ba0_35aa_11cf_b671_00aa004cd6d8
PUBLIC	__GUID_b196b28b_bab4_101a_b69c_00aa00341d07
PUBLIC	?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
PUBLIC	?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z	; ATL::CComObjectRootBase::ObjectMain
PUBLIC	?GetCategoryMap@CComObjectRootBase@ATL@@SAPBU_ATL_CATMAP_ENTRY@2@XZ ; ATL::CComObjectRootBase::GetCategoryMap
PUBLIC	??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::`vector deleting destructor'
PUBLIC	??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::`vector deleting destructor'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{112}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{112}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{112}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{116}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{116}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{116}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{120}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{120}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{120}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{124}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{124}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{124}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{128}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{128}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{128}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{132}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{132}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{132}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{136}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{136}'
PUBLIC	?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{136}'
PUBLIC	?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{140}'
PUBLIC	?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{140}'
EXTRN	__purecall:PROC
EXTRN	?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A:BYTE	; ATL::_AtlBaseModule
EXTRN	??_ECComClassFactory@ATL@@UAEPAXI@Z:PROC	; ATL::CComClassFactory::`vector deleting destructor'
EXTRN	__Init_thread_epoch:DWORD
EXTRN	_IID_IPropertyNotifySink:BYTE
EXTRN	___ImageBase:BYTE
EXTRN	?FreezeEvents@COPOSDeviceMonitor@@MAGJH@Z:PROC	; COPOSDeviceMonitor::FreezeEvents
EXTRN	?OnDraw@COPOSDeviceMonitor@@MAEJAAUATL_DRAWINFO@@@Z:PROC ; COPOSDeviceMonitor::OnDraw
EXTRN	?SOProcessID@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC	; COPOSDeviceMonitor::SOProcessID
EXTRN	?get_OpenResult@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_OpenResult
EXTRN	?get_AutoDisable@COPOSDeviceMonitor@@UAGJPAF@Z:PROC ; COPOSDeviceMonitor::get_AutoDisable
EXTRN	?put_AutoDisable@COPOSDeviceMonitor@@UAGJF@Z:PROC ; COPOSDeviceMonitor::put_AutoDisable
EXTRN	?get_BinaryConversion@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_BinaryConversion
EXTRN	?put_BinaryConversion@COPOSDeviceMonitor@@UAGJJ@Z:PROC ; COPOSDeviceMonitor::put_BinaryConversion
EXTRN	?get_CapPowerReporting@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_CapPowerReporting
EXTRN	?get_CheckHealthText@COPOSDeviceMonitor@@UAGJPAPA_W@Z:PROC ; COPOSDeviceMonitor::get_CheckHealthText
EXTRN	?get_Claimed@COPOSDeviceMonitor@@UAGJPAF@Z:PROC	; COPOSDeviceMonitor::get_Claimed
EXTRN	?get_DataCount@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_DataCount
EXTRN	?get_DataEventEnabled@COPOSDeviceMonitor@@UAGJPAF@Z:PROC ; COPOSDeviceMonitor::get_DataEventEnabled
EXTRN	?put_DataEventEnabled@COPOSDeviceMonitor@@UAGJF@Z:PROC ; COPOSDeviceMonitor::put_DataEventEnabled
EXTRN	?get_DeviceEnabled@COPOSDeviceMonitor@@UAGJPAF@Z:PROC ; COPOSDeviceMonitor::get_DeviceEnabled
EXTRN	?put_DeviceEnabled@COPOSDeviceMonitor@@UAGJF@Z:PROC ; COPOSDeviceMonitor::put_DeviceEnabled
EXTRN	?get_FreezeEvents@COPOSDeviceMonitor@@UAGJPAF@Z:PROC ; COPOSDeviceMonitor::get_FreezeEvents
EXTRN	?put_FreezeEvents@COPOSDeviceMonitor@@UAGJF@Z:PROC ; COPOSDeviceMonitor::put_FreezeEvents
EXTRN	?get_PowerNotify@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_PowerNotify
EXTRN	?put_PowerNotify@COPOSDeviceMonitor@@UAGJJ@Z:PROC ; COPOSDeviceMonitor::put_PowerNotify
EXTRN	?get_PowerState@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_PowerState
EXTRN	?get_ResultCode@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_ResultCode
EXTRN	?get_ResultCodeExtended@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_ResultCodeExtended
EXTRN	?get_State@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC	; COPOSDeviceMonitor::get_State
EXTRN	?get_ControlObjectDescription@COPOSDeviceMonitor@@UAGJPAPA_W@Z:PROC ; COPOSDeviceMonitor::get_ControlObjectDescription
EXTRN	?get_ControlObjectVersion@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_ControlObjectVersion
EXTRN	?get_ServiceObjectDescription@COPOSDeviceMonitor@@UAGJPAPA_W@Z:PROC ; COPOSDeviceMonitor::get_ServiceObjectDescription
EXTRN	?get_ServiceObjectVersion@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::get_ServiceObjectVersion
EXTRN	?get_DeviceDescription@COPOSDeviceMonitor@@UAGJPAPA_W@Z:PROC ; COPOSDeviceMonitor::get_DeviceDescription
EXTRN	?get_DeviceName@COPOSDeviceMonitor@@UAGJPAPA_W@Z:PROC ; COPOSDeviceMonitor::get_DeviceName
EXTRN	?get_CapStatisticsReporting@COPOSDeviceMonitor@@UAGJPAF@Z:PROC ; COPOSDeviceMonitor::get_CapStatisticsReporting
EXTRN	?get_CapUpdateStatistics@COPOSDeviceMonitor@@UAGJPAF@Z:PROC ; COPOSDeviceMonitor::get_CapUpdateStatistics
EXTRN	?get_CapCompareFirmwareVersion@COPOSDeviceMonitor@@UAGJPAF@Z:PROC ; COPOSDeviceMonitor::get_CapCompareFirmwareVersion
EXTRN	?get_CapUpdateFirmware@COPOSDeviceMonitor@@UAGJPAF@Z:PROC ; COPOSDeviceMonitor::get_CapUpdateFirmware
EXTRN	?CheckHealth@COPOSDeviceMonitor@@UAGJJPAJ@Z:PROC ; COPOSDeviceMonitor::CheckHealth
EXTRN	?ClaimDevice@COPOSDeviceMonitor@@UAGJJPAJ@Z:PROC ; COPOSDeviceMonitor::ClaimDevice
EXTRN	?ClearInput@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC	; COPOSDeviceMonitor::ClearInput
EXTRN	?Close@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC	; COPOSDeviceMonitor::Close
EXTRN	?DirectIO@COPOSDeviceMonitor@@UAGJJPAJPAPA_W0@Z:PROC ; COPOSDeviceMonitor::DirectIO
EXTRN	?Open@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z:PROC	; COPOSDeviceMonitor::Open
EXTRN	?ReleaseDevice@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::ReleaseDevice
EXTRN	?ResetStatistics@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z:PROC ; COPOSDeviceMonitor::ResetStatistics
EXTRN	?RetrieveStatistics@COPOSDeviceMonitor@@UAGJPAPA_WPAJ@Z:PROC ; COPOSDeviceMonitor::RetrieveStatistics
EXTRN	?UpdateStatistics@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z:PROC ; COPOSDeviceMonitor::UpdateStatistics
EXTRN	?CompareFirmwareVersion@COPOSDeviceMonitor@@UAGJPA_WPAJ1@Z:PROC ; COPOSDeviceMonitor::CompareFirmwareVersion
EXTRN	?UpdateFirmware@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z:PROC ; COPOSDeviceMonitor::UpdateFirmware
EXTRN	?ClearInputProperties@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::ClearInputProperties
EXTRN	?get_DeviceData@COPOSDeviceMonitor@@UAGJPAPA_W@Z:PROC ; COPOSDeviceMonitor::get_DeviceData
EXTRN	?get_DeviceList@COPOSDeviceMonitor@@UAGJPAPA_W@Z:PROC ; COPOSDeviceMonitor::get_DeviceList
EXTRN	?get_MonitoringDeviceList@COPOSDeviceMonitor@@UAGJPAPA_W@Z:PROC ; COPOSDeviceMonitor::get_MonitoringDeviceList
EXTRN	?AddMonitoringDevice@COPOSDeviceMonitor@@UAGJPA_WJJJJPAJ@Z:PROC ; COPOSDeviceMonitor::AddMonitoringDevice
EXTRN	?ClearMonitoringDevice@COPOSDeviceMonitor@@UAGJPAJ@Z:PROC ; COPOSDeviceMonitor::ClearMonitoringDevice
EXTRN	?DeleteMonitoringDevice@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z:PROC ; COPOSDeviceMonitor::DeleteMonitoringDevice
EXTRN	?GetDeviceValue@COPOSDeviceMonitor@@UAGJPA_WPAJ1@Z:PROC ; COPOSDeviceMonitor::GetDeviceValue
EXTRN	??_ECComModule@ATL@@UAEPAXI@Z:PROC		; ATL::CComModule::`vector deleting destructor'
EXTRN	??_E?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z:PROC ; ATL::CComObjectCached<ATL::CComClassFactory>::`vector deleting destructor'
EXTRN	??_E?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z:PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::`vector deleting destructor'
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	_GUID_NULL:BYTE
EXTRN	_CLSID_StdGlobalInterfaceTable:BYTE
EXTRN	??_ECRegObject@ATL@@UAEPAXI@Z:PROC		; ATL::CRegObject::`vector deleting destructor'
EXTRN	??_E?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z:PROC ; ATL::CComAggObject<COPOSDeviceMonitor>::`vector deleting destructor'
EXTRN	??_E?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z:PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::`vector deleting destructor'
EXTRN	_IID_IDispatch:BYTE
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?WM_ATLGETHOST@ATL@@3IA
_BSS	SEGMENT
?WM_ATLGETHOST@ATL@@3IA DD 01H DUP (?)			; ATL::WM_ATLGETHOST
_BSS	ENDS
;	COMDAT ?WM_ATLGETCONTROL@ATL@@3IA
_BSS	SEGMENT
?WM_ATLGETCONTROL@ATL@@3IA DD 01H DUP (?)		; ATL::WM_ATLGETCONTROL
_BSS	ENDS
;	COMDAT ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA
_BSS	SEGMENT
?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA DD 01H DUP (?) ; ATL::_pPerfRegFunc
_BSS	ENDS
;	COMDAT ?_pPerfUnRegFunc@ATL@@3P6AJXZA
_BSS	SEGMENT
?_pPerfUnRegFunc@ATL@@3P6AJXZA DD 01H DUP (?)		; ATL::_pPerfUnRegFunc
_BSS	ENDS
;	COMDAT ?_AtlRegisterPerUser@ATL@@3_NA
_BSS	SEGMENT
?_AtlRegisterPerUser@ATL@@3_NA DB 01H DUP (?)		; ATL::_AtlRegisterPerUser
_BSS	ENDS
;	COMDAT ?_pAtlModule@ATL@@3PAVCAtlModule@1@A
_BSS	SEGMENT
?_pAtlModule@ATL@@3PAVCAtlModule@1@A DD 01H DUP (?)	; ATL::_pAtlModule
_BSS	ENDS
;	COMDAT ?m_libid@CAtlModule@ATL@@2U_GUID@@A
_BSS	SEGMENT
?m_libid@CAtlModule@ATL@@2U_GUID@@A DB 010H DUP (?)	; ATL::CAtlModule::m_libid
_BSS	ENDS
;	COMDAT ?_pModule@ATL@@3PAVCComModule@1@A
_BSS	SEGMENT
?_pModule@ATL@@3PAVCComModule@1@A DD 01H DUP (?)	; ATL::_pModule
_BSS	ENDS
;	COMDAT ?_entries@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4QBU34@B
_BSS	SEGMENT
?_entries@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4QBU34@B DD 03H DUP (?) ; `COPOSDeviceMonitor::GetConnMap'::`2'::_entries
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4HA DD 01H DUP (?) ; `COPOSDeviceMonitor::GetConnMap'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A
_BSS	SEGMENT
?_pAtlAutoThreadModule@ATL@@3PAUIAtlAutoThreadModule@1@A DD 01H DUP (?) ; ATL::_pAtlAutoThreadModule
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT
?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B DD FLAT:__GUID_b196b287_bab4_101a_b69c_00aa00341d07 ; `ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT __GUID_b196b28b_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b28b_bab4_101a_b69c_00aa00341d07 DD 0b196b28bH
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT __GUID_55980ba0_35aa_11cf_b671_00aa004cd6d8
CONST	SEGMENT
__GUID_55980ba0_35aa_11cf_b671_00aa004cd6d8 DD 055980ba0H
	DW	035aaH
	DW	011cfH
	DB	0b6H
	DB	071H
	DB	00H
	DB	0aaH
	DB	00H
	DB	04cH
	DB	0d6H
	DB	0d8H
CONST	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT
??_7?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@ DD FLAT:?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::`vftable'
	DD	FLAT:?AddRef@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
	DD	FLAT:?Next@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJKPAUtagCONNECTDATA@@PAK@Z
	DD	FLAT:?Skip@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJK@Z
	DD	FLAT:?Reset@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJXZ
	DD	FLAT:?Clone@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z
	DD	FLAT:??_E?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?rcDefault@CWindow@ATL@@2UtagRECT@@A
_DATA	SEGMENT
?rcDefault@CWindow@ATL@@2UtagRECT@@A DD 080000000H	; ATL::CWindow::rcDefault
	DD	080000000H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT _IID_IInternalConnection
CONST	SEGMENT
_IID_IInternalConnection DD 072ad0770H
	DW	06a9fH
	DW	011d1H
	DB	0bcH
	DB	0ecH
	DB	00H
	DB	060H
	DB	08H
	DB	08fH
	DB	044H
	DB	04eH
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatchEx
CONST	SEGMENT
_IID_IAxWinAmbientDispatchEx DD 0b2d0778bH
	DW	0ac99H
	DW	04c58H
	DB	0a5H
	DB	0c8H
	DB	0e7H
	DB	072H
	DB	04eH
	DB	053H
	DB	016H
	DB	0b5H
CONST	ENDS
;	COMDAT __GUID_00020401_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020401_0000_0000_c000_000000000046 DD 020401H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_00020412_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020412_0000_0000_c000_000000000046 DD 020412H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT _IID_IAxWinAmbientDispatch
CONST	SEGMENT
_IID_IAxWinAmbientDispatch DD 0b6ea2051H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT
?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B DD FLAT:__GUID_b196b285_bab4_101a_b69c_00aa00341d07 ; `ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindowLic
CONST	SEGMENT
_IID_IAxWinHostWindowLic DD 03935bda8H
	DW	04ed9H
	DW	0495cH
	DB	086H
	DB	050H
	DB	0e0H
	DB	01fH
	DB	0c1H
	DB	0e3H
	DB	08aH
	DB	04bH
CONST	ENDS
;	COMDAT __GUID_b196b284_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b284_bab4_101a_b69c_00aa00341d07 DD 0b196b284H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@SAAAU_ATL_WNDCLASSINFOW@3@XZ@4U43@A
_DATA	SEGMENT
?wc@?1??GetWndClassInfo@?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@SAAAU_ATL_WNDCLASSINFOW@3@XZ@4U43@A DD 030H ; `ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> >::GetWndClassInfo'::`2'::wc
	DD	0bH
	DD	FLAT:?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	06H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	07f00H
	DD	01H
	DW	00H
	DB	00H, 00H
	ORG $+72
_DATA	ENDS
;	COMDAT __GUID_9bfbbc02_eff1_101a_84ed_00aa00341d07
CONST	SEGMENT
__GUID_9bfbbc02_eff1_101a_84ed_00aa00341d07 DD 09bfbbc02H
	DW	0eff1H
	DW	0101aH
	DB	084H
	DB	0edH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT _IID_IAxWinHostWindow
CONST	SEGMENT
_IID_IAxWinHostWindow DD 0b6ea2050H
	DW	048aH
	DW	011d1H
	DB	082H
	DB	0b9H
	DB	00H
	DB	0c0H
	DB	04fH
	DB	0b9H
	DB	094H
	DB	02eH
CONST	ENDS
;	COMDAT ??_C@_1BA@PICGEGJB@?$AAD?$AAI?$AAS?$AAP?$AAL?$AAA?$AAY@
CONST	SEGMENT
??_C@_1BA@PICGEGJB@?$AAD?$AAI?$AAS?$AAP?$AAL?$AAA?$AAY@ DB 'D', 00H, 'I', 00H
	DB	'S', 00H, 'P', 00H, 'L', 00H, 'A', 00H, 'Y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IDocHostUIHandlerDispatch
CONST	SEGMENT
_IID_IDocHostUIHandlerDispatch DD 0425b5af0H
	DW	065f1H
	DW	011d1H
	DB	096H
	DB	011H
	DB	00H
	DB	00H
	DB	0f8H
	DB	01eH
	DB	0dH
	DB	0dH
CONST	ENDS
;	COMDAT ??_C@_1O@GBFKGNEO@?$AAA?$AAT?$AAL?$AA?3?$AA?$CF?$AAp@
CONST	SEGMENT
??_C@_1O@GBFKGNEO@?$AAA?$AAT?$AAL?$AA?3?$AA?$CF?$AAp@ DB 'A', 00H, 'T', 00H
	DB	'L', 00H, ':', 00H, '%', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT _IID_IRegistrar
CONST	SEGMENT
_IID_IRegistrar DD 044ec053bH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT _CLSID_Registrar
CONST	SEGMENT
_CLSID_Registrar DD 044ec053aH
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@@ DD FLAT:?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ
	DD	FLAT:?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z
	DD	FLAT:?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z
	DD	FLAT:?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z
	DD	FLAT:?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPropertyNotifySinkCP@VCOPOSDeviceMonitor@@VCComDynamicUnkArray@ATL@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPropertyNotifySinkCP@VCOPOSDeviceMonitor@@VCComDynamicUnkArray@ATL@@@1@@ DD FLAT:?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ
	DD	FLAT:?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z
	DD	FLAT:?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z
	DD	FLAT:?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z
	DD	FLAT:?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ
	DD	FLAT:?GetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@PAK1@Z
	DD	FLAT:?SetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@KK@Z
	DD	FLAT:?FAccessAllowed@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@MAEHXZ
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ
	DD	FLAT:?GetClassInfoW@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAPAUITypeInfo@@@Z
	DD	FLAT:?GetGUID@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJKPAU_GUID@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDataObjectImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDataObjectImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ
	DD	FLAT:?GetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z
	DD	FLAT:?GetDataHere@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z
	DD	FLAT:?QueryGetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@@Z
	DD	FLAT:?GetCanonicalFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@0@Z
	DD	FLAT:?SetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@H@Z
	DD	FLAT:?EnumFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIEnumFORMATETC@@@Z
	DD	FLAT:?DAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@KPAUIAdviseSink@@PAK@Z
	DD	FLAT:?DUnadvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
	DD	FLAT:?EnumDAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ
	DD	FLAT:?QuickActivate@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z
	DD	FLAT:?SetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z
	DD	FLAT:?GetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ
	DD	FLAT:?GetPages@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCAUUID@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ
	DD	FLAT:?GetClassID@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?IsDirty@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?InitNew@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z
	DD	FLAT:?Load@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z
	DD	FLAT:?Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z
	DD	FLAT:?SaveCompleted@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z
	DD	FLAT:?HandsOffStorage@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ
	DD	FLAT:?EnumConnectionPoints@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z
	DD	FLAT:?FindConnectionPoint@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAUIConnectionPoint@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ
	DD	FLAT:?GetWindow@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z
	DD	FLAT:?ContextSensitiveHelp@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
	DD	FLAT:?InPlaceDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?UIDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?SetObjectRects@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@0@Z
	DD	FLAT:?ReactivateAndUndo@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?OnWindowMessage@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJIIJPAJ@Z
	DD	FLAT:?GetDropTarget@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIDropTarget@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ
	DD	FLAT:?Draw@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3P6GHK@ZK@Z
	DD	FLAT:?GetColorSet@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@PAPAUtagLOGPALETTE@@@Z
	DD	FLAT:?Freeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAK@Z
	DD	FLAT:?Unfreeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
	DD	FLAT:?SetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAUIAdviseSink@@@Z
	DD	FLAT:?GetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK0PAPAUIAdviseSink@@@Z
	DD	FLAT:?GetExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUtagSIZE@@@Z
	DD	FLAT:?GetRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAU_RECTL@@@Z
	DD	FLAT:?GetViewStatus@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK@Z
	DD	FLAT:?QueryHitPoint@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@UtagPOINT@@JPAK@Z
	DD	FLAT:?QueryHitRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@0JPAK@Z
	DD	FLAT:?GetNaturalExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUHDC__@@PAUtagExtentInfo@@PAUtagSIZE@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ
	DD	FLAT:?GetWindow@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z
	DD	FLAT:?ContextSensitiveHelp@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
	DD	FLAT:?TranslateAcceleratorW@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z
	DD	FLAT:?OnFrameWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
	DD	FLAT:?OnDocWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
	DD	FLAT:?ResizeBorder@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@PAUIOleInPlaceUIWindow@@H@Z
	DD	FLAT:?EnableModeless@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleObjectImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleObjectImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ
	DD	FLAT:?SetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIOleClientSite@@@Z
	DD	FLAT:?GetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIOleClientSite@@@Z
	DD	FLAT:?SetHostNames@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPB_W0@Z
	DD	FLAT:?Close@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
	DD	FLAT:?SetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUIMoniker@@@Z
	DD	FLAT:?GetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAPAUIMoniker@@@Z
	DD	FLAT:?InitFromData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIDataObject@@HK@Z
	DD	FLAT:?GetClipboardData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIDataObject@@@Z
	DD	FLAT:?DoVerb@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJPAUtagMSG@@PAUIOleClientSite@@JPAUHWND__@@PBUtagRECT@@@Z
	DD	FLAT:?EnumVerbs@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumOLEVERB@@@Z
	DD	FLAT:?Update@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?IsUpToDate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?GetUserClassID@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?GetUserType@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPA_W@Z
	DD	FLAT:?SetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z
	DD	FLAT:?GetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z
	DD	FLAT:?Advise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIAdviseSink@@PAK@Z
	DD	FLAT:?Unadvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
	DD	FLAT:?EnumAdvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z
	DD	FLAT:?GetMiscStatus@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAK@Z
	DD	FLAT:?SetColorScheme@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagLOGPALETTE@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleControlImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleControlImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ
	DD	FLAT:?GetControlInfo@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCONTROLINFO@@@Z
	DD	FLAT:?OnMnemonic@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientPropertyChange@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJ@Z
	DD	FLAT:?FreezeEvents@COPOSDeviceMonitor@@MAGJH@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ
	DD	FLAT:?GetClassID@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?IsDirty@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@@Z
	DD	FLAT:?Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@H@Z
	DD	FLAT:?GetSizeMax@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAT_ULARGE_INTEGER@@@Z
	DD	FLAT:?InitNew@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@1@@ DD FLAT:?ProcessWindowMessage@COPOSDeviceMonitor@@UAEHPAUHWND__@@IIJAAJK@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z
	DD	FLAT:?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6BCComControlBase@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6BCComControlBase@1@@ DD FLAT:??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?CreateControlWindow@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEPAUHWND__@@PAU3@AAUtagRECT@@@Z
	DD	FLAT:?ControlQueryInterface@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEJABU_GUID@@PAPAX@Z
	DD	FLAT:?OnDrawAdvanced@CComControlBase@ATL@@UAEJAAUATL_DRAWINFO@@@Z
	DD	FLAT:?OnDraw@COPOSDeviceMonitor@@MAEJAAUATL_DRAWINFO@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
CONST	SEGMENT
??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ DD FLAT:?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
	DD	FLAT:?GetTypeInfoCount@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z
	DD	FLAT:?GetTypeInfo@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z
	DD	FLAT:?GetIDsOfNames@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPA_WIKPAJ@Z
	DD	FLAT:?Invoke@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
	DD	FLAT:?SOData@COPOSDeviceMonitor@@MAGJJ@Z
	DD	FLAT:?SODirectIO@COPOSDeviceMonitor@@MAGJJPAJPAPA_W@Z
	DD	FLAT:?SOError@COPOSDeviceMonitor@@MAGJJJJPAJ@Z
	DD	FLAT:?SOOutputCompleteDummy@COPOSDeviceMonitor@@MAGJJ@Z
	DD	FLAT:?SOStatusUpdate@COPOSDeviceMonitor@@MAGJJ@Z
	DD	FLAT:?SOProcessID@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_OpenResult@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_AutoDisable@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?put_AutoDisable@COPOSDeviceMonitor@@UAGJF@Z
	DD	FLAT:?get_BinaryConversion@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?put_BinaryConversion@COPOSDeviceMonitor@@UAGJJ@Z
	DD	FLAT:?get_CapPowerReporting@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_CheckHealthText@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_Claimed@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?get_DataCount@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_DataEventEnabled@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?put_DataEventEnabled@COPOSDeviceMonitor@@UAGJF@Z
	DD	FLAT:?get_DeviceEnabled@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?put_DeviceEnabled@COPOSDeviceMonitor@@UAGJF@Z
	DD	FLAT:?get_FreezeEvents@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?put_FreezeEvents@COPOSDeviceMonitor@@UAGJF@Z
	DD	FLAT:?get_PowerNotify@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?put_PowerNotify@COPOSDeviceMonitor@@UAGJJ@Z
	DD	FLAT:?get_PowerState@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_ResultCode@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_ResultCodeExtended@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_State@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_ControlObjectDescription@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_ControlObjectVersion@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_ServiceObjectDescription@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_ServiceObjectVersion@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_DeviceDescription@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_DeviceName@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_CapStatisticsReporting@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?get_CapUpdateStatistics@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?get_CapCompareFirmwareVersion@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?get_CapUpdateFirmware@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?CheckHealth@COPOSDeviceMonitor@@UAGJJPAJ@Z
	DD	FLAT:?ClaimDevice@COPOSDeviceMonitor@@UAGJJPAJ@Z
	DD	FLAT:?ClearInput@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?Close@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?DirectIO@COPOSDeviceMonitor@@UAGJJPAJPAPA_W0@Z
	DD	FLAT:?Open@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?ReleaseDevice@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?ResetStatistics@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?RetrieveStatistics@COPOSDeviceMonitor@@UAGJPAPA_WPAJ@Z
	DD	FLAT:?UpdateStatistics@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?CompareFirmwareVersion@COPOSDeviceMonitor@@UAGJPA_WPAJ1@Z
	DD	FLAT:?UpdateFirmware@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?ClearInputProperties@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_DeviceData@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_DeviceList@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_MonitoringDeviceList@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?AddMonitoringDevice@COPOSDeviceMonitor@@UAGJPA_WJJJJPAJ@Z
	DD	FLAT:?ClearMonitoringDevice@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?DeleteMonitoringDevice@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?GetDeviceValue@COPOSDeviceMonitor@@UAGJPA_WPAJ1@Z
CONST	ENDS
;	COMDAT ??_7?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@6B@
CONST	SEGMENT
??_7?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@6B@ DD FLAT:?QueryInterface@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComAggObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
	DD	FLAT:??_E?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@@ DD FLAT:?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ
	DD	FLAT:?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z
	DD	FLAT:?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z
	DD	FLAT:?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z
	DD	FLAT:?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPropertyNotifySinkCP@VCOPOSDeviceMonitor@@VCComDynamicUnkArray@ATL@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPropertyNotifySinkCP@VCOPOSDeviceMonitor@@VCComDynamicUnkArray@ATL@@@1@@ DD FLAT:?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ
	DD	FLAT:?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z
	DD	FLAT:?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z
	DD	FLAT:?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z
	DD	FLAT:?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ
	DD	FLAT:?GetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@PAK1@Z
	DD	FLAT:?SetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@KK@Z
	DD	FLAT:?FAccessAllowed@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@MAEHXZ
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ
	DD	FLAT:?GetClassInfoW@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAPAUITypeInfo@@@Z
	DD	FLAT:?GetGUID@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJKPAU_GUID@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDataObjectImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDataObjectImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ
	DD	FLAT:?GetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z
	DD	FLAT:?GetDataHere@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z
	DD	FLAT:?QueryGetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@@Z
	DD	FLAT:?GetCanonicalFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@0@Z
	DD	FLAT:?SetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@H@Z
	DD	FLAT:?EnumFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIEnumFORMATETC@@@Z
	DD	FLAT:?DAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@KPAUIAdviseSink@@PAK@Z
	DD	FLAT:?DUnadvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
	DD	FLAT:?EnumDAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ
	DD	FLAT:?QuickActivate@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z
	DD	FLAT:?SetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z
	DD	FLAT:?GetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ
	DD	FLAT:?GetPages@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCAUUID@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ
	DD	FLAT:?GetClassID@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?IsDirty@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?InitNew@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z
	DD	FLAT:?Load@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z
	DD	FLAT:?Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z
	DD	FLAT:?SaveCompleted@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z
	DD	FLAT:?HandsOffStorage@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ
	DD	FLAT:?EnumConnectionPoints@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z
	DD	FLAT:?FindConnectionPoint@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAUIConnectionPoint@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ
	DD	FLAT:?GetWindow@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z
	DD	FLAT:?ContextSensitiveHelp@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
	DD	FLAT:?InPlaceDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?UIDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?SetObjectRects@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@0@Z
	DD	FLAT:?ReactivateAndUndo@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?OnWindowMessage@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJIIJPAJ@Z
	DD	FLAT:?GetDropTarget@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIDropTarget@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ
	DD	FLAT:?Draw@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3P6GHK@ZK@Z
	DD	FLAT:?GetColorSet@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@PAPAUtagLOGPALETTE@@@Z
	DD	FLAT:?Freeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAK@Z
	DD	FLAT:?Unfreeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
	DD	FLAT:?SetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAUIAdviseSink@@@Z
	DD	FLAT:?GetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK0PAPAUIAdviseSink@@@Z
	DD	FLAT:?GetExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUtagSIZE@@@Z
	DD	FLAT:?GetRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAU_RECTL@@@Z
	DD	FLAT:?GetViewStatus@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK@Z
	DD	FLAT:?QueryHitPoint@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@UtagPOINT@@JPAK@Z
	DD	FLAT:?QueryHitRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@0JPAK@Z
	DD	FLAT:?GetNaturalExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUHDC__@@PAUtagExtentInfo@@PAUtagSIZE@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ
	DD	FLAT:?GetWindow@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z
	DD	FLAT:?ContextSensitiveHelp@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
	DD	FLAT:?TranslateAcceleratorW@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z
	DD	FLAT:?OnFrameWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
	DD	FLAT:?OnDocWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
	DD	FLAT:?ResizeBorder@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@PAUIOleInPlaceUIWindow@@H@Z
	DD	FLAT:?EnableModeless@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleObjectImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleObjectImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ
	DD	FLAT:?SetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIOleClientSite@@@Z
	DD	FLAT:?GetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIOleClientSite@@@Z
	DD	FLAT:?SetHostNames@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPB_W0@Z
	DD	FLAT:?Close@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
	DD	FLAT:?SetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUIMoniker@@@Z
	DD	FLAT:?GetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAPAUIMoniker@@@Z
	DD	FLAT:?InitFromData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIDataObject@@HK@Z
	DD	FLAT:?GetClipboardData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIDataObject@@@Z
	DD	FLAT:?DoVerb@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJPAUtagMSG@@PAUIOleClientSite@@JPAUHWND__@@PBUtagRECT@@@Z
	DD	FLAT:?EnumVerbs@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumOLEVERB@@@Z
	DD	FLAT:?Update@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?IsUpToDate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?GetUserClassID@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?GetUserType@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPA_W@Z
	DD	FLAT:?SetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z
	DD	FLAT:?GetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z
	DD	FLAT:?Advise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIAdviseSink@@PAK@Z
	DD	FLAT:?Unadvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
	DD	FLAT:?EnumAdvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z
	DD	FLAT:?GetMiscStatus@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAK@Z
	DD	FLAT:?SetColorScheme@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagLOGPALETTE@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleControlImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleControlImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ
	DD	FLAT:?GetControlInfo@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCONTROLINFO@@@Z
	DD	FLAT:?OnMnemonic@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z
	DD	FLAT:?OnAmbientPropertyChange@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJ@Z
	DD	FLAT:?FreezeEvents@COPOSDeviceMonitor@@MAGJH@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ
	DD	FLAT:?GetClassID@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z
	DD	FLAT:?IsDirty@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
	DD	FLAT:?Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@@Z
	DD	FLAT:?Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@H@Z
	DD	FLAT:?GetSizeMax@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAT_ULARGE_INTEGER@@@Z
	DD	FLAT:?InitNew@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@1@@ DD FLAT:?ProcessWindowMessage@COPOSDeviceMonitor@@UAEHPAUHWND__@@IIJAAJK@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z
	DD	FLAT:?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
	DD	FLAT:?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6BCComControlBase@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6BCComControlBase@1@@ DD FLAT:??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?CreateControlWindow@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEPAUHWND__@@PAU3@AAUtagRECT@@@Z
	DD	FLAT:?ControlQueryInterface@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEJABU_GUID@@PAPAX@Z
	DD	FLAT:?OnDrawAdvanced@CComControlBase@ATL@@UAEJAAUATL_DRAWINFO@@@Z
	DD	FLAT:?OnDraw@COPOSDeviceMonitor@@MAEJAAUATL_DRAWINFO@@@Z
CONST	ENDS
;	COMDAT ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
CONST	SEGMENT
??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@ DD FLAT:?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vftable'
	DD	FLAT:?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
	DD	FLAT:?GetTypeInfoCount@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z
	DD	FLAT:?GetTypeInfo@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z
	DD	FLAT:?GetIDsOfNames@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPA_WIKPAJ@Z
	DD	FLAT:?Invoke@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
	DD	FLAT:?SOData@COPOSDeviceMonitor@@MAGJJ@Z
	DD	FLAT:?SODirectIO@COPOSDeviceMonitor@@MAGJJPAJPAPA_W@Z
	DD	FLAT:?SOError@COPOSDeviceMonitor@@MAGJJJJPAJ@Z
	DD	FLAT:?SOOutputCompleteDummy@COPOSDeviceMonitor@@MAGJJ@Z
	DD	FLAT:?SOStatusUpdate@COPOSDeviceMonitor@@MAGJJ@Z
	DD	FLAT:?SOProcessID@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_OpenResult@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_AutoDisable@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?put_AutoDisable@COPOSDeviceMonitor@@UAGJF@Z
	DD	FLAT:?get_BinaryConversion@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?put_BinaryConversion@COPOSDeviceMonitor@@UAGJJ@Z
	DD	FLAT:?get_CapPowerReporting@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_CheckHealthText@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_Claimed@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?get_DataCount@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_DataEventEnabled@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?put_DataEventEnabled@COPOSDeviceMonitor@@UAGJF@Z
	DD	FLAT:?get_DeviceEnabled@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?put_DeviceEnabled@COPOSDeviceMonitor@@UAGJF@Z
	DD	FLAT:?get_FreezeEvents@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?put_FreezeEvents@COPOSDeviceMonitor@@UAGJF@Z
	DD	FLAT:?get_PowerNotify@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?put_PowerNotify@COPOSDeviceMonitor@@UAGJJ@Z
	DD	FLAT:?get_PowerState@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_ResultCode@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_ResultCodeExtended@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_State@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_ControlObjectDescription@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_ControlObjectVersion@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_ServiceObjectDescription@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_ServiceObjectVersion@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_DeviceDescription@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_DeviceName@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_CapStatisticsReporting@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?get_CapUpdateStatistics@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?get_CapCompareFirmwareVersion@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?get_CapUpdateFirmware@COPOSDeviceMonitor@@UAGJPAF@Z
	DD	FLAT:?CheckHealth@COPOSDeviceMonitor@@UAGJJPAJ@Z
	DD	FLAT:?ClaimDevice@COPOSDeviceMonitor@@UAGJJPAJ@Z
	DD	FLAT:?ClearInput@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?Close@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?DirectIO@COPOSDeviceMonitor@@UAGJJPAJPAPA_W0@Z
	DD	FLAT:?Open@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?ReleaseDevice@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?ResetStatistics@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?RetrieveStatistics@COPOSDeviceMonitor@@UAGJPAPA_WPAJ@Z
	DD	FLAT:?UpdateStatistics@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?CompareFirmwareVersion@COPOSDeviceMonitor@@UAGJPA_WPAJ1@Z
	DD	FLAT:?UpdateFirmware@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?ClearInputProperties@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?get_DeviceData@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_DeviceList@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?get_MonitoringDeviceList@COPOSDeviceMonitor@@UAGJPAPA_W@Z
	DD	FLAT:?AddMonitoringDevice@COPOSDeviceMonitor@@UAGJPA_WJJJJPAJ@Z
	DD	FLAT:?ClearMonitoringDevice@COPOSDeviceMonitor@@UAGJPAJ@Z
	DD	FLAT:?DeleteMonitoringDevice@COPOSDeviceMonitor@@UAGJPA_WPAJ@Z
	DD	FLAT:?GetDeviceValue@COPOSDeviceMonitor@@UAGJPA_WPAJ1@Z
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY@
CONST	SEGMENT
??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY@ DB 'R', 00H, 'E'
	DB	00H, 'G', 00H, 'I', 00H, 'S', 00H, 'T', 00H, 'R', 00H, 'Y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw@
CONST	SEGMENT
??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw@ DB 'M'
	DB	00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'R', 00H, 'a', 00H, 'w', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe@
CONST	SEGMENT
??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe@ DB 'M', 00H, 'o', 00H, 'd'
	DB	00H, 'u', 00H, 'l', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD@
CONST	SEGMENT
??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD@ DB 'A', 00H, 'P', 00H, 'P', 00H
	DB	'I', 00H, 'D', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6@
CONST	SEGMENT
??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6@ DB 0dH
	DB	00H, 0aH, 00H, 09H, 00H, '}', 00H, 0dH, 00H, 0aH, 00H, '}', 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr@
CONST	SEGMENT
??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr@ DB 'H'
	DB	00H, 'K', 00H, 'C', 00H, 'U', 00H, 0dH, 00H, 0aH, 00H, '{', 00H
	DB	09H, 00H, 'S', 00H, 'o', 00H, 'f', 00H, 't', 00H, 'w', 00H, 'a'
	DB	00H, 'r', 00H, 'e', 00H, 0dH, 00H, 0aH, 00H, 09H, 00H, '{', 00H
	DB	0dH, 00H, 0aH, 00H, 09H, 00H, 09H, 00H, 'C', 00H, 'l', 00H, 'a'
	DB	00H, 's', 00H, 's', 00H, 'e', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_0000010d_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0000010d_0000_0000_c000_000000000046 DD 010dH
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_00000127_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000127_0000_0000_c000_000000000046 DD 0127H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_3af24292_0c96_11ce_a0cf_00aa00600ab8
CONST	SEGMENT
__GUID_3af24292_0c96_11ce_a0cf_00aa00600ab8 DD 03af24292H
	DW	0c96H
	DW	011ceH
	DB	0a0H
	DB	0cfH
	DB	00H
	DB	0aaH
	DB	00H
	DB	060H
	DB	0aH
	DB	0b8H
CONST	ENDS
;	COMDAT __GUID_00000112_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000112_0000_0000_c000_000000000046 DD 0112H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
CONST	SEGMENT
__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713 DD 07fd52380H
	DW	04e07H
	DW	0101bH
	DB	0aeH
	DB	02dH
	DB	08H
	DB	00H
	DB	02bH
	DB	02eH
	DB	0c7H
	DB	013H
CONST	ENDS
;	COMDAT __GUID_00000109_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000109_0000_0000_c000_000000000046 DD 0109H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ??_C@_1CI@BBJOACGG@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAU?$AAR?$AAR?$AAE?$AAN?$AAT?$AA_?$AAC?$AAO@
CONST	SEGMENT
??_C@_1CI@BBJOACGG@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAU?$AAR?$AAR?$AAE?$AAN?$AAT?$AA_?$AAC?$AAO@ DB 'H'
	DB	00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'C', 00H, 'U', 00H
	DB	'R', 00H, 'R', 00H, 'E', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'C'
	DB	00H, 'O', 00H, 'N', 00H, 'F', 00H, 'I', 00H, 'G', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@HAGMMHIA@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAD?$AAY?$AAN?$AA_?$AAD?$AAA?$AAT?$AAA@
CONST	SEGMENT
??_C@_1BM@HAGMMHIA@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAD?$AAY?$AAN?$AA_?$AAD?$AAA?$AAT?$AAA@ DB 'H'
	DB	00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'D', 00H, 'Y', 00H
	DB	'N', 00H, '_', 00H, 'D', 00H, 'A', 00H, 'T', 00H, 'A', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@KHNNAOIC@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC@
CONST	SEGMENT
??_C@_1CM@KHNNAOIC@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC@ DB 'H'
	DB	00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'P', 00H, 'E', 00H
	DB	'R', 00H, 'F', 00H, 'O', 00H, 'R', 00H, 'M', 00H, 'A', 00H, 'N'
	DB	00H, 'C', 00H, 'E', 00H, '_', 00H, 'D', 00H, 'A', 00H, 'T', 00H
	DB	'A', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@BGODANIO@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAU?$AAS?$AAE?$AAR?$AAS@
CONST	SEGMENT
??_C@_1BG@BGODANIO@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAU?$AAS?$AAE?$AAR?$AAS@ DB 'H'
	DB	00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'U', 00H, 'S', 00H
	DB	'E', 00H, 'R', 00H, 'S', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@GFBEANJL@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAL?$AAO?$AAC?$AAA?$AAL?$AA_?$AAM?$AAA?$AAC?$AAH@
CONST	SEGMENT
??_C@_1CG@GFBEANJL@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAL?$AAO?$AAC?$AAA?$AAL?$AA_?$AAM?$AAA?$AAC?$AAH@ DB 'H'
	DB	00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'L', 00H, 'O', 00H
	DB	'C', 00H, 'A', 00H, 'L', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'C'
	DB	00H, 'H', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@HLHNCBPM@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAU?$AAR?$AAR?$AAE?$AAN?$AAT?$AA_?$AAU?$AAS@
CONST	SEGMENT
??_C@_1CE@HLHNCBPM@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAU?$AAR?$AAR?$AAE?$AAN?$AAT?$AA_?$AAU?$AAS@ DB 'H'
	DB	00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'C', 00H, 'U', 00H
	DB	'R', 00H, 'R', 00H, 'E', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'U'
	DB	00H, 'S', 00H, 'E', 00H, 'R', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@PACHPJFI@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAL?$AAA?$AAS?$AAS?$AAE?$AAS?$AA_?$AAR?$AAO@
CONST	SEGMENT
??_C@_1CE@PACHPJFI@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAL?$AAA?$AAS?$AAS?$AAE?$AAS?$AA_?$AAR?$AAO@ DB 'H'
	DB	00H, 'K', 00H, 'E', 00H, 'Y', 00H, '_', 00H, 'C', 00H, 'L', 00H
	DB	'A', 00H, 'S', 00H, 'S', 00H, 'E', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'O', 00H, 'O', 00H, 'T', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_19OFICIBHH@?$AAH?$AAK?$AAC?$AAC@
CONST	SEGMENT
??_C@_19OFICIBHH@?$AAH?$AAK?$AAC?$AAC@ DB 'H', 00H, 'K', 00H, 'C', 00H, 'C'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19GFFAIJHG@?$AAH?$AAK?$AAD?$AAD@
CONST	SEGMENT
??_C@_19GFFAIJHG@?$AAH?$AAK?$AAD?$AAD@ DB 'H', 00H, 'K', 00H, 'D', 00H, 'D'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19PNBHMJPL@?$AAH?$AAK?$AAP?$AAD@
CONST	SEGMENT
??_C@_19PNBHMJPL@?$AAH?$AAK?$AAP?$AAD@ DB 'H', 00H, 'K', 00H, 'P', 00H, 'D'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_17PJOJPMPB@?$AAH?$AAK?$AAU@
CONST	SEGMENT
??_C@_17PJOJPMPB@?$AAH?$AAK?$AAU@ DB 'H', 00H, 'K', 00H, 'U', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19PEALEEJB@?$AAH?$AAK?$AAL?$AAM@
CONST	SEGMENT
??_C@_19PEALEEJB@?$AAH?$AAK?$AAL?$AAM@ DB 'H', 00H, 'K', 00H, 'L', 00H, 'M'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19JAPAIJDE@?$AAH?$AAK?$AAC?$AAU@
CONST	SEGMENT
??_C@_19JAPAIJDE@?$AAH?$AAK?$AAC?$AAU@ DB 'H', 00H, 'K', 00H, 'C', 00H, 'U'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_19NCHLBIN@?$AAH?$AAK?$AAC?$AAR@
CONST	SEGMENT
??_C@_19NCHLBIN@?$AAH?$AAK?$AAC?$AAR@ DB 'H', 00H, 'K', 00H, 'C', 00H, 'R'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B
CONST	SEGMENT
?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B DD FLAT:??_C@_19NCHLBIN@?$AAH?$AAK?$AAC?$AAR@ ; `ATL::CRegParser::HKeyFromString'::`2'::map
	DD	080000000H
	DD	FLAT:??_C@_19JAPAIJDE@?$AAH?$AAK?$AAC?$AAU@
	DD	080000001H
	DD	FLAT:??_C@_19PEALEEJB@?$AAH?$AAK?$AAL?$AAM@
	DD	080000002H
	DD	FLAT:??_C@_17PJOJPMPB@?$AAH?$AAK?$AAU@
	DD	080000003H
	DD	FLAT:??_C@_19PNBHMJPL@?$AAH?$AAK?$AAP?$AAD@
	DD	080000004H
	DD	FLAT:??_C@_19GFFAIJHG@?$AAH?$AAK?$AAD?$AAD@
	DD	080000006H
	DD	FLAT:??_C@_19OFICIBHH@?$AAH?$AAK?$AAC?$AAC@
	DD	080000005H
	DD	FLAT:??_C@_1CE@PACHPJFI@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAL?$AAA?$AAS?$AAS?$AAE?$AAS?$AA_?$AAR?$AAO@
	DD	080000000H
	DD	FLAT:??_C@_1CE@HLHNCBPM@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAU?$AAR?$AAR?$AAE?$AAN?$AAT?$AA_?$AAU?$AAS@
	DD	080000001H
	DD	FLAT:??_C@_1CG@GFBEANJL@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAL?$AAO?$AAC?$AAA?$AAL?$AA_?$AAM?$AAA?$AAC?$AAH@
	DD	080000002H
	DD	FLAT:??_C@_1BG@BGODANIO@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAU?$AAS?$AAE?$AAR?$AAS@
	DD	080000003H
	DD	FLAT:??_C@_1CM@KHNNAOIC@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAP?$AAE?$AAR?$AAF?$AAO?$AAR?$AAM?$AAA?$AAN?$AAC@
	DD	080000004H
	DD	FLAT:??_C@_1BM@HAGMMHIA@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAD?$AAY?$AAN?$AA_?$AAD?$AAA?$AAT?$AAA@
	DD	080000006H
	DD	FLAT:??_C@_1CI@BBJOACGG@?$AAH?$AAK?$AAE?$AAY?$AA_?$AAC?$AAU?$AAR?$AAR?$AAE?$AAN?$AAT?$AA_?$AAC?$AAO@
	DD	080000005H
CONST	ENDS
;	COMDAT ??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb@
CONST	SEGMENT
??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb@ DB 'T', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, 'L', 00H, 'i', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe@
CONST	SEGMENT
??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe@ DB 'S', 00H, 'o'
	DB	00H, 'f', 00H, 't', 00H, 'w', 00H, 'a', 00H, 'r', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM@
CONST	SEGMENT
??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM@ DB 'S', 00H, 'Y', 00H, 'S'
	DB	00H, 'T', 00H, 'E', 00H, 'M', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY@
CONST	SEGMENT
??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY@ DB 'S', 00H, 'E'
	DB	00H, 'C', 00H, 'U', 00H, 'R', 00H, 'I', 00H, 'T', 00H, 'Y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_17OMAOINJK@?$AAS?$AAA?$AAM@
CONST	SEGMENT
??_C@_17OMAOINJK@?$AAS?$AAA?$AAM@ DB 'S', 00H, 'A', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe@
CONST	SEGMENT
??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe@ DB 'M', 00H, 'i', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe@
CONST	SEGMENT
??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe@ DB 'H', 00H, 'a'
	DB	00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H, 'r', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe@
CONST	SEGMENT
??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe@ DB 'I', 00H
	DB	'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'f', 00H, 'a', 00H, 'c'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe@
CONST	SEGMENT
??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe@ DB 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 'T', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg@
CONST	SEGMENT
??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg@ DB 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'p', 00H, 'o', 00H, 'n', 00H, 'e', 00H
	DB	'n', 00H, 't', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT __GUID_1c2056cc_5ef4_101b_8bc8_00aa003e3b29
CONST	SEGMENT
__GUID_1c2056cc_5ef4_101b_8bc8_00aa003e3b29 DD 01c2056ccH
	DW	05ef4H
	DW	0101bH
	DB	08bH
	DB	0c8H
	DB	00H
	DB	0aaH
	DB	00H
	DB	03eH
	DB	03bH
	DB	029H
CONST	ENDS
;	COMDAT __GUID_00000113_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000113_0000_0000_c000_000000000046 DD 0113H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ??_7CRegObject@ATL@@6B@
CONST	SEGMENT
??_7CRegObject@ATL@@6B@ DD FLAT:?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CRegObject::`vftable'
	DD	FLAT:?AddRef@CRegObject@ATL@@UAGKXZ
	DD	FLAT:?Release@CRegObject@ATL@@UAGKXZ
	DD	FLAT:?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
	DD	FLAT:?ClearReplacements@CRegObject@ATL@@UAGJXZ
	DD	FLAT:??_ECRegObject@ATL@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB
CONST	SEGMENT
?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB DD FLAT:??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD@ ; ATL::CRegParser::rgszNeverDelete
	DD	FLAT:??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD@
	DD	FLAT:??_C@_1CK@OEKPKBNA@?$AAC?$AAo?$AAm?$AAp?$AAo?$AAn?$AAe?$AAn?$AAt?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg@
	DD	FLAT:??_C@_1BC@NKMMNMGL@?$AAF?$AAi?$AAl?$AAe?$AAT?$AAy?$AAp?$AAe@
	DD	FLAT:??_C@_1BE@EKPAFMCP@?$AAI?$AAn?$AAt?$AAe?$AAr?$AAf?$AAa?$AAc?$AAe@
	DD	FLAT:??_C@_1BC@MAICEHGI@?$AAH?$AAa?$AAr?$AAd?$AAw?$AAa?$AAr?$AAe@
	DD	FLAT:??_C@_19HLLLM@?$AAM?$AAi?$AAm?$AAe@
	DD	FLAT:??_C@_17OMAOINJK@?$AAS?$AAA?$AAM@
	DD	FLAT:??_C@_1BC@IBECJAAI@?$AAS?$AAE?$AAC?$AAU?$AAR?$AAI?$AAT?$AAY@
	DD	FLAT:??_C@_1O@GBFINDKL@?$AAS?$AAY?$AAS?$AAT?$AAE?$AAM@
	DD	FLAT:??_C@_1BC@EAHCMADO@?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr?$AAe@
	DD	FLAT:??_C@_1BA@JIHHIEDE@?$AAT?$AAy?$AAp?$AAe?$AAL?$AAi?$AAb@
CONST	ENDS
;	COMDAT __GUID_b196b288_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b288_bab4_101a_b69c_00aa00341d07 DD 0b196b288H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT __GUID_0000010e_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0000010e_0000_0000_c000_000000000046 DD 010eH
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe@
CONST	SEGMENT
??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe@ DB 'D', 00H, 'e', 00H, 'l'
	DB	00H, 'e', 00H, 't', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ?szDelete@ATL@@3QB_WB
CONST	SEGMENT
?szDelete@ATL@@3QB_WB DD FLAT:??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe@ ; ATL::szDelete
CONST	ENDS
;	COMDAT ??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@
CONST	SEGMENT
??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ DB 'N', 00H, 'o'
	DB	00H, 'R', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?szNoRemove@ATL@@3QB_WB
CONST	SEGMENT
?szNoRemove@ATL@@3QB_WB DD FLAT:??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ ; ATL::szNoRemove
CONST	ENDS
;	COMDAT ??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@
CONST	SEGMENT
??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ DB 'F'
	DB	00H, 'o', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'R', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'v', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?szForceRemove@ATL@@3QB_WB
CONST	SEGMENT
?szForceRemove@ATL@@3QB_WB DD FLAT:??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@ ; ATL::szForceRemove
CONST	ENDS
;	COMDAT ??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl@
CONST	SEGMENT
??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl@ DB 'V', 00H, 'a', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?szValToken@ATL@@3QB_WB
CONST	SEGMENT
?szValToken@ATL@@3QB_WB DD FLAT:??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl@ ; ATL::szValToken
CONST	ENDS
;	COMDAT ??_C@_13OPKGLAFF@?$AAB@
CONST	SEGMENT
??_C@_13OPKGLAFF@?$AAB@ DB 'B', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?szBinaryVal@ATL@@3QB_WB
CONST	SEGMENT
?szBinaryVal@ATL@@3QB_WB DD FLAT:??_C@_13OPKGLAFF@?$AAB@ ; ATL::szBinaryVal
CONST	ENDS
;	COMDAT ??_C@_13MKMNOPIJ@?$AAD@
CONST	SEGMENT
??_C@_13MKMNOPIJ@?$AAD@ DB 'D', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?szDwordVal@ATL@@3QB_WB
CONST	SEGMENT
?szDwordVal@ATL@@3QB_WB DD FLAT:??_C@_13MKMNOPIJ@?$AAD@	; ATL::szDwordVal
CONST	ENDS
;	COMDAT ??_C@_13LHMFKAAD@?$AAM@
CONST	SEGMENT
??_C@_13LHMFKAAD@?$AAM@ DB 'M', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?multiszStringVal@ATL@@3QB_WB
CONST	SEGMENT
?multiszStringVal@ATL@@3QB_WB DD FLAT:??_C@_13LHMFKAAD@?$AAM@ ; ATL::multiszStringVal
CONST	ENDS
;	COMDAT ??_C@_13HADIAKP@?$AAS@
CONST	SEGMENT
??_C@_13HADIAKP@?$AAS@ DB 'S', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ?szStringVal@ATL@@3QB_WB
CONST	SEGMENT
?szStringVal@ATL@@3QB_WB DD FLAT:??_C@_13HADIAKP@?$AAS@	; ATL::szStringVal
CONST	ENDS
;	COMDAT ?chEquals@ATL@@3_WB
CONST	SEGMENT
?chEquals@ATL@@3_WB DW 03dH				; ATL::chEquals
CONST	ENDS
;	COMDAT ?chQuote@ATL@@3_WB
CONST	SEGMENT
?chQuote@ATL@@3_WB DW 027H				; ATL::chQuote
CONST	ENDS
;	COMDAT ?chLeftBracket@ATL@@3_WB
CONST	SEGMENT
?chLeftBracket@ATL@@3_WB DW 07bH			; ATL::chLeftBracket
CONST	ENDS
;	COMDAT ?chRightBracket@ATL@@3_WB
CONST	SEGMENT
?chRightBracket@ATL@@3_WB DW 07dH			; ATL::chRightBracket
CONST	ENDS
;	COMDAT ?chDirSep@ATL@@3_WB
CONST	SEGMENT
?chDirSep@ATL@@3_WB DW 05cH				; ATL::chDirSep
CONST	ENDS
;	COMDAT ??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD@
CONST	SEGMENT
??_C@_1M@EJNEECMJ@?$AAA?$AAp?$AAp?$AAI?$AAD@ DB 'A', 00H, 'p', 00H, 'p', 00H
	DB	'I', 00H, 'D', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD@
CONST	SEGMENT
??_C@_1M@KANJNLFF@?$AAC?$AAL?$AAS?$AAI?$AAD@ DB 'C', 00H, 'L', 00H, 'S', 00H
	DB	'I', 00H, 'D', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI@
CONST	SEGMENT
??_C@_1BM@FHAEDBFK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAI?$AAS?$AAA?$AAP?$AAI@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'I', 00H, 'S', 00H, 'A', 00H, 'P', 00H, 'I', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc@
CONST	SEGMENT
??_C@_1BK@OPAPOCAL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAy?$AAn?$AAc@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'y', 00H, 'n', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt@
CONST	SEGMENT
??_C@_1CC@DMMBNCFG@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAe?$AAc?$AAu?$AAr?$AAi?$AAt@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'e', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl@
CONST	SEGMENT
??_C@_1BK@DMHCKHHD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAU?$AAt?$AAi?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'U', 00H, 't', 00H, 'i', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp@
CONST	SEGMENT
??_C@_1BI@OKDLCIEM@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAM?$AAa?$AAp@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'M', 00H, 'a', 00H, 'p', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1BO@GMLILNDJ@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl@
CONST	SEGMENT
??_C@_1CA@PBPHANCD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAt?$AAe?$AAn?$AAc?$AAi?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'i'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@
CONST	SEGMENT
??_7?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@ DD FLAT:?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::`vftable'
	DD	FLAT:?AddRef@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
	DD	FLAT:?Next@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJKPAPAUIConnectionPoint@@PAK@Z
	DD	FLAT:?Skip@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJK@Z
	DD	FLAT:?Reset@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJXZ
	DD	FLAT:?Clone@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z
	DD	FLAT:??_E?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe@
CONST	SEGMENT
??_C@_1BM@GIKLHLFD@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAa?$AAc?$AAh?$AAe@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'a', 00H, 'c', 00H, 'h', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe@
CONST	SEGMENT
??_C@_1BK@NCJHOFCL@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAT?$AAi?$AAm?$AAe@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'T', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi@
CONST	SEGMENT
??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@ENICKDH@?$AAC?$AAo?$AAn?$AAt?$AAe?$AAn?$AAt?$AAs@
CONST	SEGMENT
??_C@_1BC@ENICKDH@?$AAC?$AAo?$AAn?$AAt?$AAe?$AAn?$AAt?$AAs@ DB 'C', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ?vszContents@?6??Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z@4PB_WB
_DATA	SEGMENT
?vszContents@?6??Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z@4PB_WB DD FLAT:??_C@_1BC@ENICKDH@?$AAC?$AAo?$AAn?$AAt?$AAe?$AAn?$AAt?$AAs@ ; `ATL::IPersistStorageImpl<COPOSDeviceMonitor>::Save'::`7'::vszContents
_DATA	ENDS
;	COMDAT ??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt@
CONST	SEGMENT
??_C@_1CG@KFEEMCDH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl@
CONST	SEGMENT
??_C@_1CA@DMHPIODO@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAN?$AAo?$AAt?$AAI?$AAm?$AAp?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'N', 00H, 'o', 00H, 't', 00H, 'I', 00H, 'm', 00H, 'p'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT __GUID_00000117_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000117_0000_0000_c000_000000000046 DD 0117H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn@
CONST	SEGMENT
??_C@_1BO@EFPHNHHN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAS?$AAn?$AAa?$AAp?$AAi?$AAn@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'S', 00H, 'n', 00H, 'a', 00H, 'p', 00H, 'i', 00H, 'n'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi@
CONST	SEGMENT
??_C@_1CG@MNMMIOOI@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAP?$AAr?$AAo?$AAv?$AAi@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'v'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_b196b286_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b286_bab4_101a_b69c_00aa00341d07 DD 0b196b286H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT ??_C@_1BE@IEBMACEM@?$AAD?$AAa?$AAt?$AAa?$AAE?$AAv?$AAe?$AAn?$AAt@
CONST	SEGMENT
??_C@_1BE@IEBMACEM@?$AAD?$AAa?$AAt?$AAa?$AAE?$AAv?$AAe?$AAn?$AAt@ DB 'D', 00H
	DB	'a', 00H, 't', 00H, 'a', 00H, 'E', 00H, 'v', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@CBGEBBBJ@?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAI?$AAO?$AAE?$AAv?$AAe?$AAn?$AAt@
CONST	SEGMENT
??_C@_1BM@CBGEBBBJ@?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAI?$AAO?$AAE?$AAv?$AAe?$AAn?$AAt@ DB 'D'
	DB	00H, 'i', 00H, 'r', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'I', 00H
	DB	'O', 00H, 'E', 00H, 'v', 00H, 'e', 00H, 'n', 00H, 't', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@LODEBHDD@?$AAE?$AAr?$AAr?$AAo?$AAr?$AAE?$AAv?$AAe?$AAn?$AAt@
CONST	SEGMENT
??_C@_1BG@LODEBHDD@?$AAE?$AAr?$AAr?$AAo?$AAr?$AAE?$AAv?$AAe?$AAn?$AAt@ DB 'E'
	DB	00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, 'E', 00H, 'v', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn@
CONST	SEGMENT
??_C@_1CC@JNJJDOOH@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAD?$AAB?$AAC?$AAl?$AAi?$AAe?$AAn@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'D', 00H, 'B', 00H, 'C', 00H, 'l', 00H, 'i', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@PGFMOFKI@?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAE?$AAv?$AAe@
CONST	SEGMENT
??_C@_1CE@PGFMOFKI@?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAE?$AAv?$AAe@ DB 'S'
	DB	00H, 't', 00H, 'a', 00H, 't', 00H, 'u', 00H, 's', 00H, 'U', 00H
	DB	'p', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'E', 00H, 'v'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT __GUID_00020400_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00020400_0000_0000_c000_000000000046 DD 020400H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_00000000_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000000_0000_0000_c000_000000000046 DD 00H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_b196b289_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b289_bab4_101a_b69c_00aa00341d07 DD 0b196b289H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT ??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg@
CONST	SEGMENT
??_C@_1CA@OMOMONMN@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAH?$AAo?$AAs?$AAt?$AAi?$AAn?$AAg@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'H', 00H, 'o', 00H, 's', 00H, 't', 00H, 'i', 00H, 'n'
	DB	00H, 'g', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@
CONST	SEGMENT
??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@ DD FLAT:?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObjectCached<ATL::CComClassFactory>::`vftable'
	DD	FLAT:?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
	DD	FLAT:?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
	DD	FLAT:?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z
	DD	FLAT:?LockServer@CComClassFactory@ATL@@UAGJH@Z
	DD	FLAT:??_E?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z
CONST	ENDS
;	COMDAT __GUID_00000119_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000119_0000_0000_c000_000000000046 DD 0119H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_9c2cad80_3424_11cf_b670_00aa004cd6d8
CONST	SEGMENT
__GUID_9c2cad80_3424_11cf_b670_00aa004cd6d8 DD 09c2cad80H
	DW	03424H
	DW	011cfH
	DB	0b6H
	DB	070H
	DB	00H
	DB	0aaH
	DB	00H
	DB	04cH
	DB	0d6H
	DB	0d8H
CONST	ENDS
;	COMDAT __GUID_922eada0_3424_11cf_b670_00aa004cd6d8
CONST	SEGMENT
__GUID_922eada0_3424_11cf_b670_00aa004cd6d8 DD 0922eada0H
	DW	03424H
	DW	011cfH
	DB	0b6H
	DB	070H
	DB	00H
	DB	0aaH
	DB	00H
	DB	04cH
	DB	0d6H
	DB	0d8H
CONST	ENDS
;	COMDAT ??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl@
CONST	SEGMENT
??_C@_1CC@IMNJGBED@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAo?$AAn?$AAt?$AAr?$AAo?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'r', 00H, 'o'
	DB	00H, 'l', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi@
CONST	SEGMENT
??_C@_1CE@NAJDPMNB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAW?$AAi?$AAn?$AAd?$AAo?$AAw?$AAi@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w'
	DB	00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_7CComModule@ATL@@6B@
CONST	SEGMENT
??_7CComModule@ATL@@6B@ DD FLAT:??_ECComModule@ATL@@UAEPAXI@Z ; ATL::CComModule::`vftable'
	DD	FLAT:?Lock@CAtlModule@ATL@@UAEJXZ
	DD	FLAT:?Unlock@CAtlModule@ATL@@UAEJXZ
	DD	FLAT:?GetLockCount@CAtlModule@ATL@@UAEJXZ
	DD	FLAT:?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z
	DD	FLAT:?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z
	DD	FLAT:?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
	DD	FLAT:?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z
	DD	FLAT:?UpdateRegistryFromResource@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
	DD	FLAT:?UpdateRegistryFromResource@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z
CONST	ENDS
;	COMDAT ??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn@
CONST	SEGMENT
??_C@_1CC@BNHGJFNK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAf?$AAc?$AAo?$AAu?$AAn@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'f', 00H, 'c', 00H, 'o', 00H, 'u'
	DB	00H, 'n', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr@
CONST	SEGMENT
??_C@_1CE@NIAEAIDK@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAR?$AAe?$AAg?$AAi?$AAs?$AAt?$AAr@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'a', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI@
CONST	SEGMENT
??_C@_1BG@FPLJJEMF@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAQ?$AAI@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'Q', 00H, 'I', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_17IOIMFDBO@?$AA_?$AAc?$AAy@
CONST	SEGMENT
??_C@_17IOIMFDBO@?$AA_?$AAc?$AAy@ DB '_', 00H, 'c', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17DGDADEHL@?$AA_?$AAc?$AAx@
CONST	SEGMENT
??_C@_17DGDADEHL@?$AA_?$AAc?$AAx@ DB '_', 00H, 'c', 00H, 'x', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B
CONST	SEGMENT
?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B DD FLAT:??_C@_17DGDADEHL@?$AA_?$AAc?$AAx@ ; `COPOSDeviceMonitor::GetPropertyMap'::`2'::pPropMap
	DD	FLAT:_GUID_NULL
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	028H
	DD	04H
	DW	013H
	ORG $+2
	DD	FLAT:??_C@_17IOIMFDBO@?$AA_?$AAc?$AAy@
	DD	FLAT:_GUID_NULL
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02cH
	DD	04H
	DW	013H
	ORG $+2
	DD	00H
	DD	00H
	DD	FLAT:_GUID_NULL
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DW	00H
	ORG $+2
CONST	ENDS
;	COMDAT __GUID_cb5bdc81_93c1_11cf_8f20_00805f2cd064
CONST	SEGMENT
__GUID_cb5bdc81_93c1_11cf_8f20_00805f2cd064 DD 0cb5bdc81H
	DW	093c1H
	DW	011cfH
	DB	08fH
	DB	020H
	DB	00H
	DB	080H
	DB	05fH
	DB	02cH
	DB	0d0H
	DB	064H
CONST	ENDS
;	COMDAT __GUID_b196b283_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b283_bab4_101a_b69c_00aa00341d07 DD 0b196b283H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT ??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM@
CONST	SEGMENT
??_C@_1BI@MAFGHOEE@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAC?$AAO?$AAM@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'C', 00H, 'O', 00H, 'M', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_0000010a_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0000010a_0000_0000_c000_000000000046 DD 010aH
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_cf51ed10_62fe_11cf_bf86_00a0c9034836
CONST	SEGMENT
__GUID_cf51ed10_62fe_11cf_bf86_00a0c9034836 DD 0cf51ed10H
	DW	062feH
	DW	011cfH
	DB	0bfH
	DB	086H
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	048H
	DB	036H
CONST	ENDS
;	COMDAT ??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl@
CONST	SEGMENT
??_C@_1CA@ONGMEOAB@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAG?$AAe?$AAn?$AAe?$AAr?$AAa?$AAl@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'G', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 'l', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@COPOSDeviceMonitor@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B
CONST	SEGMENT
?_entries@?1??_GetEntries@COPOSDeviceMonitor@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B DD FLAT:_IID_IDispatch ; `COPOSDeviceMonitor::_GetEntries'::`2'::_entries
	DD	00H
	DD	01H
	DD	FLAT:_IID_IOPOSDeviceMonitor
	DD	00H
	DD	01H
	DD	FLAT:_IID_IOPOSDeviceMonitor_1_16
	DD	00H
	DD	01H
	DD	FLAT:__GUID_3af24292_0c96_11ce_a0cf_00aa00600ab8
	DD	080H
	DD	01H
	DD	FLAT:__GUID_00000127_0000_0000_c000_000000000046
	DD	080H
	DD	01H
	DD	FLAT:__GUID_0000010d_0000_0000_c000_000000000046
	DD	080H
	DD	01H
	DD	FLAT:__GUID_1c2056cc_5ef4_101b_8bc8_00aa003e3b29
	DD	084H
	DD	01H
	DD	FLAT:__GUID_00000113_0000_0000_c000_000000000046
	DD	084H
	DD	01H
	DD	FLAT:__GUID_00000114_0000_0000_c000_000000000046
	DD	084H
	DD	01H
	DD	FLAT:__GUID_00000117_0000_0000_c000_000000000046
	DD	07cH
	DD	01H
	DD	FLAT:__GUID_b196b288_bab4_101a_b69c_00aa00341d07
	DD	074H
	DD	01H
	DD	FLAT:__GUID_00000112_0000_0000_c000_000000000046
	DD	078H
	DD	01H
	DD	FLAT:__GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
	DD	070H
	DD	01H
	DD	FLAT:__GUID_0000010c_0000_0000_c000_000000000046
	DD	070H
	DD	01H
	DD	FLAT:__GUID_b196b284_bab4_101a_b69c_00aa00341d07
	DD	088H
	DD	01H
	DD	FLAT:__GUID_b196b28b_bab4_101a_b69c_00aa00341d07
	DD	090H
	DD	01H
	DD	FLAT:__GUID_cf51ed10_62fe_11cf_bf86_00a0c9034836
	DD	094H
	DD	01H
	DD	FLAT:__GUID_0000010a_0000_0000_c000_000000000046
	DD	08cH
	DD	01H
	DD	FLAT:__GUID_0000010e_0000_0000_c000_000000000046
	DD	098H
	DD	01H
	DD	FLAT:__GUID_b196b283_bab4_101a_b69c_00aa00341d07
	DD	09cH
	DD	01H
	DD	FLAT:__GUID_a6bc3ac0_dbaa_11ce_9de3_00aa004bb851
	DD	09cH
	DD	01H
	DD	FLAT:__GUID_cb5bdc81_93c1_11cf_8f20_00805f2cd064
	DD	0a0H
	DD	01H
	DD	FLAT:__GUID_b196b284_bab4_101a_b69c_00aa00341d07
	DD	088H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT __GUID_00000146_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000146_0000_0000_c000_000000000046 DD 0146H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_0000010c_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0000010c_0000_0000_c000_000000000046 DD 010cH
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT __GUID_a6bc3ac0_dbaa_11ce_9de3_00aa004bb851
CONST	SEGMENT
__GUID_a6bc3ac0_dbaa_11ce_9de3_00aa004bb851 DD 0a6bc3ac0H
	DW	0dbaaH
	DW	011ceH
	DB	09dH
	DB	0e3H
	DB	00H
	DB	0aaH
	DB	00H
	DB	04bH
	DB	0b8H
	DB	051H
CONST	ENDS
;	COMDAT ?_tih@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A
_DATA	SEGMENT
?_tih@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A DD FLAT:_CLSID_OPOSDeviceMonitor ; ATL::IProvideClassInfo2Impl<&CLSID_OPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::_tih
	DD	FLAT:_LIBID_OposDeviceMonitor_CCO
	DW	01H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT __GUID_b196b285_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b285_bab4_101a_b69c_00aa00341d07 DD 0b196b285H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT ___pobjMapEntryLast
ATL$__z	SEGMENT
___pobjMapEntryLast DD 00H
ATL$__z	ENDS
;	COMDAT ___pobjMapEntryFirst
ATL$__a	SEGMENT
___pobjMapEntryFirst DD 00H
ATL$__a	ENDS
;	COMDAT __GUID_b196b287_bab4_101a_b69c_00aa00341d07
CONST	SEGMENT
__GUID_b196b287_bab4_101a_b69c_00aa00341d07 DD 0b196b287H
	DW	0bab4H
	DW	0101aH
	DB	0b6H
	DB	09cH
	DB	00H
	DB	0aaH
	DB	00H
	DB	034H
	DB	01dH
	DB	07H
CONST	ENDS
;	COMDAT _LIBID_ATLLib
CONST	SEGMENT
_LIBID_ATLLib DD 044ec0535H
	DW	0400fH
	DW	011d0H
	DB	09dH
	DB	0cdH
	DB	00H
	DB	0a0H
	DB	0c9H
	DB	03H
	DB	091H
	DB	0d3H
CONST	ENDS
;	COMDAT ?_tih@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A
_DATA	SEGMENT
?_tih@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A DD FLAT:_IID_IOPOSDeviceMonitor ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::_tih
	DD	FLAT:_LIBID_OposDeviceMonitor_CCO
	DW	01H
	DW	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_0BI@MNCFCPFK@RegCreateKeyTransactedW@
CONST	SEGMENT
??_C@_0BI@MNCFCPFK@RegCreateKeyTransactedW@ DB 'RegCreateKeyTransactedW', 00H ; `string'
CONST	ENDS
;	COMDAT __GUID_00000114_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000114_0000_0000_c000_000000000046 DD 0114H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ??_C@_1BK@BIGILECK@?$AAA?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@
CONST	SEGMENT
??_C@_1BK@BIGILECK@?$AAA?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@ DB 'A'
	DB	00H, 'd', 00H, 'v', 00H, 'a', 00H, 'p', 00H, 'i', 00H, '3', 00H
	DB	'2', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT _CLSID_OPOSDeviceMonitor
CONST	SEGMENT
_CLSID_OPOSDeviceMonitor DD 0ccb90382H
	DW	0b81eH
	DW	011d2H
	DB	0abH
	DB	074H
	DB	00H
	DB	040H
	DB	05H
	DB	04cH
	DB	037H
	DB	019H
CONST	ENDS
;	COMDAT _DIID__IOPOSDeviceMonitorEvents
CONST	SEGMENT
_DIID__IOPOSDeviceMonitorEvents DD 0ccb90383H
	DW	0b81eH
	DW	011d2H
	DB	0abH
	DB	074H
	DB	00H
	DB	040H
	DB	05H
	DB	04cH
	DB	037H
	DB	019H
CONST	ENDS
;	COMDAT _LIBID_OposDeviceMonitor_CCO
CONST	SEGMENT
_LIBID_OposDeviceMonitor_CCO DD 0ccb90380H
	DW	0b81eH
	DW	011d2H
	DB	0abH
	DB	074H
	DB	00H
	DB	040H
	DB	05H
	DB	04cH
	DB	037H
	DB	019H
CONST	ENDS
;	COMDAT _IID_IOPOSDeviceMonitor
CONST	SEGMENT
_IID_IOPOSDeviceMonitor DD 0ccb91381H
	DW	0b81eH
	DW	011d2H
	DB	0abH
	DB	074H
	DB	00H
	DB	040H
	DB	05H
	DB	04cH
	DB	037H
	DB	019H
CONST	ENDS
;	COMDAT _IID_IOPOSDeviceMonitor_1_16
CONST	SEGMENT
_IID_IOPOSDeviceMonitor_1_16 DD 0ccb90381H
	DW	0b81eH
	DW	011d2H
	DB	0abH
	DB	074H
	DB	00H
	DB	040H
	DB	05H
	DB	04cH
	DB	037H
	DB	019H
CONST	ENDS
;	COMDAT ?s_Release@?7??GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z@4PA_WA
_DATA	SEGMENT
?s_Release@?7??GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z@4PA_WA DB 'R'
	DB	00H, 'e', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H
	DB	00H						; `ATL::CComTypeInfoHolder::GetIDsOfNames'::`8'::s_Release
_DATA	ENDS
;	COMDAT ?s_Claim@?7??GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z@4PA_WA
_DATA	SEGMENT
?s_Claim@?7??GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z@4PA_WA DB 'C'
	DB	00H, 'l', 00H, 'a', 00H, 'i', 00H, 'm', 00H, 'D', 00H, 'e', 00H
	DB	'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H ; `ATL::CComTypeInfoHolder::GetIDsOfNames'::`8'::s_Claim
_DATA	ENDS
;	COMDAT __GUID_00000001_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_00000001_0000_0000_c000_000000000046 DD 01H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B
CONST	SEGMENT
?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B DD FLAT:__GUID_00000001_0000_0000_c000_000000000046 ; `ATL::CComClassFactory::_GetEntries'::`2'::_entries
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
CONST	ENDS
;	COMDAT ??_7CComClassFactory@ATL@@6B@
CONST	SEGMENT
??_7CComClassFactory@ATL@@6B@ DD FLAT:__purecall	; ATL::CComClassFactory::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z
	DD	FLAT:?LockServer@CComClassFactory@ATL@@UAGJH@Z
	DD	FLAT:??_ECComClassFactory@ATL@@UAEPAXI@Z
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??_I@YGXPAXIIP6EX0@Z@Z				; `vector destructor iterator'
PUBLIC	_InlineIsEqualGUID
PUBLIC	_DllGetClassObject@12
PUBLIC	_DllCanUnloadNow@0
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	___local_stdio_printf_options
PUBLIC	__vswprintf_s_l
PUBLIC	_swprintf_s
PUBLIC	??$AtlMultiply@H@ATL@@YAJPAHHH@Z		; ATL::AtlMultiply<int>
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
PUBLIC	??$AtlMultiply@K@ATL@@YAJPAKKK@Z		; ATL::AtlMultiply<unsigned long>
PUBLIC	?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z		; ATL::AtlCoTaskMemCAlloc
PUBLIC	?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z		; ATL::AtlCoTaskMemRecalloc
PUBLIC	?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z		; ATL::Checked::memcpy_s
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
PUBLIC	??$AtlAdd@K@ATL@@YAJPAKKK@Z			; ATL::AtlAdd<unsigned long>
PUBLIC	?ocscpy_s@@YA_NPA_WIPB_W@Z			; ocscpy_s
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?AtlCrtErrorCheck@ATL@@YAHH@Z			; ATL::AtlCrtErrorCheck
PUBLIC	?wcscpy_s@Checked@ATL@@YAXPA_WIPB_W@Z		; ATL::Checked::wcscpy_s
PUBLIC	?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ; ATL::_AtlInitializeCriticalSectionEx
PUBLIC	?Init@CComCriticalSection@ATL@@QAEJXZ		; ATL::CComCriticalSection::Init
PUBLIC	_DllRegisterServer@0
PUBLIC	_DllUnregisterServer@0
PUBLIC	?AtlHresultFromLastError@ATL@@YAJXZ		; ATL::AtlHresultFromLastError
PUBLIC	?AtlHresultFromWin32@ATL@@YAJK@Z		; ATL::AtlHresultFromWin32
PUBLIC	?AtlComQIPtrAssign2@ATL@@YAXPAPAUIUnknown@@PAU2@ABU_GUID@@@Z ; ATL::AtlComQIPtrAssign2
PUBLIC	?AtlInternalOleLoadFromStream@ATL@@YAJPAUIStream@@ABU_GUID@@PAPAXTClassesAllowedInStream@1@K@Z ; ATL::AtlInternalOleLoadFromStream
PUBLIC	?GetProperty@?$CComPtr@UIDispatch@@@ATL@@SAJPAUIDispatch@@JPAUtagVARIANT@@@Z ; ATL::CComPtr<IDispatch>::GetProperty
PUBLIC	??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z ; ATL::CComPtr<IUnknown>::operator=
PUBLIC	?WriteToStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z	; ATL::CComBSTR::WriteToStream
PUBLIC	?ReadFromStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z ; ATL::CComBSTR::ReadFromStream
PUBLIC	??1CComVariant@ATL@@QAE@XZ			; ATL::CComVariant::~CComVariant
PUBLIC	?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@@Z ; ATL::CComVariant::WriteToStream
PUBLIC	?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@G@Z ; ATL::CComVariant::WriteToStream
PUBLIC	?ReadFromStream@CComVariant@ATL@@QAEJPAUIStream@@GTClassesAllowedInStream@2@K@Z ; ATL::CComVariant::ReadFromStream
PUBLIC	?GetSizeMax@CComVariant@ATL@@QBEJPAT_ULARGE_INTEGER@@@Z ; ATL::CComVariant::GetSizeMax
PUBLIC	??$AtlAdd@_K@ATL@@YAJPA_K_K1@Z			; ATL::AtlAdd<unsigned __int64>
PUBLIC	?RegCreateKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKPA_WKKQAU_SECURITY_ATTRIBUTES@@PAPAU3@PAK@Z ; ATL::CAtlTransactionManager::RegCreateKeyExW
PUBLIC	?RegOpenKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKKPAPAU3@@Z ; ATL::CAtlTransactionManager::RegOpenKeyExW
PUBLIC	?RegDeleteKeyW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_W@Z ; ATL::CAtlTransactionManager::RegDeleteKeyW
PUBLIC	?Add@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEHABG@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::Add
PUBLIC	?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
PUBLIC	??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
PUBLIC	?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface
PUBLIC	?AtlComModuleGetClassObject@ATL@@YGJPAU_ATL_COM_MODULE70@1@ABU_GUID@@1PAPAX@Z ; ATL::AtlComModuleGetClassObject
PUBLIC	?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
PUBLIC	?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_WPAPA_WPAPAUITypeLib@@@Z ; ATL::AtlLoadTypeLib
PUBLIC	?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z ; ATL::AtlRegisterTypeLib
PUBLIC	?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z ; ATL::AtlUnRegisterTypeLib
PUBLIC	?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ; ATL::AtlComModuleRegisterServer
PUBLIC	?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ; ATL::AtlComModuleUnregisterServer
PUBLIC	?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit
PUBLIC	?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
PUBLIC	?AtlWinModuleAddCreateWndData@ATL@@YGXPAU_ATL_WIN_MODULE70@1@PAU_AtlCreateWndData@1@PAX@Z ; ATL::AtlWinModuleAddCreateWndData
PUBLIC	?AtlWinModuleExtractCreateWndData@ATL@@YGPAXPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleExtractCreateWndData
PUBLIC	?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z	; ATL::InlineIsEqualUnknown
PUBLIC	?SetStringValue@CRegKey@ATL@@QAEJPB_W0K@Z	; ATL::CRegKey::SetStringValue
PUBLIC	?SetMultiStringValue@CRegKey@ATL@@QAEJPB_W0@Z	; ATL::CRegKey::SetMultiStringValue
PUBLIC	?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z	; ATL::CRegKey::Open
PUBLIC	?Close@CRegKey@ATL@@QAEJXZ			; ATL::CRegKey::Close
PUBLIC	?DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z		; ATL::CRegKey::DeleteSubKey
PUBLIC	?RecurseDeleteKey@CRegKey@ATL@@QAEJPB_W@Z	; ATL::CRegKey::RecurseDeleteKey
PUBLIC	??0CAtlComModule@ATL@@QAE@XZ			; ATL::CAtlComModule::CAtlComModule
PUBLIC	?Term@CAtlComModule@ATL@@QAEXXZ			; ATL::CAtlComModule::Term
PUBLIC	??0CAtlWinModule@ATL@@QAE@XZ			; ATL::CAtlWinModule::CAtlWinModule
PUBLIC	??0CAtlModule@ATL@@QAE@XZ			; ATL::CAtlModule::CAtlModule
PUBLIC	?Term@CAtlModule@ATL@@QAEXXZ			; ATL::CAtlModule::Term
PUBLIC	??1CAtlModule@ATL@@UAE@XZ			; ATL::CAtlModule::~CAtlModule
PUBLIC	?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z	; ATL::CAtlModule::AddTermFunc
PUBLIC	?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CAtlModule::UpdateRegistryFromResource
PUBLIC	?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CAtlModule::UpdateRegistryFromResource
PUBLIC	?EscapeSingleQuote@CAtlModule@ATL@@SAXPA_WIPB_W@Z ; ATL::CAtlModule::EscapeSingleQuote
PUBLIC	?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::RegisterServer
PUBLIC	?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::UnregisterServer
PUBLIC	?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z ; ATL::CComModule::Init
PUBLIC	?Term@CComModule@ATL@@QAEXXZ			; ATL::CComModule::Term
PUBLIC	?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z ; ATL::CComModule::GetClassObject
PUBLIC	?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CComModule::RegisterServer
PUBLIC	?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CComModule::UnregisterServer
PUBLIC	?Add@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQA_W0@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add
PUBLIC	?RemoveAll@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll
PUBLIC	?Lookup@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQA_W@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup
PUBLIC	?GetKeyAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetKeyAt
PUBLIC	?GetValueAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt
PUBLIC	?FindKey@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQA_W@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey
PUBLIC	?InternalSetAtIndex@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQA_W0@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex
PUBLIC	?Add@CExpansionVector@ATL@@QAEHPB_W0@Z		; ATL::CExpansionVector::Add
PUBLIC	?ClearReplacements@CExpansionVector@ATL@@QAEJXZ	; ATL::CExpansionVector::ClearReplacements
PUBLIC	?PreProcessBuffer@CRegParser@ATL@@QAEJPA_WPAPA_W@Z ; ATL::CRegParser::PreProcessBuffer
PUBLIC	?RegisterBuffer@CRegParser@ATL@@QAEJPA_WH@Z	; ATL::CRegParser::RegisterBuffer
PUBLIC	?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ		; ATL::CRegParser::SkipWhiteSpace
PUBLIC	?NextToken@CRegParser@ATL@@IAEJPA_W@Z		; ATL::CRegParser::NextToken
PUBLIC	?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PB_WPA_W@Z ; ATL::CRegParser::AddValue
PUBLIC	?CanForceRemoveKey@CRegParser@ATL@@IAEHPB_W@Z	; ATL::CRegParser::CanForceRemoveKey
PUBLIC	?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z	; ATL::CRegParser::HasSubKeys
PUBLIC	?RegisterSubkeys@CRegParser@ATL@@IAEJPA_WPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
PUBLIC	?IsSpace@CRegParser@ATL@@IAEH_W@Z		; ATL::CRegParser::IsSpace
PUBLIC	?SkipAssignment@CRegParser@ATL@@IAEJPA_W@Z	; ATL::CRegParser::SkipAssignment
PUBLIC	?EndOfVar@CRegParser@ATL@@IAEHXZ		; ATL::CRegParser::EndOfVar
PUBLIC	?StrChrW@CRegParser@ATL@@KAPA_WPA_W_W@Z		; ATL::CRegParser::StrChrW
PUBLIC	?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z ; ATL::CRegParser::HKeyFromString
PUBLIC	?ChToByte@CRegParser@ATL@@KAE_W@Z		; ATL::CRegParser::ChToByte
PUBLIC	?VTFromRegType@CRegParser@ATL@@KAHPB_WAAG@Z	; ATL::CRegParser::VTFromRegType
PUBLIC	??0CParseBuffer@CRegParser@ATL@@QAE@H@Z		; ATL::CRegParser::CParseBuffer::CParseBuffer
PUBLIC	?Append@CParseBuffer@CRegParser@ATL@@QAEHPB_WH@Z ; ATL::CRegParser::CParseBuffer::Append
PUBLIC	?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
PUBLIC	??1CRegObject@ATL@@UAE@XZ			; ATL::CRegObject::~CRegObject
PUBLIC	?ResourceRegisterSz@CRegObject@ATL@@QAGJPB_W00@Z ; ATL::CRegObject::ResourceRegisterSz
PUBLIC	?ResourceUnregisterSz@CRegObject@ATL@@QAGJPB_W00@Z ; ATL::CRegObject::ResourceUnregisterSz
PUBLIC	?RegisterFromResource@CRegObject@ATL@@IAEJPB_W00H@Z ; ATL::CRegObject::RegisterFromResource
PUBLIC	?Allocate@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::Allocate
PUBLIC	?AllocateHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::AllocateHeap
PUBLIC	?FreeHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::FreeHeap
PUBLIC	?Allocate@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::Allocate
PUBLIC	?AllocateHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::AllocateHeap
PUBLIC	?FreeHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::FreeHeap
PUBLIC	?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
PUBLIC	?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
PUBLIC	?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
PUBLIC	?Init@CDynamicStdCallThunk2@ATL@@QAEHKPAX@Z	; ATL::CDynamicStdCallThunk2::Init
PUBLIC	?IsEqualObject@?$CComPtrBase@UITypeInfo@@@ATL@@QAE_NPAUIUnknown@@@Z ; ATL::CComPtrBase<ITypeInfo>::IsEqualObject
PUBLIC	??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>
PUBLIC	?_AtlInitialConstruct@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEJXZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::_AtlInitialConstruct
PUBLIC	??1CComClassFactory@ATL@@UAE@XZ			; ATL::CComClassFactory::~CComClassFactory
PUBLIC	??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ	; ATL::CComTypeInfoHolder::stringdispid::stringdispid
PUBLIC	??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
PUBLIC	??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
PUBLIC	?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::GetTI
PUBLIC	?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z		; ATL::CComTypeInfoHolder::GetTI
PUBLIC	?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z		; ATL::CComTypeInfoHolder::Cleanup
PUBLIC	?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z ; ATL::CComTypeInfoHolder::GetIDsOfNames
PUBLIC	?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ; ATL::CComTypeInfoHolder::Invoke
PUBLIC	?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::LoadNameCache
PUBLIC	??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z ; ATL::CComPtr<ITypeInfo>::operator=<ITypeInfo2>
PUBLIC	?copy@?$_Copy@UtagCONNECTDATA@@@ATL@@SAJPAUtagCONNECTDATA@@PBU3@@Z ; ATL::_Copy<tagCONNECTDATA>::copy
PUBLIC	?Add@CComDynamicUnkArray@ATL@@QAEKPAUIUnknown@@@Z ; ATL::CComDynamicUnkArray::Add
PUBLIC	?Remove@CComDynamicUnkArray@ATL@@QAEHK@Z	; ATL::CComDynamicUnkArray::Remove
PUBLIC	?GetCookie@CComDynamicUnkArray@ATL@@QAGKPAPAUIUnknown@@@Z ; ATL::CComDynamicUnkArray::GetCookie
PUBLIC	?GetUnknown@CComDynamicUnkArray@ATL@@QAGPAUIUnknown@@K@Z ; ATL::CComDynamicUnkArray::GetUnknown
PUBLIC	?GetAt@CComDynamicUnkArray@ATL@@QAEPAUIUnknown@@H@Z ; ATL::CComDynamicUnkArray::GetAt
PUBLIC	?AtlWinModuleRegisterClassExW@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PBUtagWNDCLASSEXW@@@Z ; ATL::AtlWinModuleRegisterClassExW
PUBLIC	?AtlCreateTargetDC@ATL@@YGPAUHDC__@@PAU2@PAUtagDVTARGETDEVICE@@@Z ; ATL::AtlCreateTargetDC
PUBLIC	?AtlHiMetricToPixel@ATL@@YGXPBUtagSIZE@@PAU2@@Z	; ATL::AtlHiMetricToPixel
PUBLIC	??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z		; ATL::_ATL_MSG::_ATL_MSG
PUBLIC	?Register@_ATL_WNDCLASSINFOW@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z ; ATL::_ATL_WNDCLASSINFOW::Register
PUBLIC	?DefaultReflectionHandler@?$CWindowImplRoot@VCWindow@ATL@@@ATL@@SAHPAUHWND__@@IIJAAJ@Z ; ATL::CWindowImplRoot<ATL::CWindow>::DefaultReflectionHandler
PUBLIC	?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::WindowProc
PUBLIC	?atlCreate@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@GPAX@Z ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::atlCreate
PUBLIC	?IsEqualObject@?$CComPtrBase@UIOleClientSite@@@ATL@@QAE_NPAUIUnknown@@@Z ; ATL::CComPtrBase<IOleClientSite>::IsEqualObject
PUBLIC	??4?$CComPtr@UIOleClientSite@@@ATL@@QAEPAUIOleClientSite@@PAU2@@Z ; ATL::CComPtr<IOleClientSite>::operator=
PUBLIC	??4?$CComPtr@UIAdviseSink@@@ATL@@QAEPAUIAdviseSink@@PAU2@@Z ; ATL::CComPtr<IAdviseSink>::operator=
PUBLIC	??$AtlModuleRegisterWndClassInfoT@VAtlModuleRegisterWndClassInfoParamW@ATL@@@ATL@@YAGPAU_ATL_BASE_MODULE70@0@PAU_ATL_WIN_MODULE70@0@PAU_ATL_WNDCLASSINFOW@0@PAP6GJPAUHWND__@@IIJ@ZVAtlModuleRegisterWndClassInfoParamW@0@@Z ; ATL::AtlModuleRegisterWndClassInfoT<ATL::AtlModuleRegisterWndClassInfoParamW>
PUBLIC	?GetZoomInfo@CComControlBase@ATL@@QAEXAAUATL_DRAWINFO@@@Z ; ATL::CComControlBase::GetZoomInfo
PUBLIC	?SendOnDataChange@CComControlBase@ATL@@QAEJK@Z	; ATL::CComControlBase::SendOnDataChange
PUBLIC	?OnSetFocus@CComControlBase@ATL@@QAEJIIJAAH@Z	; ATL::CComControlBase::OnSetFocus
PUBLIC	?OnKillFocus@CComControlBase@ATL@@QAEJIIJAAH@Z	; ATL::CComControlBase::OnKillFocus
PUBLIC	?OnMouseActivate@CComControlBase@ATL@@QAEJIIJAAH@Z ; ATL::CComControlBase::OnMouseActivate
PUBLIC	?GetAmbientLocaleID@CComControlBase@ATL@@QAEJAAK@Z ; ATL::CComControlBase::GetAmbientLocaleID
PUBLIC	?GetAmbientUserMode@CComControlBase@ATL@@QAEJAAH@Z ; ATL::CComControlBase::GetAmbientUserMode
PUBLIC	?DoesVerbUIActivate@CComControlBase@ATL@@QAEHJ@Z ; ATL::CComControlBase::DoesVerbUIActivate
PUBLIC	?DoesVerbActivate@CComControlBase@ATL@@QAEHJ@Z	; ATL::CComControlBase::DoesVerbActivate
PUBLIC	?SetControlFocus@CComControlBase@ATL@@QAEHH@Z	; ATL::CComControlBase::SetControlFocus
PUBLIC	?IQuickActivate_QuickActivate@CComControlBase@ATL@@QAEJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z ; ATL::CComControlBase::IQuickActivate_QuickActivate
PUBLIC	?DoVerbProperties@CComControlBase@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::CComControlBase::DoVerbProperties
PUBLIC	?InPlaceActivate@CComControlBase@ATL@@QAEJJPBUtagRECT@@@Z ; ATL::CComControlBase::InPlaceActivate
PUBLIC	?IOleObject_SetClientSite@CComControlBase@ATL@@QAEJPAUIOleClientSite@@@Z ; ATL::CComControlBase::IOleObject_SetClientSite
PUBLIC	?IOleObject_GetClientSite@CComControlBase@ATL@@QAEJPAPAUIOleClientSite@@@Z ; ATL::CComControlBase::IOleObject_GetClientSite
PUBLIC	?IOleObject_Advise@CComControlBase@ATL@@QAEJPAUIAdviseSink@@PAK@Z ; ATL::CComControlBase::IOleObject_Advise
PUBLIC	?IOleObject_Close@CComControlBase@ATL@@QAEJK@Z	; ATL::CComControlBase::IOleObject_Close
PUBLIC	?IOleObject_SetExtent@CComControlBase@ATL@@QAEJKPAUtagSIZE@@@Z ; ATL::CComControlBase::IOleObject_SetExtent
PUBLIC	?IOleInPlaceObject_InPlaceDeactivate@CComControlBase@ATL@@QAEJXZ ; ATL::CComControlBase::IOleInPlaceObject_InPlaceDeactivate
PUBLIC	?IOleInPlaceObject_UIDeactivate@CComControlBase@ATL@@QAEJXZ ; ATL::CComControlBase::IOleInPlaceObject_UIDeactivate
PUBLIC	?IOleInPlaceObject_SetObjectRects@CComControlBase@ATL@@QAEJPBUtagRECT@@0@Z ; ATL::CComControlBase::IOleInPlaceObject_SetObjectRects
PUBLIC	?IViewObject_Draw@CComControlBase@ATL@@QAEJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3@Z ; ATL::CComControlBase::IViewObject_Draw
PUBLIC	?IDataObject_GetData@CComControlBase@ATL@@QAEJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z ; ATL::CComControlBase::IDataObject_GetData
PUBLIC	?FireViewChange@CComControlBase@ATL@@QAEJXZ	; ATL::CComControlBase::FireViewChange
PUBLIC	?OnPaint@CComControlBase@ATL@@QAEJIIJAAH@Z	; ATL::CComControlBase::OnPaint
PUBLIC	??0?$CComQIPtr@UIOleControlSite@@$1?_GUID_b196b289_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>
PUBLIC	??0OposVariant@@QAE@XZ				; OposVariant::OposVariant
PUBLIC	??1OposVariant@@QAE@XZ				; OposVariant::~OposVariant
PUBLIC	?atlCreate@?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@PAX@Z ; ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> >::atlCreate
PUBLIC	?ProcessWindowMessage@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEHPAUHWND__@@IIJAAJK@Z ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::ProcessWindowMessage
PUBLIC	?IPersistStreamInit_Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@PBUATL_PROPMAP_ENTRY@2@@Z ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IPersistStreamInit_Load
PUBLIC	?IPersistStreamInit_Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@HPBUATL_PROPMAP_ENTRY@2@@Z ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IPersistStreamInit_Save
PUBLIC	?DoVerbPrimary@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbPrimary
PUBLIC	?DoVerbInPlaceActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbInPlaceActivate
PUBLIC	?DoVerbUIActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbUIActivate
PUBLIC	?DoVerbHide@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbHide
PUBLIC	?IPSI_GetIPersistStreamInit@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@AAEPAUIPersistStreamInit@@XZ ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IPSI_GetIPersistStreamInit
PUBLIC	?GetPagesHelper@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@IAEJPAUtagCAUUID@@PBUATL_PROPMAP_ENTRY@2@@Z ; ATL::ISpecifyPropertyPagesImpl<COPOSDeviceMonitor>::GetPagesHelper
PUBLIC	?Fire_DataEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_DataEvent
PUBLIC	?Fire_DirectIOEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJPAJPAPA_W@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_DirectIOEvent
PUBLIC	?Fire_ErrorEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJJJPAJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_ErrorEvent
PUBLIC	?Fire_StatusUpdateEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_StatusUpdateEvent
PUBLIC	?FireTheEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@IAEXPAVOposVariant@@IAAJPB_WJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::FireTheEvent
PUBLIC	?GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z ; COPOSDeviceMonitor::GetConnMap
PUBLIC	?DoEvent@COPOSDeviceMonitor@@IAEXIIJ@Z		; COPOSDeviceMonitor::DoEvent
PUBLIC	_DllMain@12
PUBLIC	?CreateInstance@?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComObject<COPOSDeviceMonitor> >::CreateInstance
PUBLIC	?CreateInstance@?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComAggObject<COPOSDeviceMonitor> >::CreateInstance
PUBLIC	??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ ; ATL::CComObjectCached<ATL::CComClassFactory>::~CComObjectCached<ATL::CComClassFactory>
PUBLIC	??1?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAE@XZ ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::~CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >
PUBLIC	?Init@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@QAEJPAPAUIConnectionPoint@@0PAUIUnknown@@W4CComEnumFlags@2@@Z ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Init
PUBLIC	??0?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >
PUBLIC	??1?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::~CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >
PUBLIC	?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::CreateInstance
PUBLIC	??$AtlMultiplyThrow@I@ATL@@YAIII@Z		; ATL::AtlMultiplyThrow<unsigned int>
PUBLIC	??$AtlAddThrow@K@ATL@@YAKKK@Z			; ATL::AtlAddThrow<unsigned long>
PUBLIC	??0?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z ; ATL::CComAggObject<COPOSDeviceMonitor>::CComAggObject<COPOSDeviceMonitor>
PUBLIC	??1?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ ; ATL::CComAggObject<COPOSDeviceMonitor>::~CComAggObject<COPOSDeviceMonitor>
PUBLIC	??0?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::CComContainedObject<COPOSDeviceMonitor>
PUBLIC	??_G?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::`scalar deleting destructor'
PUBLIC	??0?$CComObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::CComObject<COPOSDeviceMonitor>
PUBLIC	??1?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ ; ATL::CComObject<COPOSDeviceMonitor>::~CComObject<COPOSDeviceMonitor>
PUBLIC	??_G?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z ; ATL::CComObject<COPOSDeviceMonitor>::`scalar deleting destructor'
PUBLIC	??1?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAE@XZ ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::~CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >
PUBLIC	?Init@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@QAEJPAUtagCONNECTDATA@@0PAUIUnknown@@W4CComEnumFlags@2@@Z ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Init
PUBLIC	??0?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >
PUBLIC	??1?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::~CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >
PUBLIC	?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CreateInstance
PUBLIC	?copy@?$_CopyInterface@UIConnectionPoint@@@ATL@@SAJPAPAUIConnectionPoint@@PBQAU3@@Z ; ATL::_CopyInterface<IConnectionPoint>::copy
PUBLIC	?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A ; ATL::atlTraceGeneral
PUBLIC	?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A ; ATL::atlTraceCOM
PUBLIC	?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A ; ATL::atlTraceQI
PUBLIC	?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A ; ATL::atlTraceRegistrar
PUBLIC	?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A ; ATL::atlTraceRefcount
PUBLIC	?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A ; ATL::atlTraceWindowing
PUBLIC	?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A ; ATL::atlTraceControls
PUBLIC	?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A ; ATL::atlTraceHosting
PUBLIC	?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A ; ATL::atlTraceDBClient
PUBLIC	?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A ; ATL::atlTraceDBProvider
PUBLIC	?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A ; ATL::atlTraceSnapin
PUBLIC	?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A ; ATL::atlTraceNotImpl
PUBLIC	?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A ; ATL::atlTraceAllocation
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A ; ATL::atlTraceTime
PUBLIC	?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A ; ATL::atlTraceCache
PUBLIC	?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A ; ATL::atlTraceStencil
PUBLIC	?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A ; ATL::atlTraceString
PUBLIC	?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A ; ATL::atlTraceMap
PUBLIC	?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A ; ATL::atlTraceUtil
PUBLIC	?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A ; ATL::atlTraceSecurity
PUBLIC	?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A ; ATL::atlTraceSync
PUBLIC	?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A ; ATL::atlTraceISAPI
PUBLIC	??_C@_0BG@EKFFMJIO@RegOpenKeyTransactedW@	; `string'
PUBLIC	??_C@_0BI@HAKLOOGP@RegDeleteKeyTransactedW@	; `string'
PUBLIC	?_AtlComModule@ATL@@3VCAtlComModule@1@A		; ATL::_AtlComModule
PUBLIC	?_AtlWinModule@ATL@@3VCAtlWinModule@1@A		; ATL::_AtlWinModule
PUBLIC	?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4P6GJPAUHKEY__@@0KK@ZA ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx
PUBLIC	?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4_NA ; `ATL::CRegKey::DeleteSubKey'::`2'::bInitialized
PUBLIC	??_C@_0BA@LILAPHGE@RegDeleteKeyExW@		; `string'
PUBLIC	??_C@_19ILOCMLCJ@?$AA?4?$AAt?$AAl?$AAb@		; `string'
PUBLIC	__GUID_0002e012_0000_0000_c000_000000000046
PUBLIC	??_C@_1O@FHBGLCIO@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?2@ ; `string'
PUBLIC	??_C@_1CK@IFBKBFAA@?$AA?2?$AAR?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAd?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg@ ; `string'
PUBLIC	??_C@_1DA@BIHALFED@?$AA?2?$AAI?$AAm?$AAp?$AAl?$AAe?$AAm?$AAe?$AAn?$AAt?$AAe?$AAd?$AA?5?$AAC?$AAa@ ; `string'
PUBLIC	??_C@_1BK@EDKOLFBJ@?$AAO?$AAL?$AAE?$AAA?$AAU?$AAT?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL@ ; `string'
PUBLIC	??_C@_0BJ@CNLFOMHB@UnRegisterTypeLibForUser@	; `string'
PUBLIC	??_C@_0BH@LBOMMKPJ@RegisterTypeLibForUser@	; `string'
PUBLIC	?_Module@@3VCComModule@ATL@@A			; _Module
PUBLIC	?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::pConnMap
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo:PROC
EXTRN	__errno:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	__recalloc:PROC
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	??_U@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new[]
EXTRN	__resetstkoflw:PROC
EXTRN	_wcsstr:PROC
EXTRN	_wcscat_s:PROC
EXTRN	_wcscpy_s:PROC
EXTRN	_wcsncpy_s:PROC
EXTRN	__imp__EncodePointer@4:PROC
EXTRN	__imp__DecodePointer@4:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__InitializeCriticalSectionEx@12:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__DisableThreadLibraryCalls@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleFileNameW@12:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryExW@12:PROC
EXTRN	__imp__LoadResource@8:PROC
EXTRN	__imp__SizeofResource@8:PROC
EXTRN	__imp__FindResourceW@12:PROC
EXTRN	__imp__GlobalAlloc@8:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__MulDiv@12:PROC
EXTRN	__imp__lstrcmpiW@8:PROC
EXTRN	__imp__CloseMetaFile@4:PROC
EXTRN	__imp__CreateDCW@16:PROC
EXTRN	__imp__CreateMetaFileW@4:PROC
EXTRN	__imp__CreateRectRgnIndirect@4:PROC
EXTRN	__imp__DeleteDC@4:PROC
EXTRN	__imp__DeleteMetaFile@4:PROC
EXTRN	__imp__GetDeviceCaps@8:PROC
EXTRN	__imp__RestoreDC@8:PROC
EXTRN	__imp__SaveDC@4:PROC
EXTRN	__imp__SetMapMode@8:PROC
EXTRN	__imp__LPtoDP@12:PROC
EXTRN	__imp__SetViewportOrgEx@16:PROC
EXTRN	__imp__SetWindowExtEx@16:PROC
EXTRN	__imp__SetWindowOrgEx@16:PROC
EXTRN	__imp__PostMessageW@16:PROC
EXTRN	__imp__DefWindowProcW@16:PROC
EXTRN	__imp__CallWindowProcW@20:PROC
EXTRN	__imp__UnregisterClassW@8:PROC
EXTRN	__imp__RegisterClassExW@4:PROC
EXTRN	__imp__GetClassInfoExW@12:PROC
EXTRN	__imp__CreateWindowExW@48:PROC
EXTRN	__imp__IsWindow@4:PROC
EXTRN	__imp__IsChild@8:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__CharNextW@4:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__GetFocus@0:PROC
EXTRN	__imp__GetKeyState@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__SetWindowRgn@12:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__IntersectRect@12:PROC
EXTRN	__imp__UnionRect@12:PROC
EXTRN	__imp__OffsetRect@12:PROC
EXTRN	__imp__EqualRect@8:PROC
EXTRN	__imp__PtInRect@12:PROC
EXTRN	__imp__GetWindowLongW@8:PROC
EXTRN	__imp__SetWindowLongW@12:PROC
EXTRN	__imp__GetParent@4:PROC
EXTRN	__imp__LoadCursorW@8:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegCreateKeyExW@36:PROC
EXTRN	__imp__RegDeleteKeyW@8:PROC
EXTRN	__imp__RegDeleteValueW@8:PROC
EXTRN	__imp__RegEnumKeyExW@32:PROC
EXTRN	__imp__RegOpenKeyExW@20:PROC
EXTRN	__imp__RegQueryInfoKeyW@48:PROC
EXTRN	__imp__RegSetValueExW@24:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	__imp__StringFromGUID2@12:PROC
EXTRN	__imp__CoTaskMemAlloc@4:PROC
EXTRN	__imp__CoTaskMemRealloc@8:PROC
EXTRN	__imp__CoTaskMemFree@4:PROC
EXTRN	__imp__ReadClassStm@8:PROC
EXTRN	__imp__WriteClassStm@8:PROC
EXTRN	__imp__CreateDataAdviseHolder@4:PROC
EXTRN	__imp__SysAllocString@4:PROC
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	__imp__SysStringLen@4:PROC
EXTRN	__imp__SysStringByteLen@4:PROC
EXTRN	__imp__SysAllocStringByteLen@8:PROC
EXTRN	__imp__VariantInit@4:PROC
EXTRN	__imp__VariantClear@4:PROC
EXTRN	__imp__VariantChangeType@16:PROC
EXTRN	__imp__VarUI4FromStr@16:PROC
EXTRN	__imp__LoadTypeLib@8:PROC
EXTRN	__imp__LoadRegTypeLib@20:PROC
EXTRN	__imp__RegisterTypeLib@12:PROC
EXTRN	__imp__UnRegisterTypeLib@20:PROC
EXTRN	__imp__OleSaveToStream@8:PROC
EXTRN	__imp__CreateOleAdviseHolder@4:PROC
EXTRN	__imp__OleRegGetUserType@12:PROC
EXTRN	__imp__OleRegGetMiscStatus@12:PROC
EXTRN	__imp__OleRegEnumVerbs@8:PROC
EXTRN	___stdio_common_vswprintf_s:PROC
EXTRN	__imp__OleCreatePropertyFrame@44:PROC
EXTRN	_AtlThunk_AllocateData@0:PROC
EXTRN	_AtlThunk_InitData@12:PROC
EXTRN	_AtlThunk_DataToCode@4:PROC
EXTRN	?SetLONG@OposVariant@@QAEXJ@Z:PROC		; OposVariant::SetLONG
EXTRN	?SetLONG_Ptr@OposVariant@@QAEXPAJAAJ@Z:PROC	; OposVariant::SetLONG_Ptr
EXTRN	?SetBSTR_InOutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z:PROC ; OposVariant::SetBSTR_InOutPtr
EXTRN	??0OposDispParms@@QAE@PAVOposVariant@@H@Z:PROC	; OposDispParms::OposDispParms
EXTRN	??1OposDispParms@@QAE@XZ:PROC			; OposDispParms::~OposDispParms
EXTRN	??0COPOSDeviceMonitor@@QAE@XZ:PROC		; COPOSDeviceMonitor::COPOSDeviceMonitor
EXTRN	?FinalConstruct@COPOSDeviceMonitor@@QAEJXZ:PROC	; COPOSDeviceMonitor::FinalConstruct
EXTRN	??1COPOSDeviceMonitor@@UAE@XZ:PROC		; COPOSDeviceMonitor::~COPOSDeviceMonitor
EXTRN	??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z:PROC ; ATL::CComContainedObject<COPOSDeviceMonitor>::`vector deleting destructor'
EXTRN	??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z:PROC ; ATL::CComObject<COPOSDeviceMonitor>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__SEH_prolog4_GS:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__chkstk:PROC
EXTRN	__except_handler4:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_CLSID_StdComponentCategoriesMgr:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A
_BSS	SEGMENT
?atlTraceGeneral@ATL@@3V?$CTraceCategoryEx@$00$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceGeneral
_BSS	ENDS
;	COMDAT ?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A
_BSS	SEGMENT
?atlTraceCOM@ATL@@3V?$CTraceCategoryEx@$01$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCOM
_BSS	ENDS
;	COMDAT ?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A
_BSS	SEGMENT
?atlTraceQI@ATL@@3V?$CTraceCategoryEx@$03$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceQI
_BSS	ENDS
;	COMDAT ?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A
_BSS	SEGMENT
?atlTraceRegistrar@ATL@@3V?$CTraceCategoryEx@$07$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRegistrar
_BSS	ENDS
;	COMDAT ?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A
_BSS	SEGMENT
?atlTraceRefcount@ATL@@3V?$CTraceCategoryEx@$0BA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceRefcount
_BSS	ENDS
;	COMDAT ?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A
_BSS	SEGMENT
?atlTraceWindowing@ATL@@3V?$CTraceCategoryEx@$0CA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceWindowing
_BSS	ENDS
;	COMDAT ?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A
_BSS	SEGMENT
?atlTraceControls@ATL@@3V?$CTraceCategoryEx@$0EA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceControls
_BSS	ENDS
;	COMDAT ?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A
_BSS	SEGMENT
?atlTraceHosting@ATL@@3V?$CTraceCategoryEx@$0IA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceHosting
_BSS	ENDS
;	COMDAT ?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBClient@ATL@@3V?$CTraceCategoryEx@$0BAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBClient
_BSS	ENDS
;	COMDAT ?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceDBProvider@ATL@@3V?$CTraceCategoryEx@$0CAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceDBProvider
_BSS	ENDS
;	COMDAT ?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSnapin@ATL@@3V?$CTraceCategoryEx@$0EAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSnapin
_BSS	ENDS
;	COMDAT ?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceNotImpl@ATL@@3V?$CTraceCategoryEx@$0IAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceNotImpl
_BSS	ENDS
;	COMDAT ?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceAllocation@ATL@@3V?$CTraceCategoryEx@$0BAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceAllocation
_BSS	ENDS
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
;	COMDAT ?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceTime@ATL@@3V?$CTraceCategoryEx@$0EAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceTime
_BSS	ENDS
;	COMDAT ?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceCache@ATL@@3V?$CTraceCategoryEx@$0IAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceCache
_BSS	ENDS
;	COMDAT ?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceStencil@ATL@@3V?$CTraceCategoryEx@$0BAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceStencil
_BSS	ENDS
;	COMDAT ?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceString@ATL@@3V?$CTraceCategoryEx@$0CAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceString
_BSS	ENDS
;	COMDAT ?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceMap@ATL@@3V?$CTraceCategoryEx@$0EAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceMap
_BSS	ENDS
;	COMDAT ?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceUtil@ATL@@3V?$CTraceCategoryEx@$0IAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceUtil
_BSS	ENDS
;	COMDAT ?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSecurity@ATL@@3V?$CTraceCategoryEx@$0BAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSecurity
_BSS	ENDS
;	COMDAT ?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceSync@ATL@@3V?$CTraceCategoryEx@$0CAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceSync
_BSS	ENDS
;	COMDAT ?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceISAPI@ATL@@3V?$CTraceCategoryEx@$0EAAAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceISAPI
_BSS	ENDS
;	COMDAT ?_AtlComModule@ATL@@3VCAtlComModule@1@A
_BSS	SEGMENT
?_AtlComModule@ATL@@3VCAtlComModule@1@A DB 028H DUP (?)	; ATL::_AtlComModule
_BSS	ENDS
;	COMDAT ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A
_BSS	SEGMENT
?_AtlWinModule@ATL@@3VCAtlWinModule@1@A DB 02cH DUP (?)	; ATL::_AtlWinModule
_BSS	ENDS
;	COMDAT ?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4P6GJPAUHKEY__@@0KK@ZA
_BSS	SEGMENT
?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4P6GJPAUHKEY__@@0KK@ZA DD 01H DUP (?) ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx
_BSS	ENDS
;	COMDAT ?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4_NA
_BSS	SEGMENT
?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4_NA DB 01H DUP (?) ; `ATL::CRegKey::DeleteSubKey'::`2'::bInitialized
_BSS	ENDS
_BSS	SEGMENT
?_Module@@3VCComModule@ATL@@A DB 030H DUP (?)		; _Module
_BSS	ENDS
;	COMDAT ?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B
_BSS	SEGMENT
?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B DD 01H DUP (?) ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::pConnMap
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlComModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlComModule@ATL@@YAXXZ ; ATL::_AtlComModule$initializer$
CRT$XCU	ENDS
_DATA	SEGMENT
?ObjectMap@@3PAU_ATL_OBJMAP_ENTRY30@ATL@@A DD FLAT:_CLSID_OPOSDeviceMonitor ; ObjectMap
	DD	FLAT:?UpdateRegistry@COPOSDeviceMonitor@@SGJH@Z
	DD	FLAT:?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
	DD	FLAT:?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
	DD	00H
	DD	00H
	DD	FLAT:?GetObjectDescription@?$CComCoClass@VCOPOSDeviceMonitor@@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B@ATL@@SGPB_WXZ
	DD	FLAT:?GetCategoryMap@CComObjectRootBase@ATL@@SAPBU_ATL_CATMAP_ENTRY@2@XZ
	DD	FLAT:?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
_DATA	ENDS
;	COMDAT ??_C@_0BH@LBOMMKPJ@RegisterTypeLibForUser@
CONST	SEGMENT
??_C@_0BH@LBOMMKPJ@RegisterTypeLibForUser@ DB 'RegisterTypeLibForUser', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CNLFOMHB@UnRegisterTypeLibForUser@
CONST	SEGMENT
??_C@_0BJ@CNLFOMHB@UnRegisterTypeLibForUser@ DB 'UnRegisterTypeLibForUser'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@EDKOLFBJ@?$AAO?$AAL?$AAE?$AAA?$AAU?$AAT?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL@
CONST	SEGMENT
??_C@_1BK@EDKOLFBJ@?$AAO?$AAL?$AAE?$AAA?$AAU?$AAT?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL@ DB 'O'
	DB	00H, 'L', 00H, 'E', 00H, 'A', 00H, 'U', 00H, 'T', 00H, '3', 00H
	DB	'2', 00H, '.', 00H, 'D', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@BIHALFED@?$AA?2?$AAI?$AAm?$AAp?$AAl?$AAe?$AAm?$AAe?$AAn?$AAt?$AAe?$AAd?$AA?5?$AAC?$AAa@
CONST	SEGMENT
??_C@_1DA@BIHALFED@?$AA?2?$AAI?$AAm?$AAp?$AAl?$AAe?$AAm?$AAe?$AAn?$AAt?$AAe?$AAd?$AA?5?$AAC?$AAa@ DB '\'
	DB	00H, 'I', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, 'm', 00H
	DB	'e', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'C'
	DB	00H, 'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@IFBKBFAA@?$AA?2?$AAR?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAd?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg@
CONST	SEGMENT
??_C@_1CK@IFBKBFAA@?$AA?2?$AAR?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAd?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg@ DB '\'
	DB	00H, 'R', 00H, 'e', 00H, 'q', 00H, 'u', 00H, 'i', 00H, 'r', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'C', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@FHBGLCIO@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?2@
CONST	SEGMENT
??_C@_1O@FHBGLCIO@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?2@ DB 'C', 00H, 'L', 00H, 'S'
	DB	00H, 'I', 00H, 'D', 00H, '\', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT __GUID_0002e012_0000_0000_c000_000000000046
CONST	SEGMENT
__GUID_0002e012_0000_0000_c000_000000000046 DD 02e012H
	DW	00H
	DW	00H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	046H
CONST	ENDS
;	COMDAT ??_C@_19ILOCMLCJ@?$AA?4?$AAt?$AAl?$AAb@
CONST	SEGMENT
??_C@_19ILOCMLCJ@?$AA?4?$AAt?$AAl?$AAb@ DB '.', 00H, 't', 00H, 'l', 00H, 'b'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LILAPHGE@RegDeleteKeyExW@
CONST	SEGMENT
??_C@_0BA@LILAPHGE@RegDeleteKeyExW@ DB 'RegDeleteKeyExW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HAKLOOGP@RegDeleteKeyTransactedW@
CONST	SEGMENT
??_C@_0BI@HAKLOOGP@RegDeleteKeyTransactedW@ DB 'RegDeleteKeyTransactedW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EKFFMJIO@RegOpenKeyTransactedW@
CONST	SEGMENT
??_C@_0BG@EKFFMJIO@RegOpenKeyTransactedW@ DB 'RegOpenKeyTransactedW', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__sehtable$?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z DD 0ffffffe4H
	DD	00H
	DD	0ffffffccH
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN13@AtlVerifyS
	DD	FLAT:$LN8@AtlVerifyS
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_AtlWinModule$initializer$@ATL@@3P6AXXZA DD FLAT:??__E_AtlWinModule@ATL@@YAXXZ ; ATL::_AtlWinModule$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?_Module$initializer$@@3P6AXXZA DD FLAT:??__E_Module@@YAXXZ ; _Module$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??pConnMap$initializer$@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0P6AXXZA@@3P6AXXZA DD FLAT:??__E?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B@@YAXXZ ; ??pConnMap$initializer$@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{180}', COMDAT
  00000	81 6c 24 04 b4
	00 00 00	 sub	 DWORD PTR [esp+4], 180	; 000000b4H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{180}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{180}', COMDAT
  00000	81 6c 24 04 b4
	00 00 00	 sub	 DWORD PTR [esp+4], 180	; 000000b4H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{180}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{168}', COMDAT
  00000	81 6c 24 04 a8
	00 00 00	 sub	 DWORD PTR [esp+4], 168	; 000000a8H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{168}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{168}', COMDAT
  00000	81 6c 24 04 a8
	00 00 00	 sub	 DWORD PTR [esp+4], 168	; 000000a8H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{168}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{160}', COMDAT
  00000	81 6c 24 04 a0
	00 00 00	 sub	 DWORD PTR [esp+4], 160	; 000000a0H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{160}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{160}', COMDAT
  00000	81 6c 24 04 a0
	00 00 00	 sub	 DWORD PTR [esp+4], 160	; 000000a0H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{160}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{160}', COMDAT
  00000	81 6c 24 04 a0
	00 00 00	 sub	 DWORD PTR [esp+4], 160	; 000000a0H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{160}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{156}', COMDAT
  00000	81 6c 24 04 9c
	00 00 00	 sub	 DWORD PTR [esp+4], 156	; 0000009cH
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{156}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{156}', COMDAT
  00000	81 6c 24 04 9c
	00 00 00	 sub	 DWORD PTR [esp+4], 156	; 0000009cH
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{156}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{156}', COMDAT
  00000	81 6c 24 04 9c
	00 00 00	 sub	 DWORD PTR [esp+4], 156	; 0000009cH
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{156}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{152}', COMDAT
  00000	81 6c 24 04 98
	00 00 00	 sub	 DWORD PTR [esp+4], 152	; 00000098H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{152}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{152}', COMDAT
  00000	81 6c 24 04 98
	00 00 00	 sub	 DWORD PTR [esp+4], 152	; 00000098H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{152}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{152}', COMDAT
  00000	81 6c 24 04 98
	00 00 00	 sub	 DWORD PTR [esp+4], 152	; 00000098H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{152}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{148}', COMDAT
  00000	81 6c 24 04 94
	00 00 00	 sub	 DWORD PTR [esp+4], 148	; 00000094H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{148}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{148}', COMDAT
  00000	81 6c 24 04 94
	00 00 00	 sub	 DWORD PTR [esp+4], 148	; 00000094H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{148}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{148}', COMDAT
  00000	81 6c 24 04 94
	00 00 00	 sub	 DWORD PTR [esp+4], 148	; 00000094H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{148}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{144}', COMDAT
  00000	81 6c 24 04 90
	00 00 00	 sub	 DWORD PTR [esp+4], 144	; 00000090H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{144}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{144}', COMDAT
  00000	81 6c 24 04 90
	00 00 00	 sub	 DWORD PTR [esp+4], 144	; 00000090H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{144}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{144}', COMDAT
  00000	81 6c 24 04 90
	00 00 00	 sub	 DWORD PTR [esp+4], 144	; 00000090H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{144}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{140}', COMDAT
  00000	81 6c 24 04 8c
	00 00 00	 sub	 DWORD PTR [esp+4], 140	; 0000008cH
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{140}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{140}', COMDAT
  00000	81 6c 24 04 8c
	00 00 00	 sub	 DWORD PTR [esp+4], 140	; 0000008cH
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{140}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{140}', COMDAT
  00000	81 6c 24 04 8c
	00 00 00	 sub	 DWORD PTR [esp+4], 140	; 0000008cH
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{140}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{136}', COMDAT
  00000	81 6c 24 04 88
	00 00 00	 sub	 DWORD PTR [esp+4], 136	; 00000088H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{136}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{136}', COMDAT
  00000	81 6c 24 04 88
	00 00 00	 sub	 DWORD PTR [esp+4], 136	; 00000088H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{136}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{136}', COMDAT
  00000	81 6c 24 04 88
	00 00 00	 sub	 DWORD PTR [esp+4], 136	; 00000088H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{136}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{132}', COMDAT
  00000	81 6c 24 04 84
	00 00 00	 sub	 DWORD PTR [esp+4], 132	; 00000084H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{132}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{132}', COMDAT
  00000	81 6c 24 04 84
	00 00 00	 sub	 DWORD PTR [esp+4], 132	; 00000084H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{132}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{132}', COMDAT
  00000	81 6c 24 04 84
	00 00 00	 sub	 DWORD PTR [esp+4], 132	; 00000084H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{132}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{128}', COMDAT
  00000	81 6c 24 04 80
	00 00 00	 sub	 DWORD PTR [esp+4], 128	; 00000080H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{128}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{128}', COMDAT
  00000	81 6c 24 04 80
	00 00 00	 sub	 DWORD PTR [esp+4], 128	; 00000080H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{128}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{128}', COMDAT
  00000	81 6c 24 04 80
	00 00 00	 sub	 DWORD PTR [esp+4], 128	; 00000080H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{128}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{124}', COMDAT
  00000	83 6c 24 04 7c	 sub	 DWORD PTR [esp+4], 124	; 0000007cH
  00005	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{124}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{124}', COMDAT
  00000	83 6c 24 04 7c	 sub	 DWORD PTR [esp+4], 124	; 0000007cH
  00005	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{124}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{124}', COMDAT
  00000	83 6c 24 04 7c	 sub	 DWORD PTR [esp+4], 124	; 0000007cH
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{124}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{120}', COMDAT
  00000	83 6c 24 04 78	 sub	 DWORD PTR [esp+4], 120	; 00000078H
  00005	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{120}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{120}', COMDAT
  00000	83 6c 24 04 78	 sub	 DWORD PTR [esp+4], 120	; 00000078H
  00005	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{120}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{120}', COMDAT
  00000	83 6c 24 04 78	 sub	 DWORD PTR [esp+4], 120	; 00000078H
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{120}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{116}', COMDAT
  00000	83 6c 24 04 74	 sub	 DWORD PTR [esp+4], 116	; 00000074H
  00005	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{116}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{116}', COMDAT
  00000	83 6c 24 04 74	 sub	 DWORD PTR [esp+4], 116	; 00000074H
  00005	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{116}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{116}', COMDAT
  00000	83 6c 24 04 74	 sub	 DWORD PTR [esp+4], 116	; 00000074H
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{116}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ
_TEXT	SEGMENT
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{112}', COMDAT
  00000	83 6c 24 04 70	 sub	 DWORD PTR [esp+4], 112	; 00000070H
  00005	e9 00 00 00 00	 jmp	 ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::Release`adjustor{112}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{112}', COMDAT
  00000	83 6c 24 04 70	 sub	 DWORD PTR [esp+4], 112	; 00000070H
  00005	e9 00 00 00 00	 jmp	 ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef`adjustor{112}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{112}', COMDAT
  00000	83 6c 24 04 70	 sub	 DWORD PTR [esp+4], 112	; 00000070H
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface`adjustor{112}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z
_TEXT	SEGMENT
??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::`vector deleting destructor', COMDAT
  00000	83 e9 4c	 sub	 ecx, 76			; 0000004cH
  00003	e9 00 00 00 00	 jmp	 ??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z
??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z
_TEXT	SEGMENT
??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z PROC ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z
??_E?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z ENDP ; [thunk]:ATL::CComContainedObject<COPOSDeviceMonitor>::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{180}', COMDAT
  00000	81 6c 24 04 b4
	00 00 00	 sub	 DWORD PTR [esp+4], 180	; 000000b4H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{180}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{180}', COMDAT
  00000	81 6c 24 04 b4
	00 00 00	 sub	 DWORD PTR [esp+4], 180	; 000000b4H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WLE@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{180}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{168}', COMDAT
  00000	81 6c 24 04 a8
	00 00 00	 sub	 DWORD PTR [esp+4], 168	; 000000a8H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{168}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{168}', COMDAT
  00000	81 6c 24 04 a8
	00 00 00	 sub	 DWORD PTR [esp+4], 168	; 000000a8H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKI@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{168}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{160}', COMDAT
  00000	81 6c 24 04 a0
	00 00 00	 sub	 DWORD PTR [esp+4], 160	; 000000a0H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{160}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{160}', COMDAT
  00000	81 6c 24 04 a0
	00 00 00	 sub	 DWORD PTR [esp+4], 160	; 000000a0H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{160}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{160}', COMDAT
  00000	81 6c 24 04 a0
	00 00 00	 sub	 DWORD PTR [esp+4], 160	; 000000a0H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WKA@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{160}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{156}', COMDAT
  00000	81 6c 24 04 9c
	00 00 00	 sub	 DWORD PTR [esp+4], 156	; 0000009cH
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{156}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{156}', COMDAT
  00000	81 6c 24 04 9c
	00 00 00	 sub	 DWORD PTR [esp+4], 156	; 0000009cH
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{156}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{156}', COMDAT
  00000	81 6c 24 04 9c
	00 00 00	 sub	 DWORD PTR [esp+4], 156	; 0000009cH
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJM@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{156}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{152}', COMDAT
  00000	81 6c 24 04 98
	00 00 00	 sub	 DWORD PTR [esp+4], 152	; 00000098H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{152}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{152}', COMDAT
  00000	81 6c 24 04 98
	00 00 00	 sub	 DWORD PTR [esp+4], 152	; 00000098H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{152}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{152}', COMDAT
  00000	81 6c 24 04 98
	00 00 00	 sub	 DWORD PTR [esp+4], 152	; 00000098H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJI@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{152}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{148}', COMDAT
  00000	81 6c 24 04 94
	00 00 00	 sub	 DWORD PTR [esp+4], 148	; 00000094H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{148}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{148}', COMDAT
  00000	81 6c 24 04 94
	00 00 00	 sub	 DWORD PTR [esp+4], 148	; 00000094H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{148}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{148}', COMDAT
  00000	81 6c 24 04 94
	00 00 00	 sub	 DWORD PTR [esp+4], 148	; 00000094H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJE@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{148}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{144}', COMDAT
  00000	81 6c 24 04 90
	00 00 00	 sub	 DWORD PTR [esp+4], 144	; 00000090H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{144}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{144}', COMDAT
  00000	81 6c 24 04 90
	00 00 00	 sub	 DWORD PTR [esp+4], 144	; 00000090H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{144}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{144}', COMDAT
  00000	81 6c 24 04 90
	00 00 00	 sub	 DWORD PTR [esp+4], 144	; 00000090H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WJA@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{144}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{140}', COMDAT
  00000	81 6c 24 04 8c
	00 00 00	 sub	 DWORD PTR [esp+4], 140	; 0000008cH
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{140}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{140}', COMDAT
  00000	81 6c 24 04 8c
	00 00 00	 sub	 DWORD PTR [esp+4], 140	; 0000008cH
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{140}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{140}', COMDAT
  00000	81 6c 24 04 8c
	00 00 00	 sub	 DWORD PTR [esp+4], 140	; 0000008cH
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIM@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{140}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{136}', COMDAT
  00000	81 6c 24 04 88
	00 00 00	 sub	 DWORD PTR [esp+4], 136	; 00000088H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{136}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{136}', COMDAT
  00000	81 6c 24 04 88
	00 00 00	 sub	 DWORD PTR [esp+4], 136	; 00000088H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{136}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{136}', COMDAT
  00000	81 6c 24 04 88
	00 00 00	 sub	 DWORD PTR [esp+4], 136	; 00000088H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WII@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{136}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{132}', COMDAT
  00000	81 6c 24 04 84
	00 00 00	 sub	 DWORD PTR [esp+4], 132	; 00000084H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{132}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{132}', COMDAT
  00000	81 6c 24 04 84
	00 00 00	 sub	 DWORD PTR [esp+4], 132	; 00000084H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{132}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{132}', COMDAT
  00000	81 6c 24 04 84
	00 00 00	 sub	 DWORD PTR [esp+4], 132	; 00000084H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIE@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{132}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{128}', COMDAT
  00000	81 6c 24 04 80
	00 00 00	 sub	 DWORD PTR [esp+4], 128	; 00000080H
  00008	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{128}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{128}', COMDAT
  00000	81 6c 24 04 80
	00 00 00	 sub	 DWORD PTR [esp+4], 128	; 00000080H
  00008	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{128}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{128}', COMDAT
  00000	81 6c 24 04 80
	00 00 00	 sub	 DWORD PTR [esp+4], 128	; 00000080H
  00008	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WIA@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{128}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{124}', COMDAT
  00000	83 6c 24 04 7c	 sub	 DWORD PTR [esp+4], 124	; 0000007cH
  00005	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{124}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{124}', COMDAT
  00000	83 6c 24 04 7c	 sub	 DWORD PTR [esp+4], 124	; 0000007cH
  00005	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{124}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{124}', COMDAT
  00000	83 6c 24 04 7c	 sub	 DWORD PTR [esp+4], 124	; 0000007cH
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHM@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{124}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{120}', COMDAT
  00000	83 6c 24 04 78	 sub	 DWORD PTR [esp+4], 120	; 00000078H
  00005	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{120}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{120}', COMDAT
  00000	83 6c 24 04 78	 sub	 DWORD PTR [esp+4], 120	; 00000078H
  00005	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{120}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{120}', COMDAT
  00000	83 6c 24 04 78	 sub	 DWORD PTR [esp+4], 120	; 00000078H
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHI@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{120}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{116}', COMDAT
  00000	83 6c 24 04 74	 sub	 DWORD PTR [esp+4], 116	; 00000074H
  00005	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{116}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{116}', COMDAT
  00000	83 6c 24 04 74	 sub	 DWORD PTR [esp+4], 116	; 00000074H
  00005	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{116}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{116}', COMDAT
  00000	83 6c 24 04 74	 sub	 DWORD PTR [esp+4], 116	; 00000074H
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHE@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{116}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ
_TEXT	SEGMENT
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{112}', COMDAT
  00000	83 6c 24 04 70	 sub	 DWORD PTR [esp+4], 112	; 00000070H
  00005	e9 00 00 00 00	 jmp	 ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::Release
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::Release`adjustor{112}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ
_TEXT	SEGMENT
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{112}', COMDAT
  00000	83 6c 24 04 70	 sub	 DWORD PTR [esp+4], 112	; 00000070H
  00005	e9 00 00 00 00	 jmp	 ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGKXZ ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::AddRef`adjustor{112}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{112}', COMDAT
  00000	83 6c 24 04 70	 sub	 DWORD PTR [esp+4], 112	; 00000070H
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WHA@AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::QueryInterface`adjustor{112}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z
_TEXT	SEGMENT
??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::`vector deleting destructor', COMDAT
  00000	83 e9 4c	 sub	 ecx, 76			; 0000004cH
  00003	e9 00 00 00 00	 jmp	 ??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z
??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@WEM@AEPAXI@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z
_TEXT	SEGMENT
??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z PROC ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z
??_E?$CComObject@VCOPOSDeviceMonitor@@@ATL@@W3AEPAXI@Z ENDP ; [thunk]:ATL::CComObject<COPOSDeviceMonitor>::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?copy@?$_CopyInterface@UIConnectionPoint@@@ATL@@SAJPAPAUIConnectionPoint@@PBQAU3@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
?copy@?$_CopyInterface@UIConnectionPoint@@@ATL@@SAJPAPAUIConnectionPoint@@PBQAU3@@Z PROC ; ATL::_CopyInterface<IConnectionPoint>::copy, COMDAT

; 5448 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5449 : 		ATLENSURE(p1 != NULL && p2 != NULL);

  00003	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 19		 je	 SHORT $LN11@copy
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _p2$[ebp]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 12		 je	 SHORT $LN11@copy

; 5450 : 		*p1 = *p2;

  00011	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00013	89 08		 mov	 DWORD PTR [eax], ecx

; 5451 : 		if (*p1)

  00015	85 c9		 test	 ecx, ecx
  00017	74 06		 je	 SHORT $LN9@copy

; 5452 : 			(*p1)->AddRef();

  00019	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001b	51		 push	 ecx
  0001c	ff 50 04	 call	 DWORD PTR [eax+4]
$LN9@copy:

; 5453 : 		return S_OK;

  0001f	33 c0		 xor	 eax, eax

; 5454 : 	}

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
$LN11@copy:

; 5449 : 		ATLENSURE(p1 != NULL && p2 != NULL);

  00023	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00028	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@copy:
  0002d	cc		 int	 3
?copy@?$_CopyInterface@UIConnectionPoint@@@ATL@@SAJPAPAUIConnectionPoint@@PBQAU3@@Z ENDP ; ATL::_CopyInterface<IConnectionPoint>::copy
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::~CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0a		 je	 SHORT $LN2@scalar
  00011	6a 1c		 push	 28			; 0000001cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx
$LN2@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CreateInstance, COMDAT

; 2963 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2964 : 	ATLASSERT(pp != NULL);
; 2965 : 	if (pp == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _pp$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@CreateInst

; 2966 : 		return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 33		 jmp	 SHORT $LN1@CreateInst
$LN2@CreateInst:

; 2967 : 	*pp = NULL;

  00012	83 26 00	 and	 DWORD PTR [esi], 0
  00015	57		 push	 edi

; 2968 : 
; 2969 : 	HRESULT hRes = E_OUTOFMEMORY;
; 2970 : 	CComObject<Base>* p = NULL;
; 2971 : 	ATLTRY(p = _ATL_NEW CComObject<Base>())

  00016	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001b	6a 1c		 push	 28			; 0000001cH
  0001d	bf 0e 00 07 80	 mov	 edi, -2147024882	; 8007000eH
  00022	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  00027	59		 pop	 ecx
  00028	59		 pop	 ecx
  00029	85 c0		 test	 eax, eax
  0002b	74 11		 je	 SHORT $LN8@CreateInst
  0002d	6a 00		 push	 0
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 ??0?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >

; 2972 : 	if (p != NULL)

  00036	85 c0		 test	 eax, eax
  00038	74 06		 je	 SHORT $LN6@CreateInst

; 2973 : 	{
; 2974 : 		p->SetVoid(NULL);
; 2975 : 		p->InternalFinalConstructAddRef();
; 2976 : 		hRes = p->_AtlInitialConstruct();
; 2977 : 		if (SUCCEEDED(hRes))
; 2978 : 			hRes = p->FinalConstruct();
; 2979 : 		if (SUCCEEDED(hRes))
; 2980 : 			hRes = p->_AtlFinalConstruct();
; 2981 : 		p->InternalFinalConstructRelease();
; 2982 : 		if (hRes != S_OK)

  0003a	33 ff		 xor	 edi, edi
  0003c	eb 02		 jmp	 SHORT $LN6@CreateInst
$LN8@CreateInst:

; 2968 : 
; 2969 : 	HRESULT hRes = E_OUTOFMEMORY;
; 2970 : 	CComObject<Base>* p = NULL;
; 2971 : 	ATLTRY(p = _ATL_NEW CComObject<Base>())

  0003e	33 c0		 xor	 eax, eax
$LN6@CreateInst:

; 2983 : 		{
; 2984 : 			delete p;
; 2985 : 			p = NULL;
; 2986 : 		}
; 2987 : 	}
; 2988 : 	*pp = p;

  00040	89 06		 mov	 DWORD PTR [esi], eax

; 2989 : 	return hRes;

  00042	8b c7		 mov	 eax, edi
  00044	5f		 pop	 edi
$LN1@CreateInst:
  00045	5e		 pop	 esi

; 2990 : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CreateInstance
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::QueryInterface, COMDAT

; 2947 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  00003	ff 75 10	 push	 DWORD PTR _ppvObject$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _iid$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
  0000e	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 2948 : 		return this->_InternalQueryInterface(iid, ppvObject);
; 2949 : 	}

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::Release, COMDAT

; 2933 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2934 : 		ULONG l = this->InternalRelease();

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 444  : 		return --(*p);

  00008	83 6e 18 01	 sub	 DWORD PTR [esi+24], 1
  0000c	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2935 : 		if (l == 0)

  0000f	75 23		 jne	 SHORT $LN2@Release

; 2891 : 		_pAtlModule->Lock();

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	ff 50 04	 call	 DWORD PTR [eax+4]

; 2936 : 		{
; 2937 : 			// Lock the module to avoid DLL unload when destruction of member variables take a long time
; 2938 : 			ModuleLockHelper lock;
; 2939 : 			delete this;

  0001c	85 f6		 test	 esi, esi
  0001e	74 09		 je	 SHORT $LN4@Release
  00020	8b 16		 mov	 edx, DWORD PTR [esi]
  00022	8b ce		 mov	 ecx, esi
  00024	6a 01		 push	 1
  00026	ff 52 1c	 call	 DWORD PTR [edx+28]
$LN4@Release:

; 2898 : 		_pAtlModule->Unlock();

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	ff 52 08	 call	 DWORD PTR [edx+8]
$LN2@Release:

; 2940 : 		}
; 2941 : 		return l;

  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi

; 2942 : 	}

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?Release@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::Release
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::AddRef, COMDAT

; 2929 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2930 : 		return this->InternalAddRef();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 440  : 		return ++(*p);

  00006	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00009	40		 inc	 eax
  0000a	89 41 18	 mov	 DWORD PTR [ecx+24], eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2931 : 	}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?AddRef@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::AddRef
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT
??1?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::~CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >, COMDAT
; _this$ = ecx

; 2918 : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@

; 2919 : 		this->m_dwRef = -(LONG_MAX/2);

  00009	c7 46 18 01 00
	00 c0		 mov	 DWORD PTR [esi+24], -1073741823 ; c0000001H

; 2920 : 		this->FinalRelease();
; 2921 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 2922 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 2923 : #endif
; 2924 : 		_pAtlModule->Unlock();

  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	ff 50 08	 call	 DWORD PTR [eax+8]
  0001b	8b ce		 mov	 ecx, esi
  0001d	5e		 pop	 esi
  0001e	e9 00 00 00 00	 jmp	 ??1?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAE@XZ ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::~CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >
??1?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::~CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00000	33 c0		 xor	 eax, eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2911 : 	CComObject(_In_opt_ void* = NULL)

  00002	56		 push	 esi
  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00005	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5501 : 		m_begin = m_end = m_iter = NULL;

  00008	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0000b	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0000e	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 5502 : 		m_dwFlags = 0;

  00011	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 2430 : 		m_dwRef = 0L;

  00014	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 2912 : 	{

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@

; 2913 : 		_pAtlModule->Lock();

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	ff 50 04	 call	 DWORD PTR [eax+4]

; 2914 : 	}

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	c2 04 00	 ret	 4
??0?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Init@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@QAEJPAUtagCONNECTDATA@@0PAUIUnknown@@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT
_hr$1$ = 8						; size = 4
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
_pUnk$ = 16						; size = 4
tv427 = 20						; size = 4
_flags$ = 20						; size = 4
?Init@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@QAEJPAUtagCONNECTDATA@@0PAUIUnknown@@W4CComEnumFlags@2@@Z PROC ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Init, COMDAT
; _this$ = ecx

; 5627 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 5628 : 	if (flags == AtlFlagCopy)

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _flags$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	83 fb 03	 cmp	 ebx, 3
  0000e	0f 85 a2 00 00
	00		 jne	 $LN10@Init

; 5629 : 	{
; 5630 : 		ATLASSUME(m_begin == NULL); //Init called twice?
; 5631 : 		ATLTRY(m_begin = _ATL_NEW T[end-begin])

  00014	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  00017	33 c9		 xor	 ecx, ecx
  00019	8b 7d 08	 mov	 edi, DWORD PTR _begin$[ebp]
  0001c	2b c7		 sub	 eax, edi
  0001e	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00023	c1 f8 03	 sar	 eax, 3
  00026	6a 08		 push	 8
  00028	5a		 pop	 edx
  00029	89 45 14	 mov	 DWORD PTR tv427[ebp], eax
  0002c	f7 e2		 mul	 edx
  0002e	0f 90 c1	 seto	 cl
  00031	f7 d9		 neg	 ecx
  00033	0b c8		 or	 ecx, eax
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 5632 : 		m_iter = m_begin;

  0003e	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 5633 : 		if (m_begin == NULL)

  00043	85 c0		 test	 eax, eax
  00045	75 0a		 jne	 SHORT $LN12@Init

; 5634 : 			return E_OUTOFMEMORY;

  00047	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0004c	e9 87 00 00 00	 jmp	 $LN1@Init
$LN12@Init:

; 5635 : 		for (T* i=begin; i != end; i++)

  00051	3b 7d 0c	 cmp	 edi, DWORD PTR _end$[ebp]
  00054	74 22		 je	 SHORT $LN27@Init
$LL7@Init:

; 5636 : 		{
; 5637 : 			Copy::init(m_iter);
; 5638 : 			HRESULT hr = Copy::copy(m_iter, i);

  00056	57		 push	 edi
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?copy@?$_Copy@UtagCONNECTDATA@@@ATL@@SAJPAUtagCONNECTDATA@@PBU3@@Z ; ATL::_Copy<tagCONNECTDATA>::copy
  0005d	89 45 08	 mov	 DWORD PTR _hr$1$[ebp], eax
  00060	59		 pop	 ecx
  00061	59		 pop	 ecx

; 5639 : 			if (FAILED(hr))

  00062	85 c0		 test	 eax, eax
  00064	78 1a		 js	 SHORT $LN20@Init

; 5647 : 			}
; 5648 : 			m_iter++;

  00066	83 46 10 08	 add	 DWORD PTR [esi+16], 8
  0006a	83 c7 08	 add	 edi, 8
  0006d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00070	3b 7d 0c	 cmp	 edi, DWORD PTR _end$[ebp]
  00073	75 e1		 jne	 SHORT $LL7@Init

; 5639 : 			if (FAILED(hr))

  00075	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$LN27@Init:

; 5649 : 		}
; 5650 : 		m_end = m_begin + (end-begin);

  00078	8b 4d 14	 mov	 ecx, DWORD PTR tv427[ebp]
  0007b	8d 04 c8	 lea	 eax, DWORD PTR [eax+ecx*8]

; 5651 : 	}

  0007e	eb 3f		 jmp	 SHORT $LN11@Init
$LN20@Init:

; 5640 : 			{
; 5641 : 				T* p = m_begin;

  00080	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 5642 : 				while (p < m_iter)

  00083	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00086	73 17		 jae	 SHORT $LN9@Init
$LL8@Init:

; 5436 : 		if (p->pUnk)

  00088	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0008a	85 c9		 test	 ecx, ecx
  0008c	74 06		 je	 SHORT $LN16@Init

; 5437 : 		{
; 5438 : 			p->pUnk->Release();

  0008e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00090	51		 push	 ecx
  00091	ff 50 08	 call	 DWORD PTR [eax+8]
$LN16@Init:

; 5643 : 					Copy::destroy(p++);

  00094	83 c7 08	 add	 edi, 8
  00097	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  0009a	72 ec		 jb	 SHORT $LL8@Init
  0009c	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
$LN9@Init:

; 5644 : 				delete [] m_begin;

  0009f	57		 push	 edi
  000a0	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 5645 : 				m_begin = m_end = m_iter = NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000aa	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000ad	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 5646 : 				return hr;

  000b0	8b 45 08	 mov	 eax, DWORD PTR _hr$1$[ebp]
  000b3	59		 pop	 ecx
  000b4	eb 22		 jmp	 SHORT $LN1@Init
$LN10@Init:

; 5652 : 	else
; 5653 : 	{
; 5654 : 		m_begin = begin;

  000b6	8b 45 08	 mov	 eax, DWORD PTR _begin$[ebp]
  000b9	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 5655 : 		m_end = end;

  000bc	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
$LN11@Init:

; 5656 : 	}
; 5657 : 	m_spUnk = pUnk;

  000bf	ff 75 10	 push	 DWORD PTR _pUnk$[ebp]
  000c2	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000c5	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000c8	e8 00 00 00 00	 call	 ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z ; ATL::CComPtr<IUnknown>::operator=

; 5658 : 	m_iter = m_begin;

  000cd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000d0	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 5659 : 	m_dwFlags = flags;
; 5660 : 	return S_OK;

  000d3	33 c0		 xor	 eax, eax
  000d5	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
$LN1@Init:

; 5661 : }

  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	5d		 pop	 ebp
  000dc	c2 10 00	 ret	 16			; 00000010H
?Init@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@QAEJPAUtagCONNECTDATA@@0PAUIUnknown@@W4CComEnumFlags@2@@Z ENDP ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Init
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_p$2 = -8						; size = 4
$T3 = -4						; size = 4
$T4 = 8							; size = 4
$T5 = 8							; size = 4
_this$ = 8						; size = 4
_ppEnum$ = 12						; size = 4
?Clone@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z PROC ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Clone, COMDAT

; 5596 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	83 65 f8 00	 and	 DWORD PTR $T1[ebp], 0

; 5597 : 	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
; 5598 : 	HRESULT hRes = E_POINTER;
; 5599 : 	if (ppEnum != NULL)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _ppEnum$[ebp]
  0000c	53		 push	 ebx
  0000d	bb 03 40 00 80	 mov	 ebx, -2147467261	; 80004003H
  00012	85 c0		 test	 eax, eax
  00014	0f 84 c0 00 00
	00		 je	 $LN9@Clone

; 5600 : 	{
; 5601 : 		*ppEnum = NULL;

  0001a	83 20 00	 and	 DWORD PTR [eax], 0

; 5602 : 		_class* p;
; 5603 : 		hRes = _class::CreateInstance(&p);

  0001d	8d 45 f8	 lea	 eax, DWORD PTR _p$2[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CreateInstance
  00026	8b d8		 mov	 ebx, eax

; 5604 : 		if (SUCCEEDED(hRes))

  00028	85 db		 test	 ebx, ebx
  0002a	0f 88 aa 00 00
	00		 js	 $LN9@Clone

; 5607 : 			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);

  00030	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00033	56		 push	 esi
  00034	57		 push	 edi
  00035	f6 43 14 02	 test	 BYTE PTR [ebx+20], 2
  00039	74 12		 je	 SHORT $LN7@Clone
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 171  :             p->AddRef();

  0003b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003d	8b fb		 mov	 edi, ebx
  0003f	53		 push	 ebx
  00040	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5607 : 			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);

  00043	8b 75 08	 mov	 esi, DWORD PTR $T4[ebp]
  00046	33 c9		 xor	 ecx, ecx
  00048	8b c3		 mov	 eax, ebx
  0004a	41		 inc	 ecx
  0004b	eb 17		 jmp	 SHORT $LN40@Clone
$LN7@Clone:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 169  :         p = lp;

  0004d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00050	8b f0		 mov	 esi, eax
  00052	85 c0		 test	 eax, eax

; 170  :         if (p != NULL)

  00054	74 08		 je	 SHORT $LN21@Clone

; 171  :             p->AddRef();

  00056	8b 06		 mov	 eax, DWORD PTR [esi]
  00058	56		 push	 esi
  00059	ff 50 04	 call	 DWORD PTR [eax+4]
  0005c	8b c6		 mov	 eax, esi
$LN21@Clone:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5607 : 			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);

  0005e	8b 7d 08	 mov	 edi, DWORD PTR $T5[ebp]
  00061	6a 02		 push	 2
  00063	59		 pop	 ecx
$LN40@Clone:
  00064	6a 00		 push	 0
  00066	50		 push	 eax
  00067	ff 73 0c	 push	 DWORD PTR [ebx+12]
  0006a	89 4d fc	 mov	 DWORD PTR $T3[ebp], ecx
  0006d	ff 73 08	 push	 DWORD PTR [ebx+8]
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00073	e8 00 00 00 00	 call	 ?Init@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@QAEJPAUtagCONNECTDATA@@0PAUIUnknown@@W4CComEnumFlags@2@@Z ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Init
  00078	8b d8		 mov	 ebx, eax
  0007a	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	a8 02		 test	 al, 2
  0007f	74 13		 je	 SHORT $LN26@Clone
  00081	83 e0 fd	 and	 eax, -3			; fffffffdH
  00084	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00087	85 f6		 test	 esi, esi
  00089	74 09		 je	 SHORT $LN26@Clone

; 184  :             p->Release();

  0008b	8b 06		 mov	 eax, DWORD PTR [esi]
  0008d	56		 push	 esi
  0008e	ff 50 08	 call	 DWORD PTR [eax+8]
  00091	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
$LN26@Clone:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5607 : 			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);

  00094	a8 01		 test	 al, 1
  00096	74 0a		 je	 SHORT $LN31@Clone
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00098	85 ff		 test	 edi, edi
  0009a	74 06		 je	 SHORT $LN31@Clone

; 184  :             p->Release();

  0009c	8b 07		 mov	 eax, DWORD PTR [edi]
  0009e	57		 push	 edi
  0009f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN31@Clone:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5608 : 			if (SUCCEEDED(hRes))

  000a2	8b 75 f8	 mov	 esi, DWORD PTR _p$2[ebp]
  000a5	85 db		 test	 ebx, ebx
  000a7	78 22		 js	 SHORT $LN37@Clone

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  000a9	ff 75 0c	 push	 DWORD PTR _ppEnum$[ebp]

; 5609 : 			{
; 5610 : 				p->m_iter = m_iter;

  000ac	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  000af	68 00 00 00 00	 push	 OFFSET __GUID_b196b287_bab4_101a_b69c_00aa00341d07
  000b4	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
  000b9	56		 push	 esi

; 5609 : 			{
; 5610 : 				p->m_iter = m_iter;

  000ba	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000bd	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  000c0	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 5611 : 				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);

  000c5	8b d8		 mov	 ebx, eax

; 5612 : 			}
; 5613 : 			if (FAILED(hRes))

  000c7	85 db		 test	 ebx, ebx
  000c9	79 0d		 jns	 SHORT $LN39@Clone
$LN37@Clone:

; 5614 : 				delete p;

  000cb	85 f6		 test	 esi, esi
  000cd	74 09		 je	 SHORT $LN39@Clone
  000cf	8b 06		 mov	 eax, DWORD PTR [esi]
  000d1	8b ce		 mov	 ecx, esi
  000d3	6a 01		 push	 1
  000d5	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN39@Clone:
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
$LN9@Clone:

; 5615 : 		}
; 5616 : 	}
; 5617 : 
; 5618 : 	return hRes;

  000da	8b c3		 mov	 eax, ebx
  000dc	5b		 pop	 ebx

; 5619 : }

  000dd	c9		 leave
  000de	c2 08 00	 ret	 8
?Clone@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z ENDP ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Clone
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Reset@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJXZ PROC ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Reset, COMDAT

; 5512 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5513 : 		m_iter = m_begin;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00009	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 5514 : 		return S_OK;

  0000c	33 c0		 xor	 eax, eax

; 5515 : 	}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?Reset@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJXZ ENDP ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Reset
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_celt$ = 12						; size = 4
?Skip@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJK@Z PROC ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Skip, COMDAT

; 5586 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5587 : 	ULONG nRem = ULONG(m_end - m_iter);
; 5588 : 	ULONG nSkip = (celt > nRem) ? nRem : celt;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _celt$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0000a	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00010	2b c2		 sub	 eax, edx
  00012	c1 f8 03	 sar	 eax, 3
  00015	3b c8		 cmp	 ecx, eax
  00017	0f 47 c8	 cmova	 ecx, eax

; 5589 : 	m_iter += nSkip;

  0001a	8d 04 ca	 lea	 eax, DWORD PTR [edx+ecx*8]
  0001d	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 5590 : 	return (celt == nSkip) ? S_OK : S_FALSE;

  00020	33 c0		 xor	 eax, eax
  00022	39 4d 0c	 cmp	 DWORD PTR _celt$[ebp], ecx
  00025	5e		 pop	 esi
  00026	0f 95 c0	 setne	 al

; 5591 : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?Skip@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJK@Z ENDP ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Skip
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Next@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJKPAUtagCONNECTDATA@@PAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_hr$1$ = 12						; size = 4
_celt$ = 12						; size = 4
tv294 = 16						; size = 4
_rgelt$ = 16						; size = 4
_pelt$1$ = 20						; size = 4
_pceltFetched$ = 20					; size = 4
?Next@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJKPAUtagCONNECTDATA@@PAK@Z PROC ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Next, COMDAT

; 5552 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 5553 : 	if (pceltFetched != NULL)

  00006	8b 7d 14	 mov	 edi, DWORD PTR _pceltFetched$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	74 03		 je	 SHORT $LN6@Next

; 5554 : 		*pceltFetched = 0;

  0000d	83 27 00	 and	 DWORD PTR [edi], 0
$LN6@Next:

; 5555 : 	if (rgelt == NULL || (celt > 1 && pceltFetched == NULL))

  00010	8b 5d 10	 mov	 ebx, DWORD PTR _rgelt$[ebp]
  00013	85 db		 test	 ebx, ebx
  00015	0f 84 b0 00 00
	00		 je	 $LN8@Next
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _celt$[ebp]
  0001e	83 f9 01	 cmp	 ecx, 1
  00021	76 08		 jbe	 SHORT $LN7@Next
  00023	85 ff		 test	 edi, edi
  00025	0f 84 a0 00 00
	00		 je	 $LN8@Next
$LN7@Next:

; 5557 : 	if (m_begin == NULL || m_end == NULL || m_iter == NULL)

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00032	0f 84 8c 00 00
	00		 je	 $LN10@Next
  00038	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0003b	85 f6		 test	 esi, esi
  0003d	0f 84 81 00 00
	00		 je	 $LN10@Next
  00043	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00047	74 7b		 je	 SHORT $LN10@Next

; 5559 : 	ULONG nRem = (ULONG)(m_end - m_iter);

  00049	2b 70 10	 sub	 esi, DWORD PTR [eax+16]
  0004c	c1 fe 03	 sar	 esi, 3

; 5560 : 	HRESULT hRes = S_OK;
; 5561 : 	if (nRem < celt)
; 5562 : 		hRes = S_FALSE;
; 5563 : 	ULONG nMin = celt < nRem ? celt : nRem ;

  0004f	3b f1		 cmp	 esi, ecx
  00051	1b d2		 sbb	 edx, edx
  00053	f7 da		 neg	 edx
  00055	3b ce		 cmp	 ecx, esi
  00057	89 55 10	 mov	 DWORD PTR tv294[ebp], edx
  0005a	0f 42 f1	 cmovb	 esi, ecx

; 5564 : 	if (pceltFetched != NULL)

  0005d	85 ff		 test	 edi, edi
  0005f	74 02		 je	 SHORT $LN12@Next

; 5565 : 		*pceltFetched = nMin;

  00061	89 37		 mov	 DWORD PTR [edi], esi
$LN12@Next:

; 5566 : 	T* pelt = rgelt;

  00063	8b cb		 mov	 ecx, ebx
  00065	89 4d 14	 mov	 DWORD PTR _pelt$1$[ebp], ecx

; 5567 : 	while(nMin--)

  00068	85 f6		 test	 esi, esi
  0006a	74 2e		 je	 SHORT $LN21@Next
  0006c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
$LL2@Next:

; 5568 : 	{
; 5569 : 		HRESULT hr = Copy::copy(pelt, m_iter);

  0006f	50		 push	 eax
  00070	51		 push	 ecx
  00071	4e		 dec	 esi
  00072	e8 00 00 00 00	 call	 ?copy@?$_Copy@UtagCONNECTDATA@@@ATL@@SAJPAUtagCONNECTDATA@@PBU3@@Z ; ATL::_Copy<tagCONNECTDATA>::copy
  00077	89 45 0c	 mov	 DWORD PTR _hr$1$[ebp], eax
  0007a	59		 pop	 ecx
  0007b	59		 pop	 ecx

; 5570 : 		if (FAILED(hr))

  0007c	85 c0		 test	 eax, eax
  0007e	78 1e		 js	 SHORT $LN20@Next

; 5577 : 		}
; 5578 : 		pelt++;
; 5579 : 		m_iter++;

  00080	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d 14	 mov	 ecx, DWORD PTR _pelt$1$[ebp]
  00086	83 c1 08	 add	 ecx, 8
  00089	89 4d 14	 mov	 DWORD PTR _pelt$1$[ebp], ecx
  0008c	83 40 10 08	 add	 DWORD PTR [eax+16], 8
  00090	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00093	85 f6		 test	 esi, esi
  00095	75 d8		 jne	 SHORT $LL2@Next

; 5570 : 		if (FAILED(hr))

  00097	8b 55 10	 mov	 edx, DWORD PTR tv294[ebp]
$LN21@Next:

; 5580 : 	}
; 5581 : 	return hRes;

  0009a	8b c2		 mov	 eax, edx
  0009c	eb 32		 jmp	 SHORT $LN1@Next
$LN20@Next:

; 5571 : 		{
; 5572 : 			while (rgelt < pelt)

  0009e	8b 75 14	 mov	 esi, DWORD PTR _pelt$1$[ebp]
  000a1	3b de		 cmp	 ebx, esi
  000a3	73 16		 jae	 SHORT $LN5@Next
$LL4@Next:

; 5436 : 		if (p->pUnk)

  000a5	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000a7	85 c9		 test	 ecx, ecx
  000a9	74 06		 je	 SHORT $LN17@Next

; 5437 : 		{
; 5438 : 			p->pUnk->Release();

  000ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ad	51		 push	 ecx
  000ae	ff 50 08	 call	 DWORD PTR [eax+8]
$LN17@Next:

; 5573 : 				Copy::destroy(rgelt++);

  000b1	83 c3 08	 add	 ebx, 8
  000b4	3b de		 cmp	 ebx, esi
  000b6	72 ed		 jb	 SHORT $LL4@Next
  000b8	8b 45 0c	 mov	 eax, DWORD PTR _hr$1$[ebp]
$LN5@Next:

; 5574 : 			if (pceltFetched != NULL)

  000bb	85 ff		 test	 edi, edi
  000bd	74 11		 je	 SHORT $LN1@Next

; 5575 : 				*pceltFetched = 0;

  000bf	83 27 00	 and	 DWORD PTR [edi], 0

; 5576 : 			return hr;

  000c2	eb 0c		 jmp	 SHORT $LN1@Next
$LN10@Next:

; 5558 : 		return E_FAIL;

  000c4	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000c9	eb 05		 jmp	 SHORT $LN1@Next
$LN8@Next:

; 5556 : 		return E_POINTER;

  000cb	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@Next:
  000d0	5f		 pop	 edi

; 5582 : }

  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	5d		 pop	 ebp
  000d4	c2 10 00	 ret	 16			; 00000010H
?Next@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAGJKPAUtagCONNECTDATA@@PAK@Z ENDP ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Next
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??1?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT
??1?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAE@XZ PROC ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::~CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >, COMDAT
; _this$ = ecx

; 5538 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 5539 : 	if (m_dwFlags & BitOwn)

  00003	f6 47 14 02	 test	 BYTE PTR [edi+20], 2
  00007	74 28		 je	 SHORT $LN5@CComEnumIm

; 5540 : 	{
; 5541 : 		for (T* p = m_begin; p != m_end; p++)

  00009	56		 push	 esi
  0000a	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0000d	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  00010	74 17		 je	 SHORT $LN3@CComEnumIm
$LL4@CComEnumIm:

; 5436 : 		if (p->pUnk)

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	85 c9		 test	 ecx, ecx
  00016	74 06		 je	 SHORT $LN2@CComEnumIm

; 5437 : 		{
; 5438 : 			p->pUnk->Release();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	51		 push	 ecx
  0001b	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@CComEnumIm:

; 5540 : 	{
; 5541 : 		for (T* p = m_begin; p != m_end; p++)

  0001e	83 c6 08	 add	 esi, 8
  00021	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  00024	75 ec		 jne	 SHORT $LL4@CComEnumIm
  00026	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
$LN3@CComEnumIm:

; 5542 : 			Copy::destroy(p);
; 5543 : 		delete [] m_begin;

  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	59		 pop	 ecx
  00030	5e		 pop	 esi
$LN5@CComEnumIm:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	5f		 pop	 edi
  00035	85 c9		 test	 ecx, ecx
  00037	74 06		 je	 SHORT $LN13@CComEnumIm

; 184  :             p->Release();

  00039	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003b	51		 push	 ecx
  0003c	ff 50 08	 call	 DWORD PTR [eax+8]
$LN13@CComEnumIm:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5545 : }

  0003f	c3		 ret	 0
??1?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@UAE@XZ ENDP ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::~CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??__E?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B@@YAXXZ
text$di	SEGMENT
??__E?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B@@YAXXZ PROC ; `dynamic initializer for 'ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::pConnMap'', COMDAT

; 6573 : __declspec(selectany) const ATL::_ATL_CONNMAP_ENTRY* IConnectionPointContainerImpl<T>::pConnMap = T::GetConnMap(NULL);

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 ?GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z ; COPOSDeviceMonitor::GetConnMap
  00007	59		 pop	 ecx
  00008	a3 00 00 00 00	 mov	 DWORD PTR ?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B, eax ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::pConnMap
  0000d	c3		 ret	 0
??__E?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B@@YAXXZ ENDP ; `dynamic initializer for 'ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::pConnMap''
text$di	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_G?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z PROC ; ATL::CComObject<COPOSDeviceMonitor>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ ; ATL::CComObject<COPOSDeviceMonitor>::~CComObject<COPOSDeviceMonitor>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0d		 je	 SHORT $LN2@scalar
  00011	68 7c 01 00 00	 push	 380			; 0000017cH
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx
$LN2@scalar:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_G?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z ENDP ; ATL::CComObject<COPOSDeviceMonitor>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface, COMDAT

; 2947 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  00003	ff 75 10	 push	 DWORD PTR _ppvObject$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _iid$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@COPOSDeviceMonitor@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B ; `COPOSDeviceMonitor::_GetEntries'::`2'::_entries
  0000e	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 2948 : 		return this->_InternalQueryInterface(iid, ppvObject);
; 2949 : 	}

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComObject<COPOSDeviceMonitor>::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ PROC ; ATL::CComObject<COPOSDeviceMonitor>::Release, COMDAT

; 2933 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2934 : 		ULONG l = this->InternalRelease();

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 444  : 		return --(*p);

  00008	83 ae dc 00 00
	00 01		 sub	 DWORD PTR [esi+220], 1
  0000f	8b be dc 00 00
	00		 mov	 edi, DWORD PTR [esi+220]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2935 : 		if (l == 0)

  00015	75 23		 jne	 SHORT $LN2@Release

; 2891 : 		_pAtlModule->Lock();

  00017	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	ff 50 04	 call	 DWORD PTR [eax+4]

; 2936 : 		{
; 2937 : 			// Lock the module to avoid DLL unload when destruction of member variables take a long time
; 2938 : 			ModuleLockHelper lock;
; 2939 : 			delete this;

  00022	85 f6		 test	 esi, esi
  00024	74 09		 je	 SHORT $LN4@Release
  00026	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	6a 01		 push	 1
  0002d	ff 12		 call	 DWORD PTR [edx]
$LN4@Release:

; 2898 : 		_pAtlModule->Unlock();

  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00035	8b 11		 mov	 edx, DWORD PTR [ecx]
  00037	ff 52 08	 call	 DWORD PTR [edx+8]
$LN2@Release:

; 2940 : 		}
; 2941 : 		return l;

  0003a	8b c7		 mov	 eax, edi
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi

; 2942 : 	}

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?Release@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ENDP ; ATL::CComObject<COPOSDeviceMonitor>::Release
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ PROC ; ATL::CComObject<COPOSDeviceMonitor>::AddRef, COMDAT

; 2929 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2930 : 		return this->InternalAddRef();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 440  : 		return ++(*p);

  00006	8b 81 dc 00 00
	00		 mov	 eax, DWORD PTR [ecx+220]
  0000c	40		 inc	 eax
  0000d	89 81 dc 00 00
	00		 mov	 DWORD PTR [ecx+220], eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2931 : 	}

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?AddRef@?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ENDP ; ATL::CComObject<COPOSDeviceMonitor>::AddRef
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??1?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ
_TEXT	SEGMENT
??1?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ PROC	; ATL::CComObject<COPOSDeviceMonitor>::~CComObject<COPOSDeviceMonitor>, COMDAT
; _this$ = ecx

; 2918 : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
  00009	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6BCComControlBase@1@@
  00010	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@1@@
  00017	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@1@@
  0001e	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleControlImpl@VCOPOSDeviceMonitor@@@1@@
  00025	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleObjectImpl@VCOPOSDeviceMonitor@@@1@@
  0002c	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@1@@
  00033	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@1@@
  0003d	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@1@@
  00047	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@1@@
  00051	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@1@@
  0005b	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@1@@
  00065	c7 86 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+148], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@1@@
  0006f	c7 86 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+152], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDataObjectImpl@VCOPOSDeviceMonitor@@@1@@
  00079	c7 86 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+156], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
  00083	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@1@@
  0008d	c7 86 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+168], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPropertyNotifySinkCP@VCOPOSDeviceMonitor@@VCComDynamicUnkArray@ATL@@@1@@
  00097	c7 86 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+180], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@@

; 2919 : 		this->m_dwRef = -(LONG_MAX/2);

  000a1	c7 86 dc 00 00
	00 01 00 00 c0	 mov	 DWORD PTR [esi+220], -1073741823 ; c0000001H

; 2920 : 		this->FinalRelease();
; 2921 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 2922 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 2923 : #endif
; 2924 : 		_pAtlModule->Unlock();

  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  000b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b3	ff 50 08	 call	 DWORD PTR [eax+8]

; 2925 : 	}

  000b6	8b ce		 mov	 ecx, esi
  000b8	5e		 pop	 esi
  000b9	e9 00 00 00 00	 jmp	 ??1COPOSDeviceMonitor@@UAE@XZ ; COPOSDeviceMonitor::~COPOSDeviceMonitor
??1?$CComObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ ENDP	; ATL::CComObject<COPOSDeviceMonitor>::~CComObject<COPOSDeviceMonitor>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??0?$CComObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$CComObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z PROC ; ATL::CComObject<COPOSDeviceMonitor>::CComObject<COPOSDeviceMonitor>, COMDAT
; _this$ = ecx

; 2911 : 	CComObject(_In_opt_ void* = NULL)

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2912 : 	{

  00003	e8 00 00 00 00	 call	 ??0COPOSDeviceMonitor@@QAE@XZ ; COPOSDeviceMonitor::COPOSDeviceMonitor
  00008	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6BCComControlBase@1@@
  00015	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@1@@
  0001c	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@1@@
  00023	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleControlImpl@VCOPOSDeviceMonitor@@@1@@
  0002a	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleObjectImpl@VCOPOSDeviceMonitor@@@1@@
  00031	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@1@@
  00038	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@1@@
  00042	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@1@@
  0004c	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@1@@
  00056	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@1@@
  00060	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@1@@
  0006a	c7 86 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+148], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@1@@
  00074	c7 86 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+152], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDataObjectImpl@VCOPOSDeviceMonitor@@@1@@
  0007e	c7 86 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+156], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
  00088	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@1@@
  00092	c7 86 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+168], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPropertyNotifySinkCP@VCOPOSDeviceMonitor@@VCComDynamicUnkArray@ATL@@@1@@
  0009c	c7 86 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+180], OFFSET ??_7?$CComObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@@

; 2913 : 		_pAtlModule->Lock();

  000a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  000ac	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ae	ff 50 04	 call	 DWORD PTR [eax+4]

; 2914 : 	}

  000b1	8b c6		 mov	 eax, esi
  000b3	5e		 pop	 esi
  000b4	c2 04 00	 ret	 4
??0?$CComObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z ENDP ; ATL::CComObject<COPOSDeviceMonitor>::CComObject<COPOSDeviceMonitor>
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_G?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z PROC ; ATL::CComAggObject<COPOSDeviceMonitor>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ ; ATL::CComAggObject<COPOSDeviceMonitor>::~CComAggObject<COPOSDeviceMonitor>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0d		 je	 SHORT $LN2@scalar
  00011	68 84 01 00 00	 push	 388			; 00000184H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx
$LN2@scalar:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_G?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z ENDP ; ATL::CComAggObject<COPOSDeviceMonitor>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_G?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z PROC ; ATL::CComContainedObject<COPOSDeviceMonitor>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1COPOSDeviceMonitor@@UAE@XZ ; COPOSDeviceMonitor::~COPOSDeviceMonitor
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0d		 je	 SHORT $LN2@scalar
  00011	68 7c 01 00 00	 push	 380			; 0000017cH
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx
$LN2@scalar:
  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??_G?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAEPAXI@Z ENDP ; ATL::CComContainedObject<COPOSDeviceMonitor>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface, COMDAT

; 3310 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2507 : 		return m_pOuterUnknown->QueryInterface(iid, ppvObject);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	ff 75 10	 push	 DWORD PTR _ppvObject$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR _iid$[ebp]
  0000c	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  00012	50		 push	 eax
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	ff 11		 call	 DWORD PTR [ecx]

; 3311 : 		return this->OuterQueryInterface(iid, ppvObject);
; 3312 : 	}

  00017	5d		 pop	 ebp
  00018	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComContainedObject<COPOSDeviceMonitor>::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ PROC ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release, COMDAT

; 3304 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2501 : 		return m_pOuterUnknown->Release();

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  0000c	50		 push	 eax
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	ff 51 08	 call	 DWORD PTR [ecx+8]

; 3305 : 		return this->OuterRelease();
; 3306 : 	}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?Release@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ENDP ; ATL::CComContainedObject<COPOSDeviceMonitor>::Release
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ PROC ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef, COMDAT

; 3300 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2497 : 		return m_pOuterUnknown->AddRef();

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [eax+220]
  0000c	50		 push	 eax
  0000d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000f	ff 51 04	 call	 DWORD PTR [ecx+4]

; 3301 : 		return this->OuterAddRef();
; 3302 : 	}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?AddRef@?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ENDP ; ATL::CComContainedObject<COPOSDeviceMonitor>::AddRef
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??0?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
_pv$ = 8						; size = 4
??0?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z PROC ; ATL::CComContainedObject<COPOSDeviceMonitor>::CComContainedObject<COPOSDeviceMonitor>, COMDAT
; _this$ = ecx

; 3287 : 	CComContainedObject(_In_opt_ void* pv)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3288 : 	{

  00006	e8 00 00 00 00	 call	 ??0COPOSDeviceMonitor@@QAE@XZ ; COPOSDeviceMonitor::COPOSDeviceMonitor

; 3289 : 		this->m_pOuterUnknown = (IUnknown*)pv;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]
  0000e	89 86 dc 00 00
	00		 mov	 DWORD PTR [esi+220], eax

; 3290 : 	}

  00014	8b c6		 mov	 eax, esi
  00016	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
  0001c	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6BCComControlBase@1@@
  00023	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@1@@
  0002a	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@1@@
  00031	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleControlImpl@VCOPOSDeviceMonitor@@@1@@
  00038	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleObjectImpl@VCOPOSDeviceMonitor@@@1@@
  0003f	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@1@@
  00046	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@1@@
  00050	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@1@@
  0005a	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@1@@
  00064	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@1@@
  0006e	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@1@@
  00078	c7 86 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+148], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@1@@
  00082	c7 86 98 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+152], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IDataObjectImpl@VCOPOSDeviceMonitor@@@1@@
  0008c	c7 86 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+156], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@1@@
  00096	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@1@@
  000a0	c7 86 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+168], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$IPropertyNotifySinkCP@VCOPOSDeviceMonitor@@VCComDynamicUnkArray@ATL@@@1@@
  000aa	c7 86 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+180], OFFSET ??_7?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@6B?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@@
  000b4	5e		 pop	 esi
  000b5	5d		 pop	 ebp
  000b6	c2 04 00	 ret	 4
??0?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z ENDP ; ATL::CComContainedObject<COPOSDeviceMonitor>::CComContainedObject<COPOSDeviceMonitor>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?QueryInterface@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::CComAggObject<COPOSDeviceMonitor>::QueryInterface, COMDAT

; 3400 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3401 : 		ATLASSERT(ppvObject != NULL);
; 3402 : 		if (ppvObject == NULL)

  00004	8b 75 10	 mov	 esi, DWORD PTR _ppvObject$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@QueryInter

; 3403 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 38		 jmp	 SHORT $LN1@QueryInter
$LN2@QueryInter:
  00012	57		 push	 edi

; 3404 : 		*ppvObject = NULL;
; 3405 : 
; 3406 : 		HRESULT hRes = S_OK;
; 3407 : 		if (InlineIsEqualUnknown(iid))

  00013	ff 75 0c	 push	 DWORD PTR _iid$[ebp]
  00016	33 ff		 xor	 edi, edi
  00018	89 3e		 mov	 DWORD PTR [esi], edi
  0001a	e8 00 00 00 00	 call	 ?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z ; ATL::InlineIsEqualUnknown
  0001f	85 c0		 test	 eax, eax
  00021	74 0d		 je	 SHORT $LN3@QueryInter

; 3408 : 		{
; 3409 : 			*ppvObject = (void*)(IUnknown*)this;

  00023	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	89 0e		 mov	 DWORD PTR [esi], ecx

; 3410 : 			AddRef();

  00028	51		 push	 ecx
  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	ff 50 04	 call	 DWORD PTR [eax+4]

; 3411 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 3412 : 			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
; 3413 : #endif // _ATL_DEBUG_INTERFACES
; 3414 : 		}

  0002e	eb 17		 jmp	 SHORT $LN4@QueryInter
$LN3@QueryInter:

; 3415 : 		else
; 3416 : 			hRes = m_contained._InternalQueryInterface(iid, ppvObject);

  00030	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  00033	56		 push	 esi
  00034	ff 75 0c	 push	 DWORD PTR _iid$[ebp]

; 3415 : 		else
; 3416 : 			hRes = m_contained._InternalQueryInterface(iid, ppvObject);

  00037	83 c0 08	 add	 eax, 8

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  0003a	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@COPOSDeviceMonitor@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B ; `COPOSDeviceMonitor::_GetEntries'::`2'::_entries
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 3415 : 		else
; 3416 : 			hRes = m_contained._InternalQueryInterface(iid, ppvObject);

  00045	8b f8		 mov	 edi, eax
$LN4@QueryInter:

; 3417 : 		return hRes;

  00047	8b c7		 mov	 eax, edi
  00049	5f		 pop	 edi
$LN1@QueryInter:
  0004a	5e		 pop	 esi

; 3418 : 	}

  0004b	5d		 pop	 ebp
  0004c	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComAggObject<COPOSDeviceMonitor>::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Release@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ PROC ; ATL::CComAggObject<COPOSDeviceMonitor>::Release, COMDAT

; 3388 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3389 : 		ULONG l = this->InternalRelease();

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 444  : 		return --(*p);

  00008	83 6e 04 01	 sub	 DWORD PTR [esi+4], 1
  0000c	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 3390 : 		if (l == 0)

  0000f	75 23		 jne	 SHORT $LN2@Release

; 2891 : 		_pAtlModule->Lock();

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	ff 50 04	 call	 DWORD PTR [eax+4]

; 3391 : 		{
; 3392 : 			ModuleLockHelper lock;
; 3393 : 			delete this;

  0001c	85 f6		 test	 esi, esi
  0001e	74 09		 je	 SHORT $LN4@Release
  00020	8b 16		 mov	 edx, DWORD PTR [esi]
  00022	8b ce		 mov	 ecx, esi
  00024	6a 01		 push	 1
  00026	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN4@Release:

; 2898 : 		_pAtlModule->Unlock();

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	ff 52 08	 call	 DWORD PTR [edx+8]
$LN2@Release:

; 3394 : 		}
; 3395 : 		return l;

  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi

; 3396 : 	}

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?Release@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ENDP ; ATL::CComAggObject<COPOSDeviceMonitor>::Release
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?AddRef@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ PROC ; ATL::CComAggObject<COPOSDeviceMonitor>::AddRef, COMDAT

; 3384 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3385 : 		return this->InternalAddRef();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 440  : 		return ++(*p);

  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	40		 inc	 eax
  0000a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 3386 : 	}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?AddRef@?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAGKXZ ENDP ; ATL::CComAggObject<COPOSDeviceMonitor>::AddRef
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??1?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ
_TEXT	SEGMENT
??1?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ PROC ; ATL::CComAggObject<COPOSDeviceMonitor>::~CComAggObject<COPOSDeviceMonitor>, COMDAT
; _this$ = ecx

; 3374 : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@6B@

; 3375 : 		this->m_dwRef = -(LONG_MAX/2);

  00009	c7 46 04 01 00
	00 c0		 mov	 DWORD PTR [esi+4], -1073741823 ; c0000001H

; 3376 : 		FinalRelease();
; 3377 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 3378 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(this);
; 3379 : #endif
; 3380 : 		_pAtlModule->Unlock();

  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	ff 50 08	 call	 DWORD PTR [eax+8]

; 3381 : 	}

  0001b	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0001e	5e		 pop	 esi
  0001f	e9 00 00 00 00	 jmp	 ??1COPOSDeviceMonitor@@UAE@XZ ; COPOSDeviceMonitor::~COPOSDeviceMonitor
??1?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@UAE@XZ ENDP ; ATL::CComAggObject<COPOSDeviceMonitor>::~CComAggObject<COPOSDeviceMonitor>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??0?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
_pv$ = 8						; size = 4
??0?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z PROC ; ATL::CComAggObject<COPOSDeviceMonitor>::CComAggObject<COPOSDeviceMonitor>, COMDAT
; _this$ = ecx

; 3347 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	ff 75 08	 push	 DWORD PTR _pv$[ebp]
  00007	8b f1		 mov	 esi, ecx

; 2430 : 		m_dwRef = 0L;

  00009	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 2431 : 	}
; 2432 : 	~CComObjectRootBase()
; 2433 : 	{
; 2434 : 	}
; 2435 : 	HRESULT FinalConstruct()
; 2436 : 	{
; 2437 : 		return S_OK;
; 2438 : 	}
; 2439 : 	// For library initialization only
; 2440 : 	_Post_satisfies_(return <= 0)   // Ensure callers handle error cases, but S_OK is only success status supported
; 2441 : 	HRESULT _AtlFinalConstruct()
; 2442 : 	{
; 2443 : 		return S_OK;
; 2444 : 	}
; 2445 : 	void FinalRelease()
; 2446 : 	{
; 2447 : 	}
; 2448 : 	void _AtlFinalRelease() // temp
; 2449 : 	{
; 2450 : 	}
; 2451 : 
; 2452 : 	void _HRPass(_In_ HRESULT hr)		// temp
; 2453 : 	{
; 2454 : 		(hr);
; 2455 : 	}
; 2456 : 
; 2457 : 	void _HRFail(_In_ HRESULT hr)		// temp...
; 2458 : 	{
; 2459 : 		(hr);
; 2460 : 	}
; 2461 : 
; 2462 : 
; 2463 : 	//ObjectMain is called during Module::Init and Module::Term
; 2464 : 	static void WINAPI ObjectMain(_In_ bool /* bStarting */);
; 2465 : 
; 2466 : 	static const struct _ATL_CATMAP_ENTRY* GetCategoryMap()
; 2467 : 	{
; 2468 : 		return NULL;
; 2469 : 	}
; 2470 : 	static HRESULT WINAPI InternalQueryInterface(
; 2471 : 		_Inout_ void* pThis,
; 2472 : 		_In_ const _ATL_INTMAP_ENTRY* pEntries,
; 2473 : 		_In_ REFIID iid,
; 2474 : 		_COM_Outptr_ void** ppvObject)
; 2475 : 	{
; 2476 : 		// Only Assert here. AtlInternalQueryInterface will return the correct HRESULT if ppvObject == NULL
; 2477 : #ifndef _ATL_OLEDB_CONFORMANCE_TESTS
; 2478 : 		ATLASSERT(ppvObject != NULL);
; 2479 : #endif
; 2480 : 		ATLASSERT(pThis != NULL);
; 2481 : 		// First entry in the com map should be a simple map entry
; 2482 : 		ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
; 2483 : 	#if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
; 2484 : 		LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
; 2485 : 		(pszClassName);
; 2486 : 	#endif // _ATL_DEBUG_INTERFACES
; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);
; 2488 : 	#if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 2489 : 		_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, pszClassName, iid);
; 2490 : 	#endif // _ATL_DEBUG_INTERFACES
; 2491 : 		return _ATLDUMPIID(iid, pszClassName, hRes);
; 2492 : 	}
; 2493 : 
; 2494 : //Outer funcs
; 2495 : 	ULONG OuterAddRef()
; 2496 : 	{
; 2497 : 		return m_pOuterUnknown->AddRef();
; 2498 : 	}
; 2499 : 	ULONG OuterRelease()
; 2500 : 	{
; 2501 : 		return m_pOuterUnknown->Release();
; 2502 : 	}
; 2503 : 	HRESULT OuterQueryInterface(
; 2504 : 		_In_ REFIID iid,
; 2505 : 		_COM_Outptr_ void** ppvObject)
; 2506 : 	{
; 2507 : 		return m_pOuterUnknown->QueryInterface(iid, ppvObject);
; 2508 : 	}
; 2509 : 
; 2510 : 	void SetVoid(_In_opt_ void*)
; 2511 : 	{
; 2512 : 	}
; 2513 : 	void InternalFinalConstructAddRef()
; 2514 : 	{
; 2515 : 	}
; 2516 : 	void InternalFinalConstructRelease()
; 2517 : 	{
; 2518 : 		ATLASSUME(m_dwRef == 0);
; 2519 : 	}
; 2520 : 	// If this assert occurs, your object has probably been deleted
; 2521 : 	// Try using DECLARE_PROTECT_FINAL_CONSTRUCT()
; 2522 : 
; 2523 :  #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 2524 : 	static HRESULT WINAPI _Break(
; 2525 : 		_In_opt_ void* /* pv */,
; 2526 : 		_In_ REFIID iid,
; 2527 : 		_COM_Outptr_result_maybenull_ void** /* ppvObject */,
; 2528 : 		_In_ DWORD_PTR /* dw */)
; 2529 : 	{
; 2530 : 		(iid);
; 2531 : 		_ATLDUMPIID(iid, _T("Break due to QI for interface "), S_OK);
; 2532 : 		__debugbreak();
; 2533 : 		_Analysis_assume_(FALSE);   // not reached, no need to analyze
; 2534 : 		return S_FALSE;
; 2535 : 	}
; 2536 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 2537 : 
; 2538 : 	static _Post_equal_to_(E_NOINTERFACE) HRESULT WINAPI _NoInterface(
; 2539 : 		_In_opt_ void* /* pv */,
; 2540 : 		_In_ REFIID /* iid */,
; 2541 : 		_Outptr_ void** /* ppvObject */,
; 2542 : 		_In_ DWORD_PTR /* dw */)
; 2543 : 	{
; 2544 : 		return E_NOINTERFACE;
; 2545 : 	}
; 2546 : 	static HRESULT WINAPI _Creator(
; 2547 : 		_In_ void* pv,
; 2548 : 		_In_ REFIID iid,
; 2549 : 		_COM_Outptr_ void** ppvObject,
; 2550 : 		_In_ DWORD_PTR dw)
; 2551 : 	{
; 2552 : 		_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw;
; 2553 : 		return pcd->pFunc(pv, iid, ppvObject);
; 2554 : 	}
; 2555 : 	static HRESULT WINAPI _Delegate(
; 2556 : 		_In_ void* pv,
; 2557 : 		_In_ REFIID iid,
; 2558 : 		_COM_Outptr_ void** ppvObject,
; 2559 : 		_In_ DWORD_PTR dw)
; 2560 : 	{
; 2561 : 		HRESULT hRes = E_NOINTERFACE;
; 2562 : 		IUnknown* p = *(IUnknown**)((DWORD_PTR)pv + dw);
; 2563 : 		*ppvObject = NULL;
; 2564 : 		if (p != NULL)
; 2565 : 			hRes = p->QueryInterface(iid, ppvObject);
; 2566 : 		return hRes;
; 2567 : 	}
; 2568 : 	static HRESULT WINAPI _Chain(
; 2569 : 		_In_ void* pv,
; 2570 : 		_In_ REFIID iid,
; 2571 : 		_COM_Outptr_ void** ppvObject,
; 2572 : 		_In_ DWORD_PTR dw)
; 2573 : 	{
; 2574 : 		_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw;
; 2575 : 		void* p = (void*)((DWORD_PTR)pv + pcd->dwOffset);
; 2576 : 		return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
; 2577 : 	}
; 2578 : 	static HRESULT WINAPI _ChainAttr(
; 2579 : 		_In_ void* pv,
; 2580 : 		_In_ REFIID iid,
; 2581 : 		_COM_Outptr_result_maybenull_ void** ppvObject,
; 2582 : 		_In_ DWORD_PTR dw)
; 2583 : 	{
; 2584 : 		const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)() = (const _ATL_INTMAP_ENTRY* (WINAPI *)())dw;
; 2585 : 		const _ATL_INTMAP_ENTRY *pEntries = pFunc();
; 2586 : 		*ppvObject = NULL;
; 2587 : 		if (pEntries == NULL)
; 2588 : 			return S_OK;
; 2589 : 		return InternalQueryInterface(pv, pEntries, iid, ppvObject);
; 2590 : 	}
; 2591 : 	static HRESULT WINAPI _Cache(
; 2592 : 		_In_ void* pv,
; 2593 : 		_In_ REFIID iid,
; 2594 : 		_COM_Outptr_result_maybenull_ void** ppvObject,
; 2595 : 		_In_ DWORD_PTR dw)
; 2596 : 	{
; 2597 : 		HRESULT hRes = E_NOINTERFACE;
; 2598 : 		_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
; 2599 : 		IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
; 2600 : 		*ppvObject = NULL;
; 2601 : 		if (*pp == NULL)
; 2602 : 			hRes = pcd->pFunc(pv, __uuidof(IUnknown), (void**)pp);
; 2603 : 		if (*pp != NULL)
; 2604 : 			hRes = (*pp)->QueryInterface(iid, ppvObject);
; 2605 : 		return hRes;
; 2606 : 	}
; 2607 : 
; 2608 : 	union
; 2609 : 	{
; 2610 : 		long m_dwRef;
; 2611 : 		IUnknown* m_pOuterUnknown;
; 2612 : 	};
; 2613 : };
; 2614 : 
; 2615 : #pragma managed(push, off)
; 2616 : inline void WINAPI CComObjectRootBase::ObjectMain(_In_ bool /* bStarting */)
; 2617 : {
; 2618 : }
; 2619 : #pragma managed(pop)
; 2620 : 
; 2621 : 
; 2622 : //forward declaration
; 2623 : template <class ThreadModel>
; 2624 : class CComObjectRootEx;
; 2625 : 
; 2626 : template <class ThreadModel>
; 2627 : class CComObjectLockT
; 2628 : {
; 2629 : public:
; 2630 : 	CComObjectLockT(_Inout_opt_ CComObjectRootEx<ThreadModel>* p)
; 2631 : 	{
; 2632 : 		if (p)
; 2633 : 			p->Lock();
; 2634 : 		m_p = p;
; 2635 : 	}
; 2636 : 
; 2637 : 	~CComObjectLockT()
; 2638 : 	{
; 2639 : 		if (m_p)
; 2640 : 			m_p->Unlock();
; 2641 : 	}
; 2642 : 	CComObjectRootEx<ThreadModel>* m_p;
; 2643 : };
; 2644 : 
; 2645 : template <> class CComObjectLockT<CComSingleThreadModel>;
; 2646 : 
; 2647 : #pragma warning(push)
; 2648 : #pragma warning(disable:26165 26167) // Macro instantiated lock object '(this->m_critsec).m_sec'
; 2649 : template <class ThreadModel>
; 2650 : class CComObjectRootEx :
; 2651 : 	public CComObjectRootBase
; 2652 : {
; 2653 : public:
; 2654 : 	typedef ThreadModel _ThreadModel;
; 2655 : 	typedef typename _ThreadModel::AutoCriticalSection _CritSec;
; 2656 : 	typedef typename _ThreadModel::AutoDeleteCriticalSection _AutoDelCritSec;
; 2657 : 	typedef CComObjectLockT<_ThreadModel> ObjectLock;
; 2658 : 
; 2659 : 	~CComObjectRootEx()
; 2660 : 	{
; 2661 : 	}
; 2662 : 
; 2663 : 	ULONG InternalAddRef()
; 2664 : 	{
; 2665 : 		ATLASSUME(m_dwRef != -1L);
; 2666 : 		return _ThreadModel::Increment(&m_dwRef);
; 2667 : 	}
; 2668 : 	ULONG InternalRelease()
; 2669 : 	{
; 2670 : #ifdef _DEBUG
; 2671 : 		LONG nRef = _ThreadModel::Decrement(&m_dwRef);
; 2672 : 		if (nRef < -(LONG_MAX / 2))
; 2673 : 		{
; 2674 : 			ATLASSERT(0 && _T("Release called on a pointer that has already been released"));
; 2675 : 		}
; 2676 : 		return nRef;
; 2677 : #else
; 2678 : 		return _ThreadModel::Decrement(&m_dwRef);
; 2679 : #endif
; 2680 : 	}
; 2681 : 
; 2682 : 	HRESULT _AtlInitialConstruct()
; 2683 : 	{
; 2684 : 		return m_critsec.Init();
; 2685 : 	}
; 2686 : 	void Lock()
; 2687 : 	{
; 2688 : 		m_critsec.Lock();
; 2689 : 	}
; 2690 : 	void Unlock()
; 2691 : 	{
; 2692 : #pragma warning(suppress: 26110) // Macro instantiated lock object '(this->m_critsec).m_sec'
; 2693 : 		m_critsec.Unlock();
; 2694 : 	}
; 2695 : private:
; 2696 : 	_AutoDelCritSec m_critsec;
; 2697 : };
; 2698 : #pragma warning(pop)
; 2699 : 
; 2700 : template <>
; 2701 : class CComObjectRootEx<CComSingleThreadModel> :
; 2702 : 	public CComObjectRootBase
; 2703 : {
; 2704 : public:
; 2705 : 	typedef CComSingleThreadModel _ThreadModel;
; 2706 : 	typedef _ThreadModel::AutoCriticalSection _CritSec;
; 2707 : 	typedef _ThreadModel::AutoDeleteCriticalSection _AutoDelCritSec;
; 2708 : 	typedef CComObjectLockT<_ThreadModel> ObjectLock;
; 2709 : 
; 2710 : 	~CComObjectRootEx() {}
; 2711 : 
; 2712 : 	ULONG InternalAddRef()
; 2713 : 	{
; 2714 : 		ATLASSUME(m_dwRef != -1L);
; 2715 : 		return _ThreadModel::Increment(&m_dwRef);
; 2716 : 	}
; 2717 : 	ULONG InternalRelease()
; 2718 : 	{
; 2719 : #ifdef _DEBUG
; 2720 : 		long nRef = _ThreadModel::Decrement(&m_dwRef);
; 2721 : 		if (nRef < -(LONG_MAX / 2))
; 2722 : 		{
; 2723 : 			ATLASSERT(0 && _T("Release called on a pointer that has already been released"));
; 2724 : 		}
; 2725 : 		return nRef;
; 2726 : #else
; 2727 : 		return _ThreadModel::Decrement(&m_dwRef);
; 2728 : #endif
; 2729 : 	}
; 2730 : 
; 2731 : 	HRESULT _AtlInitialConstruct()
; 2732 : 	{
; 2733 : 		return S_OK;
; 2734 : 	}
; 2735 : 
; 2736 : 	void Lock()
; 2737 : 	{
; 2738 : 	}
; 2739 : 	void Unlock()
; 2740 : 	{
; 2741 : 	}
; 2742 : };
; 2743 : 
; 2744 : template <>
; 2745 : class CComObjectLockT<CComSingleThreadModel>
; 2746 : {
; 2747 : public:
; 2748 : 	CComObjectLockT(_Inout_opt_ CComObjectRootEx<CComSingleThreadModel>*)
; 2749 : 	{
; 2750 : 	}
; 2751 : 	~CComObjectLockT()
; 2752 : 	{
; 2753 : 	}
; 2754 : };
; 2755 : 
; 2756 : typedef CComObjectRootEx<CComObjectThreadModel> CComObjectRoot;
; 2757 : 
; 2758 : #if defined(_WINDLL) | defined(_USRDLL)
; 2759 : #define DECLARE_CLASSFACTORY_EX(cf) typedef ATL::CComCreator< ATL::CComObjectCached< cf > > _ClassFactoryCreatorClass;
; 2760 : #else
; 2761 : // don't let class factory refcount influence lock count
; 2762 : #define DECLARE_CLASSFACTORY_EX(cf) typedef ATL::CComCreator< ATL::CComObjectNoLock< cf > > _ClassFactoryCreatorClass;
; 2763 : #endif
; 2764 : #define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(ATL::CComClassFactory)
; 2765 : #define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(ATL::CComClassFactory2<lic>)
; 2766 : #define DECLARE_CLASSFACTORY_AUTO_THREAD() DECLARE_CLASSFACTORY_EX(ATL::CComClassFactoryAutoThread)
; 2767 : #define DECLARE_CLASSFACTORY_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(ATL::CComClassFactorySingleton<obj>)
; 2768 : 
; 2769 : #define DECLARE_NO_REGISTRY()\
; 2770 : 	static HRESULT WINAPI UpdateRegistry(_In_ BOOL /*bRegister*/) throw()\
; 2771 : 	{return S_OK;}
; 2772 : 
; 2773 : #ifdef _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 2774 : 
; 2775 : #define DECLARE_OBJECT_DESCRIPTION(x)\
; 2776 : 	static LPCTSTR WINAPI GetObjectDescription() throw()\
; 2777 : 	{\
; 2778 : 		return _T(x);\
; 2779 : 	}
; 2780 : 
; 2781 : #define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\
; 2782 : 	static HRESULT WINAPI UpdateRegistry(_In_ BOOL bRegister) throw()\
; 2783 : 	{\
; 2784 : 		return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\
; 2785 : 			flags, bRegister);\
; 2786 : 	}
; 2787 : 
; 2788 : #define DECLARE_REGISTRY_RESOURCE(x)\
; 2789 : 	static HRESULT WINAPI UpdateRegistry(_In_ BOOL bRegister) throw()\
; 2790 : 	{\
; 2791 : 		__if_exists(_GetMiscStatus) \
; 2792 : 		{ \
; 2793 : 			ATL::_ATL_REGMAP_ENTRY regMapEntries[2]; \
; 2794 : 			memset(&regMapEntries[1], 0, sizeof(ATL::_ATL_REGMAP_ENTRY)); \
; 2795 : 			regMapEntries[0].szKey = L"OLEMISC"; \
; 2796 : 			TCHAR szOleMisc[32]; \
; 2797 : 			ATL::Checked::itot_s(_GetMiscStatus(), szOleMisc, _countof(szOleMisc), 10); \
; 2798 : 			USES_CONVERSION_EX; \
; 2799 : 			regMapEntries[0].szData = T2OLE_EX(szOleMisc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD); \
; 2800 : 			if (regMapEntries[0].szData == NULL) \
; 2801 : 				return E_OUTOFMEMORY; \
; 2802 : 			__if_exists(_Module) \
; 2803 : 			{ \
; 2804 : 				return _Module.UpdateRegistryFromResource(_T(#x), bRegister, regMapEntries); \
; 2805 : 			} \
; 2806 : 			__if_not_exists(_Module) \
; 2807 : 			{ \
; 2808 : 				return ATL::_pAtlModule->UpdateRegistryFromResource(_T(#x), bRegister, regMapEntries); \
; 2809 : 			} \
; 2810 : 		} \
; 2811 : 		__if_not_exists(_GetMiscStatus) \
; 2812 : 		{ \
; 2813 : 			__if_exists(_Module) \
; 2814 : 			{ \
; 2815 : 				return _Module.UpdateRegistryFromResource(_T(#x), bRegister); \
; 2816 : 			} \
; 2817 : 			__if_not_exists(_Module) \
; 2818 : 			{ \
; 2819 : 				return ATL::_pAtlModule->UpdateRegistryFromResource(_T(#x), bRegister); \
; 2820 : 			} \
; 2821 : 		} \
; 2822 : 	}
; 2823 : 
; 2824 : #define DECLARE_REGISTRY_RESOURCEID(x)\
; 2825 : 	static HRESULT WINAPI UpdateRegistry(_In_ BOOL bRegister) throw()\
; 2826 : 	{\
; 2827 : 		__if_exists(_GetMiscStatus) \
; 2828 : 		{ \
; 2829 : 			ATL::_ATL_REGMAP_ENTRY regMapEntries[2]; \
; 2830 : 			memset(&regMapEntries[1], 0, sizeof(ATL::_ATL_REGMAP_ENTRY)); \
; 2831 : 			regMapEntries[0].szKey = L"OLEMISC"; \
; 2832 : 			TCHAR szOleMisc[32]; \
; 2833 : 			ATL::Checked::itot_s(_GetMiscStatus(), szOleMisc, _countof(szOleMisc), 10); \
; 2834 : 			USES_CONVERSION_EX; \
; 2835 : 			regMapEntries[0].szData = T2OLE_EX(szOleMisc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD); \
; 2836 : 			if (regMapEntries[0].szData == NULL) \
; 2837 : 				return E_OUTOFMEMORY; \
; 2838 : 			__if_exists(_Module) \
; 2839 : 			{ \
; 2840 : 				return _Module.UpdateRegistryFromResource(x, bRegister, regMapEntries); \
; 2841 : 			} \
; 2842 : 			__if_not_exists(_Module) \
; 2843 : 			{ \
; 2844 : 				return ATL::_pAtlModule->UpdateRegistryFromResource(x, bRegister, regMapEntries); \
; 2845 : 			} \
; 2846 : 		} \
; 2847 : 		__if_not_exists(_GetMiscStatus) \
; 2848 : 		{ \
; 2849 : 			__if_exists(_Module) \
; 2850 : 			{ \
; 2851 : 				return _Module.UpdateRegistryFromResource(x, bRegister); \
; 2852 : 			} \
; 2853 : 			__if_not_exists(_Module) \
; 2854 : 			{ \
; 2855 : 				return ATL::_pAtlModule->UpdateRegistryFromResource(x, bRegister); \
; 2856 : 			} \
; 2857 : 		} \
; 2858 : 	}
; 2859 : 
; 2860 : #endif // _ATL_USE_WINAPI_FAMILY_DESKTOP_APP
; 2861 : 
; 2862 : #define DECLARE_OLEMISC_STATUS(x) \
; 2863 : 	static DWORD _GetMiscStatus() throw() \
; 2864 : 	{ \
; 2865 : 		static DWORD m_dwOleMisc = x; \
; 2866 : 		return m_dwOleMisc; \
; 2867 : 	}
; 2868 : 
; 2869 : template<class Base> class CComObject; // fwd decl
; 2870 : 
; 2871 : template <class Owner, class ThreadModel = CComObjectThreadModel>
; 2872 : class CComTearOffObjectBase :
; 2873 : 	public CComObjectRootEx<ThreadModel>
; 2874 : {
; 2875 : public:
; 2876 : 	typedef Owner _OwnerClass;
; 2877 : 	Owner* m_pOwner;
; 2878 : 	CComTearOffObjectBase()
; 2879 : 	{
; 2880 : 		m_pOwner = NULL;
; 2881 : 	}
; 2882 : };
; 2883 : 
; 2884 : // ModuleLockHelper handles unlocking module while going out of scope
; 2885 : class ModuleLockHelper
; 2886 : {
; 2887 : public:
; 2888 : 	ModuleLockHelper()
; 2889 : 	{
; 2890 : #ifndef _ATL_STATIC_LIB_IMPL
; 2891 : 		_pAtlModule->Lock();
; 2892 : #endif
; 2893 : 	}
; 2894 : 
; 2895 : 	~ModuleLockHelper()
; 2896 : 	{
; 2897 : #ifndef _ATL_STATIC_LIB_IMPL
; 2898 : 		_pAtlModule->Unlock();
; 2899 : #endif
; 2900 : 	}
; 2901 : };
; 2902 : 
; 2903 : //Base is the user's class that derives from CComObjectRoot and whatever
; 2904 : //interfaces the user wants to support on the object
; 2905 : template <class Base>
; 2906 : class CComObject :
; 2907 : 	public Base
; 2908 : {
; 2909 : public:
; 2910 : 	typedef Base _BaseClass;
; 2911 : 	CComObject(_In_opt_ void* = NULL)
; 2912 : 	{
; 2913 : 		_pAtlModule->Lock();
; 2914 : 	}
; 2915 : 	// Set refcount to -(LONG_MAX/2) to protect destruction and
; 2916 : 	// also catch mismatched Release in debug builds
; 2917 : 	virtual ~CComObject()
; 2918 : 	{
; 2919 : 		this->m_dwRef = -(LONG_MAX/2);
; 2920 : 		this->FinalRelease();
; 2921 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 2922 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 2923 : #endif
; 2924 : 		_pAtlModule->Unlock();
; 2925 : 	}
; 2926 : 	//If InternalAddRef or InternalRelease is undefined then your class
; 2927 : 	//doesn't derive from CComObjectRoot
; 2928 : 	STDMETHOD_(ULONG, AddRef)()
; 2929 : 	{
; 2930 : 		return this->InternalAddRef();
; 2931 : 	}
; 2932 : 	STDMETHOD_(ULONG, Release)()
; 2933 : 	{
; 2934 : 		ULONG l = this->InternalRelease();
; 2935 : 		if (l == 0)
; 2936 : 		{
; 2937 : 			// Lock the module to avoid DLL unload when destruction of member variables take a long time
; 2938 : 			ModuleLockHelper lock;
; 2939 : 			delete this;
; 2940 : 		}
; 2941 : 		return l;
; 2942 : 	}
; 2943 : 	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
; 2944 : 	STDMETHOD(QueryInterface)(
; 2945 : 		REFIID iid,
; 2946 : 		_COM_Outptr_ void** ppvObject) throw()
; 2947 : 	{
; 2948 : 		return this->_InternalQueryInterface(iid, ppvObject);
; 2949 : 	}
; 2950 : 	template <class Q>
; 2951 : 	HRESULT STDMETHODCALLTYPE QueryInterface(
; 2952 : 		_COM_Outptr_ Q** pp) throw()
; 2953 : 	{
; 2954 : 		return QueryInterface(__uuidof(Q), (void**)pp);
; 2955 : 	}
; 2956 : 
; 2957 : 	static HRESULT WINAPI CreateInstance(_COM_Outptr_ CComObject<Base>** pp) throw();
; 2958 : };
; 2959 : 
; 2960 : template <class Base>
; 2961 : HRESULT WINAPI CComObject<Base>::CreateInstance(
; 2962 : 	_COM_Outptr_ CComObject<Base>** pp) throw()
; 2963 : {
; 2964 : 	ATLASSERT(pp != NULL);
; 2965 : 	if (pp == NULL)
; 2966 : 		return E_POINTER;
; 2967 : 	*pp = NULL;
; 2968 : 
; 2969 : 	HRESULT hRes = E_OUTOFMEMORY;
; 2970 : 	CComObject<Base>* p = NULL;
; 2971 : 	ATLTRY(p = _ATL_NEW CComObject<Base>())
; 2972 : 	if (p != NULL)
; 2973 : 	{
; 2974 : 		p->SetVoid(NULL);
; 2975 : 		p->InternalFinalConstructAddRef();
; 2976 : 		hRes = p->_AtlInitialConstruct();
; 2977 : 		if (SUCCEEDED(hRes))
; 2978 : 			hRes = p->FinalConstruct();
; 2979 : 		if (SUCCEEDED(hRes))
; 2980 : 			hRes = p->_AtlFinalConstruct();
; 2981 : 		p->InternalFinalConstructRelease();
; 2982 : 		if (hRes != S_OK)
; 2983 : 		{
; 2984 : 			delete p;
; 2985 : 			p = NULL;
; 2986 : 		}
; 2987 : 	}
; 2988 : 	*pp = p;
; 2989 : 	return hRes;
; 2990 : }
; 2991 : 
; 2992 : //Base is the user's class that derives from CComObjectRoot and whatever
; 2993 : //interfaces the user wants to support on the object
; 2994 : // CComObjectCached is used primarily for class factories in DLL's
; 2995 : // but it is useful anytime you want to cache an object
; 2996 : template <class Base>
; 2997 : class CComObjectCached :
; 2998 : 	public Base
; 2999 : {
; 3000 : public:
; 3001 : 	typedef Base _BaseClass;
; 3002 : 	CComObjectCached(_In_opt_ void* = NULL)
; 3003 : 	{
; 3004 : 	}
; 3005 : 	// Set refcount to -(LONG_MAX/2) to protect destruction and
; 3006 : 	// also catch mismatched Release in debug builds
; 3007 : 	virtual ~CComObjectCached()
; 3008 : 	{
; 3009 : 		this->m_dwRef = -(LONG_MAX/2);
; 3010 : 		this->FinalRelease();
; 3011 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 3012 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 3013 : #endif
; 3014 : 	}
; 3015 : 	//If InternalAddRef or InternalRelease is undefined then your class
; 3016 : 	//doesn't derive from CComObjectRoot
; 3017 : 	STDMETHOD_(ULONG, AddRef)() throw()
; 3018 : 	{
; 3019 : 		ULONG l = this->InternalAddRef();
; 3020 : 		if (l == 2)
; 3021 : 			_pAtlModule->Lock();
; 3022 : 		return l;
; 3023 : 	}
; 3024 : 	STDMETHOD_(ULONG, Release)() throw()
; 3025 : 	{
; 3026 : 		ULONG l = this->InternalRelease();
; 3027 : 		if (l == 0)
; 3028 : 			delete this;
; 3029 : 		else if (l == 1)
; 3030 : 			_pAtlModule->Unlock();
; 3031 : 		return l;
; 3032 : 	}
; 3033 : 	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
; 3034 : 	STDMETHOD(QueryInterface)(
; 3035 : 		REFIID iid,
; 3036 : 		_COM_Outptr_ void** ppvObject) throw()
; 3037 : 	{
; 3038 : 		return this->_InternalQueryInterface(iid, ppvObject);
; 3039 : 	}
; 3040 : 	static _Success_(return == S_OK) HRESULT WINAPI CreateInstance(
; 3041 : 		_COM_Outptr_ CComObjectCached<Base>** pp) throw();
; 3042 : };
; 3043 : 
; 3044 : template <class Base>
; 3045 : _Success_(return == S_OK) HRESULT WINAPI CComObjectCached<Base>::CreateInstance(
; 3046 : 	_COM_Outptr_ CComObjectCached<Base>** pp) throw()
; 3047 : {
; 3048 : 	ATLASSERT(pp != NULL);
; 3049 : 	if (pp == NULL)
; 3050 : 		return E_POINTER;
; 3051 : 	*pp = NULL;
; 3052 : 
; 3053 : 	HRESULT hRes = E_OUTOFMEMORY;
; 3054 : 	CComObjectCached<Base>* p = NULL;
; 3055 : 	ATLTRY(p = _ATL_NEW CComObjectCached<Base>())
; 3056 : 	if (p != NULL)
; 3057 : 	{
; 3058 : 		p->SetVoid(NULL);
; 3059 : 		p->InternalFinalConstructAddRef();
; 3060 : 		hRes = p->_AtlInitialConstruct();
; 3061 : 		if (SUCCEEDED(hRes))
; 3062 : 			hRes = p->FinalConstruct();
; 3063 : 		if (SUCCEEDED(hRes))
; 3064 : 			hRes = p->_AtlFinalConstruct();
; 3065 : 		p->InternalFinalConstructRelease();
; 3066 : 		if (hRes != S_OK)
; 3067 : 		{
; 3068 : 			delete p;
; 3069 : 			p = NULL;
; 3070 : 		}
; 3071 : 	}
; 3072 : 	*pp = p;
; 3073 : 	return hRes;
; 3074 : }
; 3075 : 
; 3076 : 
; 3077 : //Base is the user's class that derives from CComObjectRoot and whatever
; 3078 : //interfaces the user wants to support on the object
; 3079 : template <class Base>
; 3080 : class CComObjectNoLock :
; 3081 : 	public Base
; 3082 : {
; 3083 : public:
; 3084 : 	typedef Base _BaseClass;
; 3085 : 	CComObjectNoLock(_In_opt_ void* = NULL)
; 3086 : 	{
; 3087 : 	}
; 3088 : 	// Set refcount to -(LONG_MAX/2) to protect destruction and
; 3089 : 	// also catch mismatched Release in debug builds
; 3090 : 
; 3091 : 	virtual ~CComObjectNoLock()
; 3092 : 	{
; 3093 : 		this->m_dwRef = -(LONG_MAX/2);
; 3094 : 		this->FinalRelease();
; 3095 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 3096 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 3097 : #endif
; 3098 : 	}
; 3099 : 
; 3100 : 	//If InternalAddRef or InternalRelease is undefined then your class
; 3101 : 	//doesn't derive from CComObjectRoot
; 3102 : 	STDMETHOD_(ULONG, AddRef)() throw()
; 3103 : 	{
; 3104 : 		return this->InternalAddRef();
; 3105 : 	}
; 3106 : 	STDMETHOD_(ULONG, Release)() throw()
; 3107 : 	{
; 3108 : 		ULONG l = this->InternalRelease();
; 3109 : 		if (l == 0)
; 3110 : 			delete this;
; 3111 : 		return l;
; 3112 : 	}
; 3113 : 	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
; 3114 : 	STDMETHOD(QueryInterface)(
; 3115 : 		REFIID iid,
; 3116 : 		_COM_Outptr_ void** ppvObject) throw()
; 3117 : 	{
; 3118 : 		return this->_InternalQueryInterface(iid, ppvObject);
; 3119 : 	}
; 3120 : };
; 3121 : 
; 3122 : 
; 3123 : // It is possible for Base not to derive from CComObjectRoot
; 3124 : // However, you will need to provide _InternalQueryInterface
; 3125 : template <class Base>
; 3126 : class CComObjectGlobal :
; 3127 : 	public Base
; 3128 : {
; 3129 : public:
; 3130 : 	typedef Base _BaseClass;
; 3131 : 	CComObjectGlobal(_In_opt_ void* = NULL)
; 3132 : 	{
; 3133 : 		m_hResFinalConstruct = S_OK;
; 3134 : 		__if_exists(FinalConstruct)
; 3135 : 		{
; 3136 : 			__if_exists(InternalFinalConstructAddRef)
; 3137 : 			{
; 3138 : 				InternalFinalConstructAddRef();
; 3139 : 			}
; 3140 : 			m_hResFinalConstruct = _AtlInitialConstruct();
; 3141 : 			if (SUCCEEDED(m_hResFinalConstruct))
; 3142 : 				m_hResFinalConstruct = FinalConstruct();
; 3143 : 			__if_exists(InternalFinalConstructRelease)
; 3144 : 			{
; 3145 : 				InternalFinalConstructRelease();
; 3146 : 			}
; 3147 : 		}
; 3148 : 	}
; 3149 : 	virtual ~CComObjectGlobal()
; 3150 : 	{
; 3151 : 		__if_exists(FinalRelease)
; 3152 : 		{
; 3153 : 			FinalRelease();
; 3154 : 		}
; 3155 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 3156 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 3157 : #endif
; 3158 : 	}
; 3159 : 
; 3160 : 	STDMETHOD_(ULONG, AddRef)() throw()
; 3161 : 	{
; 3162 : 		return _pAtlModule->Lock();
; 3163 : 	}
; 3164 : 	STDMETHOD_(ULONG, Release)() throw()
; 3165 : 	{
; 3166 : 		return _pAtlModule->Unlock();
; 3167 : 	}
; 3168 : 	STDMETHOD(QueryInterface)(
; 3169 : 		REFIID iid,
; 3170 : 		_COM_Outptr_ void** ppvObject) throw()
; 3171 : 	{
; 3172 : 		return this->_InternalQueryInterface(iid, ppvObject);
; 3173 : 	}
; 3174 : 	HRESULT m_hResFinalConstruct;
; 3175 : };
; 3176 : 
; 3177 : // It is possible for Base not to derive from CComObjectRoot
; 3178 : // However, you will need to provide FinalConstruct and InternalQueryInterface
; 3179 : template <class Base>
; 3180 : class CComObjectStack :
; 3181 : 	public Base
; 3182 : {
; 3183 : public:
; 3184 : 	typedef Base _BaseClass;
; 3185 : 	CComObjectStack(_In_opt_ void* = NULL)
; 3186 : 	{
; 3187 : 		m_hResFinalConstruct = this->_AtlInitialConstruct();
; 3188 : 		if (SUCCEEDED(m_hResFinalConstruct))
; 3189 : 			m_hResFinalConstruct = this->FinalConstruct();
; 3190 : 	}
; 3191 : 	virtual ~CComObjectStack()
; 3192 : 	{
; 3193 : 		this->FinalRelease();
; 3194 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 3195 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 3196 : #endif
; 3197 : 	}
; 3198 : 
; 3199 : 	STDMETHOD_(ULONG, AddRef)() throw()
; 3200 : 	{
; 3201 : 		ATLASSERT(FALSE);
; 3202 : 		return 0;
; 3203 : 	}
; 3204 : 	STDMETHOD_(ULONG, Release)() throw()
; 3205 : 	{
; 3206 : 		ATLASSERT(FALSE);
; 3207 : 		return 0;
; 3208 : 	}
; 3209 : 	STDMETHOD(QueryInterface)(
; 3210 : 		REFIID,
; 3211 : 		_COM_Outptr_ void** ppvObject) throw()
; 3212 : 	{
; 3213 : 		ATLASSERT(FALSE);
; 3214 : 		*ppvObject = NULL;
; 3215 : 		return E_NOINTERFACE;
; 3216 : 	}
; 3217 : 	HRESULT m_hResFinalConstruct;
; 3218 : };
; 3219 : 
; 3220 : // Base must be derived from CComObjectRoot
; 3221 : template <class Base>
; 3222 : class CComObjectStackEx :
; 3223 : 	public Base
; 3224 : {
; 3225 : public:
; 3226 : 	typedef Base _BaseClass;
; 3227 : 
; 3228 : 	CComObjectStackEx(_In_opt_ void* = NULL)
; 3229 : 	{
; 3230 : #ifdef _DEBUG
; 3231 : 		this->m_dwRef = 0;
; 3232 : #endif
; 3233 : 		m_hResFinalConstruct = this->_AtlInitialConstruct();
; 3234 : 		if (SUCCEEDED(m_hResFinalConstruct))
; 3235 : 			m_hResFinalConstruct = this->FinalConstruct();
; 3236 : 	}
; 3237 : 
; 3238 : 	virtual ~CComObjectStackEx()
; 3239 : 	{
; 3240 : 		// This assert indicates mismatched ref counts.
; 3241 : 		//
; 3242 : 		// The ref count has no control over the
; 3243 : 		// lifetime of this object, so you must ensure
; 3244 : 		// by some other means that the object remains
; 3245 : 		// alive while clients have references to its interfaces.
; 3246 : 		ATLASSUME(this->m_dwRef == 0);
; 3247 : 		this->FinalRelease();
; 3248 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 3249 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 3250 : #endif
; 3251 : 	}
; 3252 : 
; 3253 : 	STDMETHOD_(ULONG, AddRef)() throw()
; 3254 : 	{
; 3255 : #ifdef _DEBUG
; 3256 : 		return this->InternalAddRef();
; 3257 : #else
; 3258 : 		return 0;
; 3259 : #endif
; 3260 : 	}
; 3261 : 
; 3262 : 	STDMETHOD_(ULONG, Release)() throw()
; 3263 : 	{
; 3264 : #ifdef _DEBUG
; 3265 : 		return this->InternalRelease();
; 3266 : #else
; 3267 : 		return 0;
; 3268 : #endif
; 3269 : 	}
; 3270 : 
; 3271 : 	STDMETHOD(QueryInterface)(
; 3272 : 		REFIID iid,
; 3273 : 		_COM_Outptr_ void** ppvObject) throw()
; 3274 : 	{
; 3275 : 		return this->_InternalQueryInterface(iid, ppvObject);
; 3276 : 	}
; 3277 : 
; 3278 : 	HRESULT m_hResFinalConstruct;
; 3279 : };
; 3280 : 
; 3281 : template <class Base> //Base must be derived from CComObjectRoot
; 3282 : class CComContainedObject :
; 3283 : 	public Base
; 3284 : {
; 3285 : public:
; 3286 : 	typedef Base _BaseClass;
; 3287 : 	CComContainedObject(_In_opt_ void* pv)
; 3288 : 	{
; 3289 : 		this->m_pOuterUnknown = (IUnknown*)pv;
; 3290 : 	}
; 3291 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 3292 : 	virtual ~CComContainedObject()
; 3293 : 	{
; 3294 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 3295 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(m_pOuterUnknown);
; 3296 : 	}
; 3297 : #endif
; 3298 : 
; 3299 : 	STDMETHOD_(ULONG, AddRef)() throw()
; 3300 : 	{
; 3301 : 		return this->OuterAddRef();
; 3302 : 	}
; 3303 : 	STDMETHOD_(ULONG, Release)() throw()
; 3304 : 	{
; 3305 : 		return this->OuterRelease();
; 3306 : 	}
; 3307 : 	STDMETHOD(QueryInterface)(
; 3308 : 		REFIID iid,
; 3309 : 		_COM_Outptr_ void** ppvObject) throw()
; 3310 : 	{
; 3311 : 		return this->OuterQueryInterface(iid, ppvObject);
; 3312 : 	}
; 3313 : 	template <class Q>
; 3314 : 	HRESULT STDMETHODCALLTYPE QueryInterface(
; 3315 : 		_COM_Outptr_ Q** pp)
; 3316 : 	{
; 3317 : 		return QueryInterface(__uuidof(Q), (void**)pp);
; 3318 : 	}
; 3319 : 	//GetControllingUnknown may be virtual if the Base class has declared
; 3320 : 	//DECLARE_GET_CONTROLLING_UNKNOWN()
; 3321 : 	IUnknown* GetControllingUnknown() throw()
; 3322 : 	{
; 3323 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 3324 : 		IUnknown* p;
; 3325 : 		_AtlDebugInterfacesModule.AddNonAddRefThunk(m_pOuterUnknown, _T("CComContainedObject"), &p);
; 3326 : 		return p;
; 3327 : #else
; 3328 : 		return this->m_pOuterUnknown;
; 3329 : #endif
; 3330 : 	}
; 3331 : };
; 3332 : 
; 3333 : //contained is the user's class that derives from CComObjectRoot and whatever
; 3334 : //interfaces the user wants to support on the object
; 3335 : template <class contained>
; 3336 : class CComAggObject :
; 3337 : 	public IUnknown,
; 3338 : 	public CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS>
; 3339 : {
; 3340 : private:
; 3341 : 	typedef CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS> _MyCComObjectRootEx;
; 3342 : 
; 3343 : public:
; 3344 : 	typedef contained _BaseClass;
; 3345 : 	CComAggObject(_In_opt_ void* pv) :
; 3346 : 		m_contained(pv)

  0000d	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]

; 3347 : 	{

  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@6B@
  00016	e8 00 00 00 00	 call	 ??0?$CComContainedObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z ; ATL::CComContainedObject<COPOSDeviceMonitor>::CComContainedObject<COPOSDeviceMonitor>

; 3348 : 		_pAtlModule->Lock();

  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	ff 50 04	 call	 DWORD PTR [eax+4]

; 3349 : 	}

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z ENDP ; ATL::CComAggObject<COPOSDeviceMonitor>::CComAggObject<COPOSDeviceMonitor>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAddThrow@K@ATL@@YAKKK@Z
_TEXT	SEGMENT
_tResult$ = -4						; size = 4
_tLeft$ = 8						; size = 4
_tRight$ = 12						; size = 4
??$AtlAddThrow@K@ATL@@YAKKK@Z PROC			; ATL::AtlAddThrow<unsigned long>, COMDAT

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 194  : 	T tResult;
; 195  : 	HRESULT hr=AtlAdd(&tResult, tLeft, tRight);

  00004	ff 75 0c	 push	 DWORD PTR _tRight$[ebp]
  00007	8d 45 fc	 lea	 eax, DWORD PTR _tResult$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _tLeft$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??$AtlAdd@K@ATL@@YAJPAKKK@Z ; ATL::AtlAdd<unsigned long>
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 196  : 	if(FAILED(hr))

  00016	85 c0		 test	 eax, eax
  00018	78 05		 js	 SHORT $LN6@AtlAddThro

; 199  : 	}
; 200  : 	return tResult;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _tResult$[ebp]

; 201  : }

  0001d	c9		 leave
  0001e	c3		 ret	 0
$LN6@AtlAddThro:

; 197  : 	{
; 198  : 		AtlThrow(hr);

  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN4@AtlAddThro:
  00025	cc		 int	 3
??$AtlAddThrow@K@ATL@@YAKKK@Z ENDP			; ATL::AtlAddThrow<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiplyThrow@I@ATL@@YAIII@Z
_TEXT	SEGMENT
_tResult$ = -4						; size = 4
_tLeft$ = 8						; size = 4
_tRight$ = 12						; size = 4
??$AtlMultiplyThrow@I@ATL@@YAIII@Z PROC			; ATL::AtlMultiplyThrow<unsigned int>, COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 180  : 	T tResult;
; 181  : 	HRESULT hr=AtlMultiply(&tResult, tLeft, tRight);

  00004	ff 75 0c	 push	 DWORD PTR _tRight$[ebp]
  00007	8d 45 fc	 lea	 eax, DWORD PTR _tResult$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _tLeft$[ebp]
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??$AtlMultiply@I@ATL@@YAJPAIII@Z ; ATL::AtlMultiply<unsigned int>
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 182  : 	if(FAILED(hr))

  00016	85 c0		 test	 eax, eax
  00018	78 05		 js	 SHORT $LN6@AtlMultipl

; 185  : 	}
; 186  : 	return tResult;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _tResult$[ebp]

; 187  : }

  0001d	c9		 leave
  0001e	c3		 ret	 0
$LN6@AtlMultipl:

; 183  : 	{
; 184  : 		AtlThrow(hr);

  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN4@AtlMultipl:
  00025	cc		 int	 3
??$AtlMultiplyThrow@I@ATL@@YAIII@Z ENDP			; ATL::AtlMultiplyThrow<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_G?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::~CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0a		 je	 SHORT $LN2@scalar
  00011	6a 1c		 push	 28			; 0000001cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx
$LN2@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAEPAXI@Z ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::CreateInstance, COMDAT

; 2963 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2964 : 	ATLASSERT(pp != NULL);
; 2965 : 	if (pp == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _pp$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@CreateInst

; 2966 : 		return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 33		 jmp	 SHORT $LN1@CreateInst
$LN2@CreateInst:

; 2967 : 	*pp = NULL;

  00012	83 26 00	 and	 DWORD PTR [esi], 0
  00015	57		 push	 edi

; 2968 : 
; 2969 : 	HRESULT hRes = E_OUTOFMEMORY;
; 2970 : 	CComObject<Base>* p = NULL;
; 2971 : 	ATLTRY(p = _ATL_NEW CComObject<Base>())

  00016	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001b	6a 1c		 push	 28			; 0000001cH
  0001d	bf 0e 00 07 80	 mov	 edi, -2147024882	; 8007000eH
  00022	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  00027	59		 pop	 ecx
  00028	59		 pop	 ecx
  00029	85 c0		 test	 eax, eax
  0002b	74 11		 je	 SHORT $LN8@CreateInst
  0002d	6a 00		 push	 0
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 ??0?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >

; 2972 : 	if (p != NULL)

  00036	85 c0		 test	 eax, eax
  00038	74 06		 je	 SHORT $LN6@CreateInst

; 2973 : 	{
; 2974 : 		p->SetVoid(NULL);
; 2975 : 		p->InternalFinalConstructAddRef();
; 2976 : 		hRes = p->_AtlInitialConstruct();
; 2977 : 		if (SUCCEEDED(hRes))
; 2978 : 			hRes = p->FinalConstruct();
; 2979 : 		if (SUCCEEDED(hRes))
; 2980 : 			hRes = p->_AtlFinalConstruct();
; 2981 : 		p->InternalFinalConstructRelease();
; 2982 : 		if (hRes != S_OK)

  0003a	33 ff		 xor	 edi, edi
  0003c	eb 02		 jmp	 SHORT $LN6@CreateInst
$LN8@CreateInst:

; 2968 : 
; 2969 : 	HRESULT hRes = E_OUTOFMEMORY;
; 2970 : 	CComObject<Base>* p = NULL;
; 2971 : 	ATLTRY(p = _ATL_NEW CComObject<Base>())

  0003e	33 c0		 xor	 eax, eax
$LN6@CreateInst:

; 2983 : 		{
; 2984 : 			delete p;
; 2985 : 			p = NULL;
; 2986 : 		}
; 2987 : 	}
; 2988 : 	*pp = p;

  00040	89 06		 mov	 DWORD PTR [esi], eax

; 2989 : 	return hRes;

  00042	8b c7		 mov	 eax, edi
  00044	5f		 pop	 edi
$LN1@CreateInst:
  00045	5e		 pop	 esi

; 2990 : }

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::CreateInstance
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::QueryInterface, COMDAT

; 2947 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  00003	ff 75 10	 push	 DWORD PTR _ppvObject$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _iid$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
  0000e	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 2948 : 		return this->_InternalQueryInterface(iid, ppvObject);
; 2949 : 	}

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Release@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::Release, COMDAT

; 2933 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2934 : 		ULONG l = this->InternalRelease();

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 444  : 		return --(*p);

  00008	83 6e 18 01	 sub	 DWORD PTR [esi+24], 1
  0000c	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2935 : 		if (l == 0)

  0000f	75 23		 jne	 SHORT $LN2@Release

; 2891 : 		_pAtlModule->Lock();

  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	ff 50 04	 call	 DWORD PTR [eax+4]

; 2936 : 		{
; 2937 : 			// Lock the module to avoid DLL unload when destruction of member variables take a long time
; 2938 : 			ModuleLockHelper lock;
; 2939 : 			delete this;

  0001c	85 f6		 test	 esi, esi
  0001e	74 09		 je	 SHORT $LN4@Release
  00020	8b 16		 mov	 edx, DWORD PTR [esi]
  00022	8b ce		 mov	 ecx, esi
  00024	6a 01		 push	 1
  00026	ff 52 1c	 call	 DWORD PTR [edx+28]
$LN4@Release:

; 2898 : 		_pAtlModule->Unlock();

  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	ff 52 08	 call	 DWORD PTR [edx+8]
$LN2@Release:

; 2940 : 		}
; 2941 : 		return l;

  00034	8b c7		 mov	 eax, edi
  00036	5f		 pop	 edi
  00037	5e		 pop	 esi

; 2942 : 	}

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?Release@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::Release
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?AddRef@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::AddRef, COMDAT

; 2929 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2930 : 		return this->InternalAddRef();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 440  : 		return ++(*p);

  00006	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00009	40		 inc	 eax
  0000a	89 41 18	 mov	 DWORD PTR [ecx+24], eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2931 : 	}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?AddRef@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAGKXZ ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::AddRef
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??1?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT
??1?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::~CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >, COMDAT
; _this$ = ecx

; 2918 : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@

; 2919 : 		this->m_dwRef = -(LONG_MAX/2);

  00009	c7 46 18 01 00
	00 c0		 mov	 DWORD PTR [esi+24], -1073741823 ; c0000001H

; 2920 : 		this->FinalRelease();
; 2921 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 2922 : 		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
; 2923 : #endif
; 2924 : 		_pAtlModule->Unlock();

  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	ff 50 08	 call	 DWORD PTR [eax+8]
  0001b	8b ce		 mov	 ecx, esi
  0001d	5e		 pop	 esi
  0001e	e9 00 00 00 00	 jmp	 ??1?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAE@XZ ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::~CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >
??1?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@UAE@XZ ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::~CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??0?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z PROC ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00000	33 c0		 xor	 eax, eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2911 : 	CComObject(_In_opt_ void* = NULL)

  00002	56		 push	 esi
  00003	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00005	89 46 04	 mov	 DWORD PTR [esi+4], eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5501 : 		m_begin = m_end = m_iter = NULL;

  00008	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0000b	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0000e	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 5502 : 		m_dwFlags = 0;

  00011	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 2430 : 		m_dwRef = 0L;

  00014	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 2912 : 	{

  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@6B@

; 2913 : 		_pAtlModule->Lock();

  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00023	8b 01		 mov	 eax, DWORD PTR [ecx]
  00025	ff 50 04	 call	 DWORD PTR [eax+4]

; 2914 : 	}

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi
  0002b	c2 04 00	 ret	 4
??0?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z ENDP ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Init@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@QAEJPAPAUIConnectionPoint@@0PAUIUnknown@@W4CComEnumFlags@2@@Z
_TEXT	SEGMENT
_hr$1$ = 8						; size = 4
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
_pUnk$ = 16						; size = 4
tv427 = 20						; size = 4
_flags$ = 20						; size = 4
?Init@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@QAEJPAPAUIConnectionPoint@@0PAUIUnknown@@W4CComEnumFlags@2@@Z PROC ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Init, COMDAT
; _this$ = ecx

; 5627 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 5628 : 	if (flags == AtlFlagCopy)

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _flags$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	83 fb 03	 cmp	 ebx, 3
  0000e	0f 85 a2 00 00
	00		 jne	 $LN10@Init

; 5629 : 	{
; 5630 : 		ATLASSUME(m_begin == NULL); //Init called twice?
; 5631 : 		ATLTRY(m_begin = _ATL_NEW T[end-begin])

  00014	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
  00017	33 c9		 xor	 ecx, ecx
  00019	8b 7d 08	 mov	 edi, DWORD PTR _begin$[ebp]
  0001c	2b c7		 sub	 eax, edi
  0001e	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00023	c1 f8 02	 sar	 eax, 2
  00026	6a 04		 push	 4
  00028	5a		 pop	 edx
  00029	89 45 14	 mov	 DWORD PTR tv427[ebp], eax
  0002c	f7 e2		 mul	 edx
  0002e	0f 90 c1	 seto	 cl
  00031	f7 d9		 neg	 ecx
  00033	0b c8		 or	 ecx, eax
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  0003b	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 5632 : 		m_iter = m_begin;

  0003e	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 5633 : 		if (m_begin == NULL)

  00043	85 c0		 test	 eax, eax
  00045	75 0a		 jne	 SHORT $LN12@Init

; 5634 : 			return E_OUTOFMEMORY;

  00047	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0004c	e9 87 00 00 00	 jmp	 $LN1@Init
$LN12@Init:

; 5635 : 		for (T* i=begin; i != end; i++)

  00051	3b 7d 0c	 cmp	 edi, DWORD PTR _end$[ebp]
  00054	74 22		 je	 SHORT $LN27@Init
$LL7@Init:

; 5636 : 		{
; 5637 : 			Copy::init(m_iter);
; 5638 : 			HRESULT hr = Copy::copy(m_iter, i);

  00056	57		 push	 edi
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ?copy@?$_CopyInterface@UIConnectionPoint@@@ATL@@SAJPAPAUIConnectionPoint@@PBQAU3@@Z ; ATL::_CopyInterface<IConnectionPoint>::copy
  0005d	89 45 08	 mov	 DWORD PTR _hr$1$[ebp], eax
  00060	59		 pop	 ecx
  00061	59		 pop	 ecx

; 5639 : 			if (FAILED(hr))

  00062	85 c0		 test	 eax, eax
  00064	78 1a		 js	 SHORT $LN20@Init

; 5647 : 			}
; 5648 : 			m_iter++;

  00066	83 46 10 04	 add	 DWORD PTR [esi+16], 4
  0006a	83 c7 04	 add	 edi, 4
  0006d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00070	3b 7d 0c	 cmp	 edi, DWORD PTR _end$[ebp]
  00073	75 e1		 jne	 SHORT $LL7@Init

; 5639 : 			if (FAILED(hr))

  00075	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$LN27@Init:

; 5649 : 		}
; 5650 : 		m_end = m_begin + (end-begin);

  00078	8b 4d 14	 mov	 ecx, DWORD PTR tv427[ebp]
  0007b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 5651 : 	}

  0007e	eb 3f		 jmp	 SHORT $LN11@Init
$LN20@Init:

; 5640 : 			{
; 5641 : 				T* p = m_begin;

  00080	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 5642 : 				while (p < m_iter)

  00083	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  00086	73 17		 jae	 SHORT $LN9@Init
$LL8@Init:

; 5458 : 		if (*p)

  00088	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0008a	85 c9		 test	 ecx, ecx
  0008c	74 06		 je	 SHORT $LN16@Init

; 5459 : 		{
; 5460 : 			(*p)->Release();

  0008e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00090	51		 push	 ecx
  00091	ff 50 08	 call	 DWORD PTR [eax+8]
$LN16@Init:

; 5643 : 					Copy::destroy(p++);

  00094	83 c7 04	 add	 edi, 4
  00097	3b 7e 10	 cmp	 edi, DWORD PTR [esi+16]
  0009a	72 ec		 jb	 SHORT $LL8@Init
  0009c	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
$LN9@Init:

; 5644 : 				delete [] m_begin;

  0009f	57		 push	 edi
  000a0	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 5645 : 				m_begin = m_end = m_iter = NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000aa	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000ad	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 5646 : 				return hr;

  000b0	8b 45 08	 mov	 eax, DWORD PTR _hr$1$[ebp]
  000b3	59		 pop	 ecx
  000b4	eb 22		 jmp	 SHORT $LN1@Init
$LN10@Init:

; 5652 : 	else
; 5653 : 	{
; 5654 : 		m_begin = begin;

  000b6	8b 45 08	 mov	 eax, DWORD PTR _begin$[ebp]
  000b9	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 5655 : 		m_end = end;

  000bc	8b 45 0c	 mov	 eax, DWORD PTR _end$[ebp]
$LN11@Init:

; 5656 : 	}
; 5657 : 	m_spUnk = pUnk;

  000bf	ff 75 10	 push	 DWORD PTR _pUnk$[ebp]
  000c2	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000c5	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000c8	e8 00 00 00 00	 call	 ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z ; ATL::CComPtr<IUnknown>::operator=

; 5658 : 	m_iter = m_begin;

  000cd	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000d0	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 5659 : 	m_dwFlags = flags;
; 5660 : 	return S_OK;

  000d3	33 c0		 xor	 eax, eax
  000d5	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
$LN1@Init:

; 5661 : }

  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
  000da	5b		 pop	 ebx
  000db	5d		 pop	 ebp
  000dc	c2 10 00	 ret	 16			; 00000010H
?Init@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@QAEJPAPAUIConnectionPoint@@0PAUIUnknown@@W4CComEnumFlags@2@@Z ENDP ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Init
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Clone@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_p$2 = -8						; size = 4
$T3 = -4						; size = 4
$T4 = 8							; size = 4
$T5 = 8							; size = 4
_this$ = 8						; size = 4
_ppEnum$ = 12						; size = 4
?Clone@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z PROC ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Clone, COMDAT

; 5596 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	83 65 f8 00	 and	 DWORD PTR $T1[ebp], 0

; 5597 : 	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
; 5598 : 	HRESULT hRes = E_POINTER;
; 5599 : 	if (ppEnum != NULL)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _ppEnum$[ebp]
  0000c	53		 push	 ebx
  0000d	bb 03 40 00 80	 mov	 ebx, -2147467261	; 80004003H
  00012	85 c0		 test	 eax, eax
  00014	0f 84 c0 00 00
	00		 je	 $LN9@Clone

; 5600 : 	{
; 5601 : 		*ppEnum = NULL;

  0001a	83 20 00	 and	 DWORD PTR [eax], 0

; 5602 : 		_class* p;
; 5603 : 		hRes = _class::CreateInstance(&p);

  0001d	8d 45 f8	 lea	 eax, DWORD PTR _p$2[ebp]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?CreateInstance@?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@SGJPAPAV12@@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::CreateInstance
  00026	8b d8		 mov	 ebx, eax

; 5604 : 		if (SUCCEEDED(hRes))

  00028	85 db		 test	 ebx, ebx
  0002a	0f 88 aa 00 00
	00		 js	 $LN9@Clone

; 5607 : 			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);

  00030	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00033	56		 push	 esi
  00034	57		 push	 edi
  00035	f6 43 14 02	 test	 BYTE PTR [ebx+20], 2
  00039	74 12		 je	 SHORT $LN7@Clone
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 171  :             p->AddRef();

  0003b	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003d	8b fb		 mov	 edi, ebx
  0003f	53		 push	 ebx
  00040	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5607 : 			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);

  00043	8b 75 08	 mov	 esi, DWORD PTR $T4[ebp]
  00046	33 c9		 xor	 ecx, ecx
  00048	8b c3		 mov	 eax, ebx
  0004a	41		 inc	 ecx
  0004b	eb 17		 jmp	 SHORT $LN40@Clone
$LN7@Clone:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 169  :         p = lp;

  0004d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00050	8b f0		 mov	 esi, eax
  00052	85 c0		 test	 eax, eax

; 170  :         if (p != NULL)

  00054	74 08		 je	 SHORT $LN21@Clone

; 171  :             p->AddRef();

  00056	8b 06		 mov	 eax, DWORD PTR [esi]
  00058	56		 push	 esi
  00059	ff 50 04	 call	 DWORD PTR [eax+4]
  0005c	8b c6		 mov	 eax, esi
$LN21@Clone:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5607 : 			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);

  0005e	8b 7d 08	 mov	 edi, DWORD PTR $T5[ebp]
  00061	6a 02		 push	 2
  00063	59		 pop	 ecx
$LN40@Clone:
  00064	6a 00		 push	 0
  00066	50		 push	 eax
  00067	ff 73 0c	 push	 DWORD PTR [ebx+12]
  0006a	89 4d fc	 mov	 DWORD PTR $T3[ebp], ecx
  0006d	ff 73 08	 push	 DWORD PTR [ebx+8]
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _p$2[ebp]
  00073	e8 00 00 00 00	 call	 ?Init@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@QAEJPAPAUIConnectionPoint@@0PAUIUnknown@@W4CComEnumFlags@2@@Z ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Init
  00078	8b d8		 mov	 ebx, eax
  0007a	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	a8 02		 test	 al, 2
  0007f	74 13		 je	 SHORT $LN26@Clone
  00081	83 e0 fd	 and	 eax, -3			; fffffffdH
  00084	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00087	85 f6		 test	 esi, esi
  00089	74 09		 je	 SHORT $LN26@Clone

; 184  :             p->Release();

  0008b	8b 06		 mov	 eax, DWORD PTR [esi]
  0008d	56		 push	 esi
  0008e	ff 50 08	 call	 DWORD PTR [eax+8]
  00091	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
$LN26@Clone:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5607 : 			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);

  00094	a8 01		 test	 al, 1
  00096	74 0a		 je	 SHORT $LN31@Clone
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00098	85 ff		 test	 edi, edi
  0009a	74 06		 je	 SHORT $LN31@Clone

; 184  :             p->Release();

  0009c	8b 07		 mov	 eax, DWORD PTR [edi]
  0009e	57		 push	 edi
  0009f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN31@Clone:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5608 : 			if (SUCCEEDED(hRes))

  000a2	8b 75 f8	 mov	 esi, DWORD PTR _p$2[ebp]
  000a5	85 db		 test	 ebx, ebx
  000a7	78 22		 js	 SHORT $LN37@Clone

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  000a9	ff 75 0c	 push	 DWORD PTR _ppEnum$[ebp]

; 5609 : 			{
; 5610 : 				p->m_iter = m_iter;

  000ac	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  000af	68 00 00 00 00	 push	 OFFSET __GUID_b196b285_bab4_101a_b69c_00aa00341d07
  000b4	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
  000b9	56		 push	 esi

; 5609 : 			{
; 5610 : 				p->m_iter = m_iter;

  000ba	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000bd	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  000c0	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 5611 : 				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);

  000c5	8b d8		 mov	 ebx, eax

; 5612 : 			}
; 5613 : 			if (FAILED(hRes))

  000c7	85 db		 test	 ebx, ebx
  000c9	79 0d		 jns	 SHORT $LN39@Clone
$LN37@Clone:

; 5614 : 				delete p;

  000cb	85 f6		 test	 esi, esi
  000cd	74 09		 je	 SHORT $LN39@Clone
  000cf	8b 06		 mov	 eax, DWORD PTR [esi]
  000d1	8b ce		 mov	 ecx, esi
  000d3	6a 01		 push	 1
  000d5	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN39@Clone:
  000d8	5f		 pop	 edi
  000d9	5e		 pop	 esi
$LN9@Clone:

; 5615 : 		}
; 5616 : 	}
; 5617 : 
; 5618 : 	return hRes;

  000da	8b c3		 mov	 eax, ebx
  000dc	5b		 pop	 ebx

; 5619 : }

  000dd	c9		 leave
  000de	c2 08 00	 ret	 8
?Clone@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z ENDP ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Clone
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Reset@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Reset@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJXZ PROC ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Reset, COMDAT

; 5512 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5513 : 		m_iter = m_begin;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00009	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 5514 : 		return S_OK;

  0000c	33 c0		 xor	 eax, eax

; 5515 : 	}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?Reset@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJXZ ENDP ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Reset
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Skip@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_celt$ = 12						; size = 4
?Skip@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJK@Z PROC ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Skip, COMDAT

; 5586 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5587 : 	ULONG nRem = ULONG(m_end - m_iter);
; 5588 : 	ULONG nSkip = (celt > nRem) ? nRem : celt;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _celt$[ebp]
  00006	56		 push	 esi
  00007	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  0000a	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000d	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00010	2b c2		 sub	 eax, edx
  00012	c1 f8 02	 sar	 eax, 2
  00015	3b c8		 cmp	 ecx, eax
  00017	0f 47 c8	 cmova	 ecx, eax

; 5589 : 	m_iter += nSkip;

  0001a	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  0001d	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 5590 : 	return (celt == nSkip) ? S_OK : S_FALSE;

  00020	33 c0		 xor	 eax, eax
  00022	39 4d 0c	 cmp	 DWORD PTR _celt$[ebp], ecx
  00025	5e		 pop	 esi
  00026	0f 95 c0	 setne	 al

; 5591 : }

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?Skip@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJK@Z ENDP ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Skip
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Next@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJKPAPAUIConnectionPoint@@PAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_hr$1$ = 12						; size = 4
_celt$ = 12						; size = 4
tv294 = 16						; size = 4
_rgelt$ = 16						; size = 4
_pelt$1$ = 20						; size = 4
_pceltFetched$ = 20					; size = 4
?Next@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJKPAPAUIConnectionPoint@@PAK@Z PROC ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Next, COMDAT

; 5552 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 5553 : 	if (pceltFetched != NULL)

  00006	8b 7d 14	 mov	 edi, DWORD PTR _pceltFetched$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	74 03		 je	 SHORT $LN6@Next

; 5554 : 		*pceltFetched = 0;

  0000d	83 27 00	 and	 DWORD PTR [edi], 0
$LN6@Next:

; 5555 : 	if (rgelt == NULL || (celt > 1 && pceltFetched == NULL))

  00010	8b 5d 10	 mov	 ebx, DWORD PTR _rgelt$[ebp]
  00013	85 db		 test	 ebx, ebx
  00015	0f 84 b0 00 00
	00		 je	 $LN8@Next
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _celt$[ebp]
  0001e	83 f9 01	 cmp	 ecx, 1
  00021	76 08		 jbe	 SHORT $LN7@Next
  00023	85 ff		 test	 edi, edi
  00025	0f 84 a0 00 00
	00		 je	 $LN8@Next
$LN7@Next:

; 5557 : 	if (m_begin == NULL || m_end == NULL || m_iter == NULL)

  0002b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00032	0f 84 8c 00 00
	00		 je	 $LN10@Next
  00038	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0003b	85 f6		 test	 esi, esi
  0003d	0f 84 81 00 00
	00		 je	 $LN10@Next
  00043	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00047	74 7b		 je	 SHORT $LN10@Next

; 5559 : 	ULONG nRem = (ULONG)(m_end - m_iter);

  00049	2b 70 10	 sub	 esi, DWORD PTR [eax+16]
  0004c	c1 fe 02	 sar	 esi, 2

; 5560 : 	HRESULT hRes = S_OK;
; 5561 : 	if (nRem < celt)
; 5562 : 		hRes = S_FALSE;
; 5563 : 	ULONG nMin = celt < nRem ? celt : nRem ;

  0004f	3b f1		 cmp	 esi, ecx
  00051	1b d2		 sbb	 edx, edx
  00053	f7 da		 neg	 edx
  00055	3b ce		 cmp	 ecx, esi
  00057	89 55 10	 mov	 DWORD PTR tv294[ebp], edx
  0005a	0f 42 f1	 cmovb	 esi, ecx

; 5564 : 	if (pceltFetched != NULL)

  0005d	85 ff		 test	 edi, edi
  0005f	74 02		 je	 SHORT $LN12@Next

; 5565 : 		*pceltFetched = nMin;

  00061	89 37		 mov	 DWORD PTR [edi], esi
$LN12@Next:

; 5566 : 	T* pelt = rgelt;

  00063	8b cb		 mov	 ecx, ebx
  00065	89 4d 14	 mov	 DWORD PTR _pelt$1$[ebp], ecx

; 5567 : 	while(nMin--)

  00068	85 f6		 test	 esi, esi
  0006a	74 2e		 je	 SHORT $LN21@Next
  0006c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
$LL2@Next:

; 5568 : 	{
; 5569 : 		HRESULT hr = Copy::copy(pelt, m_iter);

  0006f	50		 push	 eax
  00070	51		 push	 ecx
  00071	4e		 dec	 esi
  00072	e8 00 00 00 00	 call	 ?copy@?$_CopyInterface@UIConnectionPoint@@@ATL@@SAJPAPAUIConnectionPoint@@PBQAU3@@Z ; ATL::_CopyInterface<IConnectionPoint>::copy
  00077	89 45 0c	 mov	 DWORD PTR _hr$1$[ebp], eax
  0007a	59		 pop	 ecx
  0007b	59		 pop	 ecx

; 5570 : 		if (FAILED(hr))

  0007c	85 c0		 test	 eax, eax
  0007e	78 1e		 js	 SHORT $LN20@Next

; 5577 : 		}
; 5578 : 		pelt++;
; 5579 : 		m_iter++;

  00080	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d 14	 mov	 ecx, DWORD PTR _pelt$1$[ebp]
  00086	83 c1 04	 add	 ecx, 4
  00089	89 4d 14	 mov	 DWORD PTR _pelt$1$[ebp], ecx
  0008c	83 40 10 04	 add	 DWORD PTR [eax+16], 4
  00090	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00093	85 f6		 test	 esi, esi
  00095	75 d8		 jne	 SHORT $LL2@Next

; 5570 : 		if (FAILED(hr))

  00097	8b 55 10	 mov	 edx, DWORD PTR tv294[ebp]
$LN21@Next:

; 5580 : 	}
; 5581 : 	return hRes;

  0009a	8b c2		 mov	 eax, edx
  0009c	eb 32		 jmp	 SHORT $LN1@Next
$LN20@Next:

; 5571 : 		{
; 5572 : 			while (rgelt < pelt)

  0009e	8b 75 14	 mov	 esi, DWORD PTR _pelt$1$[ebp]
  000a1	3b de		 cmp	 ebx, esi
  000a3	73 16		 jae	 SHORT $LN5@Next
$LL4@Next:

; 5458 : 		if (*p)

  000a5	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000a7	85 c9		 test	 ecx, ecx
  000a9	74 06		 je	 SHORT $LN17@Next

; 5459 : 		{
; 5460 : 			(*p)->Release();

  000ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ad	51		 push	 ecx
  000ae	ff 50 08	 call	 DWORD PTR [eax+8]
$LN17@Next:

; 5573 : 				Copy::destroy(rgelt++);

  000b1	83 c3 04	 add	 ebx, 4
  000b4	3b de		 cmp	 ebx, esi
  000b6	72 ed		 jb	 SHORT $LL4@Next
  000b8	8b 45 0c	 mov	 eax, DWORD PTR _hr$1$[ebp]
$LN5@Next:

; 5574 : 			if (pceltFetched != NULL)

  000bb	85 ff		 test	 edi, edi
  000bd	74 11		 je	 SHORT $LN1@Next

; 5575 : 				*pceltFetched = 0;

  000bf	83 27 00	 and	 DWORD PTR [edi], 0

; 5576 : 			return hr;

  000c2	eb 0c		 jmp	 SHORT $LN1@Next
$LN10@Next:

; 5558 : 		return E_FAIL;

  000c4	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  000c9	eb 05		 jmp	 SHORT $LN1@Next
$LN8@Next:

; 5556 : 		return E_POINTER;

  000cb	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@Next:
  000d0	5f		 pop	 edi

; 5582 : }

  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	5d		 pop	 ebp
  000d4	c2 10 00	 ret	 16			; 00000010H
?Next@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAGJKPAPAUIConnectionPoint@@PAK@Z ENDP ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Next
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??1?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT
??1?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAE@XZ PROC ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::~CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >, COMDAT
; _this$ = ecx

; 5538 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 5539 : 	if (m_dwFlags & BitOwn)

  00003	f6 47 14 02	 test	 BYTE PTR [edi+20], 2
  00007	74 28		 je	 SHORT $LN5@CComEnumIm

; 5540 : 	{
; 5541 : 		for (T* p = m_begin; p != m_end; p++)

  00009	56		 push	 esi
  0000a	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0000d	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  00010	74 17		 je	 SHORT $LN3@CComEnumIm
$LL4@CComEnumIm:

; 5458 : 		if (*p)

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	85 c9		 test	 ecx, ecx
  00016	74 06		 je	 SHORT $LN2@CComEnumIm

; 5459 : 		{
; 5460 : 			(*p)->Release();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	51		 push	 ecx
  0001b	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@CComEnumIm:

; 5540 : 	{
; 5541 : 		for (T* p = m_begin; p != m_end; p++)

  0001e	83 c6 04	 add	 esi, 4
  00021	3b 77 0c	 cmp	 esi, DWORD PTR [edi+12]
  00024	75 ec		 jne	 SHORT $LL4@CComEnumIm
  00026	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
$LN3@CComEnumIm:

; 5542 : 			Copy::destroy(p);
; 5543 : 		delete [] m_begin;

  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002f	59		 pop	 ecx
  00030	5e		 pop	 esi
$LN5@CComEnumIm:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00031	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00034	5f		 pop	 edi
  00035	85 c9		 test	 ecx, ecx
  00037	74 06		 je	 SHORT $LN13@CComEnumIm

; 184  :             p->Release();

  00039	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003b	51		 push	 ecx
  0003c	ff 50 08	 call	 DWORD PTR [eax+8]
$LN13@CComEnumIm:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 5545 : }

  0003f	c3		 ret	 0
??1?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@UAE@XZ ENDP ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::~CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_G?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z PROC ; ATL::CComObjectCached<ATL::CComClassFactory>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ ; ATL::CComObjectCached<ATL::CComClassFactory>::~CComObjectCached<ATL::CComClassFactory>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0a		 je	 SHORT $LN2@scalar
  00011	6a 28		 push	 40			; 00000028H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx
$LN2@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_G?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAEPAXI@Z ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::CComObjectCached<ATL::CComClassFactory>::QueryInterface, COMDAT

; 3037 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  00003	ff 75 10	 push	 DWORD PTR _ppvObject$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _iid$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComClassFactory::_GetEntries'::`2'::_entries
  0000e	ff 75 08	 push	 DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 3038 : 		return this->_InternalQueryInterface(iid, ppvObject);
; 3039 : 	}

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ PROC ; ATL::CComObjectCached<ATL::CComClassFactory>::Release, COMDAT

; 3025 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 427  : 		return ::InterlockedDecrement(p);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 3025 : 	{

  00006	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 427  : 		return ::InterlockedDecrement(p);

  00007	83 ce ff	 or	 esi, -1
  0000a	f0 0f c1 71 04	 lock	  xadd	 DWORD PTR [ecx+4], esi
  0000f	4e		 dec	 esi
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 3027 : 		if (l == 0)

  00010	75 0d		 jne	 SHORT $LN2@Release

; 3028 : 			delete this;

  00012	85 c9		 test	 ecx, ecx
  00014	74 19		 je	 SHORT $LN4@Release
  00016	8b 01		 mov	 eax, DWORD PTR [ecx]
  00018	6a 01		 push	 1
  0001a	ff 50 14	 call	 DWORD PTR [eax+20]
  0001d	eb 10		 jmp	 SHORT $LN4@Release
$LN2@Release:

; 3029 : 		else if (l == 1)

  0001f	83 fe 01	 cmp	 esi, 1
  00022	75 0b		 jne	 SHORT $LN4@Release

; 3030 : 			_pAtlModule->Unlock();

  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  0002a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002c	ff 52 08	 call	 DWORD PTR [edx+8]
$LN4@Release:

; 3031 : 		return l;

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi

; 3032 : 	}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
?Release@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::Release
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ PROC ; ATL::CComObjectCached<ATL::CComClassFactory>::AddRef, COMDAT

; 3018 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 423  : 		return ::InterlockedIncrement(p);

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 3018 : 	{

  00006	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 423  : 		return ::InterlockedIncrement(p);

  00007	33 f6		 xor	 esi, esi
  00009	46		 inc	 esi
  0000a	f0 0f c1 70 04	 lock	  xadd	 DWORD PTR [eax+4], esi
  0000f	46		 inc	 esi
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 3020 : 		if (l == 2)

  00010	83 fe 02	 cmp	 esi, 2
  00013	75 0b		 jne	 SHORT $LN2@AddRef

; 3021 : 			_pAtlModule->Lock();

  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  0001b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001d	ff 52 04	 call	 DWORD PTR [edx+4]
$LN2@AddRef:

; 3022 : 		return l;

  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi

; 3023 : 	}

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?AddRef@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGKXZ ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::AddRef
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ
_TEXT	SEGMENT
??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ PROC ; ATL::CComObjectCached<ATL::CComClassFactory>::~CComObjectCached<ATL::CComClassFactory>, COMDAT
; _this$ = ecx

; 3008 : 	{

  00000	8b c1		 mov	 eax, ecx

; 3009 : 		this->m_dwRef = -(LONG_MAX/2);

  00002	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]

; 3730 : 	{

  00005	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CComClassFactory@ATL@@6B@

; 3009 : 		this->m_dwRef = -(LONG_MAX/2);

  0000b	c7 01 01 00 00
	c0		 mov	 DWORD PTR [ecx], -1073741823 ; c0000001H

; 3731 : 	}

  00011	e9 00 00 00 00	 jmp	 ??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>
??1?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAE@XZ ENDP ; ATL::CComObjectCached<ATL::CComClassFactory>::~CComObjectCached<ATL::CComClassFactory>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_pv$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?CreateInstance@?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z PROC ; ATL::CComCreator<ATL::CComAggObject<COPOSDeviceMonitor> >::CreateInstance, COMDAT

; 1994 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1995 : 		ATLASSERT(ppv != NULL);
; 1996 : 		if (ppv == NULL)

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _ppv$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	75 07		 jne	 SHORT $LN2@CreateInst

; 1997 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 5e		 jmp	 SHORT $LN1@CreateInst
$LN2@CreateInst:

; 1998 : 		*ppv = NULL;

  00012	83 23 00	 and	 DWORD PTR [ebx], 0
  00015	56		 push	 esi

; 1999 : 
; 2000 : 		HRESULT hRes = E_OUTOFMEMORY;
; 2001 : 		T1* p = NULL;
; 2002 : 
; 2003 : ATLPREFAST_SUPPRESS(6014 28197)
; 2004 : 		/* prefast noise VSW 489981 */
; 2005 : 		ATLTRY(p = _ATL_NEW T1(pv))

  00016	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001b	68 84 01 00 00	 push	 388			; 00000184H
  00020	be 0e 00 07 80	 mov	 esi, -2147024882	; 8007000eH
  00025	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  0002a	59		 pop	 ecx
  0002b	59		 pop	 ecx
  0002c	85 c0		 test	 eax, eax
  0002e	74 3d		 je	 SHORT $LN11@CreateInst
  00030	57		 push	 edi
  00031	ff 75 08	 push	 DWORD PTR _pv$[ebp]
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ??0?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z ; ATL::CComAggObject<COPOSDeviceMonitor>::CComAggObject<COPOSDeviceMonitor>
  0003b	8b f8		 mov	 edi, eax

; 2006 : ATLPREFAST_UNSUPPRESS()
; 2007 : 
; 2008 : 		if (p != NULL)

  0003d	85 ff		 test	 edi, edi
  0003f	74 2b		 je	 SHORT $LN15@CreateInst

; 3364 : 		return m_contained.FinalConstruct();

  00041	8d 4f 08	 lea	 ecx, DWORD PTR [edi+8]
  00044	e8 00 00 00 00	 call	 ?FinalConstruct@COPOSDeviceMonitor@@QAEJXZ ; COPOSDeviceMonitor::FinalConstruct

; 2009 : 		{
; 2010 : 			p->SetVoid(pv);
; 2011 : 			p->InternalFinalConstructAddRef();
; 2012 : 			hRes = p->_AtlInitialConstruct();
; 2013 : 			if (SUCCEEDED(hRes))
; 2014 : 				hRes = p->FinalConstruct();
; 2015 : 			if (SUCCEEDED(hRes))
; 2016 : 				hRes = p->_AtlFinalConstruct();
; 2017 : 			p->InternalFinalConstructRelease();
; 2018 : 			if (hRes == S_OK)

  00049	33 f6		 xor	 esi, esi
  0004b	85 c0		 test	 eax, eax
  0004d	0f 48 f0	 cmovs	 esi, eax
  00050	85 f6		 test	 esi, esi
  00052	75 0f		 jne	 SHORT $LN17@CreateInst

; 2019 : 			{
; 2020 : 				hRes = p->QueryInterface(riid, ppv);

  00054	8b 07		 mov	 eax, DWORD PTR [edi]
  00056	53		 push	 ebx
  00057	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  0005a	57		 push	 edi
  0005b	ff 10		 call	 DWORD PTR [eax]
  0005d	8b f0		 mov	 esi, eax

; 2021 : 				_Analysis_assume_(hRes == S_OK || FAILED(hRes));
; 2022 : 			}
; 2023 : 			if (hRes != S_OK)

  0005f	85 f6		 test	 esi, esi
  00061	74 09		 je	 SHORT $LN15@CreateInst
$LN17@CreateInst:

; 2024 : 				delete p;

  00063	8b 17		 mov	 edx, DWORD PTR [edi]
  00065	8b cf		 mov	 ecx, edi
  00067	6a 01		 push	 1
  00069	ff 52 0c	 call	 DWORD PTR [edx+12]
$LN15@CreateInst:
  0006c	5f		 pop	 edi
$LN11@CreateInst:

; 2025 : 		}
; 2026 : 		return hRes;

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
$LN1@CreateInst:
  00070	5b		 pop	 ebx

; 2027 : 	}

  00071	5d		 pop	 ebp
  00072	c2 0c 00	 ret	 12			; 0000000cH
?CreateInstance@?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ENDP ; ATL::CComCreator<ATL::CComAggObject<COPOSDeviceMonitor> >::CreateInstance
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorImpl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_pv$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?CreateInstance@?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z PROC ; ATL::CComCreator<ATL::CComObject<COPOSDeviceMonitor> >::CreateInstance, COMDAT

; 1994 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1995 : 		ATLASSERT(ppv != NULL);
; 1996 : 		if (ppv == NULL)

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _ppv$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	75 07		 jne	 SHORT $LN2@CreateInst

; 1997 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 69		 jmp	 SHORT $LN1@CreateInst
$LN2@CreateInst:

; 1998 : 		*ppv = NULL;

  00012	83 23 00	 and	 DWORD PTR [ebx], 0
  00015	57		 push	 edi

; 1999 : 
; 2000 : 		HRESULT hRes = E_OUTOFMEMORY;
; 2001 : 		T1* p = NULL;
; 2002 : 
; 2003 : ATLPREFAST_SUPPRESS(6014 28197)
; 2004 : 		/* prefast noise VSW 489981 */
; 2005 : 		ATLTRY(p = _ATL_NEW T1(pv))

  00016	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001b	68 7c 01 00 00	 push	 380			; 0000017cH
  00020	bf 0e 00 07 80	 mov	 edi, -2147024882	; 8007000eH
  00025	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  0002a	59		 pop	 ecx
  0002b	59		 pop	 ecx
  0002c	85 c0		 test	 eax, eax
  0002e	74 48		 je	 SHORT $LN11@CreateInst
  00030	56		 push	 esi
  00031	ff 75 08	 push	 DWORD PTR _pv$[ebp]
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ??0?$CComObject@VCOPOSDeviceMonitor@@@ATL@@QAE@PAX@Z ; ATL::CComObject<COPOSDeviceMonitor>::CComObject<COPOSDeviceMonitor>
  0003b	8b f0		 mov	 esi, eax

; 2006 : ATLPREFAST_UNSUPPRESS()
; 2007 : 
; 2008 : 		if (p != NULL)

  0003d	85 f6		 test	 esi, esi
  0003f	74 36		 je	 SHORT $LN28@CreateInst
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 440  : 		return ++(*p);

  00041	ff 86 dc 00 00
	00		 inc	 DWORD PTR [esi+220]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2014 : 				hRes = p->FinalConstruct();

  00047	8b ce		 mov	 ecx, esi
  00049	e8 00 00 00 00	 call	 ?FinalConstruct@COPOSDeviceMonitor@@QAEJXZ ; COPOSDeviceMonitor::FinalConstruct
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorImpl.h

; 228  : DECLARE_PROTECT_FINAL_CONSTRUCT()

  0004e	33 ff		 xor	 edi, edi
  00050	85 c0		 test	 eax, eax
  00052	0f 48 f8	 cmovs	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 444  : 		return --(*p);

  00055	ff 8e dc 00 00
	00		 dec	 DWORD PTR [esi+220]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2018 : 			if (hRes == S_OK)

  0005b	85 ff		 test	 edi, edi
  0005d	75 0f		 jne	 SHORT $LN30@CreateInst

; 2019 : 			{
; 2020 : 				hRes = p->QueryInterface(riid, ppv);

  0005f	8b 06		 mov	 eax, DWORD PTR [esi]
  00061	53		 push	 ebx
  00062	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  00065	56		 push	 esi
  00066	ff 10		 call	 DWORD PTR [eax]
  00068	8b f8		 mov	 edi, eax

; 2021 : 				_Analysis_assume_(hRes == S_OK || FAILED(hRes));
; 2022 : 			}
; 2023 : 			if (hRes != S_OK)

  0006a	85 ff		 test	 edi, edi
  0006c	74 09		 je	 SHORT $LN28@CreateInst
$LN30@CreateInst:

; 2024 : 				delete p;

  0006e	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	6a 01		 push	 1
  00075	ff 12		 call	 DWORD PTR [edx]
$LN28@CreateInst:
  00077	5e		 pop	 esi
$LN11@CreateInst:

; 2025 : 		}
; 2026 : 		return hRes;

  00078	8b c7		 mov	 eax, edi
  0007a	5f		 pop	 edi
$LN1@CreateInst:
  0007b	5b		 pop	 ebx

; 2027 : 	}

  0007c	5d		 pop	 ebp
  0007d	c2 0c 00	 ret	 12			; 0000000cH
?CreateInstance@?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ENDP ; ATL::CComCreator<ATL::CComObject<COPOSDeviceMonitor> >::CreateInstance
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp
;	COMDAT _DllMain@12
_TEXT	SEGMENT
_hInstance$ = 8						; size = 4
_dwReason$ = 12						; size = 4
___formal$ = 16						; size = 4
_DllMain@12 PROC					; COMDAT

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   :     if (dwReason == DLL_PROCESS_ATTACH)

  00003	83 7d 0c 01	 cmp	 DWORD PTR _dwReason$[ebp], 1
  00007	75 22		 jne	 SHORT $LN2@DllMain

; 52   :     {
; 53   :         _Module.Init(ObjectMap, hInstance, &LIBID_OposDeviceMonitor_CCO);

  00009	68 00 00 00 00	 push	 OFFSET _LIBID_OposDeviceMonitor_CCO
  0000e	ff 75 08	 push	 DWORD PTR _hInstance$[ebp]
  00011	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Module@@3VCComModule@ATL@@A ; _Module
  00016	68 00 00 00 00	 push	 OFFSET ?ObjectMap@@3PAU_ATL_OBJMAP_ENTRY30@ATL@@A
  0001b	e8 00 00 00 00	 call	 ?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z ; ATL::CComModule::Init

; 54   :         DisableThreadLibraryCalls(hInstance);

  00020	ff 75 08	 push	 DWORD PTR _hInstance$[ebp]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DisableThreadLibraryCalls@4

; 55   :     }

  00029	eb 10		 jmp	 SHORT $LN4@DllMain
$LN2@DllMain:

; 56   :     else if (dwReason == DLL_PROCESS_DETACH)

  0002b	83 7d 0c 00	 cmp	 DWORD PTR _dwReason$[ebp], 0
  0002f	75 0a		 jne	 SHORT $LN4@DllMain

; 57   :         _Module.Term();

  00031	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Module@@3VCComModule@ATL@@A ; _Module
  00036	e8 00 00 00 00	 call	 ?Term@CComModule@ATL@@QAEXXZ ; ATL::CComModule::Term
$LN4@DllMain:

; 58   :     return TRUE;    // ok

  0003b	33 c0		 xor	 eax, eax
  0003d	40		 inc	 eax

; 59   : }

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_pv$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z PROC ; ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<COPOSDeviceMonitor> >,ATL::CComCreator<ATL::CComAggObject<COPOSDeviceMonitor> > >::CreateInstance, COMDAT

; 2096 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2097 : 		ATLASSERT(ppv != NULL);
; 2098 : 
; 2099 : 		return (pv == NULL) ?

  00003	83 7d 08 00	 cmp	 DWORD PTR _pv$[ebp], 0
  00007	75 11		 jne	 SHORT $LN3@CreateInst
  00009	ff 75 10	 push	 DWORD PTR _ppv$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  0000f	6a 00		 push	 0
  00011	e8 00 00 00 00	 call	 ?CreateInstance@?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComObject<COPOSDeviceMonitor> >::CreateInstance

; 2100 : 			T1::CreateInstance(NULL, riid, ppv) :
; 2101 : 			T2::CreateInstance(pv, riid, ppv);
; 2102 : 	}

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
$LN3@CreateInst:
  0001a	5d		 pop	 ebp

; 2097 : 		ATLASSERT(ppv != NULL);
; 2098 : 
; 2099 : 		return (pv == NULL) ?

  0001b	e9 00 00 00 00	 jmp	 ?CreateInstance@?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ; ATL::CComCreator<ATL::CComAggObject<COPOSDeviceMonitor> >::CreateInstance
?CreateInstance@?$CComCreator2@V?$CComCreator@V?$CComObject@VCOPOSDeviceMonitor@@@ATL@@@ATL@@V?$CComCreator@V?$CComAggObject@VCOPOSDeviceMonitor@@@ATL@@@2@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ENDP ; ATL::CComCreator2<ATL::CComCreator<ATL::CComObject<COPOSDeviceMonitor> >,ATL::CComCreator<ATL::CComAggObject<COPOSDeviceMonitor> > >::CreateInstance
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_pv$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z PROC ; ATL::CComCreator<ATL::CComObjectCached<ATL::CComClassFactory> >::CreateInstance, COMDAT

; 1994 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1995 : 		ATLASSERT(ppv != NULL);
; 1996 : 		if (ppv == NULL)

  00003	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 0a		 jne	 SHORT $LN2@CreateInst

; 1997 : 			return E_POINTER;

  0000a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000f	e9 88 00 00 00	 jmp	 $LN1@CreateInst
$LN2@CreateInst:

; 1998 : 		*ppv = NULL;

  00014	83 20 00	 and	 DWORD PTR [eax], 0
  00017	53		 push	 ebx
  00018	56		 push	 esi

; 1999 : 
; 2000 : 		HRESULT hRes = E_OUTOFMEMORY;
; 2001 : 		T1* p = NULL;
; 2002 : 
; 2003 : ATLPREFAST_SUPPRESS(6014 28197)
; 2004 : 		/* prefast noise VSW 489981 */
; 2005 : 		ATLTRY(p = _ATL_NEW T1(pv))

  00019	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001e	6a 28		 push	 40			; 00000028H
  00020	be 0e 00 07 80	 mov	 esi, -2147024882	; 8007000eH
  00025	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  0002a	8b d8		 mov	 ebx, eax
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx
  0002e	85 db		 test	 ebx, ebx
  00030	74 66		 je	 SHORT $LN11@CreateInst

; 2430 : 		m_dwRef = 0L;

  00032	83 63 04 00	 and	 DWORD PTR [ebx+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00036	33 c0		 xor	 eax, eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2430 : 		m_dwRef = 0L;

  00038	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00039	6a 06		 push	 6
  0003b	59		 pop	 ecx
  0003c	8d 7b 08	 lea	 edi, DWORD PTR [ebx+8]
  0003f	f3 ab		 rep stosd

; 184  : 	CComSafeDeleteCriticalSection(): m_bInitialized(false)

  00041	88 43 20	 mov	 BYTE PTR [ebx+32], al
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2012 : 			hRes = p->_AtlInitialConstruct();

  00044	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00047	8b 45 08	 mov	 eax, DWORD PTR _pv$[ebp]

; 3003 : 	{

  0004a	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], OFFSET ??_7?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@6B@

; 2006 : ATLPREFAST_UNSUPPRESS()
; 2007 : 
; 2008 : 		if (p != NULL)
; 2009 : 		{
; 2010 : 			p->SetVoid(pv);

  00050	89 43 24	 mov	 DWORD PTR [ebx+36], eax

; 2012 : 			hRes = p->_AtlInitialConstruct();

  00053	e8 00 00 00 00	 call	 ?_AtlInitialConstruct@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEJXZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::_AtlInitialConstruct
  00058	5f		 pop	 edi

; 2013 : 			if (SUCCEEDED(hRes))

  00059	85 c0		 test	 eax, eax
  0005b	79 0b		 jns	 SHORT $LN37@CreateInst

; 2018 : 			if (hRes == S_OK)

  0005d	33 f6		 xor	 esi, esi
  0005f	85 c0		 test	 eax, eax
  00061	0f 48 f0	 cmovs	 esi, eax
  00064	85 f6		 test	 esi, esi
  00066	75 27		 jne	 SHORT $LN40@CreateInst
$LN37@CreateInst:

; 2019 : 			{
; 2020 : 				hRes = p->QueryInterface(riid, ppv);

  00068	8b 03		 mov	 eax, DWORD PTR [ebx]
  0006a	ff 75 10	 push	 DWORD PTR _ppv$[ebp]
  0006d	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  00070	8b 00		 mov	 eax, DWORD PTR [eax]
  00072	3d 00 00 00 00	 cmp	 eax, OFFSET ?QueryInterface@?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ; ATL::CComObjectCached<ATL::CComClassFactory>::QueryInterface
  00077	75 0d		 jne	 SHORT $LN28@CreateInst

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  00079	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@CComClassFactory@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComClassFactory::_GetEntries'::`2'::_entries
  0007e	53		 push	 ebx
  0007f	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 2014 : 				hRes = p->FinalConstruct();
; 2015 : 			if (SUCCEEDED(hRes))
; 2016 : 				hRes = p->_AtlFinalConstruct();
; 2017 : 			p->InternalFinalConstructRelease();

  00084	eb 03		 jmp	 SHORT $LN41@CreateInst
$LN28@CreateInst:
  00086	53		 push	 ebx

; 2019 : 			{
; 2020 : 				hRes = p->QueryInterface(riid, ppv);

  00087	ff d0		 call	 eax
$LN41@CreateInst:

; 2021 : 				_Analysis_assume_(hRes == S_OK || FAILED(hRes));
; 2022 : 			}
; 2023 : 			if (hRes != S_OK)

  00089	8b f0		 mov	 esi, eax
  0008b	85 f6		 test	 esi, esi
  0008d	74 09		 je	 SHORT $LN11@CreateInst
$LN40@CreateInst:

; 2024 : 				delete p;

  0008f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00091	8b cb		 mov	 ecx, ebx
  00093	6a 01		 push	 1
  00095	ff 50 14	 call	 DWORD PTR [eax+20]
$LN11@CreateInst:

; 2025 : 		}
; 2026 : 		return hRes;

  00098	8b c6		 mov	 eax, esi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx
$LN1@CreateInst:

; 2027 : 	}

  0009c	5d		 pop	 ebp
  0009d	c2 0c 00	 ret	 12			; 0000000cH
?CreateInstance@?$CComCreator@V?$CComObjectCached@VCComClassFactory@ATL@@@ATL@@@ATL@@SGJPAXABU_GUID@@PAPAX@Z ENDP ; ATL::CComCreator<ATL::CComObjectCached<ATL::CComClassFactory> >::CreateInstance
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??__F_Module@@YAXXZ
text$yd	SEGMENT
??__F_Module@@YAXXZ PROC				; `dynamic atexit destructor for '_Module'', COMDAT

; 4716 : 	{

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_Module@@3VCComModule@ATL@@A, OFFSET ??_7CComModule@ATL@@6B@

; 3082 : 		Term();

  0000a	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Module@@3VCComModule@ATL@@A ; _Module
  0000f	e9 00 00 00 00	 jmp	 ?Term@CAtlModule@ATL@@QAEXXZ ; ATL::CAtlModule::Term
??__F_Module@@YAXXZ ENDP				; `dynamic atexit destructor for '_Module''
text$yd	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp
;	COMDAT ??__E_Module@@YAXXZ
text$di	SEGMENT
??__E_Module@@YAXXZ PROC				; `dynamic initializer for '_Module'', COMDAT

; 39   : CComModule _Module;

  00000	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 3279 : 	{

  00001	be 00 00 00 00	 mov	 esi, OFFSET ?_Module@@3VCComModule@ATL@@A ; _Module
  00006	8b ce		 mov	 ecx, esi
  00008	e8 00 00 00 00	 call	 ??0CAtlModule@ATL@@QAE@XZ ; ATL::CAtlModule::CAtlModule
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp

; 39   : CComModule _Module;

  0000d	68 00 00 00 00	 push	 OFFSET ??__F_Module@@YAXXZ ; `dynamic atexit destructor for '_Module''
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 4692 : 	CComModule()

  00012	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_Module@@3VCComModule@ATL@@A, OFFSET ??_7CComModule@ATL@@6B@

; 4693 : 	{
; 4694 : 		// Should have only one instance of a class
; 4695 : 		// derived from CComModule in a project.
; 4696 : 		ATLASSERT(_pModule == NULL);
; 4697 : 		_pModule = this;

  0001c	89 35 00 00 00
	00		 mov	 DWORD PTR ?_pModule@ATL@@3PAVCComModule@1@A, esi ; ATL::_pModule
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp

; 39   : CComModule _Module;

  00022	e8 00 00 00 00	 call	 _atexit
  00027	59		 pop	 ecx
  00028	5e		 pop	 esi
  00029	c3		 ret	 0
??__E_Module@@YAXXZ ENDP				; `dynamic initializer for '_Module''
text$di	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorEvent.h
;	COMDAT ?DoEvent@COPOSDeviceMonitor@@IAEXIIJ@Z
_TEXT	SEGMENT
_Msg$ = 8						; size = 4
_wParam$ = 12						; size = 4
_lParam$ = 16						; size = 4
?DoEvent@COPOSDeviceMonitor@@IAEXIIJ@Z PROC		; COPOSDeviceMonitor::DoEvent, COMDAT
; _this$ = ecx

; 428  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 429  :         // Restrict access of the following code to one thread at a time.
; 430  :         ::WaitForSingleObject( _Event_DoEventMutex, INFINITE );

  00006	6a ff		 push	 -1
  00008	ff b6 68 01 00
	00		 push	 DWORD PTR [esi+360]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 431  :         DOTRACEV( ( _T("+DoEvent: Msg 0x%X"), Msg ) );
; 432  : 
; 433  :         // Clear the delivered flag.
; 434  :         _Event_bEventDelivered = false;

  00014	c6 86 63 01 00
	00 00		 mov	 BYTE PTR [esi+355], 0

; 435  : 
; 436  :         // Loop until delivered or events become illegal.
; 437  :         //   Can only execute more than once if events are frozen.
; 438  :         for (;;)
; 439  :         {
; 440  :             // The following two items must be in this order to avoid race
; 441  :             //   condition with "PreCloseRelease":
; 442  :             //  - Reset the event that the event function will use to tell us it is done.
; 443  :             ::ResetEvent( _Event_FiringDoneEvent );

  0001b	eb 3d		 jmp	 SHORT $LN17@DoEvent
$LL2@DoEvent:

; 447  :                 break;
; 448  : 
; 449  :             // Post an event message to the event window.
; 450  :             DOTRACEV( ( _T("*DoEvent: Posting event firing message") ) );
; 451  :             ::PostMessage( _Event_hEventWnd, Msg, wParam, lParam );

  0001d	ff 75 10	 push	 DWORD PTR _lParam$[ebp]
  00020	ff 75 0c	 push	 DWORD PTR _wParam$[ebp]
  00023	ff 75 08	 push	 DWORD PTR _Msg$[ebp]
  00026	ff b6 6c 01 00
	00		 push	 DWORD PTR [esi+364]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PostMessageW@16

; 452  : 
; 453  :             // Wait for the event handler to finish (or for the exception case of
; 454  :             //   Release or Close called).
; 455  :             ::WaitForSingleObject( _Event_FiringDoneEvent, INFINITE );

  00032	6a ff		 push	 -1
  00034	ff b6 64 01 00
	00		 push	 DWORD PTR [esi+356]
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8

; 456  : 
; 457  :             // If the message was delivered, then break out: done!
; 458  :             //
; 459  :             // If events are now illegal, then Close or Release occurred during the
; 460  :             // event firing, so bail out -- the delivery may or may not have occurred.
; 461  :             // Either the Close or Release function was called by the event handler
; 462  :             // (in which case we generated an exception), or Close or Release was
; 463  :             // called before our event function message handler got control.
; 464  :             //
; 465  :             if ( _Event_bEventDelivered || ! _Event_bEventsLegal )

  00040	80 be 63 01 00
	00 00		 cmp	 BYTE PTR [esi+355], 0
  00047	75 26		 jne	 SHORT $LN15@DoEvent
  00049	80 be 61 01 00
	00 00		 cmp	 BYTE PTR [esi+353], 0
  00050	74 1d		 je	 SHORT $LN15@DoEvent

; 466  :                 break;
; 467  : 
; 468  :             // If events legal but not delivered, then either the container or app
; 469  :             //   has frozen them.  Could have used events to trigger when to retry,
; 470  :             //   but since this should be an uncommon situation, we'll just sleep
; 471  :             //   for a short while, then retry.
; 472  :             Sleep( 100 );                   // Wait 1/10 second.

  00052	6a 64		 push	 100			; 00000064H
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
$LN17@DoEvent:

; 444  :             // If events are not legal (release/close has been done),
; 445  :             //   then break out.
; 446  :             if ( ! _Event_bEventsLegal )

  0005a	ff b6 64 01 00
	00		 push	 DWORD PTR [esi+356]
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ResetEvent@4
  00066	80 be 61 01 00
	00 00		 cmp	 BYTE PTR [esi+353], 0
  0006d	75 ae		 jne	 SHORT $LL2@DoEvent
$LN15@DoEvent:

; 473  :         }
; 474  : 
; 475  :         // Allow other threads.
; 476  :         DOTRACEV( ( _T("-DoEvent: Msg 0x%X"), Msg ) );
; 477  :         ::ReleaseMutex( _Event_DoEventMutex );

  0006f	ff b6 68 01 00
	00		 push	 DWORD PTR [esi+360]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseMutex@4
  0007b	5e		 pop	 esi

; 478  :     }

  0007c	5d		 pop	 ebp
  0007d	c2 0c 00	 ret	 12			; 0000000cH
?DoEvent@COPOSDeviceMonitor@@IAEXIIJ@Z ENDP		; COPOSDeviceMonitor::DoEvent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorEvent.h
;	COMDAT ?SOStatusUpdate@COPOSDeviceMonitor@@MAGJJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_Data$ = 12						; size = 4
?SOStatusUpdate@COPOSDeviceMonitor@@MAGJJ@Z PROC	; COPOSDeviceMonitor::SOStatusUpdate, COMDAT

; 376  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 377  :         DOTRACEV( ( _T("+StatusUpdateEvent: Data %d"), Data ) );
; 378  : 
; 379  :         if ( _Event_ControlThreadID == GetCurrentThreadId() )

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	39 81 5c 01 00
	00		 cmp	 DWORD PTR [ecx+348], eax
  00012	75 10		 jne	 SHORT $LN2@SOStatusUp

; 380  :             CProxy_IOPOSEvents< COPOSDeviceMonitor >::Fire_StatusUpdateEvent( Data );

  00014	ff 75 0c	 push	 DWORD PTR _Data$[ebp]
  00017	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0001d	e8 00 00 00 00	 call	 ?Fire_StatusUpdateEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_StatusUpdateEvent
  00022	eb 0f		 jmp	 SHORT $LN3@SOStatusUp
$LN2@SOStatusUp:

; 381  :         else
; 382  :             DoEvent( WMU_STATUS_UPDATE_EVENT, Data, 0 );

  00024	6a 00		 push	 0
  00026	ff 75 0c	 push	 DWORD PTR _Data$[ebp]
  00029	68 68 04 00 00	 push	 1128			; 00000468H
  0002e	e8 00 00 00 00	 call	 ?DoEvent@COPOSDeviceMonitor@@IAEXIIJ@Z ; COPOSDeviceMonitor::DoEvent
$LN3@SOStatusUp:

; 383  : 
; 384  :         DOTRACEV( ( _T("-StatusUpdateEvent") ) );
; 385  :         return S_OK;

  00033	33 c0		 xor	 eax, eax

; 386  :     }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?SOStatusUpdate@COPOSDeviceMonitor@@MAGJJ@Z ENDP	; COPOSDeviceMonitor::SOStatusUpdate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorEvent.h
;	COMDAT ?SOOutputCompleteDummy@COPOSDeviceMonitor@@MAGJJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_OutputID$ = 12						; size = 4
?SOOutputCompleteDummy@COPOSDeviceMonitor@@MAGJJ@Z PROC	; COPOSDeviceMonitor::SOOutputCompleteDummy, COMDAT

; 370  :         return E_NOTIMPL;

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 371  :     }

  00005	c2 08 00	 ret	 8
?SOOutputCompleteDummy@COPOSDeviceMonitor@@MAGJJ@Z ENDP	; COPOSDeviceMonitor::SOOutputCompleteDummy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorEvent.h
;	COMDAT ?SOError@COPOSDeviceMonitor@@MAGJJJJPAJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ResultCode$ = 12					; size = 4
_ResultCodeExtended$ = 16				; size = 4
_ErrorLocus$ = 20					; size = 4
_pErrorResponse$ = 24					; size = 4
?SOError@COPOSDeviceMonitor@@MAGJJJJPAJ@Z PROC		; COPOSDeviceMonitor::SOError, COMDAT

; 348  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 349  :         DOTRACEV( ( _T("+ErrorEvent: RC %d, RCExt %d (0x%X), Locus %d, Response %d"), \
; 350  :             ResultCode, ResultCodeExtended, ResultCodeExtended, ErrorLocus, *pErrorResponse ) );
; 351  : 
; 352  :         if ( _Event_ControlThreadID == GetCurrentThreadId() )

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	39 81 5c 01 00
	00		 cmp	 DWORD PTR [ecx+348], eax
  00012	75 19		 jne	 SHORT $LN2@SOError

; 353  :             CProxy_IOPOSEvents< COPOSDeviceMonitor >::Fire_ErrorEvent( ResultCode, ResultCodeExtended,

  00014	ff 75 18	 push	 DWORD PTR _pErrorResponse$[ebp]
  00017	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0001d	ff 75 14	 push	 DWORD PTR _ErrorLocus$[ebp]
  00020	ff 75 10	 push	 DWORD PTR _ResultCodeExtended$[ebp]
  00023	ff 75 0c	 push	 DWORD PTR _ResultCode$[ebp]
  00026	e8 00 00 00 00	 call	 ?Fire_ErrorEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJJJPAJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_ErrorEvent
  0002b	eb 22		 jmp	 SHORT $LN3@SOError
$LN2@SOError:

; 354  :                     ErrorLocus, pErrorResponse );
; 355  :         else
; 356  :         {
; 357  :             _Event_Err_ErrorLocus = ErrorLocus;
; 358  :             _Event_Err_pErrorResponse = pErrorResponse;
; 359  :             DoEvent( WMU_ERROR_EVENT, ResultCode, ResultCodeExtended );

  0002d	ff 75 10	 push	 DWORD PTR _ResultCodeExtended$[ebp]
  00030	8b 45 14	 mov	 eax, DWORD PTR _ErrorLocus$[ebp]
  00033	ff 75 0c	 push	 DWORD PTR _ResultCode$[ebp]
  00036	89 81 74 01 00
	00		 mov	 DWORD PTR [ecx+372], eax
  0003c	8b 45 18	 mov	 eax, DWORD PTR _pErrorResponse$[ebp]
  0003f	68 66 04 00 00	 push	 1126			; 00000466H
  00044	89 81 78 01 00
	00		 mov	 DWORD PTR [ecx+376], eax
  0004a	e8 00 00 00 00	 call	 ?DoEvent@COPOSDeviceMonitor@@IAEXIIJ@Z ; COPOSDeviceMonitor::DoEvent
$LN3@SOError:

; 360  :         }
; 361  : 
; 362  :         DOTRACEV( ( _T("-ErrorEvent: Response %d"), *pErrorResponse ) );
; 363  :         return S_OK;

  0004f	33 c0		 xor	 eax, eax

; 364  :     }

  00051	5d		 pop	 ebp
  00052	c2 14 00	 ret	 20			; 00000014H
?SOError@COPOSDeviceMonitor@@MAGJJJJPAJ@Z ENDP		; COPOSDeviceMonitor::SOError
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorEvent.h
;	COMDAT ?SODirectIO@COPOSDeviceMonitor@@MAGJJPAJPAPA_W@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_EventNumber$ = 12					; size = 4
_pData$ = 16						; size = 4
_pString$ = 20						; size = 4
?SODirectIO@COPOSDeviceMonitor@@MAGJJPAJPAPA_W@Z PROC	; COPOSDeviceMonitor::SODirectIO, COMDAT

; 312  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  :     #ifdef _DEBUG
; 314  :         DOTRACEV( ( _T("+DirectIOEvent: Event %d (0x%X), Data %d (0x%X)"), \
; 315  :             EventNumber, EventNumber, *pData, *pData ) );
; 316  :         DOTRACESTRINGV( _T("    String."), *pString );
; 317  :         HRESULT hr;
; 318  :         OposVariant DIOStr;
; 319  :         DIOStr.SetBSTR_Copy( *pString, hr );
; 320  :     #endif
; 321  : 
; 322  :         if ( _Event_ControlThreadID == GetCurrentThreadId() )

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	39 81 5c 01 00
	00		 cmp	 DWORD PTR [ecx+348], eax
  00012	75 16		 jne	 SHORT $LN2@SODirectIO

; 323  :             CProxy_IOPOSEvents< COPOSDeviceMonitor >::Fire_DirectIOEvent( EventNumber, pData, pString );

  00014	ff 75 14	 push	 DWORD PTR _pString$[ebp]
  00017	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0001d	ff 75 10	 push	 DWORD PTR _pData$[ebp]
  00020	ff 75 0c	 push	 DWORD PTR _EventNumber$[ebp]
  00023	e8 00 00 00 00	 call	 ?Fire_DirectIOEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJPAJPAPA_W@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_DirectIOEvent
  00028	eb 19		 jmp	 SHORT $LN3@SODirectIO
$LN2@SODirectIO:

; 324  :         else
; 325  :         {
; 326  :             _Event_DIO_pString = pString;
; 327  :             DoEvent( WMU_DIRECT_IO_EVENT, EventNumber, (LPARAM) pData );

  0002a	ff 75 10	 push	 DWORD PTR _pData$[ebp]
  0002d	8b 45 14	 mov	 eax, DWORD PTR _pString$[ebp]
  00030	ff 75 0c	 push	 DWORD PTR _EventNumber$[ebp]
  00033	89 81 70 01 00
	00		 mov	 DWORD PTR [ecx+368], eax
  00039	68 65 04 00 00	 push	 1125			; 00000465H
  0003e	e8 00 00 00 00	 call	 ?DoEvent@COPOSDeviceMonitor@@IAEXIIJ@Z ; COPOSDeviceMonitor::DoEvent
$LN3@SODirectIO:

; 328  :         }
; 329  : 
; 330  :     #ifdef _DEBUG
; 331  :         UINT nStrLen = ::SysStringByteLen( DIOStr.bstrVal );
; 332  :         if ( nStrLen == ::SysStringByteLen( *pString ) &&
; 333  :              0 == ::memcmp( DIOStr.bstrVal, *pString, nStrLen ) )
; 334  :             DOTRACEV( ( _T("-DirectIOEvent: Data %d (0x%X); String Unchanged"), *pData, *pData ) );
; 335  :         else
; 336  :         {
; 337  :             DOTRACEV( ( _T("-DirectIOEvent: Data %d (0x%X)"), *pData, *pData ) );
; 338  :             DOTRACESTRINGV( _T("    String."), *pString );
; 339  :         }
; 340  :     #endif
; 341  :         return S_OK;

  00043	33 c0		 xor	 eax, eax

; 342  :     }

  00045	5d		 pop	 ebp
  00046	c2 10 00	 ret	 16			; 00000010H
?SODirectIO@COPOSDeviceMonitor@@MAGJJPAJPAPA_W@Z ENDP	; COPOSDeviceMonitor::SODirectIO
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorEvent.h
;	COMDAT ?SOData@COPOSDeviceMonitor@@MAGJJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_Status$ = 12						; size = 4
?SOData@COPOSDeviceMonitor@@MAGJJ@Z PROC		; COPOSDeviceMonitor::SOData, COMDAT

; 297  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 298  :         DOTRACEV( ( _T("+DataEvent: Status %d (0x%X)"), Status, Status ) );
; 299  : 
; 300  :         if ( _Event_ControlThreadID == GetCurrentThreadId() )

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	39 81 5c 01 00
	00		 cmp	 DWORD PTR [ecx+348], eax
  00012	75 10		 jne	 SHORT $LN2@SOData

; 301  :             CProxy_IOPOSEvents< COPOSDeviceMonitor >::Fire_DataEvent( Status );

  00014	ff 75 0c	 push	 DWORD PTR _Status$[ebp]
  00017	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  0001d	e8 00 00 00 00	 call	 ?Fire_DataEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_DataEvent
  00022	eb 0f		 jmp	 SHORT $LN3@SOData
$LN2@SOData:

; 302  :         else
; 303  :             DoEvent( WMU_DATA_EVENT, Status, 0 );

  00024	6a 00		 push	 0
  00026	ff 75 0c	 push	 DWORD PTR _Status$[ebp]
  00029	68 64 04 00 00	 push	 1124			; 00000464H
  0002e	e8 00 00 00 00	 call	 ?DoEvent@COPOSDeviceMonitor@@IAEXIIJ@Z ; COPOSDeviceMonitor::DoEvent
$LN3@SOData:

; 304  : 
; 305  :         DOTRACEV( ( _T("-DataEvent") ) );
; 306  :         return S_OK;

  00033	33 c0		 xor	 eax, eax

; 307  :     }

  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?SOData@COPOSDeviceMonitor@@MAGJJ@Z ENDP		; COPOSDeviceMonitor::SOData
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorImpl.h
;	COMDAT ?ProcessWindowMessage@COPOSDeviceMonitor@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_lResult$ = 24						; size = 4
_dwMsgMapID$ = 28					; size = 4
?ProcessWindowMessage@COPOSDeviceMonitor@@UAEHPAUHWND__@@IIJAAJK@Z PROC ; COPOSDeviceMonitor::ProcessWindowMessage, COMDAT
; _this$ = ecx

; 273  : BEGIN_MSG_MAP(COPOSDeviceMonitor)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 7d 1c 00	 cmp	 DWORD PTR _dwMsgMapID$[ebp], 0
  00007	75 3a		 jne	 SHORT $LN6@ProcessWin

; 274  :     CHAIN_MSG_MAP(CComControl<COPOSDeviceMonitor>)

  00009	6a 00		 push	 0
  0000b	ff 75 18	 push	 DWORD PTR _lResult$[ebp]
  0000e	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00011	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR _uMsg$[ebp]
  00017	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  0001a	e8 00 00 00 00	 call	 ?ProcessWindowMessage@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEHPAUHWND__@@IIJAAJK@Z ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::ProcessWindowMessage
  0001f	85 c0		 test	 eax, eax
  00021	75 1b		 jne	 SHORT $LN9@ProcessWin

; 275  :     DEFAULT_REFLECTION_HANDLER()

  00023	ff 75 18	 push	 DWORD PTR _lResult$[ebp]
  00026	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00029	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  0002c	ff 75 0c	 push	 DWORD PTR _uMsg$[ebp]
  0002f	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00032	e8 00 00 00 00	 call	 ?DefaultReflectionHandler@?$CWindowImplRoot@VCWindow@ATL@@@ATL@@SAHPAUHWND__@@IIJAAJ@Z ; ATL::CWindowImplRoot<ATL::CWindow>::DefaultReflectionHandler
  00037	83 c4 14	 add	 esp, 20			; 00000014H
  0003a	85 c0		 test	 eax, eax
  0003c	74 05		 je	 SHORT $LN6@ProcessWin
$LN9@ProcessWin:
  0003e	33 c0		 xor	 eax, eax
  00040	40		 inc	 eax
  00041	eb 02		 jmp	 SHORT $LN1@ProcessWin
$LN6@ProcessWin:

; 276  : END_MSG_MAP()

  00043	33 c0		 xor	 eax, eax
$LN1@ProcessWin:
  00045	5d		 pop	 ebp
  00046	c2 18 00	 ret	 24			; 00000018H
?ProcessWindowMessage@COPOSDeviceMonitor@@UAEHPAUHWND__@@IIJAAJK@Z ENDP ; COPOSDeviceMonitor::ProcessWindowMessage
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorImpl.h
;	COMDAT ?GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z
_TEXT	SEGMENT
_pnEntries$ = 8						; size = 4
?GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z PROC ; COPOSDeviceMonitor::GetConnMap, COMDAT

; 267  : BEGIN_CONNECTION_POINT_MAP(COPOSDeviceMonitor)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  0000f	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4HA ; `COPOSDeviceMonitor::GetConnMap'::`2'::$TSS0
  00017	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  0001d	7f 17		 jg	 SHORT $LN15@GetConnMap
  0001f	eb 01		 jmp	 SHORT $LN2@GetConnMap
$LN13@GetConnMap:
  00021	5e		 pop	 esi
$LN2@GetConnMap:

; 268  :     CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
; 269  :     CONNECTION_POINT_ENTRY(DIID__IOPOSDeviceMonitorEvents)
; 270  : END_CONNECTION_POINT_MAP()

  00022	8b 45 08	 mov	 eax, DWORD PTR _pnEntries$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	74 06		 je	 SHORT $LN3@GetConnMap
  00029	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
$LN3@GetConnMap:
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET ?_entries@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4QBU34@B ; `COPOSDeviceMonitor::GetConnMap'::`2'::_entries
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
$LN15@GetConnMap:

; 267  : BEGIN_CONNECTION_POINT_MAP(COPOSDeviceMonitor)

  00036	56		 push	 esi
  00037	be 00 00 00 00	 mov	 esi, OFFSET ?$TSS0@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4HA ; `COPOSDeviceMonitor::GetConnMap'::`2'::$TSS0
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 __Init_thread_header
  00042	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4HA, -1 ; `COPOSDeviceMonitor::GetConnMap'::`2'::$TSS0
  00049	59		 pop	 ecx
  0004a	75 d5		 jne	 SHORT $LN13@GetConnMap

; 268  :     CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
; 269  :     CONNECTION_POINT_ENTRY(DIID__IOPOSDeviceMonitorEvents)
; 270  : END_CONNECTION_POINT_MAP()

  0004c	83 0d 08 00 00
	00 ff		 or	 DWORD PTR ?_entries@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4QBU34@B+8, -1
  00053	56		 push	 esi
  00054	c7 05 00 00 00
	00 20 00 00 00	 mov	 DWORD PTR ?_entries@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4QBU34@B, 32 ; 00000020H
  0005e	c7 05 04 00 00
	00 2c 00 00 00	 mov	 DWORD PTR ?_entries@?1??GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z@4QBU34@B+4, 44 ; 0000002cH
  00068	e8 00 00 00 00	 call	 __Init_thread_footer
  0006d	59		 pop	 ecx
  0006e	eb b1		 jmp	 SHORT $LN13@GetConnMap
?GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z ENDP ; COPOSDeviceMonitor::GetConnMap
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorImpl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorImpl.h
;	COMDAT ?UpdateRegistry@COPOSDeviceMonitor@@SGJH@Z
_TEXT	SEGMENT
_bRegister$ = 8						; size = 4
?UpdateRegistry@COPOSDeviceMonitor@@SGJH@Z PROC		; COPOSDeviceMonitor::UpdateRegistry, COMDAT

; 226  : DECLARE_REGISTRY_RESOURCEID(IDR_OPOSDEVICEMONITOR)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 4913 : 		return CAtlModuleT<CComModule>::UpdateRegistryFromResource(nResID, bRegister, pMapEntries);

  00003	6a 00		 push	 0
  00005	ff 75 08	 push	 DWORD PTR _bRegister$[ebp]
  00008	6a 66		 push	 102			; 00000066H
  0000a	68 00 00 00 00	 push	 OFFSET ?_Module@@3VCComModule@ATL@@A ; _Module
  0000f	e8 00 00 00 00	 call	 ?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CAtlModule::UpdateRegistryFromResource
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorImpl.h

; 226  : DECLARE_REGISTRY_RESOURCEID(IDR_OPOSDEVICEMONITOR)

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?UpdateRegistry@COPOSDeviceMonitor@@SGJH@Z ENDP		; COPOSDeviceMonitor::UpdateRegistry
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
;	COMDAT ?FireTheEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@IAEXPAVOposVariant@@IAAJPB_WJ@Z
_TEXT	SEGMENT
_DispParms$ = -16					; size = 16
_rgvarg$ = 8						; size = 4
_DispID$ = 12						; size = 4
_cArgs$ = 12						; size = 4
_FirstDispID$ = 16					; size = 4
_pName$ = 20						; size = 4
_MyDispID$ = 24						; size = 4
?FireTheEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@IAEXPAVOposVariant@@IAAJPB_WJ@Z PROC ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::FireTheEvent, COMDAT
; _this$ = ecx

; 183  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 184  :         IFDEBUG( const OLECHAR* pNameOrig = pName );
; 185  : 
; 186  :         // Declare and initialize the dispatch parameters and dispatch ID.
; 187  :         OposDispParms DispParms( rgvarg, cArgs );

  00009	ff 75 0c	 push	 DWORD PTR _cArgs$[ebp]
  0000c	8b f1		 mov	 esi, ecx
  0000e	8d 4d f0	 lea	 ecx, DWORD PTR _DispParms$[ebp]
  00011	ff 75 08	 push	 DWORD PTR _rgvarg$[ebp]
  00014	e8 00 00 00 00	 call	 ??0OposDispParms@@QAE@PAVOposVariant@@H@Z ; OposDispParms::OposDispParms

; 188  :         DISPID DispID = FirstDispID;

  00019	8b 7d 10	 mov	 edi, DWORD PTR _FirstDispID$[ebp]

; 189  :         // If not first connection (not likely for our controls!) or first dispatch ID not yet looked up...
; 190  :         if ( _nCOConnectionIndex != 0 || FirstDispID < 0 )

  0001c	33 db		 xor	 ebx, ebx
  0001e	8b 17		 mov	 edx, DWORD PTR [edi]
  00020	89 55 0c	 mov	 DWORD PTR _DispID$[ebp], edx
  00023	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  00026	75 04		 jne	 SHORT $LN3@FireTheEve
  00028	85 d2		 test	 edx, edx
  0002a	79 3a		 jns	 SHORT $LN7@FireTheEve
$LN3@FireTheEve:

; 191  :         {
; 192  :             // Get the dispatch ID of the event we want to call.
; 193  :             //   If not implemented, then assume that client used typelib to use our default DispIDs.
; 194  :             //   If other failure, the can't fire.
; 195  :             HRESULT hRC = _pCPDispatch->GetIDsOfNames( IID_NULL, const_cast<OLECHAR**>(&pName), 1, LOCALE_USER_DEFAULT, &DispID );

  0002c	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002f	8d 55 0c	 lea	 edx, DWORD PTR _DispID$[ebp]
  00032	52		 push	 edx
  00033	68 00 04 00 00	 push	 1024			; 00000400H
  00038	6a 01		 push	 1
  0003a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003c	8d 55 14	 lea	 edx, DWORD PTR _pName$[ebp]
  0003f	52		 push	 edx
  00040	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  00045	50		 push	 eax
  00046	ff 51 14	 call	 DWORD PTR [ecx+20]

; 196  :             if ( hRC == E_NOTIMPL )

  00049	3d 01 40 00 80	 cmp	 eax, -2147467263	; 80004001H
  0004e	75 08		 jne	 SHORT $LN4@FireTheEve

; 197  :                 DispID = MyDispID;

  00050	8b 55 18	 mov	 edx, DWORD PTR _MyDispID$[ebp]
  00053	89 55 0c	 mov	 DWORD PTR _DispID$[ebp], edx
  00056	eb 07		 jmp	 SHORT $LN6@FireTheEve
$LN4@FireTheEve:

; 198  :             else if ( hRC != S_OK )

  00058	85 c0		 test	 eax, eax
  0005a	75 27		 jne	 SHORT $LN9@FireTheEve
  0005c	8b 55 0c	 mov	 edx, DWORD PTR _DispID$[ebp]
$LN6@FireTheEve:

; 199  :                 return;
; 200  :             // If first connection, then save in cache for next time.
; 201  :             if ( _nCOConnectionIndex == 0 )

  0005f	39 5e 20	 cmp	 DWORD PTR [esi+32], ebx
  00062	75 02		 jne	 SHORT $LN7@FireTheEve

; 202  :                 FirstDispID = DispID;

  00064	89 17		 mov	 DWORD PTR [edi], edx
$LN7@FireTheEve:

; 203  :         }
; 204  :         // Call the event.
; 205  :         IFDEBUG( _pOposControl->DOTRACEV( ( _T("*FireTheEvent: Delivering %ls; Sink 0x%X; DispID %d"), pNameOrig, pUnkSink, DispID ) ) );
; 206  :         _pCPDispatch->Invoke( DispID, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &DispParms, NULL, NULL, NULL );

  00066	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00069	8d 75 f0	 lea	 esi, DWORD PTR _DispParms$[ebp]
  0006c	53		 push	 ebx
  0006d	53		 push	 ebx
  0006e	53		 push	 ebx
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	56		 push	 esi
  00072	6a 01		 push	 1
  00074	68 00 04 00 00	 push	 1024			; 00000400H
  00079	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  0007e	52		 push	 edx
  0007f	50		 push	 eax
  00080	ff 51 18	 call	 DWORD PTR [ecx+24]
$LN9@FireTheEve:

; 207  :     }

  00083	8d 4d f0	 lea	 ecx, DWORD PTR _DispParms$[ebp]
  00086	e8 00 00 00 00	 call	 ??1OposDispParms@@QAE@XZ ; OposDispParms::~OposDispParms
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx
  0008e	c9		 leave
  0008f	c2 14 00	 ret	 20			; 00000014H
?FireTheEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@IAEXPAVOposVariant@@IAAJPB_WJ@Z ENDP ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::FireTheEvent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
;	COMDAT ?Fire_StatusUpdateEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z
_TEXT	SEGMENT
_var$ = -24						; size = 24
_Data$ = 8						; size = 4
?Fire_StatusUpdateEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z PROC ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_StatusUpdateEvent, COMDAT
; _this$ = ecx

; 123  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 77   :     OposVariant() { vt = VT_EMPTY; _bNeedClear = false; }

  0000a	33 c0		 xor	 eax, eax
  0000c	66 89 45 e8	 mov	 WORD PTR _var$[ebp], ax
  00010	88 45 f8	 mov	 BYTE PTR _var$[ebp+16], al
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 126  :         int nConnections = m_vec.GetSize();

  00013	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]

; 128  :         for (_nCOConnectionIndex = 0; _nCOConnectionIndex < nConnections; _nCOConnectionIndex++)

  00016	21 46 20	 and	 DWORD PTR [esi+32], eax
  00019	85 db		 test	 ebx, ebx
  0001b	7e 73		 jle	 SHORT $LN26@Fire_Statu
  0001d	33 c9		 xor	 ecx, ecx
  0001f	57		 push	 edi
$LL4@Fire_Statu:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6198 : 		if (nIndex >= 0 && nIndex < m_nSize)

  00020	85 c9		 test	 ecx, ecx
  00022	78 48		 js	 SHORT $LN12@Fire_Statu
  00024	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00027	7d 43		 jge	 SHORT $LN12@Fire_Statu

; 6199 : 			return m_ppUnk[nIndex];

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	8b 3c 88	 mov	 edi, DWORD PTR [eax+ecx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 170  :         if (p != NULL)

  0002f	85 ff		 test	 edi, edi
  00031	74 34		 je	 SHORT $LN18@Fire_Statu

; 171  :             p->AddRef();

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
  00035	57		 push	 edi
  00036	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 136  :                 var.SetLONG( Data );

  00039	ff 75 08	 push	 DWORD PTR _Data$[ebp]
  0003c	8d 4d e8	 lea	 ecx, DWORD PTR _var$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 171  :             p->AddRef();

  0003f	89 7e 24	 mov	 DWORD PTR [esi+36], edi
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 136  :                 var.SetLONG( Data );

  00042	e8 00 00 00 00	 call	 ?SetLONG@OposVariant@@QAEXJ@Z ; OposVariant::SetLONG

; 137  :                 FireTheEvent( FEUNKNOWN &var, 1, _DIDStatus, L"StatusUpdateEvent", 5 );

  00047	6a 05		 push	 5
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@PGFMOFKI@?$AAS?$AAt?$AAa?$AAt?$AAu?$AAs?$AAU?$AAp?$AAd?$AAa?$AAt?$AAe?$AAE?$AAv?$AAe@
  0004e	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00051	8b ce		 mov	 ecx, esi
  00053	50		 push	 eax
  00054	6a 01		 push	 1
  00056	8d 45 e8	 lea	 eax, DWORD PTR _var$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?FireTheEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@IAEXPAVOposVariant@@IAAJPB_WJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::FireTheEvent
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 184  :             p->Release();

  0005f	8b 07		 mov	 eax, DWORD PTR [edi]
  00061	57		 push	 edi
  00062	ff 50 08	 call	 DWORD PTR [eax+8]
  00065	eb 09		 jmp	 SHORT $LN2@Fire_Statu
$LN18@Fire_Statu:
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 133  :             _pCPDispatch = reinterpret_cast<IDispatch*>(sp.p);

  00067	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0006a	eb 04		 jmp	 SHORT $LN2@Fire_Statu
$LN12@Fire_Statu:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6201 : 			return NULL;

  0006c	83 66 24 00	 and	 DWORD PTR [esi+36], 0
$LN2@Fire_Statu:
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 128  :         for (_nCOConnectionIndex = 0; _nCOConnectionIndex < nConnections; _nCOConnectionIndex++)

  00070	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00073	41		 inc	 ecx
  00074	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  00077	3b cb		 cmp	 ecx, ebx
  00079	7c a5		 jl	 SHORT $LL4@Fire_Statu
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 78   :     ~OposVariant() { if (_bNeedClear) Clear(); }

  0007b	80 7d f8 00	 cmp	 BYTE PTR _var$[ebp+16], 0
  0007f	5f		 pop	 edi
  00080	74 0e		 je	 SHORT $LN26@Fire_Statu

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00082	8d 45 e8	 lea	 eax, DWORD PTR _var$[ebp]
  00085	c6 45 f8 00	 mov	 BYTE PTR _var$[ebp+16], 0
  00089	50		 push	 eax
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN26@Fire_Statu:
  00090	5e		 pop	 esi
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 140  :     }

  00091	5b		 pop	 ebx
  00092	c9		 leave
  00093	c2 04 00	 ret	 4
?Fire_StatusUpdateEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z ENDP ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_StatusUpdateEvent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
;	COMDAT ?Fire_ErrorEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJJJPAJ@Z
_TEXT	SEGMENT
_hr$1 = -112						; size = 4
_nConnections$1$ = -108					; size = 4
_pErrorResponse$GSCopy$1$ = -104			; size = 4
_vars$ = -100						; size = 96
__$ArrayPad$ = -4					; size = 4
_ResultCode$ = 8					; size = 4
_ResultCodeExtended$ = 12				; size = 4
_ErrorLocus$ = 16					; size = 4
_pErrorResponse$ = 20					; size = 4
?Fire_ErrorEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJJJPAJ@Z PROC ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_ErrorEvent, COMDAT
; _this$ = ecx

; 97   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 14	 mov	 eax, DWORD PTR _pErrorResponse$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	6a 04		 push	 4
  00017	5f		 pop	 edi
  00018	8b f1		 mov	 esi, ecx
  0001a	89 45 98	 mov	 DWORD PTR _pErrorResponse$GSCopy$1$[ebp], eax

; 98   :         T* pT = static_cast<T*>(this);
; 99   :         OposVariant vars[4];

  0001d	8d 45 9c	 lea	 eax, DWORD PTR _vars$[ebp]
  00020	8b cf		 mov	 ecx, edi
$LL10@Fire_Error:
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 77   :     OposVariant() { vt = VT_EMPTY; _bNeedClear = false; }

  00022	33 d2		 xor	 edx, edx
  00024	66 89 10	 mov	 WORD PTR [eax], dx
  00027	8d 40 18	 lea	 eax, DWORD PTR [eax+24]
  0002a	88 50 f8	 mov	 BYTE PTR [eax-8], dl
  0002d	83 e9 01	 sub	 ecx, 1
  00030	75 f0		 jne	 SHORT $LL10@Fire_Error
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 100  :         int nConnections = m_vec.GetSize();

  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 102  :         for (_nCOConnectionIndex = 0; _nCOConnectionIndex < nConnections; _nCOConnectionIndex++)

  00035	21 56 20	 and	 DWORD PTR [esi+32], edx
  00038	89 45 94	 mov	 DWORD PTR _nConnections$1$[ebp], eax
  0003b	85 c0		 test	 eax, eax
  0003d	0f 8e 82 00 00
	00		 jle	 $LN3@Fire_Error
  00043	53		 push	 ebx
$LL4@Fire_Error:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6198 : 		if (nIndex >= 0 && nIndex < m_nSize)

  00044	85 c9		 test	 ecx, ecx
  00046	78 6c		 js	 SHORT $LN16@Fire_Error
  00048	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0004b	7d 67		 jge	 SHORT $LN16@Fire_Error

; 6199 : 			return m_ppUnk[nIndex];

  0004d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00050	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 170  :         if (p != NULL)

  00053	85 db		 test	 ebx, ebx
  00055	74 58		 je	 SHORT $LN22@Fire_Error

; 171  :             p->AddRef();

  00057	8b 03		 mov	 eax, DWORD PTR [ebx]
  00059	53		 push	 ebx
  0005a	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 111  :                 vars[3].SetLONG( ResultCode );

  0005d	ff 75 08	 push	 DWORD PTR _ResultCode$[ebp]
  00060	8d 4d e4	 lea	 ecx, DWORD PTR _vars$[ebp+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 171  :             p->AddRef();

  00063	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 111  :                 vars[3].SetLONG( ResultCode );

  00066	e8 00 00 00 00	 call	 ?SetLONG@OposVariant@@QAEXJ@Z ; OposVariant::SetLONG

; 112  :                 vars[2].SetLONG( ResultCodeExtended );

  0006b	ff 75 0c	 push	 DWORD PTR _ResultCodeExtended$[ebp]
  0006e	8d 4d cc	 lea	 ecx, DWORD PTR _vars$[ebp+48]
  00071	e8 00 00 00 00	 call	 ?SetLONG@OposVariant@@QAEXJ@Z ; OposVariant::SetLONG

; 113  :                 vars[1].SetLONG( ErrorLocus );

  00076	ff 75 10	 push	 DWORD PTR _ErrorLocus$[ebp]
  00079	8d 4d b4	 lea	 ecx, DWORD PTR _vars$[ebp+24]
  0007c	e8 00 00 00 00	 call	 ?SetLONG@OposVariant@@QAEXJ@Z ; OposVariant::SetLONG

; 114  :                 vars[0].SetLONG_Ptr( pErrorResponse, hr );

  00081	8d 45 90	 lea	 eax, DWORD PTR _hr$1[ebp]
  00084	50		 push	 eax
  00085	ff 75 98	 push	 DWORD PTR _pErrorResponse$GSCopy$1$[ebp]
  00088	8d 4d 9c	 lea	 ecx, DWORD PTR _vars$[ebp]
  0008b	e8 00 00 00 00	 call	 ?SetLONG_Ptr@OposVariant@@QAEXPAJAAJ@Z ; OposVariant::SetLONG_Ptr

; 115  :                 FireTheEvent( FEUNKNOWN vars, 4, _DIDError, L"ErrorEvent", 3 );

  00090	6a 03		 push	 3
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@LODEBHDD@?$AAE?$AAr?$AAr?$AAo?$AAr?$AAE?$AAv?$AAe?$AAn?$AAt@
  00097	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  0009a	8b ce		 mov	 ecx, esi
  0009c	50		 push	 eax
  0009d	57		 push	 edi
  0009e	8d 45 9c	 lea	 eax, DWORD PTR _vars$[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ?FireTheEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@IAEXPAVOposVariant@@IAAJPB_WJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::FireTheEvent
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 184  :             p->Release();

  000a7	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a9	53		 push	 ebx
  000aa	ff 50 08	 call	 DWORD PTR [eax+8]
  000ad	eb 09		 jmp	 SHORT $LN2@Fire_Error
$LN22@Fire_Error:
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 107  :             _pCPDispatch = reinterpret_cast<IDispatch*>(sp.p);

  000af	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
  000b2	eb 04		 jmp	 SHORT $LN2@Fire_Error
$LN16@Fire_Error:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6201 : 			return NULL;

  000b4	83 66 24 00	 and	 DWORD PTR [esi+36], 0
$LN2@Fire_Error:
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 102  :         for (_nCOConnectionIndex = 0; _nCOConnectionIndex < nConnections; _nCOConnectionIndex++)

  000b8	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  000bb	41		 inc	 ecx
  000bc	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  000bf	3b 4d 94	 cmp	 ecx, DWORD PTR _nConnections$1$[ebp]
  000c2	7c 80		 jl	 SHORT $LL4@Fire_Error
  000c4	5b		 pop	 ebx
$LN3@Fire_Error:
  000c5	8d 75 fc	 lea	 esi, DWORD PTR _vars$[ebp+96]
$LL45@Fire_Error:
  000c8	83 ee 18	 sub	 esi, 24			; 00000018H
  000cb	4f		 dec	 edi
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 78   :     ~OposVariant() { if (_bNeedClear) Clear(); }

  000cc	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  000d0	74 0b		 je	 SHORT $LN34@Fire_Error

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  000d2	56		 push	 esi
  000d3	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN34@Fire_Error:
  000dd	85 ff		 test	 edi, edi
  000df	75 e7		 jne	 SHORT $LL45@Fire_Error
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 118  :     }

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e4	5f		 pop	 edi
  000e5	33 cd		 xor	 ecx, ebp
  000e7	5e		 pop	 esi
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	c9		 leave
  000ee	c2 10 00	 ret	 16			; 00000010H
?Fire_ErrorEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJJJPAJ@Z ENDP ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_ErrorEvent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
;	COMDAT ?Fire_DirectIOEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJPAJPAPA_W@Z
_TEXT	SEGMENT
_nConnections$1$ = -92					; size = 4
_pString$GSCopy$1$ = -88				; size = 4
_hr$1 = -84						; size = 4
_pData$GSCopy$1$ = -80					; size = 4
_vars$ = -76						; size = 72
__$ArrayPad$ = -4					; size = 4
_EventNumber$ = 8					; size = 4
_pData$ = 12						; size = 4
_pString$ = 16						; size = 4
?Fire_DirectIOEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJPAJPAPA_W@Z PROC ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_DirectIOEvent, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _pData$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	89 45 b0	 mov	 DWORD PTR _pData$GSCopy$1$[ebp], eax
  00018	8b f1		 mov	 esi, ecx
  0001a	8b 45 10	 mov	 eax, DWORD PTR _pString$[ebp]
  0001d	6a 03		 push	 3
  0001f	5f		 pop	 edi
  00020	89 45 a8	 mov	 DWORD PTR _pString$GSCopy$1$[ebp], eax
  00023	8b cf		 mov	 ecx, edi

; 73   :         T* pT = static_cast<T*>(this);
; 74   :         OposVariant vars[3];

  00025	8d 45 b4	 lea	 eax, DWORD PTR _vars$[ebp]
$LL10@Fire_Direc:
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 77   :     OposVariant() { vt = VT_EMPTY; _bNeedClear = false; }

  00028	33 d2		 xor	 edx, edx
  0002a	66 89 10	 mov	 WORD PTR [eax], dx
  0002d	8d 40 18	 lea	 eax, DWORD PTR [eax+24]
  00030	88 50 f8	 mov	 BYTE PTR [eax-8], dl
  00033	83 e9 01	 sub	 ecx, 1
  00036	75 f0		 jne	 SHORT $LL10@Fire_Direc
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 75   :         int nConnections = m_vec.GetSize();

  00038	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 77   :         for (_nCOConnectionIndex = 0; _nCOConnectionIndex < nConnections; _nCOConnectionIndex++)

  0003b	21 56 20	 and	 DWORD PTR [esi+32], edx
  0003e	89 45 a4	 mov	 DWORD PTR _nConnections$1$[ebp], eax
  00041	85 c0		 test	 eax, eax
  00043	7e 7b		 jle	 SHORT $LN3@Fire_Direc
  00045	53		 push	 ebx
$LL4@Fire_Direc:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6198 : 		if (nIndex >= 0 && nIndex < m_nSize)

  00046	85 c9		 test	 ecx, ecx
  00048	78 65		 js	 SHORT $LN16@Fire_Direc
  0004a	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0004d	7d 60		 jge	 SHORT $LN16@Fire_Direc

; 6199 : 			return m_ppUnk[nIndex];

  0004f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00052	8b 1c 88	 mov	 ebx, DWORD PTR [eax+ecx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 170  :         if (p != NULL)

  00055	85 db		 test	 ebx, ebx
  00057	74 51		 je	 SHORT $LN22@Fire_Direc

; 171  :             p->AddRef();

  00059	8b 03		 mov	 eax, DWORD PTR [ebx]
  0005b	53		 push	 ebx
  0005c	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 86   :                 vars[2].SetLONG( EventNumber );

  0005f	ff 75 08	 push	 DWORD PTR _EventNumber$[ebp]
  00062	8d 4d e4	 lea	 ecx, DWORD PTR _vars$[ebp+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 171  :             p->AddRef();

  00065	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 86   :                 vars[2].SetLONG( EventNumber );

  00068	e8 00 00 00 00	 call	 ?SetLONG@OposVariant@@QAEXJ@Z ; OposVariant::SetLONG

; 87   :                 vars[1].SetLONG_Ptr( pData, hr );

  0006d	8d 45 ac	 lea	 eax, DWORD PTR _hr$1[ebp]
  00070	50		 push	 eax
  00071	ff 75 b0	 push	 DWORD PTR _pData$GSCopy$1$[ebp]
  00074	8d 4d cc	 lea	 ecx, DWORD PTR _vars$[ebp+24]
  00077	e8 00 00 00 00	 call	 ?SetLONG_Ptr@OposVariant@@QAEXPAJAAJ@Z ; OposVariant::SetLONG_Ptr

; 88   :                 vars[0].SetBSTR_InOutPtr( pString, hr );

  0007c	8d 45 ac	 lea	 eax, DWORD PTR _hr$1[ebp]
  0007f	50		 push	 eax
  00080	ff 75 a8	 push	 DWORD PTR _pString$GSCopy$1$[ebp]
  00083	8d 4d b4	 lea	 ecx, DWORD PTR _vars$[ebp]
  00086	e8 00 00 00 00	 call	 ?SetBSTR_InOutPtr@OposVariant@@QAE_NPAPA_WAAJ@Z ; OposVariant::SetBSTR_InOutPtr

; 89   :                 FireTheEvent( FEUNKNOWN vars, 3, _DIDDirectIO, L"DirectIOEvent", 2 );

  0008b	6a 02		 push	 2
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@CBGEBBBJ@?$AAD?$AAi?$AAr?$AAe?$AAc?$AAt?$AAI?$AAO?$AAE?$AAv?$AAe?$AAn?$AAt@
  00092	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00095	8b ce		 mov	 ecx, esi
  00097	50		 push	 eax
  00098	57		 push	 edi
  00099	8d 45 b4	 lea	 eax, DWORD PTR _vars$[ebp]
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ?FireTheEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@IAEXPAVOposVariant@@IAAJPB_WJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::FireTheEvent
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 184  :             p->Release();

  000a2	8b 03		 mov	 eax, DWORD PTR [ebx]
  000a4	53		 push	 ebx
  000a5	ff 50 08	 call	 DWORD PTR [eax+8]
  000a8	eb 09		 jmp	 SHORT $LN2@Fire_Direc
$LN22@Fire_Direc:
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 82   :             _pCPDispatch = reinterpret_cast<IDispatch*>(sp.p);

  000aa	89 5e 24	 mov	 DWORD PTR [esi+36], ebx
  000ad	eb 04		 jmp	 SHORT $LN2@Fire_Direc
$LN16@Fire_Direc:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6201 : 			return NULL;

  000af	83 66 24 00	 and	 DWORD PTR [esi+36], 0
$LN2@Fire_Direc:
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 77   :         for (_nCOConnectionIndex = 0; _nCOConnectionIndex < nConnections; _nCOConnectionIndex++)

  000b3	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  000b6	41		 inc	 ecx
  000b7	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  000ba	3b 4d a4	 cmp	 ecx, DWORD PTR _nConnections$1$[ebp]
  000bd	7c 87		 jl	 SHORT $LL4@Fire_Direc
  000bf	5b		 pop	 ebx
$LN3@Fire_Direc:
  000c0	8d 75 fc	 lea	 esi, DWORD PTR _vars$[ebp+72]
$LL45@Fire_Direc:
  000c3	83 ee 18	 sub	 esi, 24			; 00000018H
  000c6	4f		 dec	 edi
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 78   :     ~OposVariant() { if (_bNeedClear) Clear(); }

  000c7	80 7e 10 00	 cmp	 BYTE PTR [esi+16], 0
  000cb	74 0b		 je	 SHORT $LN34@Fire_Direc

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  000cd	56		 push	 esi
  000ce	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN34@Fire_Direc:
  000d8	85 ff		 test	 edi, edi
  000da	75 e7		 jne	 SHORT $LL45@Fire_Direc
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 92   :     }

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	5f		 pop	 edi
  000e0	33 cd		 xor	 ecx, ebp
  000e2	5e		 pop	 esi
  000e3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e8	c9		 leave
  000e9	c2 0c 00	 ret	 12			; 0000000cH
?Fire_DirectIOEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJPAJPAPA_W@Z ENDP ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_DirectIOEvent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h
;	COMDAT ?Fire_DataEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z
_TEXT	SEGMENT
_var$ = -24						; size = 24
_Status$ = 8						; size = 4
?Fire_DataEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z PROC ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_DataEvent, COMDAT
; _this$ = ecx

; 50   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 77   :     OposVariant() { vt = VT_EMPTY; _bNeedClear = false; }

  0000a	33 c0		 xor	 eax, eax
  0000c	66 89 45 e8	 mov	 WORD PTR _var$[ebp], ax
  00010	88 45 f8	 mov	 BYTE PTR _var$[ebp+16], al
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 53   :         int nConnections = m_vec.GetSize();

  00013	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]

; 55   :         for (_nCOConnectionIndex = 0; _nCOConnectionIndex < nConnections; _nCOConnectionIndex++)

  00016	21 46 20	 and	 DWORD PTR [esi+32], eax
  00019	85 db		 test	 ebx, ebx
  0001b	7e 73		 jle	 SHORT $LN26@Fire_DataE
  0001d	33 c9		 xor	 ecx, ecx
  0001f	57		 push	 edi
$LL4@Fire_DataE:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6198 : 		if (nIndex >= 0 && nIndex < m_nSize)

  00020	85 c9		 test	 ecx, ecx
  00022	78 48		 js	 SHORT $LN12@Fire_DataE
  00024	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00027	7d 43		 jge	 SHORT $LN12@Fire_DataE

; 6199 : 			return m_ppUnk[nIndex];

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	8b 3c 88	 mov	 edi, DWORD PTR [eax+ecx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 170  :         if (p != NULL)

  0002f	85 ff		 test	 edi, edi
  00031	74 34		 je	 SHORT $LN18@Fire_DataE

; 171  :             p->AddRef();

  00033	8b 07		 mov	 eax, DWORD PTR [edi]
  00035	57		 push	 edi
  00036	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 63   :                 var.SetLONG( Status );

  00039	ff 75 08	 push	 DWORD PTR _Status$[ebp]
  0003c	8d 4d e8	 lea	 ecx, DWORD PTR _var$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 171  :             p->AddRef();

  0003f	89 7e 24	 mov	 DWORD PTR [esi+36], edi
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 63   :                 var.SetLONG( Status );

  00042	e8 00 00 00 00	 call	 ?SetLONG@OposVariant@@QAEXJ@Z ; OposVariant::SetLONG

; 64   :                 FireTheEvent( FEUNKNOWN &var, 1, _DIDData, L"DataEvent", 1 );

  00047	6a 01		 push	 1
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@IEBMACEM@?$AAD?$AAa?$AAt?$AAa?$AAE?$AAv?$AAe?$AAn?$AAt@
  0004e	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00051	8b ce		 mov	 ecx, esi
  00053	50		 push	 eax
  00054	6a 01		 push	 1
  00056	8d 45 e8	 lea	 eax, DWORD PTR _var$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?FireTheEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@IAEXPAVOposVariant@@IAAJPB_WJ@Z ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::FireTheEvent
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 184  :             p->Release();

  0005f	8b 07		 mov	 eax, DWORD PTR [edi]
  00061	57		 push	 edi
  00062	ff 50 08	 call	 DWORD PTR [eax+8]
  00065	eb 09		 jmp	 SHORT $LN2@Fire_DataE
$LN18@Fire_DataE:
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 60   :             _pCPDispatch = reinterpret_cast<IDispatch*>(sp.p);

  00067	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0006a	eb 04		 jmp	 SHORT $LN2@Fire_DataE
$LN12@Fire_DataE:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6201 : 			return NULL;

  0006c	83 66 24 00	 and	 DWORD PTR [esi+36], 0
$LN2@Fire_DataE:
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 55   :         for (_nCOConnectionIndex = 0; _nCOConnectionIndex < nConnections; _nCOConnectionIndex++)

  00070	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00073	41		 inc	 ecx
  00074	89 4e 20	 mov	 DWORD PTR [esi+32], ecx
  00077	3b cb		 cmp	 ecx, ebx
  00079	7c a5		 jl	 SHORT $LL4@Fire_DataE
; File C:\Develop\OPOS-CCO\Common\OposVariant.h

; 78   :     ~OposVariant() { if (_bNeedClear) Clear(); }

  0007b	80 7d f8 00	 cmp	 BYTE PTR _var$[ebp+16], 0
  0007f	5f		 pop	 edi
  00080	74 0e		 je	 SHORT $LN26@Fire_DataE

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00082	8d 45 e8	 lea	 eax, DWORD PTR _var$[ebp]
  00085	c6 45 f8 00	 mov	 BYTE PTR _var$[ebp+16], 0
  00089	50		 push	 eax
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN26@Fire_DataE:
  00090	5e		 pop	 esi
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitorCP.h

; 67   :     }

  00091	5b		 pop	 ebx
  00092	c9		 leave
  00093	c2 04 00	 ret	 4
?Fire_DataEvent@?$CProxy_IOPOSEvents@VCOPOSDeviceMonitor@@@@QAEXJ@Z ENDP ; CProxy_IOPOSEvents<COPOSDeviceMonitor>::Fire_DataEvent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z
_TEXT	SEGMENT
_pcd$1$ = -8						; size = 4
_pend$1$ = -4						; size = 4
_this$ = 8						; size = 4
_ppEnum$ = 12						; size = 4
?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::EnumConnections, COMDAT

; 6412 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	57		 push	 edi

; 6413 : 	if (ppEnum == NULL)

  00006	8b 7d 0c	 mov	 edi, DWORD PTR _ppEnum$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	75 07		 jne	 SHORT $LN5@EnumConnec

; 6414 : 		return E_POINTER;

  0000d	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00012	eb 5b		 jmp	 SHORT $LN1@EnumConnec
$LN5@EnumConnec:

; 6415 : 	*ppEnum = NULL;

  00014	83 27 00	 and	 DWORD PTR [edi], 0
  00017	53		 push	 ebx
  00018	56		 push	 esi

; 6416 : 	CComObject<CComEnumConnections>* pEnum = NULL;
; 6417 : 	pEnum = _ATL_NEW CComObject<CComEnumConnections>;

  00019	bb 00 00 00 00	 mov	 ebx, OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001e	53		 push	 ebx
  0001f	6a 1c		 push	 28			; 0000001cH
  00021	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  00026	59		 pop	 ecx
  00027	59		 pop	 ecx
  00028	85 c0		 test	 eax, eax
  0002a	74 3c		 je	 SHORT $LN31@EnumConnec
  0002c	6a 00		 push	 0
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ??0?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >
  00035	8b f0		 mov	 esi, eax

; 6418 : 	if (pEnum == NULL)

  00037	85 f6		 test	 esi, esi
  00039	74 2d		 je	 SHORT $LN31@EnumConnec

; 6420 : 	T* pT = static_cast<T*>(this);
; 6421 : 	pT->Lock();
; 6422 : 	CONNECTDATA* pcd = NULL;
; 6423 : 	pcd = _ATL_NEW CONNECTDATA[m_vec.end()-m_vec.begin()];

  0003b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	33 c9		 xor	 ecx, ecx
  00040	53		 push	 ebx
  00041	6a 08		 push	 8
  00043	5a		 pop	 edx
  00044	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00047	f7 e2		 mul	 edx
  00049	0f 90 c1	 seto	 cl
  0004c	f7 d9		 neg	 ecx
  0004e	0b c8		 or	 ecx, eax
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  00056	89 45 f8	 mov	 DWORD PTR _pcd$1$[ebp], eax
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 6424 : 	if (pcd == NULL)

  0005b	85 c0		 test	 eax, eax
  0005d	75 15		 jne	 SHORT $LN7@EnumConnec

; 6425 : 	{
; 6426 : 		delete pEnum;

  0005f	8b 06		 mov	 eax, DWORD PTR [esi]
  00061	8b ce		 mov	 ecx, esi
  00063	6a 01		 push	 1
  00065	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN31@EnumConnec:

; 6419 : 		return E_OUTOFMEMORY;

  00068	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
$LN32@EnumConnec:
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
$LN1@EnumConnec:
  0006f	5f		 pop	 edi

; 6449 : }

  00070	c9		 leave
  00071	c2 08 00	 ret	 8
$LN7@EnumConnec:

; 6427 : 		pT->Unlock();
; 6428 : 		return E_OUTOFMEMORY;
; 6429 : 	}
; 6430 : 	CONNECTDATA* pend = pcd;

  00074	8b d0		 mov	 edx, eax

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  00076	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00079	89 55 fc	 mov	 DWORD PTR _pend$1$[ebp], edx
  0007c	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]

; 6192 : 		return &m_ppUnk[m_nSize];

  0007f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  00082	8b 19		 mov	 ebx, DWORD PTR [ecx]

; 6192 : 		return &m_ppUnk[m_nSize];

  00084	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  00087	3b d8		 cmp	 ebx, eax
  00089	73 3a		 jae	 SHORT $LN3@EnumConnec
  0008b	8b f9		 mov	 edi, ecx
$LL4@EnumConnec:

; 6433 : 	{
; 6434 : 		if (*pp != NULL)

  0008d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0008f	85 c9		 test	 ecx, ecx
  00091	74 20		 je	 SHORT $LN2@EnumConnec

; 6435 : 		{
; 6436 : 			(*pp)->AddRef();

  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	51		 push	 ecx
  00096	ff 50 04	 call	 DWORD PTR [eax+4]

; 6437 : 			pend->pUnk = *pp;

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _pend$1$[ebp]
  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]

; 6438 : 			pend->dwCookie = m_vec.GetCookie(pp);

  0009e	53		 push	 ebx
  0009f	57		 push	 edi
  000a0	89 01		 mov	 DWORD PTR [ecx], eax
  000a2	e8 00 00 00 00	 call	 ?GetCookie@CComDynamicUnkArray@ATL@@QAGKPAPAUIUnknown@@@Z ; ATL::CComDynamicUnkArray::GetCookie
  000a7	8b 55 fc	 mov	 edx, DWORD PTR _pend$1$[ebp]
  000aa	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 6439 : 			pend++;

  000ad	83 c2 08	 add	 edx, 8
  000b0	89 55 fc	 mov	 DWORD PTR _pend$1$[ebp], edx
$LN2@EnumConnec:

; 6192 : 		return &m_ppUnk[m_nSize];

  000b3	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  000b6	83 c3 04	 add	 ebx, 4

; 6192 : 		return &m_ppUnk[m_nSize];

  000b9	8b 07		 mov	 eax, DWORD PTR [edi]
  000bb	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  000be	3b d8		 cmp	 ebx, eax
  000c0	72 cb		 jb	 SHORT $LL4@EnumConnec
  000c2	8b 7d 0c	 mov	 edi, DWORD PTR _ppEnum$[ebp]
$LN3@EnumConnec:

; 6440 : 		}
; 6441 : 	}
; 6442 : 	// don't copy the data, but transfer ownership to it
; 6443 : 	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);

  000c5	6a 02		 push	 2
  000c7	6a 00		 push	 0
  000c9	52		 push	 edx
  000ca	ff 75 f8	 push	 DWORD PTR _pcd$1$[ebp]
  000cd	8b ce		 mov	 ecx, esi
  000cf	e8 00 00 00 00	 call	 ?Init@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@QAEJPAUtagCONNECTDATA@@0PAUIUnknown@@W4CComEnumFlags@2@@Z ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Init

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  000d4	57		 push	 edi
  000d5	68 00 00 00 00	 push	 OFFSET __GUID_b196b287_bab4_101a_b69c_00aa00341d07
  000da	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
  000df	56		 push	 esi
  000e0	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 6444 : 	pT->Unlock();
; 6445 : 	HRESULT hRes = pEnum->_InternalQueryInterface(__uuidof(IEnumConnections), (void**)ppEnum);

  000e5	8b f8		 mov	 edi, eax

; 6446 : 	if (FAILED(hRes))

  000e7	85 ff		 test	 edi, edi
  000e9	79 09		 jns	 SHORT $LN17@EnumConnec

; 6447 : 		delete pEnum;

  000eb	8b 16		 mov	 edx, DWORD PTR [esi]
  000ed	8b ce		 mov	 ecx, esi
  000ef	6a 01		 push	 1
  000f1	ff 52 1c	 call	 DWORD PTR [edx+28]
$LN17@EnumConnec:

; 6448 : 	return hRes;

  000f4	8b c7		 mov	 eax, edi
  000f6	e9 72 ff ff ff	 jmp	 $LN32@EnumConnec
?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::EnumConnections
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwCookie$ = 12						; size = 4
?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::Unadvise, COMDAT

; 6397 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 6398 : 	T* pT = static_cast<T*>(this);
; 6399 : 	pT->Lock();
; 6400 : 	IUnknown* p = m_vec.GetUnknown(dwCookie);

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	57		 push	 edi
  00008	ff 75 0c	 push	 DWORD PTR _dwCookie$[ebp]
  0000b	83 c6 04	 add	 esi, 4
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 ?GetUnknown@CComDynamicUnkArray@ATL@@QAGPAUIUnknown@@K@Z ; ATL::CComDynamicUnkArray::GetUnknown

; 6401 : 	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;

  00014	ff 75 0c	 push	 DWORD PTR _dwCookie$[ebp]
  00017	8b ce		 mov	 ecx, esi
  00019	8b f8		 mov	 edi, eax
  0001b	e8 00 00 00 00	 call	 ?Remove@CComDynamicUnkArray@ATL@@QAEHK@Z ; ATL::CComDynamicUnkArray::Remove
  00020	33 c9		 xor	 ecx, ecx
  00022	be 00 02 04 80	 mov	 esi, -2147220992	; 80040200H
  00027	85 c0		 test	 eax, eax
  00029	0f 45 f1	 cmovne	 esi, ecx

; 6402 : 	pT->Unlock();
; 6403 : 	if (hRes == S_OK && p != NULL)

  0002c	74 0a		 je	 SHORT $LN2@Unadvise
  0002e	85 ff		 test	 edi, edi
  00030	74 06		 je	 SHORT $LN2@Unadvise

; 6404 : 		p->Release();

  00032	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00034	57		 push	 edi
  00035	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN2@Unadvise:

; 6405 : 	return hRes;

  00038	5f		 pop	 edi
  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi

; 6406 : }

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::Unadvise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z
_TEXT	SEGMENT
_p$ = -24						; size = 4
_iid$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_pUnkSink$ = 12						; size = 4
_pdwCookie$ = 16					; size = 4
?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::Advise, COMDAT

; 6368 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6369 : 	T* pT = static_cast<T*>(this);
; 6370 : 	IUnknown* p = NULL;

  00010	83 65 e8 00	 and	 DWORD PTR _p$[ebp], 0
  00014	53		 push	 ebx
  00015	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00018	56		 push	 esi
  00019	8b 75 0c	 mov	 esi, DWORD PTR _pUnkSink$[ebp]
  0001c	57		 push	 edi
  0001d	8b 7d 10	 mov	 edi, DWORD PTR _pdwCookie$[ebp]

; 6371 : 	HRESULT hRes = S_OK;
; 6372 : 	if (pdwCookie != NULL)

  00020	85 ff		 test	 edi, edi
  00022	74 03		 je	 SHORT $LN13@Advise

; 6373 : 		*pdwCookie = 0;

  00024	83 27 00	 and	 DWORD PTR [edi], 0
$LN13@Advise:

; 6374 : 	if (pUnkSink == NULL || pdwCookie == NULL)

  00027	85 f6		 test	 esi, esi
  00029	74 5f		 je	 SHORT $LN4@Advise
  0002b	85 ff		 test	 edi, edi
  0002d	74 5b		 je	 SHORT $LN4@Advise

; 6376 : 	IID iid;
; 6377 : 	GetConnectionInterface(&iid);

  0002f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00031	8d 4d ec	 lea	 ecx, DWORD PTR _iid$[ebp]
  00034	51		 push	 ecx
  00035	53		 push	 ebx
  00036	ff 50 0c	 call	 DWORD PTR [eax+12]

; 6378 : 	hRes = pUnkSink->QueryInterface(iid, (void**)&p);

  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	8d 4d e8	 lea	 ecx, DWORD PTR _p$[ebp]
  0003e	51		 push	 ecx
  0003f	8d 4d ec	 lea	 ecx, DWORD PTR _iid$[ebp]
  00042	51		 push	 ecx
  00043	56		 push	 esi
  00044	ff 10		 call	 DWORD PTR [eax]
  00046	8b f0		 mov	 esi, eax

; 6379 : 	if (SUCCEEDED(hRes))

  00048	85 f6		 test	 esi, esi
  0004a	78 2a		 js	 SHORT $LN5@Advise

; 6380 : 	{
; 6381 : 		pT->Lock();
; 6382 : 		*pdwCookie = m_vec.Add(p);

  0004c	ff 75 e8	 push	 DWORD PTR _p$[ebp]
  0004f	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00052	e8 00 00 00 00	 call	 ?Add@CComDynamicUnkArray@ATL@@QAEKPAUIUnknown@@@Z ; ATL::CComDynamicUnkArray::Add

; 6383 : 		hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT;

  00057	33 c9		 xor	 ecx, ecx
  00059	89 07		 mov	 DWORD PTR [edi], eax
  0005b	85 c0		 test	 eax, eax
  0005d	be 01 02 04 80	 mov	 esi, -2147220991	; 80040201H
  00062	0f 45 f1	 cmovne	 esi, ecx

; 6384 : 		pT->Unlock();
; 6385 : 		if (hRes != S_OK)

  00065	75 09		 jne	 SHORT $LN8@Advise

; 6386 : 			p->Release();

  00067	8b 45 e8	 mov	 eax, DWORD PTR _p$[ebp]
  0006a	50		 push	 eax
  0006b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006d	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN8@Advise:

; 6390 : 	if (FAILED(hRes))

  00070	85 f6		 test	 esi, esi
  00072	79 12		 jns	 SHORT $LN9@Advise
  00074	eb 0d		 jmp	 SHORT $LN14@Advise
$LN5@Advise:

; 6387 : 	}
; 6388 : 	else if (hRes == E_NOINTERFACE)

  00076	81 fe 02 40 00
	80		 cmp	 esi, -2147467262	; 80004002H
  0007c	75 05		 jne	 SHORT $LN14@Advise

; 6389 : 		hRes = CONNECT_E_CANNOTCONNECT;

  0007e	be 02 02 04 80	 mov	 esi, -2147220990	; 80040202H
$LN14@Advise:

; 6391 : 		*pdwCookie = 0;

  00083	83 27 00	 and	 DWORD PTR [edi], 0
$LN9@Advise:

; 6392 : 	return hRes;

  00086	8b c6		 mov	 eax, esi
  00088	eb 05		 jmp	 SHORT $LN1@Advise
$LN4@Advise:

; 6375 : 		return E_POINTER;

  0008a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@Advise:

; 6393 : }

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	33 cd		 xor	 ecx, ebp
  00096	5b		 pop	 ebx
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	c9		 leave
  0009d	c2 0c 00	 ret	 12			; 0000000cH
?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::Advise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ppCPC$ = 12						; size = 4
?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::GetConnectionPointContainer, COMDAT

; 6338 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6339 : 		T* pT = static_cast<T*>(this);
; 6340 : 		// No need to check ppCPC for NULL since QI will do that for us
; 6341 : 		return pT->QueryInterface(__uuidof(IConnectionPointContainer), (void**)ppCPC);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _ppCPC$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET __GUID_b196b284_bab4_101a_b69c_00aa00341d07
  0000e	8d 81 4c ff ff
	ff		 lea	 eax, DWORD PTR [ecx-180]
  00014	f7 d9		 neg	 ecx
  00016	1b c9		 sbb	 ecx, ecx
  00018	23 c8		 and	 ecx, eax
  0001a	51		 push	 ecx
  0001b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001d	ff 10		 call	 DWORD PTR [eax]

; 6342 : 	}

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::GetConnectionPointContainer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_piid2$ = 12						; size = 4
?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::GetConnectionInterface, COMDAT

; 6330 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 6331 : 		if (piid2 == NULL)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _piid2$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 07		 jne	 SHORT $LN2@GetConnect

; 6332 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 0d		 jmp	 SHORT $LN1@GetConnect
$LN2@GetConnect:
  00012	56		 push	 esi

; 6333 : 		*piid2 = *piid;

  00013	be 00 00 00 00	 mov	 esi, OFFSET _DIID__IOPOSDeviceMonitorEvents

; 6334 : 		return S_OK;

  00018	33 c0		 xor	 eax, eax
  0001a	a5		 movsd
  0001b	a5		 movsd
  0001c	a5		 movsd
  0001d	a5		 movsd
  0001e	5e		 pop	 esi
$LN1@GetConnect:
  0001f	5f		 pop	 edi

; 6335 : 	}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::GetConnectionInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::_LocCPQueryInterface, COMDAT

; 6308 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 6309 : #ifndef _ATL_OLEDB_CONFORMANCE_TESTS
; 6310 : 		ATLASSERT(ppvObject != NULL);
; 6311 : #endif
; 6312 : 		if (ppvObject == NULL)

  00004	8b 75 10	 mov	 esi, DWORD PTR _ppvObject$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@LocCPQuery

; 6313 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 36		 jmp	 SHORT $LN4@LocCPQuery
$LN2@LocCPQuery:

; 6314 : 		*ppvObject = NULL;

  00012	83 26 00	 and	 DWORD PTR [esi], 0

; 6315 : 
; 6316 : 		if (InlineIsEqualGUID(riid, __uuidof(IConnectionPoint)) || InlineIsEqualUnknown(riid))

  00015	68 00 00 00 00	 push	 OFFSET __GUID_b196b286_bab4_101a_b69c_00aa00341d07
  0001a	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  0001d	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
  00024	85 c0		 test	 eax, eax
  00026	75 13		 jne	 SHORT $LN5@LocCPQuery
  00028	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  0002b	e8 00 00 00 00	 call	 ?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z ; ATL::InlineIsEqualUnknown
  00030	85 c0		 test	 eax, eax
  00032	75 07		 jne	 SHORT $LN5@LocCPQuery

; 6324 : 		}
; 6325 : 		else
; 6326 : 			return E_NOINTERFACE;

  00034	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  00039	eb 0d		 jmp	 SHORT $LN4@LocCPQuery
$LN5@LocCPQuery:

; 6317 : 		{
; 6318 : 			*ppvObject = this;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx

; 6319 : 			this->AddRef();

  00040	51		 push	 ecx
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	ff 50 04	 call	 DWORD PTR [eax+4]

; 6320 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 6321 : 			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, _T("IConnectionPointImpl"), riid);
; 6322 : #endif // _ATL_DEBUG_INTERFACES
; 6323 : 			return S_OK;

  00046	33 c0		 xor	 eax, eax
$LN4@LocCPQuery:
  00048	5e		 pop	 esi

; 6327 : 	}

  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?DIID__IOPOSDeviceMonitorEvents@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,ATL::CComDynamicUnkArray>::_LocCPQueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetObjectDescription@?$CComCoClass@VCOPOSDeviceMonitor@@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B@ATL@@SGPB_WXZ
_TEXT	SEGMENT
?GetObjectDescription@?$CComCoClass@VCOPOSDeviceMonitor@@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B@ATL@@SGPB_WXZ PROC ; ATL::CComCoClass<COPOSDeviceMonitor,&CLSID_OPOSDeviceMonitor>::GetObjectDescription, COMDAT

; 4015 : 		return NULL;

  00000	33 c0		 xor	 eax, eax

; 4016 : 	}

  00002	c3		 ret	 0
?GetObjectDescription@?$CComCoClass@VCOPOSDeviceMonitor@@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B@ATL@@SGPB_WXZ ENDP ; ATL::CComCoClass<COPOSDeviceMonitor,&CLSID_OPOSDeviceMonitor>::GetObjectDescription
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z
_TEXT	SEGMENT
_pcd$1$ = -8						; size = 4
_pend$1$ = -4						; size = 4
_this$ = 8						; size = 4
_ppEnum$ = 12						; size = 4
?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::EnumConnections, COMDAT

; 6412 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	57		 push	 edi

; 6413 : 	if (ppEnum == NULL)

  00006	8b 7d 0c	 mov	 edi, DWORD PTR _ppEnum$[ebp]
  00009	85 ff		 test	 edi, edi
  0000b	75 07		 jne	 SHORT $LN5@EnumConnec

; 6414 : 		return E_POINTER;

  0000d	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00012	eb 5b		 jmp	 SHORT $LN1@EnumConnec
$LN5@EnumConnec:

; 6415 : 	*ppEnum = NULL;

  00014	83 27 00	 and	 DWORD PTR [edi], 0
  00017	53		 push	 ebx
  00018	56		 push	 esi

; 6416 : 	CComObject<CComEnumConnections>* pEnum = NULL;
; 6417 : 	pEnum = _ATL_NEW CComObject<CComEnumConnections>;

  00019	bb 00 00 00 00	 mov	 ebx, OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001e	53		 push	 ebx
  0001f	6a 1c		 push	 28			; 0000001cH
  00021	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  00026	59		 pop	 ecx
  00027	59		 pop	 ecx
  00028	85 c0		 test	 eax, eax
  0002a	74 3c		 je	 SHORT $LN31@EnumConnec
  0002c	6a 00		 push	 0
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ??0?$CComObject@V?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel> >
  00035	8b f0		 mov	 esi, eax

; 6418 : 	if (pEnum == NULL)

  00037	85 f6		 test	 esi, esi
  00039	74 2d		 je	 SHORT $LN31@EnumConnec

; 6420 : 	T* pT = static_cast<T*>(this);
; 6421 : 	pT->Lock();
; 6422 : 	CONNECTDATA* pcd = NULL;
; 6423 : 	pcd = _ATL_NEW CONNECTDATA[m_vec.end()-m_vec.begin()];

  0003b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	33 c9		 xor	 ecx, ecx
  00040	53		 push	 ebx
  00041	6a 08		 push	 8
  00043	5a		 pop	 edx
  00044	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00047	f7 e2		 mul	 edx
  00049	0f 90 c1	 seto	 cl
  0004c	f7 d9		 neg	 ecx
  0004e	0b c8		 or	 ecx, eax
  00050	51		 push	 ecx
  00051	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  00056	89 45 f8	 mov	 DWORD PTR _pcd$1$[ebp], eax
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 6424 : 	if (pcd == NULL)

  0005b	85 c0		 test	 eax, eax
  0005d	75 15		 jne	 SHORT $LN7@EnumConnec

; 6425 : 	{
; 6426 : 		delete pEnum;

  0005f	8b 06		 mov	 eax, DWORD PTR [esi]
  00061	8b ce		 mov	 ecx, esi
  00063	6a 01		 push	 1
  00065	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN31@EnumConnec:

; 6419 : 		return E_OUTOFMEMORY;

  00068	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
$LN32@EnumConnec:
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
$LN1@EnumConnec:
  0006f	5f		 pop	 edi

; 6449 : }

  00070	c9		 leave
  00071	c2 08 00	 ret	 8
$LN7@EnumConnec:

; 6427 : 		pT->Unlock();
; 6428 : 		return E_OUTOFMEMORY;
; 6429 : 	}
; 6430 : 	CONNECTDATA* pend = pcd;

  00074	8b d0		 mov	 edx, eax

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  00076	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00079	89 55 fc	 mov	 DWORD PTR _pend$1$[ebp], edx
  0007c	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]

; 6192 : 		return &m_ppUnk[m_nSize];

  0007f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  00082	8b 19		 mov	 ebx, DWORD PTR [ecx]

; 6192 : 		return &m_ppUnk[m_nSize];

  00084	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  00087	3b d8		 cmp	 ebx, eax
  00089	73 3a		 jae	 SHORT $LN3@EnumConnec
  0008b	8b f9		 mov	 edi, ecx
$LL4@EnumConnec:

; 6433 : 	{
; 6434 : 		if (*pp != NULL)

  0008d	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0008f	85 c9		 test	 ecx, ecx
  00091	74 20		 je	 SHORT $LN2@EnumConnec

; 6435 : 		{
; 6436 : 			(*pp)->AddRef();

  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	51		 push	 ecx
  00096	ff 50 04	 call	 DWORD PTR [eax+4]

; 6437 : 			pend->pUnk = *pp;

  00099	8b 4d fc	 mov	 ecx, DWORD PTR _pend$1$[ebp]
  0009c	8b 03		 mov	 eax, DWORD PTR [ebx]

; 6438 : 			pend->dwCookie = m_vec.GetCookie(pp);

  0009e	53		 push	 ebx
  0009f	57		 push	 edi
  000a0	89 01		 mov	 DWORD PTR [ecx], eax
  000a2	e8 00 00 00 00	 call	 ?GetCookie@CComDynamicUnkArray@ATL@@QAGKPAPAUIUnknown@@@Z ; ATL::CComDynamicUnkArray::GetCookie
  000a7	8b 55 fc	 mov	 edx, DWORD PTR _pend$1$[ebp]
  000aa	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 6439 : 			pend++;

  000ad	83 c2 08	 add	 edx, 8
  000b0	89 55 fc	 mov	 DWORD PTR _pend$1$[ebp], edx
$LN2@EnumConnec:

; 6192 : 		return &m_ppUnk[m_nSize];

  000b3	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  000b6	83 c3 04	 add	 ebx, 4

; 6192 : 		return &m_ppUnk[m_nSize];

  000b9	8b 07		 mov	 eax, DWORD PTR [edi]
  000bb	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 6431 : 	// Copy the valid CONNECTDATA's
; 6432 : 	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)

  000be	3b d8		 cmp	 ebx, eax
  000c0	72 cb		 jb	 SHORT $LL4@EnumConnec
  000c2	8b 7d 0c	 mov	 edi, DWORD PTR _ppEnum$[ebp]
$LN3@EnumConnec:

; 6440 : 		}
; 6441 : 	}
; 6442 : 	// don't copy the data, but transfer ownership to it
; 6443 : 	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);

  000c5	6a 02		 push	 2
  000c7	6a 00		 push	 0
  000c9	52		 push	 edx
  000ca	ff 75 f8	 push	 DWORD PTR _pcd$1$[ebp]
  000cd	8b ce		 mov	 ecx, esi
  000cf	e8 00 00 00 00	 call	 ?Init@?$CComEnumImpl@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@@ATL@@QAEJPAUtagCONNECTDATA@@0PAUIUnknown@@W4CComEnumFlags@2@@Z ; ATL::CComEnumImpl<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA> >::Init

; 2487 : 		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);

  000d4	57		 push	 edi
  000d5	68 00 00 00 00	 push	 OFFSET __GUID_b196b287_bab4_101a_b69c_00aa00341d07
  000da	68 00 00 00 00	 push	 OFFSET ?_entries@?1??_GetEntries@?$CComEnum@UIEnumConnections@@$1?_GUID_b196b287_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BUtagCONNECTDATA@@V?$_Copy@UtagCONNECTDATA@@@ATL@@VCComSingleThreadModel@6@@ATL@@SGPBU_ATL_INTMAP_ENTRY@3@XZ@4QBU43@B ; `ATL::CComEnum<IEnumConnections,&_GUID_b196b287_bab4_101a_b69c_00aa00341d07,tagCONNECTDATA,ATL::_Copy<tagCONNECTDATA>,ATL::CComSingleThreadModel>::_GetEntries'::`2'::_entries
  000df	56		 push	 esi
  000e0	e8 00 00 00 00	 call	 ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ; ATL::AtlInternalQueryInterface

; 6444 : 	pT->Unlock();
; 6445 : 	HRESULT hRes = pEnum->_InternalQueryInterface(__uuidof(IEnumConnections), (void**)ppEnum);

  000e5	8b f8		 mov	 edi, eax

; 6446 : 	if (FAILED(hRes))

  000e7	85 ff		 test	 edi, edi
  000e9	79 09		 jns	 SHORT $LN17@EnumConnec

; 6447 : 		delete pEnum;

  000eb	8b 16		 mov	 edx, DWORD PTR [esi]
  000ed	8b ce		 mov	 ecx, esi
  000ef	6a 01		 push	 1
  000f1	ff 52 1c	 call	 DWORD PTR [edx+28]
$LN17@EnumConnec:

; 6448 : 	return hRes;

  000f4	8b c7		 mov	 eax, edi
  000f6	e9 72 ff ff ff	 jmp	 $LN32@EnumConnec
?EnumConnections@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIEnumConnections@@@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::EnumConnections
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwCookie$ = 12						; size = 4
?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::Unadvise, COMDAT

; 6397 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 6398 : 	T* pT = static_cast<T*>(this);
; 6399 : 	pT->Lock();
; 6400 : 	IUnknown* p = m_vec.GetUnknown(dwCookie);

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	57		 push	 edi
  00008	ff 75 0c	 push	 DWORD PTR _dwCookie$[ebp]
  0000b	83 c6 04	 add	 esi, 4
  0000e	56		 push	 esi
  0000f	e8 00 00 00 00	 call	 ?GetUnknown@CComDynamicUnkArray@ATL@@QAGPAUIUnknown@@K@Z ; ATL::CComDynamicUnkArray::GetUnknown

; 6401 : 	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;

  00014	ff 75 0c	 push	 DWORD PTR _dwCookie$[ebp]
  00017	8b ce		 mov	 ecx, esi
  00019	8b f8		 mov	 edi, eax
  0001b	e8 00 00 00 00	 call	 ?Remove@CComDynamicUnkArray@ATL@@QAEHK@Z ; ATL::CComDynamicUnkArray::Remove
  00020	33 c9		 xor	 ecx, ecx
  00022	be 00 02 04 80	 mov	 esi, -2147220992	; 80040200H
  00027	85 c0		 test	 eax, eax
  00029	0f 45 f1	 cmovne	 esi, ecx

; 6402 : 	pT->Unlock();
; 6403 : 	if (hRes == S_OK && p != NULL)

  0002c	74 0a		 je	 SHORT $LN2@Unadvise
  0002e	85 ff		 test	 edi, edi
  00030	74 06		 je	 SHORT $LN2@Unadvise

; 6404 : 		p->Release();

  00032	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00034	57		 push	 edi
  00035	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN2@Unadvise:

; 6405 : 	return hRes;

  00038	5f		 pop	 edi
  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi

; 6406 : }

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
?Unadvise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJK@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::Unadvise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z
_TEXT	SEGMENT
_p$ = -24						; size = 4
_iid$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_pUnkSink$ = 12						; size = 4
_pdwCookie$ = 16					; size = 4
?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::Advise, COMDAT

; 6368 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6369 : 	T* pT = static_cast<T*>(this);
; 6370 : 	IUnknown* p = NULL;

  00010	83 65 e8 00	 and	 DWORD PTR _p$[ebp], 0
  00014	53		 push	 ebx
  00015	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  00018	56		 push	 esi
  00019	8b 75 0c	 mov	 esi, DWORD PTR _pUnkSink$[ebp]
  0001c	57		 push	 edi
  0001d	8b 7d 10	 mov	 edi, DWORD PTR _pdwCookie$[ebp]

; 6371 : 	HRESULT hRes = S_OK;
; 6372 : 	if (pdwCookie != NULL)

  00020	85 ff		 test	 edi, edi
  00022	74 03		 je	 SHORT $LN13@Advise

; 6373 : 		*pdwCookie = 0;

  00024	83 27 00	 and	 DWORD PTR [edi], 0
$LN13@Advise:

; 6374 : 	if (pUnkSink == NULL || pdwCookie == NULL)

  00027	85 f6		 test	 esi, esi
  00029	74 5f		 je	 SHORT $LN4@Advise
  0002b	85 ff		 test	 edi, edi
  0002d	74 5b		 je	 SHORT $LN4@Advise

; 6376 : 	IID iid;
; 6377 : 	GetConnectionInterface(&iid);

  0002f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00031	8d 4d ec	 lea	 ecx, DWORD PTR _iid$[ebp]
  00034	51		 push	 ecx
  00035	53		 push	 ebx
  00036	ff 50 0c	 call	 DWORD PTR [eax+12]

; 6378 : 	hRes = pUnkSink->QueryInterface(iid, (void**)&p);

  00039	8b 06		 mov	 eax, DWORD PTR [esi]
  0003b	8d 4d e8	 lea	 ecx, DWORD PTR _p$[ebp]
  0003e	51		 push	 ecx
  0003f	8d 4d ec	 lea	 ecx, DWORD PTR _iid$[ebp]
  00042	51		 push	 ecx
  00043	56		 push	 esi
  00044	ff 10		 call	 DWORD PTR [eax]
  00046	8b f0		 mov	 esi, eax

; 6379 : 	if (SUCCEEDED(hRes))

  00048	85 f6		 test	 esi, esi
  0004a	78 2a		 js	 SHORT $LN5@Advise

; 6380 : 	{
; 6381 : 		pT->Lock();
; 6382 : 		*pdwCookie = m_vec.Add(p);

  0004c	ff 75 e8	 push	 DWORD PTR _p$[ebp]
  0004f	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00052	e8 00 00 00 00	 call	 ?Add@CComDynamicUnkArray@ATL@@QAEKPAUIUnknown@@@Z ; ATL::CComDynamicUnkArray::Add

; 6383 : 		hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT;

  00057	33 c9		 xor	 ecx, ecx
  00059	89 07		 mov	 DWORD PTR [edi], eax
  0005b	85 c0		 test	 eax, eax
  0005d	be 01 02 04 80	 mov	 esi, -2147220991	; 80040201H
  00062	0f 45 f1	 cmovne	 esi, ecx

; 6384 : 		pT->Unlock();
; 6385 : 		if (hRes != S_OK)

  00065	75 09		 jne	 SHORT $LN8@Advise

; 6386 : 			p->Release();

  00067	8b 45 e8	 mov	 eax, DWORD PTR _p$[ebp]
  0006a	50		 push	 eax
  0006b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006d	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN8@Advise:

; 6390 : 	if (FAILED(hRes))

  00070	85 f6		 test	 esi, esi
  00072	79 12		 jns	 SHORT $LN9@Advise
  00074	eb 0d		 jmp	 SHORT $LN14@Advise
$LN5@Advise:

; 6387 : 	}
; 6388 : 	else if (hRes == E_NOINTERFACE)

  00076	81 fe 02 40 00
	80		 cmp	 esi, -2147467262	; 80004002H
  0007c	75 05		 jne	 SHORT $LN14@Advise

; 6389 : 		hRes = CONNECT_E_CANNOTCONNECT;

  0007e	be 02 02 04 80	 mov	 esi, -2147220990	; 80040202H
$LN14@Advise:

; 6391 : 		*pdwCookie = 0;

  00083	83 27 00	 and	 DWORD PTR [edi], 0
$LN9@Advise:

; 6392 : 	return hRes;

  00086	8b c6		 mov	 eax, esi
  00088	eb 05		 jmp	 SHORT $LN1@Advise
$LN4@Advise:

; 6375 : 		return E_POINTER;

  0008a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@Advise:

; 6393 : }

  0008f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	33 cd		 xor	 ecx, ebp
  00096	5b		 pop	 ebx
  00097	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009c	c9		 leave
  0009d	c2 0c 00	 ret	 12			; 0000000cH
?Advise@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAUIUnknown@@PAK@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::Advise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ppCPC$ = 12						; size = 4
?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::GetConnectionPointContainer, COMDAT

; 6338 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6339 : 		T* pT = static_cast<T*>(this);
; 6340 : 		// No need to check ppCPC for NULL since QI will do that for us
; 6341 : 		return pT->QueryInterface(__uuidof(IConnectionPointContainer), (void**)ppCPC);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _ppCPC$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET __GUID_b196b284_bab4_101a_b69c_00aa00341d07
  0000e	8d 81 58 ff ff
	ff		 lea	 eax, DWORD PTR [ecx-168]
  00014	f7 d9		 neg	 ecx
  00016	1b c9		 sbb	 ecx, ecx
  00018	23 c8		 and	 ecx, eax
  0001a	51		 push	 ecx
  0001b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001d	ff 10		 call	 DWORD PTR [eax]

; 6342 : 	}

  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?GetConnectionPointContainer@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAPAUIConnectionPointContainer@@@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::GetConnectionPointContainer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_piid2$ = 12						; size = 4
?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::GetConnectionInterface, COMDAT

; 6330 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 6331 : 		if (piid2 == NULL)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _piid2$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 07		 jne	 SHORT $LN2@GetConnect

; 6332 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 0d		 jmp	 SHORT $LN1@GetConnect
$LN2@GetConnect:
  00012	56		 push	 esi

; 6333 : 		*piid2 = *piid;

  00013	be 00 00 00 00	 mov	 esi, OFFSET _IID_IPropertyNotifySink

; 6334 : 		return S_OK;

  00018	33 c0		 xor	 eax, eax
  0001a	a5		 movsd
  0001b	a5		 movsd
  0001c	a5		 movsd
  0001d	a5		 movsd
  0001e	5e		 pop	 esi
$LN1@GetConnect:
  0001f	5f		 pop	 edi

; 6335 : 	}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?GetConnectionInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJPAU_GUID@@@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::GetConnectionInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppvObject$ = 16					; size = 4
?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::_LocCPQueryInterface, COMDAT

; 6308 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 6309 : #ifndef _ATL_OLEDB_CONFORMANCE_TESTS
; 6310 : 		ATLASSERT(ppvObject != NULL);
; 6311 : #endif
; 6312 : 		if (ppvObject == NULL)

  00004	8b 75 10	 mov	 esi, DWORD PTR _ppvObject$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@LocCPQuery

; 6313 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 36		 jmp	 SHORT $LN4@LocCPQuery
$LN2@LocCPQuery:

; 6314 : 		*ppvObject = NULL;

  00012	83 26 00	 and	 DWORD PTR [esi], 0

; 6315 : 
; 6316 : 		if (InlineIsEqualGUID(riid, __uuidof(IConnectionPoint)) || InlineIsEqualUnknown(riid))

  00015	68 00 00 00 00	 push	 OFFSET __GUID_b196b286_bab4_101a_b69c_00aa00341d07
  0001a	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  0001d	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
  00024	85 c0		 test	 eax, eax
  00026	75 13		 jne	 SHORT $LN5@LocCPQuery
  00028	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  0002b	e8 00 00 00 00	 call	 ?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z ; ATL::InlineIsEqualUnknown
  00030	85 c0		 test	 eax, eax
  00032	75 07		 jne	 SHORT $LN5@LocCPQuery

; 6324 : 		}
; 6325 : 		else
; 6326 : 			return E_NOINTERFACE;

  00034	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  00039	eb 0d		 jmp	 SHORT $LN4@LocCPQuery
$LN5@LocCPQuery:

; 6317 : 		{
; 6318 : 			*ppvObject = this;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx

; 6319 : 			this->AddRef();

  00040	51		 push	 ecx
  00041	8b 01		 mov	 eax, DWORD PTR [ecx]
  00043	ff 50 04	 call	 DWORD PTR [eax+4]

; 6320 : #if defined(_ATL_DEBUG_INTERFACES) && !defined(_ATL_STATIC_LIB_IMPL)
; 6321 : 			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, _T("IConnectionPointImpl"), riid);
; 6322 : #endif // _ATL_DEBUG_INTERFACES
; 6323 : 			return S_OK;

  00046	33 c0		 xor	 eax, eax
$LN4@LocCPQuery:
  00048	5e		 pop	 esi

; 6327 : 	}

  00049	5d		 pop	 ebp
  0004a	c2 0c 00	 ret	 12			; 0000000cH
?_LocCPQueryInterface@?$IConnectionPointImpl@VCOPOSDeviceMonitor@@$1?IID_IPropertyNotifySink@@3U_GUID@@BVCComDynamicUnkArray@ATL@@@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::IConnectionPointImpl<COPOSDeviceMonitor,&IID_IPropertyNotifySink,ATL::CComDynamicUnkArray>::_LocCPQueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@KK@Z
_TEXT	SEGMENT
_pUnk$ = -4						; size = 4
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_dwOptionSetMask$ = 16					; size = 4
_dwEnabledOptions$ = 20					; size = 4
?SetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@KK@Z PROC ; ATL::IObjectSafetyImpl<COPOSDeviceMonitor,3>::SetInterfaceSafetyOptions, COMDAT

; 3704 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3705 : 		ATLTRACE(atlTraceControls,2,_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
; 3706 : 		T* pT = static_cast<T*>(this);
; 3707 : 		IUnknown* pUnk = NULL;

  00004	83 65 fc 00	 and	 DWORD PTR _pUnk$[ebp], 0

; 3708 : 
; 3709 : 		// Check if we support the interface and return E_NOINTEFACE if we don't
; 3710 : 		if (FAILED(pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk)))

  00008	8d 55 fc	 lea	 edx, DWORD PTR _pUnk$[ebp]
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  0000f	8b cf		 mov	 ecx, edi
  00011	f7 d9		 neg	 ecx
  00013	52		 push	 edx
  00014	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  00017	8d 87 60 ff ff
	ff		 lea	 eax, DWORD PTR [edi-160]
  0001d	1b c9		 sbb	 ecx, ecx
  0001f	23 c8		 and	 ecx, eax
  00021	51		 push	 ecx
  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	ff 10		 call	 DWORD PTR [eax]
  00026	85 c0		 test	 eax, eax
  00028	79 07		 jns	 SHORT $LN2@SetInterfa

; 3711 : 			return E_NOINTERFACE;

  0002a	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  0002f	eb 44		 jmp	 SHORT $LN1@SetInterfa
$LN2@SetInterfa:

; 3712 : 		pUnk->Release();	// Release the interface we just acquired

  00031	8b 45 fc	 mov	 eax, DWORD PTR _pUnk$[ebp]
  00034	50		 push	 eax
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	ff 51 08	 call	 DWORD PTR [ecx+8]

; 3713 : 
; 3714 : 		// If we are asked to set options we don't support then fail
; 3715 : 		if (dwOptionSetMask & ~dwSupportedSafety)

  0003a	8b 45 10	 mov	 eax, DWORD PTR _dwOptionSetMask$[ebp]
  0003d	a9 fc ff ff ff	 test	 eax, -4			; fffffffcH
  00042	74 07		 je	 SHORT $LN3@SetInterfa

; 3716 : 			return E_FAIL;

  00044	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00049	eb 2a		 jmp	 SHORT $LN1@SetInterfa
$LN3@SetInterfa:
  0004b	56		 push	 esi

; 3717 : 
; 3718 : 		DWORD dwNewSafety = (m_dwCurrentSafety & ~dwOptionSetMask) | (dwOptionSetMask & dwEnabledOptions);

  0004c	8b f0		 mov	 esi, eax
  0004e	23 45 14	 and	 eax, DWORD PTR _dwEnabledOptions$[ebp]
  00051	f7 d6		 not	 esi
  00053	23 77 04	 and	 esi, DWORD PTR [edi+4]
  00056	0b f0		 or	 esi, eax

; 3719 : 
; 3720 : 		if (m_dwCurrentSafety == dwNewSafety)

  00058	39 77 04	 cmp	 DWORD PTR [edi+4], esi
  0005b	74 15		 je	 SHORT $LN10@SetInterfa

; 3721 : 		{
; 3722 : 			return S_OK;
; 3723 : 		}
; 3724 : 
; 3725 : 		if (!FAccessAllowed())

  0005d	8b 07		 mov	 eax, DWORD PTR [edi]
  0005f	8b cf		 mov	 ecx, edi
  00061	ff 50 14	 call	 DWORD PTR [eax+20]
  00064	85 c0		 test	 eax, eax
  00066	75 07		 jne	 SHORT $LN5@SetInterfa

; 3726 : 		{
; 3727 : 			return E_ACCESSDENIED;

  00068	b8 05 00 07 80	 mov	 eax, -2147024891	; 80070005H
  0006d	eb 05		 jmp	 SHORT $LN9@SetInterfa
$LN5@SetInterfa:

; 3728 : 		}
; 3729 : 		// Set the safety options we have been asked to
; 3730 : 		m_dwCurrentSafety = dwNewSafety;

  0006f	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN10@SetInterfa:

; 3731 : 
; 3732 : 		return S_OK;

  00072	33 c0		 xor	 eax, eax
$LN9@SetInterfa:
  00074	5e		 pop	 esi
$LN1@SetInterfa:
  00075	5f		 pop	 edi

; 3733 : 	}

  00076	c9		 leave
  00077	c2 10 00	 ret	 16			; 00000010H
?SetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@KK@Z ENDP ; ATL::IObjectSafetyImpl<COPOSDeviceMonitor,3>::SetInterfaceSafetyOptions
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@PAK1@Z
_TEXT	SEGMENT
_hr$1$ = 8						; size = 4
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_pUnk$ = 16						; size = 4
_pdwSupportedOptions$ = 16				; size = 4
_pdwEnabledOptions$ = 20				; size = 4
?GetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@PAK1@Z PROC ; ATL::IObjectSafetyImpl<COPOSDeviceMonitor,3>::GetInterfaceSafetyOptions, COMDAT

; 3667 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 14	 mov	 eax, DWORD PTR _pdwEnabledOptions$[ebp]
  00006	57		 push	 edi

; 3668 : 		ATLTRACE(atlTraceControls,2,_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
; 3669 : 		T* pT = static_cast<T*>(this);
; 3670 : 		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)

  00007	8b 7d 10	 mov	 edi, DWORD PTR _pdwSupportedOptions$[ebp]
  0000a	85 ff		 test	 edi, edi
  0000c	74 5c		 je	 SHORT $LN3@GetInterfa
  0000e	85 c0		 test	 eax, eax
  00010	74 58		 je	 SHORT $LN3@GetInterfa

; 3672 : 
; 3673 : 		HRESULT hr;
; 3674 : 		IUnknown* pUnk = NULL;

  00012	53		 push	 ebx
  00013	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]

; 3675 : 		// Check if we support this interface
; 3676 : 		hr = pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk);

  00016	8d 55 10	 lea	 edx, DWORD PTR _pUnk$[ebp]
  00019	56		 push	 esi
  0001a	33 f6		 xor	 esi, esi
  0001c	8b cb		 mov	 ecx, ebx
  0001e	f7 d9		 neg	 ecx
  00020	89 75 10	 mov	 DWORD PTR _pUnk$[ebp], esi
  00023	8d 83 60 ff ff
	ff		 lea	 eax, DWORD PTR [ebx-160]
  00029	1b c9		 sbb	 ecx, ecx
  0002b	23 c8		 and	 ecx, eax
  0002d	52		 push	 edx
  0002e	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	51		 push	 ecx
  00034	ff 10		 call	 DWORD PTR [eax]
  00036	89 45 08	 mov	 DWORD PTR _hr$1$[ebp], eax

; 3677 : 		if (SUCCEEDED(hr))

  00039	85 c0		 test	 eax, eax
  0003b	78 1f		 js	 SHORT $LN4@GetInterfa

; 3678 : 		{
; 3679 : 			// We support this interface so set the safety options accordingly
; 3680 : 			pUnk->Release();	// Release the interface we just acquired

  0003d	8b 4d 10	 mov	 ecx, DWORD PTR _pUnk$[ebp]
  00040	51		 push	 ecx
  00041	8b 11		 mov	 edx, DWORD PTR [ecx]
  00043	ff 52 08	 call	 DWORD PTR [edx+8]

; 3681 : 			*pdwSupportedOptions = dwSupportedSafety;

  00046	c7 07 03 00 00
	00		 mov	 DWORD PTR [edi], 3

; 3682 : 
; 3683 : 			if (FAccessAllowed())

  0004c	8b cb		 mov	 ecx, ebx
  0004e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00050	ff 52 14	 call	 DWORD PTR [edx+20]
  00053	85 c0		 test	 eax, eax
  00055	74 07		 je	 SHORT $LN5@GetInterfa

; 3684 : 			{
; 3685 : 				*pdwEnabledOptions   = m_dwCurrentSafety;

  00057	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]

; 3686 : 			}
; 3687 : 			else
; 3688 : 			{
; 3689 : 				*pdwEnabledOptions   = 0;
; 3690 : 			}
; 3691 : 		}

  0005a	eb 02		 jmp	 SHORT $LN5@GetInterfa
$LN4@GetInterfa:

; 3692 : 		else
; 3693 : 		{
; 3694 : 			// We don't support this interface
; 3695 : 			*pdwSupportedOptions = 0;

  0005c	89 37		 mov	 DWORD PTR [edi], esi
$LN5@GetInterfa:

; 3696 : 			*pdwEnabledOptions   = 0;
; 3697 : 		}
; 3698 : 		return hr;

  0005e	8b 45 14	 mov	 eax, DWORD PTR _pdwEnabledOptions$[ebp]
  00061	89 30		 mov	 DWORD PTR [eax], esi
  00063	8b 45 08	 mov	 eax, DWORD PTR _hr$1$[ebp]
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	eb 05		 jmp	 SHORT $LN1@GetInterfa
$LN3@GetInterfa:

; 3671 : 			return E_POINTER;

  0006a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@GetInterfa:
  0006f	5f		 pop	 edi

; 3699 : 	}

  00070	5d		 pop	 ebp
  00071	c2 10 00	 ret	 16			; 00000010H
?GetInterfaceSafetyOptions@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@UAGJABU_GUID@@PAK1@Z ENDP ; ATL::IObjectSafetyImpl<COPOSDeviceMonitor,3>::GetInterfaceSafetyOptions
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?FAccessAllowed@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@MAEHXZ
_TEXT	SEGMENT
?FAccessAllowed@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@MAEHXZ PROC ; ATL::IObjectSafetyImpl<COPOSDeviceMonitor,3>::FAccessAllowed, COMDAT
; _this$ = ecx

; 3653 : 		return TRUE;

  00000	33 c0		 xor	 eax, eax
  00002	40		 inc	 eax

; 3654 : 	}

  00003	c3		 ret	 0
?FAccessAllowed@?$IObjectSafetyImpl@VCOPOSDeviceMonitor@@$02@ATL@@MAEHXZ ENDP ; ATL::IObjectSafetyImpl<COPOSDeviceMonitor,3>::FAccessAllowed
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetGUID@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJKPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwGuidKind$ = 12					; size = 4
_pGUID$ = 16						; size = 4
?GetGUID@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJKPAU_GUID@@@Z PROC ; ATL::IProvideClassInfo2Impl<&CLSID_OPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetGUID, COMDAT

; 5255 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5256 : 		if (pGUID == NULL)

  00003	8b 45 10	 mov	 eax, DWORD PTR _pGUID$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 07		 jne	 SHORT $LN2@GetGUID

; 5257 : 		{
; 5258 : 			return E_POINTER;

  0000a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000f	eb 29		 jmp	 SHORT $LN1@GetGUID
$LN2@GetGUID:

; 5259 : 		}
; 5260 : 		*pGUID = GUID_NULL;
; 5261 : 		if(dwGuidKind!=GUIDKIND_DEFAULT_SOURCE_DISP_IID)

  00011	83 7d 0c 01	 cmp	 DWORD PTR _dwGuidKind$[ebp], 1
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	be 00 00 00 00	 mov	 esi, OFFSET _GUID_NULL
  0001c	8b f8		 mov	 edi, eax
  0001e	a5		 movsd
  0001f	a5		 movsd
  00020	a5		 movsd
  00021	a5		 movsd
  00022	74 07		 je	 SHORT $LN3@GetGUID

; 5262 : 		{
; 5263 : 			return E_INVALIDARG;

  00024	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00029	eb 0d		 jmp	 SHORT $LN6@GetGUID
$LN3@GetGUID:

; 5264 : 		}
; 5265 : 		if (psrcid != NULL)
; 5266 : 		{
; 5267 : 			*pGUID = *psrcid;

  0002b	8b f8		 mov	 edi, eax
  0002d	be 00 00 00 00	 mov	 esi, OFFSET _DIID__IOPOSDeviceMonitorEvents

; 5268 : 			return S_OK;

  00032	33 c0		 xor	 eax, eax
  00034	a5		 movsd
  00035	a5		 movsd
  00036	a5		 movsd
  00037	a5		 movsd
$LN6@GetGUID:
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
$LN1@GetGUID:

; 5269 : 		}
; 5270 : 		return E_FAIL;
; 5271 : 	}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?GetGUID@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJKPAU_GUID@@@Z ENDP ; ATL::IProvideClassInfo2Impl<&CLSID_OPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetGUID
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetClassInfoW@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAPAUITypeInfo@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pptinfo$ = 12						; size = 4
?GetClassInfoW@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAPAUITypeInfo@@@Z PROC ; ATL::IProvideClassInfo2Impl<&CLSID_OPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetClassInfoW, COMDAT

; 5249 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4155 : 		return GetTI(lcid, pptinfo);

  00003	ff 75 0c	 push	 DWORD PTR _pptinfo$[ebp]
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?_tih@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A ; ATL::IProvideClassInfo2Impl<&CLSID_OPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::_tih
  0000b	6a 00		 push	 0
  0000d	e8 00 00 00 00	 call	 ?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::GetTI

; 5250 : 		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
; 5251 : 	}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
?GetClassInfoW@?$IProvideClassInfo2Impl@$1?CLSID_OPOSDeviceMonitor@@3U_GUID@@B$1?DIID__IOPOSDeviceMonitorEvents@@3U2@B$1?LIBID_OposDeviceMonitor_CCO@@3U2@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAPAUITypeInfo@@@Z ENDP ; ATL::IProvideClassInfo2Impl<&CLSID_OPOSDeviceMonitor,&DIID__IOPOSDeviceMonitorEvents,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetClassInfoW
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?EnumDAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ppenumAdvise$ = 12					; size = 4
?EnumDAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z PROC ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::EnumDAdvise, COMDAT

; 3614 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3615 : 		ATLTRACE(atlTraceControls,2,_T("IDataObjectImpl::EnumDAdvise\n"));
; 3616 : 		ATLASSERT(ppenumAdvise != NULL);
; 3617 : 		if (ppenumAdvise == NULL)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _ppenumAdvise$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	75 07		 jne	 SHORT $LN2@EnumDAdvis

; 3618 : 			return E_POINTER;

  0000a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000f	eb 2a		 jmp	 SHORT $LN1@EnumDAdvis
$LN2@EnumDAdvis:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00011	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 3619 : 		*ppenumAdvise = NULL;

  00014	83 22 00	 and	 DWORD PTR [edx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00017	85 c0		 test	 eax, eax
  00019	56		 push	 esi
  0001a	6a 0c		 push	 12			; 0000000cH
  0001c	5e		 pop	 esi
  0001d	8d 88 74 ff ff
	ff		 lea	 ecx, DWORD PTR [eax-140]
  00023	0f 44 ce	 cmove	 ecx, esi
  00026	5e		 pop	 esi
  00027	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00029	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 3622 : 		if (pT->m_spDataAdviseHolder != NULL)

  0002b	74 09		 je	 SHORT $LN3@EnumDAdvis

; 3623 : 			return pT->m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);

  0002d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002f	52		 push	 edx
  00030	51		 push	 ecx
  00031	ff 50 14	 call	 DWORD PTR [eax+20]
  00034	eb 05		 jmp	 SHORT $LN1@EnumDAdvis
$LN3@EnumDAdvis:

; 3624 : 		return E_FAIL;

  00036	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$LN1@EnumDAdvis:

; 3625 : 	}

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?EnumDAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z ENDP ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::EnumDAdvise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DUnadvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwConnection$ = 12					; size = 4
?DUnadvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z PROC ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::DUnadvise, COMDAT

; 3602 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	6a 0c		 push	 12			; 0000000cH
  0000a	5a		 pop	 edx
  0000b	8d 88 74 ff ff
	ff		 lea	 ecx, DWORD PTR [eax-140]
  00011	0f 44 ca	 cmove	 ecx, edx
  00014	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00016	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 3606 : 		if (pT->m_spDataAdviseHolder == NULL)

  00018	75 07		 jne	 SHORT $LN2@DUnadvise

; 3607 : 			hr = OLE_E_NOCONNECTION;

  0001a	b8 04 00 04 80	 mov	 eax, -2147221500	; 80040004H
  0001f	eb 09		 jmp	 SHORT $LN3@DUnadvise
$LN2@DUnadvise:

; 3608 : 		else
; 3609 : 			hr = pT->m_spDataAdviseHolder->Unadvise(dwConnection);

  00021	ff 75 0c	 push	 DWORD PTR _dwConnection$[ebp]
  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	51		 push	 ecx
  00027	ff 50 10	 call	 DWORD PTR [eax+16]
$LN3@DUnadvise:

; 3610 : 		return hr;
; 3611 : 	}

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?DUnadvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z ENDP ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::DUnadvise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@KPAUIAdviseSink@@PAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pformatetc$ = 12					; size = 4
_advf$ = 16						; size = 4
_pAdvSink$ = 20						; size = 4
_pdwConnection$ = 24					; size = 4
?DAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@KPAUIAdviseSink@@PAK@Z PROC ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::DAdvise, COMDAT

; 3589 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]
  00008	85 ff		 test	 edi, edi
  0000a	6a 0c		 push	 12			; 0000000cH
  0000c	58		 pop	 eax
  0000d	8d b7 74 ff ff
	ff		 lea	 esi, DWORD PTR [edi-140]
  00013	0f 44 f0	 cmove	 esi, eax
  00016	83 3e 00	 cmp	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 3593 : 		if (pT->m_spDataAdviseHolder == NULL)

  00019	75 0b		 jne	 SHORT $LN9@DAdvise

; 3594 : 			hr = CreateDataAdviseHolder(&pT->m_spDataAdviseHolder);

  0001b	56		 push	 esi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDataAdviseHolder@4

; 3595 : 
; 3596 : 		if (hr == S_OK)

  00022	85 c0		 test	 eax, eax
  00024	75 15		 jne	 SHORT $LN3@DAdvise
$LN9@DAdvise:

; 3597 : 			hr = pT->m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

  00026	ff 75 18	 push	 DWORD PTR _pdwConnection$[ebp]
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	ff 75 14	 push	 DWORD PTR _pAdvSink$[ebp]
  0002e	ff 75 10	 push	 DWORD PTR _advf$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	ff 75 0c	 push	 DWORD PTR _pformatetc$[ebp]
  00036	57		 push	 edi
  00037	50		 push	 eax
  00038	ff 51 0c	 call	 DWORD PTR [ecx+12]
$LN3@DAdvise:

; 3598 : 
; 3599 : 		return hr;

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi

; 3600 : 	}

  0003d	5d		 pop	 ebp
  0003e	c2 14 00	 ret	 20			; 00000014H
?DAdvise@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@KPAUIAdviseSink@@PAK@Z ENDP ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::DAdvise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?EnumFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIEnumFORMATETC@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?EnumFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIEnumFORMATETC@@@Z PROC ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::EnumFormatEtc, COMDAT

; 3582 : 		ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3583 : 	}

  00005	c2 0c 00	 ret	 12			; 0000000cH
?EnumFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIEnumFORMATETC@@@Z ENDP ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::EnumFormatEtc
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@H@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?SetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@H@Z PROC ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::SetData, COMDAT

; 3576 : 		ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3577 : 	}

  00005	c2 10 00	 ret	 16			; 00000010H
?SetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@H@Z ENDP ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::SetData
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetCanonicalFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetCanonicalFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@0@Z PROC ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::GetCanonicalFormatEtc, COMDAT

; 3569 : 		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3570 : 	}

  00005	c2 0c 00	 ret	 12			; 0000000cH
?GetCanonicalFormatEtc@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@0@Z ENDP ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::GetCanonicalFormatEtc
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?QueryGetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?QueryGetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@@Z PROC ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::QueryGetData, COMDAT

; 3563 : 		ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3564 : 	}

  00005	c2 08 00	 ret	 8
?QueryGetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@@Z ENDP ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::QueryGetData
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetDataHere@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetDataHere@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z PROC ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::GetDataHere, COMDAT

; 3559 : 		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3560 : 	}

  00005	c2 0c 00	 ret	 12			; 0000000cH
?GetDataHere@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z ENDP ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::GetDataHere
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pformatetcIn$ = 12					; size = 4
_pmedium$ = 16						; size = 4
?GetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z PROC ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::GetData, COMDAT

; 3550 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3551 : 		ATLTRACE(atlTraceControls,2,_T("IDataObjectImpl::GetData\n"));
; 3552 : 		T* pT = (T*) this;
; 3553 : 		return pT->IDataObject_GetData(pformatetcIn, pmedium);

  00003	ff 75 10	 push	 DWORD PTR _pmedium$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	ff 75 0c	 push	 DWORD PTR _pformatetcIn$[ebp]
  0000e	6a 04		 push	 4
  00010	8d 88 6c ff ff
	ff		 lea	 ecx, DWORD PTR [eax-148]
  00016	5a		 pop	 edx
  00017	0f 44 ca	 cmove	 ecx, edx
  0001a	e8 00 00 00 00	 call	 ?IDataObject_GetData@CComControlBase@ATL@@QAEJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z ; ATL::CComControlBase::IDataObject_GetData

; 3554 : 	}

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
?GetData@?$IDataObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z ENDP ; ATL::IDataObjectImpl<COPOSDeviceMonitor>::GetData
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pSize$ = 12						; size = 4
?GetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z PROC ; ATL::IQuickActivateImpl<COPOSDeviceMonitor>::GetContentExtent, COMDAT

; 2184 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2185 : 		T* pT = static_cast<T*>(this);
; 2186 : 		ATLTRACE(atlTraceControls,2,_T("IQuickActivateImpl::GetContentExtent\n"));
; 2187 : 		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	56		 push	 esi

; 2462 : 		if (psizel == NULL)

  00007	8b 75 0c	 mov	 esi, DWORD PTR _pSize$[ebp]

; 2185 : 		T* pT = static_cast<T*>(this);
; 2186 : 		ATLTRACE(atlTraceControls,2,_T("IQuickActivateImpl::GetContentExtent\n"));
; 2187 : 		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);

  0000a	8d 81 6c ff ff
	ff		 lea	 eax, DWORD PTR [ecx-148]
  00010	f7 d9		 neg	 ecx
  00012	1b c9		 sbb	 ecx, ecx
  00014	23 c8		 and	 ecx, eax
  00016	8d 51 78	 lea	 edx, DWORD PTR [ecx+120]

; 2458 : 		T* pT = static_cast<T*>(this);

  00019	f7 da		 neg	 edx
  0001b	1b d2		 sbb	 edx, edx
  0001d	23 d1		 and	 edx, ecx

; 2459 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetExtent\n"));
; 2460 : 		if (dwDrawAspect != DVASPECT_CONTENT)
; 2461 : 			return E_FAIL;
; 2462 : 		if (psizel == NULL)

  0001f	85 f6		 test	 esi, esi
  00021	75 07		 jne	 SHORT $LN7@GetContent

; 2463 : 			return E_POINTER;

  00023	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00028	eb 0d		 jmp	 SHORT $LN5@GetContent
$LN7@GetContent:

; 2464 : 		*psizel = pT->m_sizeExtent;

  0002a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0002d	8b 4a 2c	 mov	 ecx, DWORD PTR [edx+44]
  00030	89 06		 mov	 DWORD PTR [esi], eax

; 2465 : 		return S_OK;

  00032	33 c0		 xor	 eax, eax
  00034	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN5@GetContent:

; 2185 : 		T* pT = static_cast<T*>(this);
; 2186 : 		ATLTRACE(atlTraceControls,2,_T("IQuickActivateImpl::GetContentExtent\n"));
; 2187 : 		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);

  00037	5e		 pop	 esi

; 2188 : 	}

  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z ENDP ; ATL::IQuickActivateImpl<COPOSDeviceMonitor>::GetContentExtent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pSize$ = 12						; size = 4
?SetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z PROC ; ATL::IQuickActivateImpl<COPOSDeviceMonitor>::SetContentExtent, COMDAT

; 2178 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2179 : 		T* pT = static_cast<T*>(this);
; 2180 : 		ATLTRACE(atlTraceControls,2,_T("IQuickActivateImpl::SetContentExtent\n"));
; 2181 : 		return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);

  00003	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]

; 2452 : 		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);

  00006	ff 75 0c	 push	 DWORD PTR _pSize$[ebp]
  00009	6a 01		 push	 1

; 2179 : 		T* pT = static_cast<T*>(this);
; 2180 : 		ATLTRACE(atlTraceControls,2,_T("IQuickActivateImpl::SetContentExtent\n"));
; 2181 : 		return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);

  0000b	8d 82 6c ff ff
	ff		 lea	 eax, DWORD PTR [edx-148]
  00011	f7 da		 neg	 edx
  00013	1b d2		 sbb	 edx, edx
  00015	23 d0		 and	 edx, eax
  00017	8d 4a 78	 lea	 ecx, DWORD PTR [edx+120]

; 2450 : 		T* pT = static_cast<T*>(this);

  0001a	f7 d9		 neg	 ecx
  0001c	1b c9		 sbb	 ecx, ecx
  0001e	23 ca		 and	 ecx, edx

; 2451 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::SetExtent\n"));
; 2452 : 		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);

  00020	83 c1 04	 add	 ecx, 4
  00023	e8 00 00 00 00	 call	 ?IOleObject_SetExtent@CComControlBase@ATL@@QAEJKPAUtagSIZE@@@Z ; ATL::CComControlBase::IOleObject_SetExtent

; 2182 : 	}

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?SetContentExtent@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagSIZE@@@Z ENDP ; ATL::IQuickActivateImpl<COPOSDeviceMonitor>::SetContentExtent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?QuickActivate@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pQACont$ = 12						; size = 4
_pQACtrl$ = 16						; size = 4
?QuickActivate@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z PROC ; ATL::IQuickActivateImpl<COPOSDeviceMonitor>::QuickActivate, COMDAT

; 2157 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2158 : 		T* pT = static_cast<T*>(this);
; 2159 : 		ATLTRACE(atlTraceControls,2,_T("IQuickActivateImpl::QuickActivate\n"));
; 2160 : 		__if_exists(T::m_clrForeColor)
; 2161 : 		{
; 2162 : 			pT->m_clrForeColor = pQACont->colorFore;
; 2163 : 		}
; 2164 : 		__if_exists(T::m_clrBackColor)
; 2165 : 		{
; 2166 : 			pT->m_clrBackColor = pQACont->colorBack;
; 2167 : 		}
; 2168 : 		__if_exists(T::m_nAppearance)
; 2169 : 		{
; 2170 : 			// If you've declared m_nAppearance as something other than
; 2171 : 			// 'short', you'll need to typedef AppearanceType to that type
; 2172 : 			// in your derived class T.
; 2173 : 			pT->m_nAppearance = static_cast<typename T::AppearanceType>(pQACont->dwAppearance);
; 2174 : 		}
; 2175 : 		return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);

  00003	ff 75 10	 push	 DWORD PTR _pQACtrl$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	ff 75 0c	 push	 DWORD PTR _pQACont$[ebp]
  0000e	6a 04		 push	 4
  00010	8d 88 70 ff ff
	ff		 lea	 ecx, DWORD PTR [eax-144]
  00016	5a		 pop	 edx
  00017	0f 44 ca	 cmove	 ecx, edx
  0001a	e8 00 00 00 00	 call	 ?IQuickActivate_QuickActivate@CComControlBase@ATL@@QAEJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z ; ATL::CComControlBase::IQuickActivate_QuickActivate

; 2176 : 	}

  0001f	5d		 pop	 ebp
  00020	c2 0c 00	 ret	 12			; 0000000cH
?QuickActivate@?$IQuickActivateImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z ENDP ; ATL::IQuickActivateImpl<COPOSDeviceMonitor>::QuickActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetPagesHelper@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@IAEJPAUtagCAUUID@@PBUATL_PROPMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_i$2$ = -16						; size = 4
tv320 = -12						; size = 4
tv324 = -8						; size = 4
_j$1$ = -4						; size = 4
_pPages$ = 8						; size = 4
_nCnt$2$ = 12						; size = 4
_nCnt$1$ = 12						; size = 4
_pMap$ = 12						; size = 4
?GetPagesHelper@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@IAEJPAUtagCAUUID@@PBUATL_PROPMAP_ENTRY@2@@Z PROC ; ATL::ISpecifyPropertyPagesImpl<COPOSDeviceMonitor>::GetPagesHelper, COMDAT
; _this$ = ecx

; 5884 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 5885 : 		if (pPages == NULL)

  00009	8b 7d 08	 mov	 edi, DWORD PTR _pPages$[ebp]
  0000c	85 ff		 test	 edi, edi
  0000e	0f 84 07 01 00
	00		 je	 $LN35@GetPagesHe

; 5886 : 			return E_POINTER;
; 5887 : 		ATLASSERT(pMap != NULL);
; 5888 : 		if (pMap == NULL)

  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _pMap$[ebp]
  00017	85 db		 test	 ebx, ebx
  00019	0f 84 fc 00 00
	00		 je	 $LN35@GetPagesHe

; 5890 : 
; 5891 : 		int nCnt = 0;

  0001f	33 c0		 xor	 eax, eax

; 5892 : 		int i;
; 5893 : 		// Get count of unique pages to alloc the array
; 5894 : ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
; 5895 : 		for (i = 0; pMap[i].pclsidPropPage != NULL; i++)

  00021	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  00024	8b c8		 mov	 ecx, eax
  00026	89 4d 0c	 mov	 DWORD PTR _nCnt$1$[ebp], ecx
  00029	39 06		 cmp	 DWORD PTR [esi], eax
  0002b	74 3a		 je	 SHORT $LN3@GetPagesHe
  0002d	8b d6		 mov	 edx, esi
  0002f	8b c3		 mov	 eax, ebx
  00031	8b f9		 mov	 edi, ecx
  00033	33 f6		 xor	 esi, esi
$LL4@GetPagesHe:

; 5896 : ATLPREFAST_UNSUPPRESS()
; 5897 : 		{
; 5898 : 			// only allow non data entry types
; 5899 : 			if (pMap[i].vt == 0)

  00035	66 39 70 20	 cmp	 WORD PTR [eax+32], si
  00039	75 19		 jne	 SHORT $LN2@GetPagesHe

; 5900 : 			{
; 5901 : 				// Does this property have a page?  CLSID_NULL means it does not
; 5902 : 				if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))

  0003b	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  00040	ff 32		 push	 DWORD PTR [edx]
  00042	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR _nCnt$1$[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	75 04		 jne	 SHORT $LN2@GetPagesHe

; 5903 : 					nCnt++;

  00050	41		 inc	 ecx
  00051	89 4d 0c	 mov	 DWORD PTR _nCnt$1$[ebp], ecx
$LN2@GetPagesHe:

; 5892 : 		int i;
; 5893 : 		// Get count of unique pages to alloc the array
; 5894 : ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
; 5895 : 		for (i = 0; pMap[i].pclsidPropPage != NULL; i++)

  00054	47		 inc	 edi
  00055	6b c7 24	 imul	 eax, edi, 36
  00058	03 c3		 add	 eax, ebx
  0005a	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  0005d	39 32		 cmp	 DWORD PTR [edx], esi
  0005f	75 d4		 jne	 SHORT $LL4@GetPagesHe
  00061	8b 7d 08	 mov	 edi, DWORD PTR _pPages$[ebp]
  00064	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
$LN3@GetPagesHe:

; 5904 : 			}
; 5905 : 		}
; 5906 : 		pPages->pElems = (GUID*) ::ATL::AtlCoTaskMemCAlloc(nCnt, static_cast<ULONG>(sizeof(CLSID)));

  00067	6a 10		 push	 16			; 00000010H
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 ?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z ; ATL::AtlCoTaskMemCAlloc
  0006f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00072	59		 pop	 ecx
  00073	59		 pop	 ecx

; 5907 : 		if (pPages->pElems == NULL)

  00074	85 c0		 test	 eax, eax
  00076	75 0a		 jne	 SHORT $LN15@GetPagesHe

; 5908 : 			return E_OUTOFMEMORY;

  00078	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  0007d	e9 9e 00 00 00	 jmp	 $LN1@GetPagesHe
$LN15@GetPagesHe:

; 5909 : 		// reset count of items we have added to the array
; 5910 : 		nCnt = 0;

  00082	33 c0		 xor	 eax, eax
  00084	8b c8		 mov	 ecx, eax

; 5911 : 		for (i = 0; pMap[i].pclsidPropPage != NULL; i++)

  00086	89 45 f0	 mov	 DWORD PTR _i$2$[ebp], eax
  00089	89 4d 0c	 mov	 DWORD PTR _nCnt$2$[ebp], ecx
  0008c	39 06		 cmp	 DWORD PTR [esi], eax
  0008e	0f 84 81 00 00
	00		 je	 $LN6@GetPagesHe

; 5923 : 					{
; 5924 : 						if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))

  00094	33 d2		 xor	 edx, edx
  00096	8b c3		 mov	 eax, ebx
  00098	89 55 f4	 mov	 DWORD PTR tv320[ebp], edx
$LL7@GetPagesHe:

; 5912 : 		{
; 5913 : 			// only allow non data entry types
; 5914 : 			if (pMap[i].vt == 0)

  0009b	66 39 50 20	 cmp	 WORD PTR [eax+32], dx
  0009f	75 61		 jne	 SHORT $LN5@GetPagesHe

; 5915 : 			{
; 5916 : 				// Does this property have a page?  CLSID_NULL means it does not
; 5917 : 				if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))

  000a1	8b 06		 mov	 eax, DWORD PTR [esi]
  000a3	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  000a8	50		 push	 eax
  000a9	89 45 f8	 mov	 DWORD PTR tv324[ebp], eax
  000ac	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  000b1	59		 pop	 ecx
  000b2	59		 pop	 ecx
  000b3	8b 4d 0c	 mov	 ecx, DWORD PTR _nCnt$2$[ebp]
  000b6	85 c0		 test	 eax, eax
  000b8	75 46		 jne	 SHORT $LN38@GetPagesHe

; 5918 : 				{
; 5919 : 					BOOL bFound = FALSE;
; 5920 : 					// Search through array we are building up to see
; 5921 : 					// if it is already in there
; 5922 : 					for (int j=0; j<nCnt; j++)

  000ba	89 45 fc	 mov	 DWORD PTR _j$1$[ebp], eax
  000bd	85 c9		 test	 ecx, ecx
  000bf	7e 23		 jle	 SHORT $LN34@GetPagesHe

; 5923 : 					{
; 5924 : 						if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))

  000c1	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
$LL10@GetPagesHe:
  000c4	56		 push	 esi
  000c5	ff 75 f8	 push	 DWORD PTR tv324[ebp]
  000c8	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  000cd	59		 pop	 ecx
  000ce	59		 pop	 ecx
  000cf	8b 4d 0c	 mov	 ecx, DWORD PTR _nCnt$2$[ebp]
  000d2	85 c0		 test	 eax, eax
  000d4	75 2a		 jne	 SHORT $LN38@GetPagesHe

; 5918 : 				{
; 5919 : 					BOOL bFound = FALSE;
; 5920 : 					// Search through array we are building up to see
; 5921 : 					// if it is already in there
; 5922 : 					for (int j=0; j<nCnt; j++)

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _j$1$[ebp]
  000d9	83 c6 10	 add	 esi, 16			; 00000010H
  000dc	40		 inc	 eax
  000dd	89 45 fc	 mov	 DWORD PTR _j$1$[ebp], eax
  000e0	3b c1		 cmp	 eax, ecx
  000e2	7c e0		 jl	 SHORT $LL10@GetPagesHe
$LN34@GetPagesHe:

; 5925 : 						{
; 5926 : 							// It's already there, so no need to add it again
; 5927 : 							bFound = TRUE;
; 5928 : 							break;
; 5929 : 						}
; 5930 : 					}
; 5931 : 					// If we didn't find it in there then add it
; 5932 : 					if (!bFound)
; 5933 : 						pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;

  000e4	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  000e7	8b 55 f4	 mov	 edx, DWORD PTR tv320[ebp]
  000ea	03 fa		 add	 edi, edx
  000ec	8b 75 f8	 mov	 esi, DWORD PTR tv324[ebp]
  000ef	41		 inc	 ecx
  000f0	83 c2 10	 add	 edx, 16			; 00000010H
  000f3	89 4d 0c	 mov	 DWORD PTR _nCnt$2$[ebp], ecx
  000f6	89 55 f4	 mov	 DWORD PTR tv320[ebp], edx
  000f9	a5		 movsd
  000fa	a5		 movsd
  000fb	a5		 movsd
  000fc	a5		 movsd
  000fd	8b 7d 08	 mov	 edi, DWORD PTR _pPages$[ebp]
$LN38@GetPagesHe:

; 5911 : 		for (i = 0; pMap[i].pclsidPropPage != NULL; i++)

  00100	33 d2		 xor	 edx, edx
$LN5@GetPagesHe:
  00102	8b 45 f0	 mov	 eax, DWORD PTR _i$2$[ebp]
  00105	40		 inc	 eax
  00106	89 45 f0	 mov	 DWORD PTR _i$2$[ebp], eax
  00109	6b c0 24	 imul	 eax, eax, 36
  0010c	03 c3		 add	 eax, ebx
  0010e	8d 70 04	 lea	 esi, DWORD PTR [eax+4]
  00111	39 16		 cmp	 DWORD PTR [esi], edx
  00113	75 86		 jne	 SHORT $LL7@GetPagesHe
$LN6@GetPagesHe:

; 5934 : 				}
; 5935 : 			}
; 5936 : 		}
; 5937 : 		pPages->cElems = nCnt;

  00115	89 0f		 mov	 DWORD PTR [edi], ecx

; 5938 : 		return S_OK;

  00117	33 c0		 xor	 eax, eax
  00119	eb 05		 jmp	 SHORT $LN1@GetPagesHe
$LN35@GetPagesHe:

; 5889 : 			return E_POINTER;

  0011b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@GetPagesHe:
  00120	5f		 pop	 edi

; 5939 : 	}

  00121	5e		 pop	 esi
  00122	5b		 pop	 ebx
  00123	c9		 leave
  00124	c2 08 00	 ret	 8
?GetPagesHelper@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@IAEJPAUtagCAUUID@@PBUATL_PROPMAP_ENTRY@2@@Z ENDP ; ATL::ISpecifyPropertyPagesImpl<COPOSDeviceMonitor>::GetPagesHelper
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetPages@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCAUUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pPages$ = 12						; size = 4
?GetPages@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCAUUID@@@Z PROC ; ATL::ISpecifyPropertyPagesImpl<COPOSDeviceMonitor>::GetPages, COMDAT

; 5875 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5876 : 		ATLTRACE(atlTraceCOM, 2, _T("ISpecifyPropertyPagesImpl::GetPages\n"));
; 5877 : 		const ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
; 5878 : 		return GetPagesHelper(pPages, pMap);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B ; `COPOSDeviceMonitor::GetPropertyMap'::`2'::pPropMap
  0000b	ff 75 0c	 push	 DWORD PTR _pPages$[ebp]
  0000e	e8 00 00 00 00	 call	 ?GetPagesHelper@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@IAEJPAUtagCAUUID@@PBUATL_PROPMAP_ENTRY@2@@Z ; ATL::ISpecifyPropertyPagesImpl<COPOSDeviceMonitor>::GetPagesHelper

; 5879 : 	}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
?GetPages@?$ISpecifyPropertyPagesImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCAUUID@@@Z ENDP ; ATL::ISpecifyPropertyPagesImpl<COPOSDeviceMonitor>::GetPages
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?IPSI_GetIPersistStreamInit@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@AAEPAUIPersistStreamInit@@XZ
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_p$ = -4						; size = 4
?IPSI_GetIPersistStreamInit@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@AAEPAUIPersistStreamInit@@XZ PROC ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IPSI_GetIPersistStreamInit, COMDAT
; _this$ = ecx

; 835  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 836  : 	T* pT = static_cast<T*>(this);
; 837  : 	IPersistStreamInit* p = NULL;

  00005	8d 81 74 ff ff
	ff		 lea	 eax, DWORD PTR [ecx-140]
  0000b	f7 d9		 neg	 ecx
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	1b c9		 sbb	 ecx, ecx

; 838  : 	if (FAILED(pT->GetUnknown()->QueryInterface(__uuidof(IPersistStreamInit), (void**)&p)))

  00011	8d 55 fc	 lea	 edx, DWORD PTR _p$[ebp]
  00014	23 c8		 and	 ecx, eax
  00016	33 f6		 xor	 esi, esi
  00018	57		 push	 edi
  00019	52		 push	 edx
  0001a	68 00 00 00 00	 push	 OFFSET __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	51		 push	 ecx
  00022	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  00025	89 75 fc	 mov	 DWORD PTR _p$[ebp], esi
  00028	ff 10		 call	 DWORD PTR [eax]
  0002a	85 c0		 test	 eax, eax
  0002c	79 70		 jns	 SHORT $LN42@IPSI_GetIP
  0002e	bf 08 00 00 00	 mov	 edi, OFFSET ?_entries@?1??_GetEntries@COPOSDeviceMonitor@@SGPBU_ATL_INTMAP_ENTRY@ATL@@XZ@4QBU34@B+8
$LL13@IPSI_GetIP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8296 : 		BOOL bBlind = (pEntries->piid == NULL);

  00033	8b 5f f8	 mov	 ebx, DWORD PTR [edi-8]

; 8297 : 		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))

  00036	85 db		 test	 ebx, ebx
  00038	74 29		 je	 SHORT $LN20@IPSI_GetIP
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h

; 152  :    return (

  0003a	81 3b 80 23 d5
	7f		 cmp	 DWORD PTR [ebx], 2144674688 ; 7fd52380H
  00040	75 45		 jne	 SHORT $LN11@IPSI_GetIP
  00042	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00045	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713+4
  0004b	75 3a		 jne	 SHORT $LN11@IPSI_GetIP
  0004d	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00050	3b 05 08 00 00
	00		 cmp	 eax, DWORD PTR __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713+8
  00056	75 2f		 jne	 SHORT $LN11@IPSI_GetIP
  00058	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0005b	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713+12
  00061	75 24		 jne	 SHORT $LN11@IPSI_GetIP
$LN20@IPSI_GetIP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8299 : 			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset

  00063	8b 07		 mov	 eax, DWORD PTR [edi]
  00065	83 f8 01	 cmp	 eax, 1
  00068	74 26		 je	 SHORT $LN35@IPSI_GetIP

; 8304 : 				*ppvObject = pUnk;
; 8305 : 				return S_OK;
; 8306 : 			}
; 8307 : 
; 8308 : 			// Actual function call
; 8309 : 
; 8310 : 			hRes = pEntries->pFunc(pThis,

  0006a	ff 77 fc	 push	 DWORD PTR [edi-4]
  0006d	8d 4d fc	 lea	 ecx, DWORD PTR _p$[ebp]
  00070	51		 push	 ecx
  00071	68 00 00 00 00	 push	 OFFSET __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
  00076	ff 75 f8	 push	 DWORD PTR _this$1$[ebp]
  00079	ff d0		 call	 eax

; 8311 : 				iid, ppvObject, pEntries->dw);
; 8312 : 			if (hRes == S_OK)

  0007b	85 c0		 test	 eax, eax
  0007d	74 1f		 je	 SHORT $LN42@IPSI_GetIP

; 8313 : 				return S_OK;
; 8314 : 			if (!bBlind && FAILED(hRes))

  0007f	85 db		 test	 ebx, ebx
  00081	74 04		 je	 SHORT $LN11@IPSI_GetIP
  00083	85 c0		 test	 eax, eax
  00085	78 1a		 js	 SHORT $LN15@IPSI_GetIP
$LN11@IPSI_GetIP:

; 8288 : 	for (;; pEntries++)

  00087	83 c7 0c	 add	 edi, 12			; 0000000cH

; 8289 : 	{
; 8290 : 		if (pEntries->pFunc == NULL)

  0008a	39 37		 cmp	 DWORD PTR [edi], esi
  0008c	75 a5		 jne	 SHORT $LL13@IPSI_GetIP

; 8315 : 				break;
; 8316 : 		}
; 8317 : 	}
; 8318 : 
; 8319 : 	*ppvObject = NULL;

  0008e	eb 11		 jmp	 SHORT $LN15@IPSI_GetIP
$LN35@IPSI_GetIP:

; 8300 : 			{
; 8301 : 				ATLASSERT(!bBlind);
; 8302 : 				IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);

  00090	8b 77 fc	 mov	 esi, DWORD PTR [edi-4]
  00093	03 75 f8	 add	 esi, DWORD PTR _this$1$[ebp]

; 8303 : 				pUnk->AddRef();

  00096	56		 push	 esi
  00097	8b 06		 mov	 eax, DWORD PTR [esi]
  00099	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 838  : 	if (FAILED(pT->GetUnknown()->QueryInterface(__uuidof(IPersistStreamInit), (void**)&p)))

  0009c	eb 03		 jmp	 SHORT $LN15@IPSI_GetIP
$LN42@IPSI_GetIP:
  0009e	8b 75 fc	 mov	 esi, DWORD PTR _p$[ebp]
$LN15@IPSI_GetIP:

; 839  : 		pT->_InternalQueryInterface(__uuidof(IPersistStreamInit), (void**)&p);
; 840  : 	return p;

  000a1	5f		 pop	 edi
  000a2	8b c6		 mov	 eax, esi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx

; 841  : }

  000a6	c9		 leave
  000a7	c3		 ret	 0
?IPSI_GetIPersistStreamInit@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@AAEPAUIPersistStreamInit@@XZ ENDP ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IPSI_GetIPersistStreamInit
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?HandsOffStorage@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?HandsOffStorage@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ PROC ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::HandsOffStorage, COMDAT

; 826  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::HandsOffStorage\n"));
; 827  : 		return S_OK;

  00000	33 c0		 xor	 eax, eax

; 828  : 	}

  00002	c2 04 00	 ret	 4
?HandsOffStorage@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ENDP ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::HandsOffStorage
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?SaveCompleted@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?SaveCompleted@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z PROC ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::SaveCompleted, COMDAT

; 821  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::SaveCompleted\n"));
; 822  : 		return S_OK;

  00000	33 c0		 xor	 eax, eax

; 823  : 	}

  00002	c2 08 00	 ret	 8
?SaveCompleted@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z ENDP ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::SaveCompleted
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_spStream$1 = 12					; size = 4
_pStorage$ = 12						; size = 4
_fSameAsLoad$ = 16					; size = 4
?Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z PROC ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::Save, COMDAT

; 800  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 801  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::Save\n"));
; 802  : 		if (pStorage == NULL)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _pStorage$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	75 07		 jne	 SHORT $LN2@Save

; 803  : 			return E_INVALIDARG;

  0000b	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00010	eb 5c		 jmp	 SHORT $LN1@Save
$LN2@Save:

; 804  : 		CComPtr<IPersistStreamInit> p;
; 805  : 		p.p = IPSI_GetIPersistStreamInit();

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ?IPSI_GetIPersistStreamInit@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@AAEPAUIPersistStreamInit@@XZ ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IPSI_GetIPersistStreamInit
  0001c	8b f0		 mov	 esi, eax

; 806  : 		HRESULT hr = E_FAIL;

  0001e	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00023	85 f6		 test	 esi, esi
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 807  : 		if (p != NULL)

  00025	74 43		 je	 SHORT $LN26@Save

; 811  : 			hr = pStorage->CreateStream(vszContents,

  00027	8b 03		 mov	 eax, DWORD PTR [ebx]
  00029	8d 4d 0c	 lea	 ecx, DWORD PTR _spStream$1[ebp]
  0002c	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0002d	33 d2		 xor	 edx, edx
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 811  : 			hr = pStorage->CreateStream(vszContents,

  0002f	52		 push	 edx
  00030	52		 push	 edx
  00031	68 12 10 00 00	 push	 4114			; 00001012H
  00036	ff 35 00 00 00
	00		 push	 DWORD PTR ?vszContents@?6??Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z@4PB_WB ; `ATL::IPersistStorageImpl<COPOSDeviceMonitor>::Save'::`7'::vszContents
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0003c	89 55 0c	 mov	 DWORD PTR _spStream$1[ebp], edx
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 811  : 			hr = pStorage->CreateStream(vszContents,

  0003f	53		 push	 ebx
  00040	ff 50 0c	 call	 DWORD PTR [eax+12]
  00043	8b f8		 mov	 edi, eax

; 812  : 				STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
; 813  : 				0, 0, &spStream);
; 814  : 			if (SUCCEEDED(hr))

  00045	85 ff		 test	 edi, edi
  00047	78 0e		 js	 SHORT $LN4@Save

; 815  : 				hr = p->Save(spStream, fSameAsLoad);

  00049	ff 75 10	 push	 DWORD PTR _fSameAsLoad$[ebp]
  0004c	8b 06		 mov	 eax, DWORD PTR [esi]
  0004e	ff 75 0c	 push	 DWORD PTR _spStream$1[ebp]
  00051	56		 push	 esi
  00052	ff 50 18	 call	 DWORD PTR [eax+24]
  00055	8b f8		 mov	 edi, eax
$LN4@Save:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00057	8b 45 0c	 mov	 eax, DWORD PTR _spStream$1[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 06		 je	 SHORT $LN21@Save

; 184  :             p->Release();

  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	50		 push	 eax
  00061	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN21@Save:
  00064	8b 06		 mov	 eax, DWORD PTR [esi]
  00066	56		 push	 esi
  00067	ff 50 08	 call	 DWORD PTR [eax+8]
$LN26@Save:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 817  : 		return hr;

  0006a	8b c7		 mov	 eax, edi
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
$LN1@Save:
  0006e	5b		 pop	 ebx

; 818  : 	}

  0006f	5d		 pop	 ebp
  00070	c2 0c 00	 ret	 12			; 0000000cH
?Save@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@H@Z ENDP ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::Save
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Load@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_spStream$1 = 12					; size = 4
_pStorage$ = 12						; size = 4
?Load@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z PROC ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::Load, COMDAT

; 782  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 783  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::Load\n"));
; 784  : 		if (pStorage == NULL)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _pStorage$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	75 07		 jne	 SHORT $LN2@Load

; 785  : 			return E_INVALIDARG;

  0000b	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00010	eb 55		 jmp	 SHORT $LN1@Load
$LN2@Load:

; 786  : 		CComPtr<IPersistStreamInit> p;
; 787  : 		p.p = IPSI_GetIPersistStreamInit();

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	e8 00 00 00 00	 call	 ?IPSI_GetIPersistStreamInit@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@AAEPAUIPersistStreamInit@@XZ ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IPSI_GetIPersistStreamInit
  0001c	8b f0		 mov	 esi, eax

; 788  : 		HRESULT hr = E_FAIL;

  0001e	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00023	85 f6		 test	 esi, esi
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 789  : 		if (p != NULL)

  00025	74 3c		 je	 SHORT $LN26@Load

; 792  : 			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,

  00027	8b 03		 mov	 eax, DWORD PTR [ebx]
  00029	8d 4d 0c	 lea	 ecx, DWORD PTR _spStream$1[ebp]
  0002c	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0002d	33 d2		 xor	 edx, edx
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 792  : 			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,

  0002f	52		 push	 edx
  00030	6a 10		 push	 16			; 00000010H
  00032	52		 push	 edx
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@ENICKDH@?$AAC?$AAo?$AAn?$AAt?$AAe?$AAn?$AAt?$AAs@
  00038	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00039	89 55 0c	 mov	 DWORD PTR _spStream$1[ebp], edx
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 792  : 			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,

  0003c	ff 50 10	 call	 DWORD PTR [eax+16]
  0003f	8b f8		 mov	 edi, eax

; 793  : 				STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &spStream);
; 794  : 			if (SUCCEEDED(hr))

  00041	85 ff		 test	 edi, edi
  00043	78 0b		 js	 SHORT $LN4@Load

; 795  : 				hr = p->Load(spStream);

  00045	ff 75 0c	 push	 DWORD PTR _spStream$1[ebp]
  00048	8b 06		 mov	 eax, DWORD PTR [esi]
  0004a	56		 push	 esi
  0004b	ff 50 14	 call	 DWORD PTR [eax+20]
  0004e	8b f8		 mov	 edi, eax
$LN4@Load:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00050	8b 45 0c	 mov	 eax, DWORD PTR _spStream$1[ebp]
  00053	85 c0		 test	 eax, eax
  00055	74 06		 je	 SHORT $LN21@Load

; 184  :             p->Release();

  00057	8b 08		 mov	 ecx, DWORD PTR [eax]
  00059	50		 push	 eax
  0005a	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN21@Load:
  0005d	8b 06		 mov	 eax, DWORD PTR [esi]
  0005f	56		 push	 esi
  00060	ff 50 08	 call	 DWORD PTR [eax+8]
$LN26@Load:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 797  : 		return hr;

  00063	8b c7		 mov	 eax, edi
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
$LN1@Load:
  00067	5b		 pop	 ebx

; 798  : 	}

  00068	5d		 pop	 ebp
  00069	c2 08 00	 ret	 8
?Load@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z ENDP ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::Load
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?InitNew@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?InitNew@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z PROC ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::InitNew, COMDAT

; 775  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 776  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::InitNew\n"));
; 777  : 		CComPtr<IPersistStreamInit> p;
; 778  : 		p.p = IPSI_GetIPersistStreamInit();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?IPSI_GetIPersistStreamInit@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@AAEPAUIPersistStreamInit@@XZ ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IPSI_GetIPersistStreamInit
  0000d	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  0000f	85 f6		 test	 esi, esi
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 779  : 		return (p != NULL) ? p->InitNew() : E_FAIL;

  00011	74 10		 je	 SHORT $LN3@InitNew
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	56		 push	 esi
  00016	ff 50 20	 call	 DWORD PTR [eax+32]
  00019	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 184  :             p->Release();

  0001b	8b 06		 mov	 eax, DWORD PTR [esi]
  0001d	56		 push	 esi
  0001e	ff 50 08	 call	 DWORD PTR [eax+8]
  00021	eb 05		 jmp	 SHORT $LN16@InitNew
$LN3@InitNew:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 779  : 		return (p != NULL) ? p->InitNew() : E_FAIL;

  00023	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
$LN16@InitNew:
  00028	8b c7		 mov	 eax, edi
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi

; 780  : 	}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?InitNew@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStorage@@@Z ENDP ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::InitNew
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?IsDirty@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?IsDirty@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ PROC ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IsDirty, COMDAT

; 768  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 769  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::IsDirty\n"));
; 770  : 		CComPtr<IPersistStreamInit> p;
; 771  : 		p.p = IPSI_GetIPersistStreamInit();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	e8 00 00 00 00	 call	 ?IPSI_GetIPersistStreamInit@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@AAEPAUIPersistStreamInit@@XZ ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IPSI_GetIPersistStreamInit
  0000d	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  0000f	85 f6		 test	 esi, esi
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 772  : 		return (p != NULL) ? p->IsDirty() : E_FAIL;

  00011	74 10		 je	 SHORT $LN3@IsDirty
  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	56		 push	 esi
  00016	ff 50 10	 call	 DWORD PTR [eax+16]
  00019	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 184  :             p->Release();

  0001b	8b 06		 mov	 eax, DWORD PTR [esi]
  0001d	56		 push	 esi
  0001e	ff 50 08	 call	 DWORD PTR [eax+8]
  00021	eb 05		 jmp	 SHORT $LN16@IsDirty
$LN3@IsDirty:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 772  : 		return (p != NULL) ? p->IsDirty() : E_FAIL;

  00023	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
$LN16@IsDirty:
  00028	8b c7		 mov	 eax, edi
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi

; 773  : 	}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?IsDirty@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ENDP ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::IsDirty
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetClassID@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pClassID$ = 12						; size = 4
?GetClassID@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z PROC ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::GetClassID, COMDAT

; 758  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 759  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::GetClassID\n"));
; 760  : 		if (pClassID == NULL)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _pClassID$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 07		 jne	 SHORT $LN2@GetClassID

; 761  : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 0d		 jmp	 SHORT $LN1@GetClassID
$LN2@GetClassID:
  00012	56		 push	 esi

; 762  : 		*pClassID = T::GetObjectCLSID();

  00013	be 00 00 00 00	 mov	 esi, OFFSET _CLSID_OPOSDeviceMonitor

; 763  : 		return S_OK;

  00018	33 c0		 xor	 eax, eax
  0001a	a5		 movsd
  0001b	a5		 movsd
  0001c	a5		 movsd
  0001d	a5		 movsd
  0001e	5e		 pop	 esi
$LN1@GetClassID:
  0001f	5f		 pop	 edi

; 764  : 	}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?GetClassID@?$IPersistStorageImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z ENDP ; ATL::IPersistStorageImpl<COPOSDeviceMonitor>::GetClassID
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?FindConnectionPoint@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAUIConnectionPoint@@@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -24					; size = 4
_iid$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppCP$ = 16						; size = 4
?FindConnectionPoint@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAUIConnectionPoint@@@Z PROC ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::FindConnectionPoint, COMDAT

; 6538 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	53		 push	 ebx
  00014	8b 5d 10	 mov	 ebx, DWORD PTR _ppCP$[ebp]
  00017	89 4d e8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx

; 6539 : 		if (ppCP == NULL)

  0001a	85 db		 test	 ebx, ebx
  0001c	75 07		 jne	 SHORT $LN4@FindConnec

; 6540 : 			return E_POINTER;

  0001e	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00023	eb 6f		 jmp	 SHORT $LN1@FindConnec
$LN4@FindConnec:

; 6541 : 		*ppCP = NULL;

  00025	83 23 00	 and	 DWORD PTR [ebx], 0
  00028	56		 push	 esi

; 6542 : 		HRESULT hRes = CONNECT_E_NOCONNECTION;
; 6543 : 		const _ATL_CONNMAP_ENTRY* pEntry = pConnMap;

  00029	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::pConnMap

; 6544 : 		IID iid;
; 6545 : 		while (pEntry->dwOffset != (DWORD_PTR)-1)

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	83 f8 ff	 cmp	 eax, -1
  00034	74 50		 je	 SHORT $LN15@FindConnec
  00036	57		 push	 edi
$LL2@FindConnec:

; 6546 : 		{
; 6547 : 			if (pEntry->dwOffset == (DWORD_PTR)-2)

  00037	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  0003a	75 0c		 jne	 SHORT $LN5@FindConnec

; 6548 : 			{
; 6549 : 				pEntry++;
; 6550 : 				const _ATL_CONNMAP_ENTRY* (*pFunc)(int*) =  (const _ATL_CONNMAP_ENTRY* (*)(int*))(pEntry->dwOffset);

  0003c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 6551 : 				pEntry = pFunc(NULL);

  0003f	6a 00		 push	 0
  00041	ff d0		 call	 eax
  00043	59		 pop	 ecx
  00044	8b f0		 mov	 esi, eax

; 6552 : 				continue;

  00046	eb 26		 jmp	 SHORT $LN11@FindConnec
$LN5@FindConnec:

; 6553 : 			}
; 6554 : 			IConnectionPoint* pCP =

  00048	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]

; 6555 : 				(IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);
; 6556 : 			if (SUCCEEDED(pCP->GetConnectionInterface(&iid)) &&

  0004b	8b 07		 mov	 eax, DWORD PTR [edi]
  0004d	8d 4d ec	 lea	 ecx, DWORD PTR _iid$[ebp]
  00050	51		 push	 ecx
  00051	57		 push	 edi
  00052	ff 50 0c	 call	 DWORD PTR [eax+12]
  00055	85 c0		 test	 eax, eax
  00057	78 12		 js	 SHORT $LN6@FindConnec
  00059	8d 45 ec	 lea	 eax, DWORD PTR _iid$[ebp]
  0005c	50		 push	 eax
  0005d	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  00060	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  00065	59		 pop	 ecx
  00066	59		 pop	 ecx
  00067	85 c0		 test	 eax, eax
  00069	75 0f		 jne	 SHORT $LN10@FindConnec
$LN6@FindConnec:

; 6562 : 				break;
; 6563 : 			}
; 6564 : 			pEntry++;

  0006b	83 c6 04	 add	 esi, 4
$LN11@FindConnec:

; 6544 : 		IID iid;
; 6545 : 		while (pEntry->dwOffset != (DWORD_PTR)-1)

  0006e	8b 06		 mov	 eax, DWORD PTR [esi]
  00070	83 f8 ff	 cmp	 eax, -1
  00073	74 18		 je	 SHORT $LN16@FindConnec
  00075	8b 4d e8	 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00078	eb bd		 jmp	 SHORT $LL2@FindConnec
$LN10@FindConnec:

; 6557 : 				InlineIsEqualGUID(riid, iid))
; 6558 : 			{
; 6559 : 				*ppCP = pCP;

  0007a	89 3b		 mov	 DWORD PTR [ebx], edi

; 6560 : 				pCP->AddRef();

  0007c	8b 07		 mov	 eax, DWORD PTR [edi]
  0007e	57		 push	 edi
  0007f	ff 50 04	 call	 DWORD PTR [eax+4]

; 6561 : 				hRes = S_OK;

  00082	33 c0		 xor	 eax, eax
  00084	eb 0c		 jmp	 SHORT $LN17@FindConnec
$LN15@FindConnec:

; 6544 : 		IID iid;
; 6545 : 		while (pEntry->dwOffset != (DWORD_PTR)-1)

  00086	b8 00 02 04 80	 mov	 eax, -2147220992	; 80040200H
  0008b	eb 06		 jmp	 SHORT $LN14@FindConnec
$LN16@FindConnec:
  0008d	b8 00 02 04 80	 mov	 eax, -2147220992	; 80040200H
$LN17@FindConnec:
  00092	5f		 pop	 edi
$LN14@FindConnec:

; 6565 : 		}
; 6566 : 		return hRes;

  00093	5e		 pop	 esi
$LN1@FindConnec:

; 6567 : 	}

  00094	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00097	33 cd		 xor	 ecx, ebp
  00099	5b		 pop	 ebx
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	c9		 leave
  000a0	c2 0c 00	 ret	 12			; 0000000cH
?FindConnectionPoint@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJABU_GUID@@PAPAUIConnectionPoint@@@Z ENDP ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::FindConnectionPoint
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?EnumConnectionPoints@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z
_TEXT	SEGMENT
_nCPCount$ = -20					; size = 4
_ppCP$1$ = -16						; size = 4
tv476 = -12						; size = 4
__AtlSafeAllocaManager$ = -12				; size = 4
_pEnum$1$ = -8						; size = 4
_nBytes$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_ppEnum$ = 12						; size = 4
?EnumConnectionPoints@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z PROC ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::EnumConnectionPoints, COMDAT

; 6469 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6470 : 		if (ppEnum == NULL)

  00010	8b 45 0c	 mov	 eax, DWORD PTR _ppEnum$[ebp]
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	85 c0		 test	 eax, eax
  00018	75 0a		 jne	 SHORT $LN4@EnumConnec

; 6471 : 			return E_POINTER;

  0001a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0001f	e9 54 01 00 00	 jmp	 $LN1@EnumConnec
$LN4@EnumConnec:

; 6472 : 		*ppEnum = NULL;
; 6473 : 
; 6474 : 		CComEnumConnectionPoints* pEnum = _ATL_NEW CComObject<CComEnumConnectionPoints>;

  00024	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00029	33 db		 xor	 ebx, ebx
  0002b	6a 1c		 push	 28			; 0000001cH
  0002d	89 18		 mov	 DWORD PTR [eax], ebx
  0002f	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx
  00036	85 c0		 test	 eax, eax
  00038	0f 84 35 01 00
	00		 je	 $LN73@EnumConnec
  0003e	53		 push	 ebx
  0003f	8b c8		 mov	 ecx, eax
  00041	e8 00 00 00 00	 call	 ??0?$CComObject@V?$CComEnum@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@VCComSingleThreadModel@6@@ATL@@@ATL@@QAE@PAX@Z ; ATL::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >::CComObject<ATL::CComEnum<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint>,ATL::CComSingleThreadModel> >
  00046	8b f8		 mov	 edi, eax

; 6475 : 		if (pEnum == NULL)

  00048	85 ff		 test	 edi, edi
  0004a	0f 84 23 01 00
	00		 je	 $LN73@EnumConnec

; 6479 : 		T::GetConnMap(&nCPCount);

  00050	8d 45 ec	 lea	 eax, DWORD PTR _nCPCount$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?GetConnMap@COPOSDeviceMonitor@@SAPBU_ATL_CONNMAP_ENTRY@ATL@@PAH@Z ; COPOSDeviceMonitor::GetConnMap

; 6480 : 
; 6481 : 		// allocate an initialize a vector of connection point object pointers
; 6482 : 		USES_ATL_SAFE_ALLOCA;
; 6483 : 		if ((nCPCount < 0) || (nCPCount > (INT_MAX / sizeof(IConnectionPoint*))))

  00059	8b 45 ec	 mov	 eax, DWORD PTR _nCPCount$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h

; 674  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL)

  0005c	8b f3		 mov	 esi, ebx
  0005e	89 75 f4	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6479 : 		T::GetConnMap(&nCPCount);

  00061	59		 pop	 ecx

; 6480 : 
; 6481 : 		// allocate an initialize a vector of connection point object pointers
; 6482 : 		USES_ATL_SAFE_ALLOCA;
; 6483 : 		if ((nCPCount < 0) || (nCPCount > (INT_MAX / sizeof(IConnectionPoint*))))

  00062	85 c0		 test	 eax, eax
  00064	0f 88 e8 00 00
	00		 js	 $LN7@EnumConnec
  0006a	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0006f	0f 87 dd 00 00
	00		 ja	 $LN7@EnumConnec

; 6484 : 		{
; 6485 : 			delete pEnum;
; 6486 : 			return E_OUTOFMEMORY;
; 6487 : 		}
; 6488 : 
; 6489 : 		size_t nBytes=0;
; 6490 : 		HRESULT hr=S_OK;
; 6491 : 		if( FAILED(hr=::ATL::AtlMultiply(&nBytes, sizeof(IConnectionPoint*), static_cast<size_t>(nCPCount))))

  00075	50		 push	 eax
  00076	8d 45 f8	 lea	 eax, DWORD PTR _nBytes$[ebp]
  00079	89 5d f8	 mov	 DWORD PTR _nBytes$[ebp], ebx
  0007c	6a 04		 push	 4
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??$AtlMultiply@I@ATL@@YAJPAIII@Z ; ATL::AtlMultiply<unsigned int>
  00084	8b d8		 mov	 ebx, eax
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	85 db		 test	 ebx, ebx
  0008b	0f 88 b6 00 00
	00		 js	 $LN76@EnumConnec

; 6492 : 		{
; 6493 : 			delete pEnum;
; 6494 : 			return hr;
; 6495 : 		}
; 6496 : 		IConnectionPoint** ppCP = (IConnectionPoint**)_ATL_SAFE_ALLOCA(nBytes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00091	8b 5d f8	 mov	 ebx, DWORD PTR _nBytes$[ebp]
  00094	81 fb 00 04 00
	00		 cmp	 ebx, 1024		; 00000400H
  0009a	77 16		 ja	 SHORT $LN20@EnumConnec
  0009c	53		 push	 ebx
  0009d	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  000a2	59		 pop	 ecx
  000a3	84 c0		 test	 al, al
  000a5	74 0b		 je	 SHORT $LN20@EnumConnec
  000a7	8b c3		 mov	 eax, ebx
  000a9	e8 00 00 00 00	 call	 __alloca_probe_16
  000ae	8b cc		 mov	 ecx, esp
  000b0	eb 0e		 jmp	 SHORT $LN74@EnumConnec
$LN20@EnumConnec:
  000b2	53		 push	 ebx
  000b3	8d 4d f4	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000b6	e8 00 00 00 00	 call	 ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
  000bb	8b 75 f4	 mov	 esi, DWORD PTR __AtlSafeAllocaManager$[ebp]
  000be	8b c8		 mov	 ecx, eax
$LN74@EnumConnec:

; 6497 : 		if (ppCP == NULL)

  000c0	89 4d f0	 mov	 DWORD PTR _ppCP$1$[ebp], ecx
  000c3	85 c9		 test	 ecx, ecx
  000c5	0f 84 87 00 00
	00		 je	 $LN7@EnumConnec

; 6498 : 		{
; 6499 : 			delete pEnum;
; 6500 : 			return E_OUTOFMEMORY;
; 6501 : 		}
; 6502 : 
; 6503 : 		int i = 0;
; 6504 : 		const _ATL_CONNMAP_ENTRY* pEntry = pConnMap;

  000cb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?pConnMap@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@0PBU_ATL_CONNMAP_ENTRY@2@B ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::pConnMap

; 6505 : 		while (pEntry->dwOffset != (DWORD_PTR)-1)

  000d1	8b df		 mov	 ebx, edi
  000d3	89 5d f8	 mov	 DWORD PTR _pEnum$1$[ebp], ebx
  000d6	8b 02		 mov	 eax, DWORD PTR [edx]
  000d8	83 f8 ff	 cmp	 eax, -1
  000db	74 35		 je	 SHORT $LN3@EnumConnec
  000dd	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  000e0	89 4d f4	 mov	 DWORD PTR tv476[ebp], ecx
  000e3	89 7d f8	 mov	 DWORD PTR _pEnum$1$[ebp], edi
$LL2@EnumConnec:

; 6506 : 		{
; 6507 : 			if (pEntry->dwOffset == (DWORD_PTR)-2)

  000e6	83 c2 04	 add	 edx, 4
  000e9	83 f8 fe	 cmp	 eax, -2			; fffffffeH
  000ec	75 0e		 jne	 SHORT $LN10@EnumConnec

; 6508 : 			{
; 6509 : 				pEntry++;
; 6510 : 				const _ATL_CONNMAP_ENTRY* (*pFunc)(int*) =  (const _ATL_CONNMAP_ENTRY* (*)(int*))(pEntry->dwOffset);

  000ee	8b 02		 mov	 eax, DWORD PTR [edx]

; 6511 : 				pEntry = pFunc(NULL);

  000f0	6a 00		 push	 0
  000f2	ff d0		 call	 eax
  000f4	59		 pop	 ecx

; 6512 : 				continue;

  000f5	8b 4d f4	 mov	 ecx, DWORD PTR tv476[ebp]
  000f8	8b d0		 mov	 edx, eax
  000fa	eb 0a		 jmp	 SHORT $LN67@EnumConnec
$LN10@EnumConnec:

; 6513 : 			}
; 6514 : 			ppCP[i++] = (IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);

  000fc	03 c3		 add	 eax, ebx
  000fe	89 01		 mov	 DWORD PTR [ecx], eax
  00100	83 c1 04	 add	 ecx, 4
  00103	89 4d f4	 mov	 DWORD PTR tv476[ebp], ecx
$LN67@EnumConnec:

; 6505 : 		while (pEntry->dwOffset != (DWORD_PTR)-1)

  00106	8b 02		 mov	 eax, DWORD PTR [edx]
  00108	83 f8 ff	 cmp	 eax, -1
  0010b	75 d9		 jne	 SHORT $LL2@EnumConnec
  0010d	8b 4d f0	 mov	 ecx, DWORD PTR _ppCP$1$[ebp]
  00110	8b df		 mov	 ebx, edi
$LN3@EnumConnec:

; 6515 : 			pEntry++;
; 6516 : 		}
; 6517 : 
; 6518 : 		// copy the pointers: they will AddRef this object
; 6519 : 		HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],

  00112	8b 45 ec	 mov	 eax, DWORD PTR _nCPCount$[ebp]
  00115	6a 03		 push	 3
  00117	ff 75 08	 push	 DWORD PTR _this$[ebp]
  0011a	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0011d	50		 push	 eax
  0011e	51		 push	 ecx
  0011f	8b cb		 mov	 ecx, ebx
  00121	e8 00 00 00 00	 call	 ?Init@?$CComEnumImpl@UIEnumConnectionPoints@@$1?_GUID_b196b285_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@BPAUIConnectionPoint@@V?$_CopyInterface@UIConnectionPoint@@@ATL@@@ATL@@QAEJPAPAUIConnectionPoint@@0PAUIUnknown@@W4CComEnumFlags@2@@Z ; ATL::CComEnumImpl<IEnumConnectionPoints,&_GUID_b196b285_bab4_101a_b69c_00aa00341d07,IConnectionPoint *,ATL::_CopyInterface<IConnectionPoint> >::Init
  00126	8b d8		 mov	 ebx, eax
  00128	8b 07		 mov	 eax, DWORD PTR [edi]

; 6520 : 			(IConnectionPoint**)&ppCP[nCPCount],
; 6521 : 			static_cast<IConnectionPointContainer*>(this), AtlFlagCopy);
; 6522 : 		if (FAILED(hRes))

  0012a	85 db		 test	 ebx, ebx
  0012c	79 05		 jns	 SHORT $LN11@EnumConnec

; 6523 : 		{
; 6524 : 			delete pEnum;

  0012e	8b 4d f8	 mov	 ecx, DWORD PTR _pEnum$1$[ebp]

; 6525 : 			return hRes;

  00131	eb 18		 jmp	 SHORT $LN78@EnumConnec
$LN11@EnumConnec:

; 6526 : 		}
; 6527 : 		hRes = pEnum->QueryInterface(__uuidof(IEnumConnectionPoints), (void**)ppEnum);

  00133	ff 75 0c	 push	 DWORD PTR _ppEnum$[ebp]
  00136	8b 7d f8	 mov	 edi, DWORD PTR _pEnum$1$[ebp]
  00139	68 00 00 00 00	 push	 OFFSET __GUID_b196b285_bab4_101a_b69c_00aa00341d07
  0013e	57		 push	 edi
  0013f	ff 10		 call	 DWORD PTR [eax]
  00141	8b d8		 mov	 ebx, eax

; 6528 : 		if (FAILED(hRes))

  00143	85 db		 test	 ebx, ebx
  00145	79 24		 jns	 SHORT $LN77@EnumConnec
$LN76@EnumConnec:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h

; 692  : 		while (m_pHead != NULL)

  00147	8b 07		 mov	 eax, DWORD PTR [edi]
  00149	8b cf		 mov	 ecx, edi
$LN78@EnumConnec:
  0014b	6a 01		 push	 1
  0014d	ff 50 1c	 call	 DWORD PTR [eax+28]
  00150	eb 19		 jmp	 SHORT $LN77@EnumConnec
$LN7@EnumConnec:
  00152	8b 07		 mov	 eax, DWORD PTR [edi]
  00154	8b cf		 mov	 ecx, edi
  00156	6a 01		 push	 1
  00158	ff 50 1c	 call	 DWORD PTR [eax+28]
  0015b	bb 0e 00 07 80	 mov	 ebx, -2147024882	; 8007000eH
  00160	eb 09		 jmp	 SHORT $LN77@EnumConnec
$LL59@EnumConnec:

; 267  : 		free(p);

  00162	56		 push	 esi

; 695  : 			m_pHead = m_pHead->m_pNext;

  00163	8b 36		 mov	 esi, DWORD PTR [esi]

; 267  : 		free(p);

  00165	e8 00 00 00 00	 call	 _free
  0016a	59		 pop	 ecx
$LN77@EnumConnec:

; 692  : 		while (m_pHead != NULL)

  0016b	85 f6		 test	 esi, esi
  0016d	75 f3		 jne	 SHORT $LL59@EnumConnec
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6531 : 		return hRes;

  0016f	8b c3		 mov	 eax, ebx
  00171	eb 05		 jmp	 SHORT $LN1@EnumConnec
$LN73@EnumConnec:

; 6476 : 			return E_OUTOFMEMORY;

  00173	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
$LN1@EnumConnec:

; 6532 : 	}

  00178	8d 65 e0	 lea	 esp, DWORD PTR [ebp-32]
  0017b	5f		 pop	 edi
  0017c	5e		 pop	 esi
  0017d	5b		 pop	 ebx
  0017e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00181	33 cd		 xor	 ecx, ebp
  00183	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00188	c9		 leave
  00189	c2 08 00	 ret	 8
?EnumConnectionPoints@?$IConnectionPointContainerImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumConnectionPoints@@@Z ENDP ; ATL::IConnectionPointContainerImpl<COPOSDeviceMonitor>::EnumConnectionPoints
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetDropTarget@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIDropTarget@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetDropTarget@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIDropTarget@@@Z PROC ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::GetDropTarget, COMDAT

; 3368 : 		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3369 : 	}

  00005	c2 08 00	 ret	 8
?GetDropTarget@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIDropTarget@@@Z ENDP ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::GetDropTarget
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnWindowMessage@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJIIJPAJ@Z
_TEXT	SEGMENT
_message$ = -36						; size = 36
_this$ = 8						; size = 4
_msg$ = 12						; size = 4
_wParam$ = 16						; size = 4
tv290 = 20						; size = 4
_lParam$ = 20						; size = 4
_plResult$ = 24						; size = 4
?OnWindowMessage@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJIIJPAJ@Z PROC ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::OnWindowMessage, COMDAT

; 3353 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 3354 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n"));
; 3355 : 		T* pT = static_cast<T*>(this);
; 3356 : 		_ATL_MSG message(NULL, msg, wParam, lParam);

  00009	6a 01		 push	 1
  0000b	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  0000e	8d 4d dc	 lea	 ecx, DWORD PTR _message$[ebp]
  00011	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR _msg$[ebp]
  00017	6a 00		 push	 0
  00019	e8 00 00 00 00	 call	 ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z ; ATL::_ATL_MSG::_ATL_MSG

; 3357 : 		const _ATL_MSG* pOldMsg = pT->m_pCurrentMsg;

  0001e	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00021	85 f6		 test	 esi, esi
  00023	6a 64		 push	 100			; 00000064H
  00025	58		 pop	 eax

; 3358 : 		pT->m_pCurrentMsg = &message;
; 3359 : 		BOOL b = pT->ProcessWindowMessage(pT->m_hWnd, msg, wParam, lParam, *plResult);

  00026	6a 4c		 push	 76			; 0000004cH
  00028	8d 5e e0	 lea	 ebx, DWORD PTR [esi-32]
  0002b	0f 44 d8	 cmove	 ebx, eax
  0002e	8d 4e c8	 lea	 ecx, DWORD PTR [esi-56]
  00031	8d 45 dc	 lea	 eax, DWORD PTR _message$[ebp]
  00034	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00036	89 03		 mov	 DWORD PTR [ebx], eax
  00038	58		 pop	 eax
  00039	6a 00		 push	 0
  0003b	ff 75 18	 push	 DWORD PTR _plResult$[ebp]
  0003e	0f 44 c8	 cmove	 ecx, eax
  00041	8d 46 cc	 lea	 eax, DWORD PTR [esi-52]
  00044	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00047	c7 45 14 50 00
	00 00		 mov	 DWORD PTR tv290[ebp], 80 ; 00000050H
  0004e	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00051	0f 44 45 14	 cmove	 eax, DWORD PTR tv290[ebp]
  00055	ff 75 0c	 push	 DWORD PTR _msg$[ebp]
  00058	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005a	ff 30		 push	 DWORD PTR [eax]
  0005c	ff 12		 call	 DWORD PTR [edx]

; 3360 : 		// restore saved value for the current message
; 3361 : 		ATLASSERT(pT->m_pCurrentMsg == &message);
; 3362 : 		pT->m_pCurrentMsg = pOldMsg;
; 3363 : 		return b ? S_OK : S_FALSE;

  0005e	33 c9		 xor	 ecx, ecx
  00060	89 3b		 mov	 DWORD PTR [ebx], edi
  00062	85 c0		 test	 eax, eax
  00064	5f		 pop	 edi
  00065	0f 94 c1	 sete	 cl
  00068	5e		 pop	 esi
  00069	8b c1		 mov	 eax, ecx
  0006b	5b		 pop	 ebx

; 3364 : 	}

  0006c	c9		 leave
  0006d	c2 14 00	 ret	 20			; 00000014H
?OnWindowMessage@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJIIJPAJ@Z ENDP ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::OnWindowMessage
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?ReactivateAndUndo@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?ReactivateAndUndo@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ PROC ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::ReactivateAndUndo, COMDAT

; 3343 : 		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3344 : 	}

  00005	c2 04 00	 ret	 4
?ReactivateAndUndo@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ENDP ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::ReactivateAndUndo
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetObjectRects@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_prcPos$ = 12						; size = 4
_prcClip$ = 16						; size = 4
?SetObjectRects@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@0@Z PROC ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::SetObjectRects, COMDAT

; 3336 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3337 : 		T* pT = static_cast<T*>(this);
; 3338 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n"));
; 3339 : 		return pT->IOleInPlaceObject_SetObjectRects(prcPos, prcClip);

  00003	ff 75 10	 push	 DWORD PTR _prcClip$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	ff 75 0c	 push	 DWORD PTR _prcPos$[ebp]
  0000e	6a 04		 push	 4
  00010	8d 48 80	 lea	 ecx, DWORD PTR [eax-128]
  00013	5a		 pop	 edx
  00014	0f 44 ca	 cmove	 ecx, edx
  00017	e8 00 00 00 00	 call	 ?IOleInPlaceObject_SetObjectRects@CComControlBase@ATL@@QAEJPBUtagRECT@@0@Z ; ATL::CComControlBase::IOleInPlaceObject_SetObjectRects

; 3340 : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
?SetObjectRects@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@0@Z ENDP ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::SetObjectRects
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?UIDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?UIDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ PROC ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::UIDeactivate, COMDAT

; 3328 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3329 : 		T* pT = static_cast<T*>(this);
; 3330 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n"));
; 3331 : 		return pT->IOleInPlaceObject_UIDeactivate();

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	6a 04		 push	 4
  0000a	5a		 pop	 edx
  0000b	8d 48 80	 lea	 ecx, DWORD PTR [eax-128]
  0000e	0f 44 ca	 cmove	 ecx, edx
  00011	e8 00 00 00 00	 call	 ?IOleInPlaceObject_UIDeactivate@CComControlBase@ATL@@QAEJXZ ; ATL::CComControlBase::IOleInPlaceObject_UIDeactivate

; 3332 : 	}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?UIDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ENDP ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::UIDeactivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?InPlaceDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?InPlaceDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ PROC ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::InPlaceDeactivate, COMDAT

; 3322 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3323 : 		T* pT = static_cast<T*>(this);
; 3324 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n"));
; 3325 : 		return pT->IOleInPlaceObject_InPlaceDeactivate();

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	6a 04		 push	 4
  0000a	5a		 pop	 edx
  0000b	8d 48 80	 lea	 ecx, DWORD PTR [eax-128]
  0000e	0f 44 ca	 cmove	 ecx, edx
  00011	e8 00 00 00 00	 call	 ?IOleInPlaceObject_InPlaceDeactivate@CComControlBase@ATL@@QAEJXZ ; ATL::CComControlBase::IOleInPlaceObject_InPlaceDeactivate

; 3326 : 	}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?InPlaceDeactivate@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ENDP ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::InPlaceDeactivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?ContextSensitiveHelp@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?ContextSensitiveHelp@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z PROC ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::ContextSensitiveHelp, COMDAT

; 3316 : 		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3317 : 	}

  00005	c2 08 00	 ret	 8
?ContextSensitiveHelp@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ENDP ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::ContextSensitiveHelp
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetWindow@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_phwnd$ = 12						; size = 4
?GetWindow@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z PROC ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::GetWindow, COMDAT

; 3299 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3300 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n"));
; 3301 : 		T* pT = static_cast<T*>(this);
; 3302 : 		HRESULT hRes = E_POINTER;
; 3303 : 
; 3304 : 		if (pT->m_bWasOnceWindowless)

  00003	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	56		 push	 esi
  00009	6a 48		 push	 72			; 00000048H
  0000b	59		 pop	 ecx
  0000c	8d 42 c4	 lea	 eax, DWORD PTR [edx-60]
  0000f	be 03 40 00 80	 mov	 esi, -2147467261	; 80004003H
  00014	0f 44 c1	 cmove	 eax, ecx
  00017	f7 00 00 01 00
	00		 test	 DWORD PTR [eax], 256	; 00000100H
  0001d	74 05		 je	 SHORT $LN2@GetWindow

; 3305 : 			return E_FAIL;

  0001f	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00022	eb 24		 jmp	 SHORT $LN1@GetWindow
$LN2@GetWindow:

; 3306 : 
; 3307 : 		if (phwnd != NULL)

  00024	8b 45 0c	 mov	 eax, DWORD PTR _phwnd$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	74 1b		 je	 SHORT $LN3@GetWindow

; 3308 : 		{
; 3309 : 			*phwnd = pT->m_hWnd;

  0002b	6a 50		 push	 80			; 00000050H
  0002d	85 d2		 test	 edx, edx
  0002f	8d 4a cc	 lea	 ecx, DWORD PTR [edx-52]
  00032	5e		 pop	 esi
  00033	0f 44 ce	 cmove	 ecx, esi

; 3310 : 			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;

  00036	33 f6		 xor	 esi, esi
  00038	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003a	85 c9		 test	 ecx, ecx
  0003c	89 08		 mov	 DWORD PTR [eax], ecx
  0003e	b8 ff ff 00 80	 mov	 eax, -2147418113	; 8000ffffH
  00043	0f 44 f0	 cmove	 esi, eax
$LN3@GetWindow:

; 3311 : 		}
; 3312 : 		return hRes;

  00046	8b c6		 mov	 eax, esi
$LN1@GetWindow:
  00048	5e		 pop	 esi

; 3313 : 	}

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
?GetWindow@?$IOleInPlaceObjectWindowlessImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z ENDP ; ATL::IOleInPlaceObjectWindowlessImpl<COPOSDeviceMonitor>::GetWindow
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetNaturalExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUHDC__@@PAUtagExtentInfo@@PAUtagSIZE@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwAspect$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
_pExtentInfo$ = 28					; size = 4
_psizel$ = 32						; size = 4
?GetNaturalExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUHDC__@@PAUtagExtentInfo@@PAUtagSIZE@@@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetNaturalExtent, COMDAT

; 3263 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3264 : 		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::GetNaturalExtent\n"));
; 3265 : 		ATLASSERT(pExtentInfo != NULL);
; 3266 : 		ATLASSERT(psizel != NULL);
; 3267 : 		if ((pExtentInfo == NULL) || (psizel == NULL))

  00003	8b 45 1c	 mov	 eax, DWORD PTR _pExtentInfo$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 38		 je	 SHORT $LN3@GetNatural
  0000a	8b 55 20	 mov	 edx, DWORD PTR _psizel$[ebp]
  0000d	85 d2		 test	 edx, edx
  0000f	74 31		 je	 SHORT $LN3@GetNatural

; 3269 : 
; 3270 : 		HRESULT hRes = E_FAIL;
; 3271 : 		T* pT = static_cast<T*>(this);
; 3272 : 		if (dwAspect == DVASPECT_CONTENT)

  00011	83 7d 0c 01	 cmp	 DWORD PTR _dwAspect$[ebp], 1
  00015	b9 05 40 00 80	 mov	 ecx, -2147467259	; 80004005H
  0001a	75 22		 jne	 SHORT $LN5@GetNatural

; 3273 : 		{
; 3274 : 			if (pExtentInfo->dwExtentMode == DVEXTENT_CONTENT)

  0001c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00020	75 1c		 jne	 SHORT $LN5@GetNatural

; 3275 : 			{
; 3276 : 				*psizel = pT->m_sizeNatural;

  00022	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	56		 push	 esi
  00028	6a 20		 push	 32			; 00000020H
  0002a	5e		 pop	 esi
  0002b	8d 48 a0	 lea	 ecx, DWORD PTR [eax-96]
  0002e	0f 44 ce	 cmove	 ecx, esi

; 3277 : 				hRes = S_OK;

  00031	5e		 pop	 esi
  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00037	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  0003a	33 c9		 xor	 ecx, ecx
  0003c	89 02		 mov	 DWORD PTR [edx], eax
$LN5@GetNatural:

; 3278 : 			}
; 3279 : 		}
; 3280 : 		return hRes;

  0003e	8b c1		 mov	 eax, ecx
  00040	eb 05		 jmp	 SHORT $LN1@GetNatural
$LN3@GetNatural:

; 3268 : 			return E_POINTER;

  00042	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@GetNatural:

; 3281 : 	}

  00047	5d		 pop	 ebp
  00048	c2 1c 00	 ret	 28			; 0000001cH
?GetNaturalExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUHDC__@@PAUtagExtentInfo@@PAUtagSIZE@@@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetNaturalExtent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?QueryHitRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@0JPAK@Z
_TEXT	SEGMENT
_rc$1 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_dwAspect$ = 12						; size = 4
_pRectBounds$ = 16					; size = 4
_prcLoc$ = 20						; size = 4
___formal$ = 24						; size = 4
_pHitResult$ = 28					; size = 4
?QueryHitRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@0JPAK@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::QueryHitRect, COMDAT

; 3240 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _pRectBounds$[ebp]
  00013	8b 4d 14	 mov	 ecx, DWORD PTR _prcLoc$[ebp]
  00016	56		 push	 esi
  00017	8b 75 1c	 mov	 esi, DWORD PTR _pHitResult$[ebp]

; 3241 : 		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitRect\n"));
; 3242 : 		ATLASSERT(pHitResult != NULL);
; 3243 : 		if (pHitResult == NULL)

  0001a	85 f6		 test	 esi, esi
  0001c	75 07		 jne	 SHORT $LN2@QueryHitRe

; 3244 : 			return E_POINTER;

  0001e	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00023	eb 27		 jmp	 SHORT $LN1@QueryHitRe
$LN2@QueryHitRe:

; 3245 : 
; 3246 : 		if (dwAspect == DVASPECT_CONTENT)

  00025	83 7d 0c 01	 cmp	 DWORD PTR _dwAspect$[ebp], 1
  00029	75 19		 jne	 SHORT $LN3@QueryHitRe

; 3247 : 		{
; 3248 : 			RECT rc;
; 3249 : 			*pHitResult = UnionRect(&rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	8d 45 ec	 lea	 eax, DWORD PTR _rc$1[ebp]
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnionRect@12
  00037	f7 d8		 neg	 eax
  00039	1b c0		 sbb	 eax, eax
  0003b	83 e0 03	 and	 eax, 3
  0003e	89 06		 mov	 DWORD PTR [esi], eax

; 3250 : 			return S_OK;

  00040	33 c0		 xor	 eax, eax
  00042	eb 08		 jmp	 SHORT $LN1@QueryHitRe
$LN3@QueryHitRe:

; 3251 : 		}
; 3252 : 		*pHitResult = NULL;

  00044	83 26 00	 and	 DWORD PTR [esi], 0

; 3253 : 		ATLTRACE(atlTraceControls,2,_T("Wrong DVASPECT\n"));
; 3254 : 		return E_FAIL;

  00047	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$LN1@QueryHitRe:

; 3255 : 	}

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004f	33 cd		 xor	 ecx, ebp
  00051	5e		 pop	 esi
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	c9		 leave
  00058	c2 18 00	 ret	 24			; 00000018H
?QueryHitRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@0JPAK@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::QueryHitRect
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?QueryHitPoint@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@UtagPOINT@@JPAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwAspect$ = 12						; size = 4
_pRectBounds$ = 16					; size = 4
_ptlLoc$ = 20						; size = 8
___formal$ = 28						; size = 4
_pHitResult$ = 32					; size = 4
?QueryHitPoint@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@UtagPOINT@@JPAK@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::QueryHitPoint, COMDAT

; 3219 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3220 : 		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitPoint\n"));
; 3221 : 		ATLASSERT(pHitResult != NULL);
; 3222 : 		if (pHitResult == NULL)

  00004	8b 75 20	 mov	 esi, DWORD PTR _pHitResult$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN2@QueryHitPo

; 3223 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 2a		 jmp	 SHORT $LN1@QueryHitPo
$LN2@QueryHitPo:

; 3224 : 
; 3225 : 		if (dwAspect == DVASPECT_CONTENT)

  00012	83 7d 0c 01	 cmp	 DWORD PTR _dwAspect$[ebp], 1
  00016	75 1c		 jne	 SHORT $LN3@QueryHitPo

; 3226 : 		{
; 3227 : 			*pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;

  00018	ff 75 18	 push	 DWORD PTR _ptlLoc$[ebp+4]
  0001b	ff 75 14	 push	 DWORD PTR _ptlLoc$[ebp]
  0001e	ff 75 10	 push	 DWORD PTR _pRectBounds$[ebp]
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PtInRect@12
  00027	f7 d8		 neg	 eax
  00029	1b c0		 sbb	 eax, eax
  0002b	83 e0 03	 and	 eax, 3
  0002e	89 06		 mov	 DWORD PTR [esi], eax

; 3228 : 			return S_OK;

  00030	33 c0		 xor	 eax, eax
  00032	eb 08		 jmp	 SHORT $LN1@QueryHitPo
$LN3@QueryHitPo:

; 3229 : 		}
; 3230 : 		*pHitResult = NULL;

  00034	83 26 00	 and	 DWORD PTR [esi], 0

; 3231 : 		ATLTRACE(atlTraceControls,2,_T("Wrong DVASPECT\n"));
; 3232 : 		return E_FAIL;

  00037	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$LN1@QueryHitPo:
  0003c	5e		 pop	 esi

; 3233 : 	}

  0003d	5d		 pop	 ebp
  0003e	c2 1c 00	 ret	 28			; 0000001cH
?QueryHitPoint@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPBUtagRECT@@UtagPOINT@@JPAK@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::QueryHitPoint
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetViewStatus@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pdwStatus$ = 12					; size = 4
?GetViewStatus@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetViewStatus, COMDAT

; 3203 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3204 : 		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::GetViewStatus\n"));
; 3205 : 		ATLASSERT(pdwStatus != NULL);
; 3206 : 		if (pdwStatus == NULL)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pdwStatus$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 07		 jne	 SHORT $LN2@GetViewSta

; 3207 : 			return E_POINTER;

  0000a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000f	eb 08		 jmp	 SHORT $LN1@GetViewSta
$LN2@GetViewSta:

; 3208 : 
; 3209 : 		T* pT = static_cast<T*>(this);
; 3210 : 		*pdwStatus = pT->_GetViewStatus();

  00011	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3

; 3211 : 		return S_OK;

  00017	33 c0		 xor	 eax, eax
$LN1@GetViewSta:

; 3212 : 	}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?GetViewStatus@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetViewStatus
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAU_RECTL@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAU_RECTL@@@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetRect, COMDAT

; 3199 : 		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3200 : 	}

  00005	c2 0c 00	 ret	 12			; 0000000cH
?GetRect@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAU_RECTL@@@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetRect
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUtagSIZE@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
_lpsizel$ = 24						; size = 4
?GetExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUtagSIZE@@@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetExtent, COMDAT

; 3182 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3183 : 		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::GetExtent\n"));
; 3184 : 		ATLASSERT(lpsizel != NULL);
; 3185 : 		if (lpsizel == NULL)

  00003	8b 55 18	 mov	 edx, DWORD PTR _lpsizel$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	75 07		 jne	 SHORT $LN2@GetExtent

; 3186 : 			return E_POINTER;

  0000a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000f	eb 1c		 jmp	 SHORT $LN1@GetExtent
$LN2@GetExtent:

; 3187 : 
; 3188 : 		T* pT = static_cast<T*>(this);
; 3189 : 		*lpsizel = pT->m_sizeExtent;

  00011	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00014	85 c0		 test	 eax, eax
  00016	56		 push	 esi
  00017	6a 28		 push	 40			; 00000028H
  00019	5e		 pop	 esi
  0001a	8d 48 a8	 lea	 ecx, DWORD PTR [eax-88]
  0001d	0f 44 ce	 cmove	 ecx, esi

; 3190 : 		return S_OK;

  00020	5e		 pop	 esi
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00026	89 02		 mov	 DWORD PTR [edx], eax
  00028	33 c0		 xor	 eax, eax
  0002a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN1@GetExtent:

; 3191 : 	}

  0002d	5d		 pop	 ebp
  0002e	c2 14 00	 ret	 20			; 00000014H
?GetExtent@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAUtagDVTARGETDEVICE@@PAUtagSIZE@@@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetExtent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK0PAPAUIAdviseSink@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_ppAdvSink$ = 20					; size = 4
?GetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK0PAPAUIAdviseSink@@@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetAdvise, COMDAT

; 3159 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3160 : 		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::GetAdvise\n"));
; 3161 : 		ATLASSERT(ppAdvSink != NULL);
; 3162 : 
; 3163 : 		HRESULT hr = E_POINTER;
; 3164 : 		if (ppAdvSink != NULL)

  00003	8b 55 14	 mov	 edx, DWORD PTR _ppAdvSink$[ebp]
  00006	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000b	85 d2		 test	 edx, edx
  0000d	74 22		 je	 SHORT $LN2@GetAdvise

; 3165 : 		{
; 3166 : 			T* pT = static_cast<T*>(this);
; 3167 : 			*ppAdvSink = pT->m_spAdviseSink;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00012	85 c0		 test	 eax, eax
  00014	56		 push	 esi
  00015	6a 18		 push	 24			; 00000018H
  00017	5e		 pop	 esi
  00018	8d 48 98	 lea	 ecx, DWORD PTR [eax-104]
  0001b	0f 44 ce	 cmove	 ecx, esi

; 3168 : 			if (pT->m_spAdviseSink)

  0001e	5e		 pop	 esi
  0001f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00021	89 02		 mov	 DWORD PTR [edx], eax
  00023	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00025	85 c9		 test	 ecx, ecx
  00027	74 06		 je	 SHORT $LN3@GetAdvise

; 3169 : 				pT->m_spAdviseSink.p->AddRef();

  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	51		 push	 ecx
  0002c	ff 50 04	 call	 DWORD PTR [eax+4]
$LN3@GetAdvise:

; 3170 : 			hr = S_OK;

  0002f	33 c0		 xor	 eax, eax
$LN2@GetAdvise:

; 3171 : 		}
; 3172 : 		return hr;
; 3173 : 	}

  00031	5d		 pop	 ebp
  00032	c2 10 00	 ret	 16			; 00000010H
?GetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAK0PAPAUIAdviseSink@@@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetAdvise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAUIAdviseSink@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_pAdvSink$ = 20						; size = 4
?SetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAUIAdviseSink@@@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::SetAdvise, COMDAT

; 3149 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3150 : 		T* pT = static_cast<T*>(this);
; 3151 : 		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::SetAdvise\n"));
; 3152 : 		pT->m_spAdviseSink = pAdvSink;

  00003	ff 75 14	 push	 DWORD PTR _pAdvSink$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	6a 18		 push	 24			; 00000018H
  0000d	5a		 pop	 edx
  0000e	8d 48 98	 lea	 ecx, DWORD PTR [eax-104]
  00011	0f 44 ca	 cmove	 ecx, edx
  00014	e8 00 00 00 00	 call	 ??4?$CComPtr@UIAdviseSink@@@ATL@@QAEPAUIAdviseSink@@PAU2@@Z ; ATL::CComPtr<IAdviseSink>::operator=

; 3153 : 		return S_OK;

  00019	33 c0		 xor	 eax, eax

; 3154 : 	}

  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
?SetAdvise@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAUIAdviseSink@@@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::SetAdvise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?Unfreeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?Unfreeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::Unfreeze, COMDAT

; 3143 : 		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3144 : 	}

  00005	c2 08 00	 ret	 8
?Unfreeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::Unfreeze
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?Freeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?Freeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAK@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::Freeze, COMDAT

; 3139 : 		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3140 : 	}

  00005	c2 14 00	 ret	 20			; 00000014H
?Freeze@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAK@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::Freeze
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetColorSet@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@PAPAUtagLOGPALETTE@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
___formal$ = 32						; size = 4
?GetColorSet@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@PAPAUtagLOGPALETTE@@@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetColorSet, COMDAT

; 3131 : 		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3132 : 	}

  00005	c2 1c 00	 ret	 28			; 0000001cH
?GetColorSet@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@PAPAUtagLOGPALETTE@@@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::GetColorSet
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?Draw@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3P6GHK@ZK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwDrawAspect$ = 12					; size = 4
_lindex$ = 16						; size = 4
_pvAspect$ = 20						; size = 4
_ptd$ = 24						; size = 4
_hicTargetDev$ = 28					; size = 4
_hdcDraw$ = 32						; size = 4
_prcBounds$ = 36					; size = 4
_prcWBounds$ = 40					; size = 4
___formal$ = 44						; size = 4
___formal$ = 48						; size = 4
?Draw@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3P6GHK@ZK@Z PROC ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::Draw, COMDAT

; 3117 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3118 : 		T* pT = static_cast<T*>(this);
; 3119 : 		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::Draw\n"));
; 3120 : 		return pT->IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,

  00003	ff 75 28	 push	 DWORD PTR _prcWBounds$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	ff 75 24	 push	 DWORD PTR _prcBounds$[ebp]
  0000e	ff 75 20	 push	 DWORD PTR _hdcDraw$[ebp]
  00011	8d 48 84	 lea	 ecx, DWORD PTR [eax-124]
  00014	ff 75 1c	 push	 DWORD PTR _hicTargetDev$[ebp]
  00017	ff 75 18	 push	 DWORD PTR _ptd$[ebp]
  0001a	ff 75 14	 push	 DWORD PTR _pvAspect$[ebp]
  0001d	ff 75 10	 push	 DWORD PTR _lindex$[ebp]
  00020	ff 75 0c	 push	 DWORD PTR _dwDrawAspect$[ebp]
  00023	6a 04		 push	 4
  00025	5a		 pop	 edx
  00026	0f 44 ca	 cmove	 ecx, edx
  00029	e8 00 00 00 00	 call	 ?IViewObject_Draw@CComControlBase@ATL@@QAEJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3@Z ; ATL::CComControlBase::IViewObject_Draw

; 3121 : 			prcBounds, prcWBounds);
; 3122 : 	}

  0002e	5d		 pop	 ebp
  0002f	c2 2c 00	 ret	 44			; 0000002cH
?Draw@?$IViewObjectExImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3P6GHK@ZK@Z ENDP ; ATL::IViewObjectExImpl<COPOSDeviceMonitor>::Draw
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?EnableModeless@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?EnableModeless@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z PROC ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::EnableModeless, COMDAT

; 3462 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::EnableModeless\n"));
; 3463 : 		return S_OK;

  00000	33 c0		 xor	 eax, eax

; 3464 : 	}

  00002	c2 08 00	 ret	 8
?EnableModeless@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ENDP ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::EnableModeless
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?ResizeBorder@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@PAUIOleInPlaceUIWindow@@H@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?ResizeBorder@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@PAUIOleInPlaceUIWindow@@H@Z PROC ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::ResizeBorder, COMDAT

; 3457 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n"));
; 3458 : 		return S_OK;

  00000	33 c0		 xor	 eax, eax

; 3459 : 	}

  00002	c2 10 00	 ret	 16			; 00000010H
?ResizeBorder@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPBUtagRECT@@PAUIOleInPlaceUIWindow@@H@Z ENDP ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::ResizeBorder
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnDocWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_fActivate$ = 12					; size = 4
?OnDocWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z PROC ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::OnDocWindowActivate, COMDAT

; 3445 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3446 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n"));
; 3447 : 		T* pT = static_cast<T*>(this);
; 3448 : 		if (fActivate == FALSE)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _fActivate$[ebp], 0
  00007	75 13		 jne	 SHORT $LN2@OnDocWindo

; 3449 : 			pT->IOleInPlaceObject_UIDeactivate();

  00009	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	6a 04		 push	 4
  00010	5a		 pop	 edx
  00011	8d 48 88	 lea	 ecx, DWORD PTR [eax-120]
  00014	0f 44 ca	 cmove	 ecx, edx
  00017	e8 00 00 00 00	 call	 ?IOleInPlaceObject_UIDeactivate@CComControlBase@ATL@@QAEJXZ ; ATL::CComControlBase::IOleInPlaceObject_UIDeactivate
$LN2@OnDocWindo:

; 3450 : 		return S_OK;

  0001c	33 c0		 xor	 eax, eax

; 3451 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?OnDocWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ENDP ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::OnDocWindowActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnFrameWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?OnFrameWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z PROC ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::OnFrameWindowActivate, COMDAT

; 3441 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n"));
; 3442 : 		return S_OK;

  00000	33 c0		 xor	 eax, eax

; 3443 : 	}

  00002	c2 08 00	 ret	 8
?OnFrameWindowActivate@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ENDP ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::OnFrameWindowActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?TranslateAcceleratorW@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z
_TEXT	SEGMENT
_msg$ = -32						; size = 28
_spCtlSite$ = -4					; size = 4
_this$ = 8						; size = 4
_pMsg$ = 12						; size = 4
?TranslateAcceleratorW@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z PROC ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::TranslateAcceleratorW, COMDAT

; 3409 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 3410 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n"));
; 3411 : 		T* pT = static_cast<T*>(this);
; 3412 : 		HRESULT hRet = S_OK;
; 3413 : 		MSG msg = *pMsg;

  00008	8b 75 0c	 mov	 esi, DWORD PTR _pMsg$[ebp]
  0000b	57		 push	 edi
  0000c	6a 07		 push	 7
  0000e	59		 pop	 ecx
  0000f	8d 7d e0	 lea	 edi, DWORD PTR _msg$[ebp]
  00012	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]

; 165  :         p = NULL;

  00017	33 f6		 xor	 esi, esi

; 223  :         return p == pT;

  00019	85 c9		 test	 ecx, ecx

; 165  :         p = NULL;

  0001b	8b c6		 mov	 eax, esi

; 223  :         return p == pT;

  0001d	6a 14		 push	 20			; 00000014H
  0001f	5f		 pop	 edi
  00020	8d 51 98	 lea	 edx, DWORD PTR [ecx-104]

; 165  :         p = NULL;

  00023	89 45 fc	 mov	 DWORD PTR _spCtlSite$[ebp], eax

; 223  :         return p == pT;

  00026	0f 44 d7	 cmove	 edx, edi
  00029	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0002b	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 663  : 		if (m_spClientSite == NULL)

  0002d	75 07		 jne	 SHORT $LN18@TranslateA

; 3414 : 		if (pT->PreTranslateAccelerator(&msg, hRet))
; 3415 : 		{
; 3416 : 			return hRet;
; 3417 : 		}
; 3418 : 
; 3419 : 		CComPtr<IOleControlSite> spCtlSite;
; 3420 : 		hRet = pT->InternalGetSite(__uuidof(IOleControlSite), (void**)&spCtlSite);

  0002f	b9 05 40 00 80	 mov	 ecx, -2147467259	; 80004005H

; 666  : 			return E_FAIL;

  00034	eb 5e		 jmp	 SHORT $LN5@TranslateA
$LN18@TranslateA:

; 667  : 		}
; 668  : 		return m_spClientSite->QueryInterface(riid, ppUnkSite);

  00036	8b 01		 mov	 eax, DWORD PTR [ecx]
  00038	8d 55 fc	 lea	 edx, DWORD PTR _spCtlSite$[ebp]
  0003b	52		 push	 edx
  0003c	68 00 00 00 00	 push	 OFFSET __GUID_b196b289_bab4_101a_b69c_00aa00341d07
  00041	51		 push	 ecx
  00042	ff 10		 call	 DWORD PTR [eax]
  00044	8b c8		 mov	 ecx, eax

; 3421 : 		if (SUCCEEDED(hRet))

  00046	8b 45 fc	 mov	 eax, DWORD PTR _spCtlSite$[ebp]
  00049	85 c9		 test	 ecx, ecx
  0004b	78 47		 js	 SHORT $LN5@TranslateA
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  0004d	85 c0		 test	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 3423 : 			if (spCtlSite != NULL)

  0004f	74 40		 je	 SHORT $LN4@TranslateA

; 3424 : 			{
; 3425 : 				DWORD dwKeyMod = 0;
; 3426 : 				if (::GetKeyState(VK_SHIFT) < 0)

  00051	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetKeyState@4
  00057	6a 10		 push	 16			; 00000010H
  00059	ff d7		 call	 edi
  0005b	33 c9		 xor	 ecx, ecx
  0005d	41		 inc	 ecx
  0005e	66 85 c0	 test	 ax, ax

; 3427 : 					dwKeyMod += 1;	// KEYMOD_SHIFT
; 3428 : 				if (::GetKeyState(VK_CONTROL) < 0)

  00061	6a 11		 push	 17			; 00000011H
  00063	0f 48 f1	 cmovs	 esi, ecx
  00066	ff d7		 call	 edi
  00068	66 85 c0	 test	 ax, ax
  0006b	79 03		 jns	 SHORT $LN7@TranslateA

; 3429 : 					dwKeyMod += 2;	// KEYMOD_CONTROL

  0006d	83 c6 02	 add	 esi, 2
$LN7@TranslateA:

; 3430 : 				if (::GetKeyState(VK_MENU) < 0)

  00070	6a 12		 push	 18			; 00000012H
  00072	ff d7		 call	 edi
  00074	66 85 c0	 test	 ax, ax
  00077	79 03		 jns	 SHORT $LN8@TranslateA

; 3431 : 					dwKeyMod += 4;	// KEYMOD_ALT

  00079	83 c6 04	 add	 esi, 4
$LN8@TranslateA:

; 3432 : 				hRet = spCtlSite->TranslateAccelerator(&msg, dwKeyMod);

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _spCtlSite$[ebp]
  0007f	8d 55 e0	 lea	 edx, DWORD PTR _msg$[ebp]
  00082	56		 push	 esi
  00083	52		 push	 edx
  00084	50		 push	 eax
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	ff 51 1c	 call	 DWORD PTR [ecx+28]
  0008a	8b c8		 mov	 ecx, eax

; 3433 : 			}

  0008c	8b 45 fc	 mov	 eax, DWORD PTR _spCtlSite$[ebp]
  0008f	eb 03		 jmp	 SHORT $LN5@TranslateA
$LN4@TranslateA:

; 3434 : 			else
; 3435 : 				hRet = S_FALSE;

  00091	33 c9		 xor	 ecx, ecx
  00093	41		 inc	 ecx
$LN5@TranslateA:

; 3437 : 		return (hRet == S_OK) ? S_OK : S_FALSE;

  00094	33 db		 xor	 ebx, ebx
  00096	85 c9		 test	 ecx, ecx
  00098	0f 95 c3	 setne	 bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0009b	85 c0		 test	 eax, eax
  0009d	74 06		 je	 SHORT $LN29@TranslateA

; 184  :             p->Release();

  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	50		 push	 eax
  000a2	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN29@TranslateA:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 3437 : 		return (hRet == S_OK) ? S_OK : S_FALSE;

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	8b c3		 mov	 eax, ebx
  000a9	5b		 pop	 ebx

; 3438 : 	}

  000aa	c9		 leave
  000ab	c2 08 00	 ret	 8
?TranslateAcceleratorW@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z ENDP ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::TranslateAcceleratorW
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?ContextSensitiveHelp@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?ContextSensitiveHelp@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z PROC ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::ContextSensitiveHelp, COMDAT

; 3403 : 		ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 3404 : 	}

  00005	c2 08 00	 ret	 8
?ContextSensitiveHelp@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJH@Z ENDP ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::ContextSensitiveHelp
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetWindow@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_phwnd$ = 12						; size = 4
?GetWindow@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z PROC ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::GetWindow, COMDAT

; 3386 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3387 : 		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::GetWindow\n"));
; 3388 : 		T* pT = static_cast<T*>(this);
; 3389 : 		HRESULT hRes = E_POINTER;
; 3390 : 
; 3391 : 		if (pT->m_bWasOnceWindowless)

  00003	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	56		 push	 esi
  00009	6a 48		 push	 72			; 00000048H
  0000b	59		 pop	 ecx
  0000c	8d 42 cc	 lea	 eax, DWORD PTR [edx-52]
  0000f	be 03 40 00 80	 mov	 esi, -2147467261	; 80004003H
  00014	0f 44 c1	 cmove	 eax, ecx
  00017	f7 00 00 01 00
	00		 test	 DWORD PTR [eax], 256	; 00000100H
  0001d	74 05		 je	 SHORT $LN2@GetWindow

; 3392 : 			return E_FAIL;

  0001f	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  00022	eb 24		 jmp	 SHORT $LN1@GetWindow
$LN2@GetWindow:

; 3393 : 
; 3394 : 		if (phwnd != NULL)

  00024	8b 45 0c	 mov	 eax, DWORD PTR _phwnd$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	74 1b		 je	 SHORT $LN3@GetWindow

; 3395 : 		{
; 3396 : 			*phwnd = pT->m_hWnd;

  0002b	6a 50		 push	 80			; 00000050H
  0002d	85 d2		 test	 edx, edx
  0002f	8d 4a d4	 lea	 ecx, DWORD PTR [edx-44]
  00032	5e		 pop	 esi
  00033	0f 44 ce	 cmove	 ecx, esi

; 3397 : 			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;

  00036	33 f6		 xor	 esi, esi
  00038	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003a	85 c9		 test	 ecx, ecx
  0003c	89 08		 mov	 DWORD PTR [eax], ecx
  0003e	b8 ff ff 00 80	 mov	 eax, -2147418113	; 8000ffffH
  00043	0f 44 f0	 cmove	 esi, eax
$LN3@GetWindow:

; 3398 : 		}
; 3399 : 		return hRes;

  00046	8b c6		 mov	 eax, esi
$LN1@GetWindow:
  00048	5e		 pop	 esi

; 3400 : 	}

  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
?GetWindow@?$IOleInPlaceActiveObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUHWND__@@@Z ENDP ; ATL::IOleInPlaceActiveObjectImpl<COPOSDeviceMonitor>::GetWindow
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetColorScheme@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagLOGPALETTE@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?SetColorScheme@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagLOGPALETTE@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetColorScheme, COMDAT

; 2507 : 		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2508 : 	}

  00005	c2 08 00	 ret	 8
?SetColorScheme@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagLOGPALETTE@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetColorScheme
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetMiscStatus@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwAspect$ = 12						; size = 4
_pdwStatus$ = 16					; size = 4
?GetMiscStatus@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAK@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetMiscStatus, COMDAT

; 2501 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2502 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetMiscStatus\n"));
; 2503 : 		return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus);

  00003	ff 75 10	 push	 DWORD PTR _pdwStatus$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _dwAspect$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET _CLSID_OPOSDeviceMonitor
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleRegGetMiscStatus@12

; 2504 : 	}

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
?GetMiscStatus@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAK@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetMiscStatus
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?EnumAdvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ppenumAdvise$ = 12					; size = 4
?EnumAdvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::EnumAdvise, COMDAT

; 2485 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2486 : 		T* pT = static_cast<T*>(this);
; 2487 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::EnumAdvise\n"));
; 2488 : 		ATLASSERT(ppenumAdvise != NULL);
; 2489 : 		if (ppenumAdvise == NULL)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _ppenumAdvise$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	75 07		 jne	 SHORT $LN2@EnumAdvise

; 2490 : 			return E_POINTER;

  0000a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000f	eb 2b		 jmp	 SHORT $LN1@EnumAdvise
$LN2@EnumAdvise:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00011	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2491 : 		*ppenumAdvise = NULL;

  00014	83 22 00	 and	 DWORD PTR [edx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00017	85 c0		 test	 eax, eax
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	6a 10		 push	 16			; 00000010H
  0001d	8d 48 98	 lea	 ecx, DWORD PTR [eax-104]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2492 : 		HRESULT hRes = E_FAIL;

  00020	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00025	5f		 pop	 edi
  00026	0f 44 cf	 cmove	 ecx, edi
  00029	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0002b	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2493 : 		if (pT->m_spOleAdviseHolder != NULL)

  0002d	74 09		 je	 SHORT $LN3@EnumAdvise

; 2494 : 			hRes = pT->m_spOleAdviseHolder->EnumAdvise(ppenumAdvise);

  0002f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00031	52		 push	 edx
  00032	51		 push	 ecx
  00033	ff 50 14	 call	 DWORD PTR [eax+20]
  00036	8b f0		 mov	 esi, eax
$LN3@EnumAdvise:

; 2495 : 
; 2496 : 		return hRes;

  00038	5f		 pop	 edi
  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi
$LN1@EnumAdvise:

; 2497 : 	}

  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
?EnumAdvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumSTATDATA@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::EnumAdvise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?Unadvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwConnection$ = 12					; size = 4
?Unadvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Unadvise, COMDAT

; 2476 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2479 : 		HRESULT hRes = E_FAIL;

  00006	ba 05 40 00 80	 mov	 edx, -2147467259	; 80004005H
  0000b	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  0000c	6a 10		 push	 16			; 00000010H
  0000e	85 c0		 test	 eax, eax
  00010	5e		 pop	 esi
  00011	8d 48 98	 lea	 ecx, DWORD PTR [eax-104]
  00014	0f 44 ce	 cmove	 ecx, esi
  00017	5e		 pop	 esi
  00018	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001a	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2480 : 		if (pT->m_spOleAdviseHolder != NULL)

  0001c	74 0b		 je	 SHORT $LN2@Unadvise

; 2481 : 			hRes = pT->m_spOleAdviseHolder->Unadvise(dwConnection);

  0001e	ff 75 0c	 push	 DWORD PTR _dwConnection$[ebp]
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	51		 push	 ecx
  00024	ff 50 10	 call	 DWORD PTR [eax+16]
  00027	8b d0		 mov	 edx, eax
$LN2@Unadvise:

; 2482 : 		return hRes;

  00029	8b c2		 mov	 eax, edx

; 2483 : 	}

  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
?Unadvise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Unadvise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?Advise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIAdviseSink@@PAK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pAdvSink$ = 12						; size = 4
_pdwConnection$ = 16					; size = 4
?Advise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIAdviseSink@@PAK@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Advise, COMDAT

; 2470 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2471 : 		T* pT = static_cast<T*>(this);
; 2472 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::Advise\n"));
; 2473 : 		return pT->IOleObject_Advise(pAdvSink, pdwConnection);

  00003	ff 75 10	 push	 DWORD PTR _pdwConnection$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	ff 75 0c	 push	 DWORD PTR _pAdvSink$[ebp]
  0000e	6a 04		 push	 4
  00010	8d 48 8c	 lea	 ecx, DWORD PTR [eax-116]
  00013	5a		 pop	 edx
  00014	0f 44 ca	 cmove	 ecx, edx
  00017	e8 00 00 00 00	 call	 ?IOleObject_Advise@CComControlBase@ATL@@QAEJPAUIAdviseSink@@PAK@Z ; ATL::CComControlBase::IOleObject_Advise

; 2474 : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
?Advise@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIAdviseSink@@PAK@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Advise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwDrawAspect$ = 12					; size = 4
_psizel$ = 16						; size = 4
?GetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetExtent, COMDAT

; 2457 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2458 : 		T* pT = static_cast<T*>(this);
; 2459 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetExtent\n"));
; 2460 : 		if (dwDrawAspect != DVASPECT_CONTENT)

  00003	83 7d 0c 01	 cmp	 DWORD PTR _dwDrawAspect$[ebp], 1
  00007	74 07		 je	 SHORT $LN2@GetExtent

; 2461 : 			return E_FAIL;

  00009	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0000e	eb 2a		 jmp	 SHORT $LN1@GetExtent
$LN2@GetExtent:

; 2462 : 		if (psizel == NULL)

  00010	8b 55 10	 mov	 edx, DWORD PTR _psizel$[ebp]
  00013	85 d2		 test	 edx, edx
  00015	75 07		 jne	 SHORT $LN3@GetExtent

; 2463 : 			return E_POINTER;

  00017	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0001c	eb 1c		 jmp	 SHORT $LN1@GetExtent
$LN3@GetExtent:

; 2464 : 		*psizel = pT->m_sizeExtent;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00021	85 c0		 test	 eax, eax
  00023	56		 push	 esi
  00024	6a 28		 push	 40			; 00000028H
  00026	5e		 pop	 esi
  00027	8d 48 b0	 lea	 ecx, DWORD PTR [eax-80]
  0002a	0f 44 ce	 cmove	 ecx, esi

; 2465 : 		return S_OK;

  0002d	5e		 pop	 esi
  0002e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00030	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00033	89 02		 mov	 DWORD PTR [edx], eax
  00035	33 c0		 xor	 eax, eax
  00037	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
$LN1@GetExtent:

; 2466 : 	}

  0003a	5d		 pop	 ebp
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?GetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetExtent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwDrawAspect$ = 12					; size = 4
_psizel$ = 16						; size = 4
?SetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetExtent, COMDAT

; 2449 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2450 : 		T* pT = static_cast<T*>(this);
; 2451 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::SetExtent\n"));
; 2452 : 		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);

  00003	ff 75 10	 push	 DWORD PTR _psizel$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	ff 75 0c	 push	 DWORD PTR _dwDrawAspect$[ebp]
  0000e	6a 04		 push	 4
  00010	8d 48 8c	 lea	 ecx, DWORD PTR [eax-116]
  00013	5a		 pop	 edx
  00014	0f 44 ca	 cmove	 ecx, edx
  00017	e8 00 00 00 00	 call	 ?IOleObject_SetExtent@CComControlBase@ATL@@QAEJKPAUtagSIZE@@@Z ; ATL::CComControlBase::IOleObject_SetExtent

; 2453 : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
?SetExtent@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUtagSIZE@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetExtent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetUserType@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPA_W@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwFormOfType$ = 12					; size = 4
_pszUserType$ = 16					; size = 4
?GetUserType@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPA_W@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetUserType, COMDAT

; 2442 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2443 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetUserType\n"));
; 2444 : 		return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType);

  00003	ff 75 10	 push	 DWORD PTR _pszUserType$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _dwFormOfType$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET _CLSID_OPOSDeviceMonitor
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleRegGetUserType@12

; 2445 : 	}

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
?GetUserType@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPA_W@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetUserType
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetUserClassID@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pClsid$ = 12						; size = 4
?GetUserClassID@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetUserClassID, COMDAT

; 2431 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 2432 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetUserClassID\n"));
; 2433 : 		ATLASSERT(pClsid);
; 2434 : 		if (!pClsid)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _pClsid$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 07		 jne	 SHORT $LN2@GetUserCla

; 2435 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 0d		 jmp	 SHORT $LN1@GetUserCla
$LN2@GetUserCla:
  00012	56		 push	 esi

; 2436 : 		*pClsid = T::GetObjectCLSID();

  00013	be 00 00 00 00	 mov	 esi, OFFSET _CLSID_OPOSDeviceMonitor

; 2437 : 		return S_OK;

  00018	33 c0		 xor	 eax, eax
  0001a	a5		 movsd
  0001b	a5		 movsd
  0001c	a5		 movsd
  0001d	a5		 movsd
  0001e	5e		 pop	 esi
$LN1@GetUserCla:
  0001f	5f		 pop	 edi

; 2438 : 	}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?GetUserClassID@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetUserClassID
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IsUpToDate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?IsUpToDate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::IsUpToDate, COMDAT

; 2427 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::IsUpToDate\n"));
; 2428 : 		return S_OK;

  00000	33 c0		 xor	 eax, eax

; 2429 : 	}

  00002	c2 04 00	 ret	 4
?IsUpToDate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::IsUpToDate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?Update@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Update@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Update, COMDAT

; 2422 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::Update\n"));
; 2423 : 		return S_OK;

  00000	33 c0		 xor	 eax, eax

; 2424 : 	}

  00002	c2 04 00	 ret	 4
?Update@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Update
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?EnumVerbs@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumOLEVERB@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ppEnumOleVerb$ = 12					; size = 4
?EnumVerbs@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumOLEVERB@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::EnumVerbs, COMDAT

; 2413 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2414 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::EnumVerbs\n"));
; 2415 : 		ATLASSERT(ppEnumOleVerb);
; 2416 : 		if (!ppEnumOleVerb)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _ppEnumOleVerb$[ebp], 0
  00007	75 07		 jne	 SHORT $LN2@EnumVerbs

; 2417 : 			return E_POINTER;

  00009	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000e	eb 0e		 jmp	 SHORT $LN1@EnumVerbs
$LN2@EnumVerbs:

; 2418 : 		return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb);

  00010	ff 75 0c	 push	 DWORD PTR _ppEnumOleVerb$[ebp]
  00013	68 00 00 00 00	 push	 OFFSET _CLSID_OPOSDeviceMonitor
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleRegEnumVerbs@8
$LN1@EnumVerbs:

; 2419 : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
?EnumVerbs@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIEnumOLEVERB@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::EnumVerbs
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DoVerb@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJPAUtagMSG@@PAUIOleClientSite@@JPAUHWND__@@PBUtagRECT@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_iVerb$ = 12						; size = 4
___formal$ = 16						; size = 4
_pActiveSite$ = 20					; size = 4
___formal$ = 24						; size = 4
_hwndParent$ = 28					; size = 4
_lprcPosRect$ = 32					; size = 4
?DoVerb@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJPAUtagMSG@@PAUIOleClientSite@@JPAUHWND__@@PBUtagRECT@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerb, COMDAT

; 2363 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 2364 : 		T* pT = static_cast<T*>(this);
; 2365 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::DoVerb(%d)\n"), iVerb);
; 2366 : 		ATLASSERT(pT->m_spClientSite);
; 2367 : 
; 2368 : 		// We don't support getting a different site from the one passed into SetClientSite.
; 2369 : 			if (!pT->m_spClientSite.IsEqualObject(pActiveSite))

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	ff 75 14	 push	 DWORD PTR _pActiveSite$[ebp]
  0000a	8d 46 88	 lea	 eax, DWORD PTR [esi-120]
  0000d	f7 de		 neg	 esi
  0000f	1b f6		 sbb	 esi, esi
  00011	23 f0		 and	 esi, eax
  00013	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00016	e8 00 00 00 00	 call	 ?IsEqualObject@?$CComPtrBase@UIOleClientSite@@@ATL@@QAE_NPAUIUnknown@@@Z ; ATL::CComPtrBase<IOleClientSite>::IsEqualObject
  0001b	84 c0		 test	 al, al
  0001d	75 0a		 jne	 SHORT $LN4@DoVerb

; 2370 : 		{
; 2371 : 			return E_UNEXPECTED;

  0001f	b8 ff ff 00 80	 mov	 eax, -2147418113	; 8000ffffH
  00024	e9 a4 00 00 00	 jmp	 $LN1@DoVerb
$LN4@DoVerb:

; 2372 : 		}
; 2373 : 
; 2374 : 		HRESULT hr;
; 2375 : 		if (iVerb > 0)

  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _iVerb$[ebp]
  0002c	85 c9		 test	 ecx, ecx
  0002e	7e 18		 jle	 SHORT $LN5@DoVerb

; 2376 : 		{
; 2377 : 			pT->DoVerbPrimary(lprcPosRect, hwndParent);

  00030	ff 75 1c	 push	 DWORD PTR _hwndParent$[ebp]
  00033	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]
  00036	ff 75 20	 push	 DWORD PTR _lprcPosRect$[ebp]
  00039	e8 00 00 00 00	 call	 ?DoVerbPrimary@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbPrimary

; 2378 : 			hr = OLEOBJ_S_INVALIDVERB;

  0003e	b8 80 01 04 00	 mov	 eax, 262528		; 00040180H

; 2379 : 		}

  00043	e9 85 00 00 00	 jmp	 $LN1@DoVerb
$LN5@DoVerb:

; 2380 : 		else
; 2381 : 		{
; 2382 : 			hr = E_NOTIMPL;
; 2383 : 			switch (iVerb)

  00048	83 c1 07	 add	 ecx, 7
  0004b	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H
  00050	83 f9 07	 cmp	 ecx, 7
  00053	77 78		 ja	 SHORT $LN1@DoVerb
  00055	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN24@DoVerb[ecx*4]
$LN7@DoVerb:

; 2384 : 			{
; 2385 : 			case OLEIVERB_PRIMARY:
; 2386 : 				hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);

  0005c	ff 75 1c	 push	 DWORD PTR _hwndParent$[ebp]
  0005f	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]
  00062	ff 75 20	 push	 DWORD PTR _lprcPosRect$[ebp]
  00065	e8 00 00 00 00	 call	 ?DoVerbPrimary@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbPrimary

; 2387 : 				break;

  0006a	eb 61		 jmp	 SHORT $LN1@DoVerb
$LN8@DoVerb:

; 2277 : 			hr = pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);

  0006c	ff 75 20	 push	 DWORD PTR _lprcPosRect$[ebp]

; 2388 : 			case OLEIVERB_SHOW:
; 2389 : 				hr = pT->DoVerbShow(lprcPosRect, hwndParent);

  0006f	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]

; 2272 : 		T* pT = static_cast<T*>(this);

  00072	f7 d9		 neg	 ecx

; 2273 : 		HRESULT hr;
; 2274 : 		hr = pT->OnPreVerbShow();
; 2275 : 		if (SUCCEEDED(hr))
; 2276 : 		{
; 2277 : 			hr = pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);

  00074	6a ff		 push	 -1
  00076	1b c9		 sbb	 ecx, ecx
  00078	23 ce		 and	 ecx, esi
  0007a	83 c1 04	 add	 ecx, 4
  0007d	e8 00 00 00 00	 call	 ?InPlaceActivate@CComControlBase@ATL@@QAEJJPBUtagRECT@@@Z ; ATL::CComControlBase::InPlaceActivate

; 2278 : 			if (SUCCEEDED(hr))

  00082	33 c9		 xor	 ecx, ecx
  00084	85 c0		 test	 eax, eax
  00086	0f 49 c1	 cmovns	 eax, ecx

; 2390 : 				break;

  00089	eb 42		 jmp	 SHORT $LN1@DoVerb
$LN9@DoVerb:

; 2391 : 			case OLEIVERB_INPLACEACTIVATE:
; 2392 : 				hr = pT->DoVerbInPlaceActivate(lprcPosRect, hwndParent);

  0008b	ff 75 1c	 push	 DWORD PTR _hwndParent$[ebp]
  0008e	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]
  00091	ff 75 20	 push	 DWORD PTR _lprcPosRect$[ebp]
  00094	e8 00 00 00 00	 call	 ?DoVerbInPlaceActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbInPlaceActivate

; 2393 : 				break;

  00099	eb 32		 jmp	 SHORT $LN1@DoVerb
$LN10@DoVerb:

; 2394 : 			case OLEIVERB_UIACTIVATE:
; 2395 : 				hr = pT->DoVerbUIActivate(lprcPosRect, hwndParent);

  0009b	ff 75 1c	 push	 DWORD PTR _hwndParent$[ebp]
  0009e	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]
  000a1	ff 75 20	 push	 DWORD PTR _lprcPosRect$[ebp]
  000a4	e8 00 00 00 00	 call	 ?DoVerbUIActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbUIActivate

; 2396 : 				break;

  000a9	eb 22		 jmp	 SHORT $LN1@DoVerb
$LN11@DoVerb:

; 2397 : 			case OLEIVERB_HIDE:
; 2398 : 				hr = pT->DoVerbHide(lprcPosRect, hwndParent);

  000ab	ff 75 1c	 push	 DWORD PTR _hwndParent$[ebp]
  000ae	8d 4e 78	 lea	 ecx, DWORD PTR [esi+120]
  000b1	ff 75 20	 push	 DWORD PTR _lprcPosRect$[ebp]
  000b4	e8 00 00 00 00	 call	 ?DoVerbHide@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbHide

; 2399 : 				break;

  000b9	eb 12		 jmp	 SHORT $LN1@DoVerb
$LN12@DoVerb:

; 2408 : 			}
; 2409 : 		}
; 2410 : 		return hr;
; 2411 : 	}

  000bb	33 c0		 xor	 eax, eax
  000bd	eb 0e		 jmp	 SHORT $LN1@DoVerb
$LN14@DoVerb:

; 2400 : 			case OLEIVERB_OPEN:
; 2401 : 				hr = pT->DoVerbOpen(lprcPosRect, hwndParent);
; 2402 : 				break;
; 2403 : 			case OLEIVERB_DISCARDUNDOSTATE:
; 2404 : 				hr = pT->DoVerbDiscardUndo(lprcPosRect, hwndParent);
; 2405 : 				break;
; 2406 : 			case OLEIVERB_PROPERTIES:
; 2407 : 				hr = pT->DoVerbProperties(lprcPosRect, hwndParent);

  000bf	ff 75 1c	 push	 DWORD PTR _hwndParent$[ebp]
  000c2	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  000c5	ff 75 20	 push	 DWORD PTR _lprcPosRect$[ebp]
  000c8	e8 00 00 00 00	 call	 ?DoVerbProperties@CComControlBase@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::CComControlBase::DoVerbProperties
$LN1@DoVerb:
  000cd	5e		 pop	 esi

; 2408 : 			}
; 2409 : 		}
; 2410 : 		return hr;
; 2411 : 	}

  000ce	5d		 pop	 ebp
  000cf	c2 1c 00	 ret	 28			; 0000001cH
  000d2	66 90		 npad	 2
$LN24@DoVerb:
  000d4	00 00 00 00	 DD	 $LN14@DoVerb
  000d8	00 00 00 00	 DD	 $LN12@DoVerb
  000dc	00 00 00 00	 DD	 $LN9@DoVerb
  000e0	00 00 00 00	 DD	 $LN10@DoVerb
  000e4	00 00 00 00	 DD	 $LN11@DoVerb
  000e8	00 00 00 00	 DD	 $LN12@DoVerb
  000ec	00 00 00 00	 DD	 $LN8@DoVerb
  000f0	00 00 00 00	 DD	 $LN7@DoVerb
?DoVerb@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJPAUtagMSG@@PAUIOleClientSite@@JPAUHWND__@@PBUtagRECT@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerb
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DoVerbHide@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?DoVerbHide@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbHide, COMDAT
; _this$ = ecx

; 2321 : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2322 : 		T* pT = static_cast<T*>(this);
; 2323 : 		HRESULT hr;
; 2324 : 		hr = pT->OnPreVerbHide();
; 2325 : 		if (SUCCEEDED(hr))
; 2326 : 		{
; 2327 : 			pT->UIDeactivate();

  00003	b8 84 00 00 00	 mov	 eax, 132		; 00000084H
  00008	85 f6		 test	 esi, esi
  0000a	8d 56 0c	 lea	 edx, DWORD PTR [esi+12]
  0000d	0f 44 d0	 cmove	 edx, eax
  00010	52		 push	 edx
  00011	8b 02		 mov	 eax, DWORD PTR [edx]
  00013	ff 50 18	 call	 DWORD PTR [eax+24]

; 2328 : 			if (pT->m_hWnd)

  00016	6a 50		 push	 80			; 00000050H
  00018	85 f6		 test	 esi, esi
  0001a	8d 46 d8	 lea	 eax, DWORD PTR [esi-40]
  0001d	59		 pop	 ecx
  0001e	0f 44 c1	 cmove	 eax, ecx
  00021	5e		 pop	 esi
  00022	83 38 00	 cmp	 DWORD PTR [eax], 0
  00025	74 0a		 je	 SHORT $LN3@DoVerbHide
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 1289 : 		return ::ShowWindow(m_hWnd, nCmdShow);

  00027	6a 00		 push	 0
  00029	ff 30		 push	 DWORD PTR [eax]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN3@DoVerbHide:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2332 : 		return hr;

  00031	33 c0		 xor	 eax, eax

; 2333 : 	}

  00033	c2 08 00	 ret	 8
?DoVerbHide@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbHide
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DoVerbUIActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z
_TEXT	SEGMENT
_prcPosRect$ = 8					; size = 4
___formal$ = 12						; size = 4
?DoVerbUIActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbUIActivate, COMDAT
; _this$ = ecx

; 2303 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2304 : 		T* pT = static_cast<T*>(this);
; 2305 : 		HRESULT hr = S_OK;

  00006	33 d2		 xor	 edx, edx

; 2306 : 		if (!pT->m_bUIActive)

  00008	6a 48		 push	 72			; 00000048H
  0000a	85 f6		 test	 esi, esi
  0000c	59		 pop	 ecx
  0000d	8d 46 d0	 lea	 eax, DWORD PTR [esi-48]
  00010	0f 44 c1	 cmove	 eax, ecx
  00013	f6 00 08	 test	 BYTE PTR [eax], 8
  00016	75 1e		 jne	 SHORT $LN4@DoVerbUIAc

; 2307 : 		{
; 2308 : 			hr = pT->OnPreVerbUIActivate();
; 2309 : 			if (SUCCEEDED(hr))
; 2310 : 			{
; 2311 : 				hr = pT->InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect);

  00018	ff 75 08	 push	 DWORD PTR _prcPosRect$[ebp]
  0001b	85 f6		 test	 esi, esi
  0001d	8d 4e 8c	 lea	 ecx, DWORD PTR [esi-116]
  00020	6a fc		 push	 -4			; fffffffcH
  00022	6a 04		 push	 4
  00024	58		 pop	 eax
  00025	0f 44 c8	 cmove	 ecx, eax
  00028	e8 00 00 00 00	 call	 ?InPlaceActivate@CComControlBase@ATL@@QAEJJPBUtagRECT@@@Z ; ATL::CComControlBase::InPlaceActivate
  0002d	8b d0		 mov	 edx, eax

; 2312 : 				if (SUCCEEDED(hr))

  0002f	33 c0		 xor	 eax, eax
  00031	85 d2		 test	 edx, edx
  00033	0f 49 d0	 cmovns	 edx, eax
$LN4@DoVerbUIAc:

; 2313 : 					hr = pT->OnPostVerbUIActivate();
; 2314 : 			}
; 2315 : 		}
; 2316 : 		return hr;

  00036	8b c2		 mov	 eax, edx
  00038	5e		 pop	 esi

; 2317 : 	}

  00039	5d		 pop	 ebp
  0003a	c2 08 00	 ret	 8
?DoVerbUIActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbUIActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DoVerbInPlaceActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z
_TEXT	SEGMENT
_prcPosRect$ = 8					; size = 4
___formal$ = 12						; size = 4
?DoVerbInPlaceActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbInPlaceActivate, COMDAT
; _this$ = ecx

; 2286 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 2287 : 		T* pT = static_cast<T*>(this);
; 2288 : 		HRESULT hr;
; 2289 : 		hr = pT->OnPreVerbInPlaceActivate();
; 2290 : 		if (SUCCEEDED(hr))
; 2291 : 		{
; 2292 : 			hr = pT->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);

  00005	6a 04		 push	 4
  00007	58		 pop	 eax
  00008	ff 75 08	 push	 DWORD PTR _prcPosRect$[ebp]
  0000b	85 c9		 test	 ecx, ecx
  0000d	8d 79 8c	 lea	 edi, DWORD PTR [ecx-116]
  00010	6a fb		 push	 -5			; fffffffbH
  00012	0f 44 f8	 cmove	 edi, eax
  00015	8b cf		 mov	 ecx, edi
  00017	e8 00 00 00 00	 call	 ?InPlaceActivate@CComControlBase@ATL@@QAEJJPBUtagRECT@@@Z ; ATL::CComControlBase::InPlaceActivate
  0001c	8b f0		 mov	 esi, eax

; 2293 : 			if (SUCCEEDED(hr))

  0001e	85 f6		 test	 esi, esi
  00020	78 09		 js	 SHORT $LN4@DoVerbInPl

; 2294 : 				hr = pT->OnPostVerbInPlaceActivate();
; 2295 : 			if (SUCCEEDED(hr))
; 2296 : 				pT->FireViewChange();

  00022	8b cf		 mov	 ecx, edi
  00024	33 f6		 xor	 esi, esi
  00026	e8 00 00 00 00	 call	 ?FireViewChange@CComControlBase@ATL@@QAEJXZ ; ATL::CComControlBase::FireViewChange
$LN4@DoVerbInPl:

; 2297 : 		}
; 2298 : 		return hr;

  0002b	5f		 pop	 edi
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi

; 2299 : 	}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?DoVerbInPlaceActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbInPlaceActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DoVerbPrimary@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z
_TEXT	SEGMENT
_var$ = -16						; size = 16
_prcPosRect$ = 8					; size = 4
_hwndParent$ = 12					; size = 4
?DoVerbPrimary@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbPrimary, COMDAT
; _this$ = ecx

; 2255 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  00006	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2255 : 	{

  00008	56		 push	 esi
  00009	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  0000a	8d 7d f0	 lea	 edi, DWORD PTR _var$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2255 : 	{

  0000d	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  0000f	ab		 stosd
  00010	ab		 stosd
  00011	ab		 stosd
  00012	ab		 stosd

; 2161 :         ::VariantInit(this);

  00013	8d 45 f0	 lea	 eax, DWORD PTR _var$[ebp]
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2261 : 		HRESULT hRes = pT->GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);

  0001d	6a 04		 push	 4
  0001f	85 f6		 test	 esi, esi
  00021	8d 7e 8c	 lea	 edi, DWORD PTR [esi-116]
  00024	58		 pop	 eax
  00025	0f 44 f8	 cmove	 edi, eax

; 328  : 		if (m_spAmbientDispatch.p != NULL)

  00028	83 7f 18 00	 cmp	 DWORD PTR [edi+24], 0
  0002c	74 35		 je	 SHORT $LN3@DoVerbPrim
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 429  :         return GetProperty(this->p, dwDispID, pVar);

  0002e	8d 45 f0	 lea	 eax, DWORD PTR _var$[ebp]
  00031	50		 push	 eax
  00032	68 3b fd ff ff	 push	 -709			; fffffd3bH
  00037	ff 77 18	 push	 DWORD PTR [edi+24]
  0003a	e8 00 00 00 00	 call	 ?GetProperty@?$CComPtr@UIDispatch@@@ATL@@SAJPAUIDispatch@@JPAUtagVARIANT@@@Z ; ATL::CComPtr<IDispatch>::GetProperty
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2262 : 		if (SUCCEEDED(hRes) && var.vt == VT_BOOL && !var.boolVal)

  00042	85 c0		 test	 eax, eax
  00044	78 1d		 js	 SHORT $LN3@DoVerbPrim
  00046	66 83 7d f0 0b	 cmp	 WORD PTR _var$[ebp], 11	; 0000000bH
  0004b	75 16		 jne	 SHORT $LN3@DoVerbPrim
  0004d	66 83 7d f8 00	 cmp	 WORD PTR _var$[ebp+8], 0
  00052	75 0f		 jne	 SHORT $LN3@DoVerbPrim

; 2263 : 			bDesignMode = TRUE;
; 2264 : 		if (bDesignMode)
; 2265 : 			return pT->DoVerbProperties(prcPosRect, hwndParent);

  00054	ff 75 0c	 push	 DWORD PTR _hwndParent$[ebp]
  00057	8b cf		 mov	 ecx, edi
  00059	ff 75 08	 push	 DWORD PTR _prcPosRect$[ebp]
  0005c	e8 00 00 00 00	 call	 ?DoVerbProperties@CComControlBase@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::CComControlBase::DoVerbProperties
  00061	eb 15		 jmp	 SHORT $LN23@DoVerbPrim
$LN3@DoVerbPrim:

; 2266 : 		return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);

  00063	ff 75 0c	 push	 DWORD PTR _hwndParent$[ebp]
  00066	85 f6		 test	 esi, esi
  00068	ff 75 08	 push	 DWORD PTR _prcPosRect$[ebp]
  0006b	6a 78		 push	 120			; 00000078H
  0006d	58		 pop	 eax
  0006e	0f 44 f0	 cmove	 esi, eax
  00071	8b ce		 mov	 ecx, esi
  00073	e8 00 00 00 00	 call	 ?DoVerbInPlaceActivate@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbInPlaceActivate
$LN23@DoVerbPrim:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2865 :         return ::VariantClear(this);

  00078	8b f0		 mov	 esi, eax
  0007a	8d 45 f0	 lea	 eax, DWORD PTR _var$[ebp]
  0007d	50		 push	 eax
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 2266 : 		return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);

  00084	5f		 pop	 edi
  00085	8b c6		 mov	 eax, esi
  00087	5e		 pop	 esi

; 2267 : 	}

  00088	c9		 leave
  00089	c2 08 00	 ret	 8
?DoVerbPrimary@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::DoVerbPrimary
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetClipboardData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIDataObject@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?GetClipboardData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIDataObject@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetClipboardData, COMDAT

; 2248 : 		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2249 : 	}

  00005	c2 0c 00	 ret	 12			; 0000000cH
?GetClipboardData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAPAUIDataObject@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetClipboardData
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?InitFromData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIDataObject@@HK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?InitFromData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIDataObject@@HK@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::InitFromData, COMDAT

; 2242 : 		ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2243 : 	}

  00005	c2 10 00	 ret	 16			; 00000010H
?InitFromData@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIDataObject@@HK@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::InitFromData
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAPAUIMoniker@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?GetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAPAUIMoniker@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetMoniker, COMDAT

; 2235 : 		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2236 : 	}

  00005	c2 10 00	 ret	 16			; 00000010H
?GetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKKPAPAUIMoniker@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetMoniker
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUIMoniker@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?SetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUIMoniker@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetMoniker, COMDAT

; 2228 : 		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2229 : 	}

  00005	c2 0c 00	 ret	 12			; 0000000cH
?SetMoniker@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJKPAUIMoniker@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetMoniker
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?Close@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwSaveOption$ = 12					; size = 4
?Close@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Close, COMDAT

; 2219 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2220 : 		T* pT = static_cast<T*>(this);
; 2221 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::Close\n"));
; 2222 : 		return pT->IOleObject_Close(dwSaveOption);

  00003	ff 75 0c	 push	 DWORD PTR _dwSaveOption$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	6a 04		 push	 4
  0000d	5a		 pop	 edx
  0000e	8d 48 8c	 lea	 ecx, DWORD PTR [eax-116]
  00011	0f 44 ca	 cmove	 ecx, edx
  00014	e8 00 00 00 00	 call	 ?IOleObject_Close@CComControlBase@ATL@@QAEJK@Z ; ATL::CComControlBase::IOleObject_Close

; 2223 : 	}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?Close@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJK@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::Close
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetHostNames@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPB_W0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?SetHostNames@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPB_W0@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetHostNames, COMDAT

; 2215 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::SetHostNames\n"));
; 2216 : 		return S_OK;

  00000	33 c0		 xor	 eax, eax

; 2217 : 	}

  00002	c2 0c 00	 ret	 12			; 0000000cH
?SetHostNames@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPB_W0@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetHostNames
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIOleClientSite@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ppClientSite$ = 12					; size = 4
?GetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIOleClientSite@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetClientSite, COMDAT

; 2206 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2207 : 		T* pT = static_cast<T*>(this);
; 2208 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetClientSite\n"));
; 2209 : 		return pT->IOleObject_GetClientSite(ppClientSite);

  00003	ff 75 0c	 push	 DWORD PTR _ppClientSite$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	6a 04		 push	 4
  0000d	5a		 pop	 edx
  0000e	8d 48 8c	 lea	 ecx, DWORD PTR [eax-116]
  00011	0f 44 ca	 cmove	 ecx, edx
  00014	e8 00 00 00 00	 call	 ?IOleObject_GetClientSite@CComControlBase@ATL@@QAEJPAPAUIOleClientSite@@@Z ; ATL::CComControlBase::IOleObject_GetClientSite

; 2210 : 	}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?GetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAPAUIOleClientSite@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::GetClientSite
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIOleClientSite@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pClientSite$ = 12					; size = 4
?SetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIOleClientSite@@@Z PROC ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetClientSite, COMDAT

; 2200 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2201 : 		T* pT = static_cast<T*>(this);
; 2202 : 		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::SetClientSite\n"));
; 2203 : 		return pT->IOleObject_SetClientSite(pClientSite);

  00003	ff 75 0c	 push	 DWORD PTR _pClientSite$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00009	85 c0		 test	 eax, eax
  0000b	6a 04		 push	 4
  0000d	5a		 pop	 edx
  0000e	8d 48 8c	 lea	 ecx, DWORD PTR [eax-116]
  00011	0f 44 ca	 cmove	 ecx, edx
  00014	e8 00 00 00 00	 call	 ?IOleObject_SetClientSite@CComControlBase@ATL@@QAEJPAUIOleClientSite@@@Z ; ATL::CComControlBase::IOleObject_SetClientSite

; 2204 : 	}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?SetClientSite@?$IOleObjectImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIOleClientSite@@@Z ENDP ; ATL::IOleObjectImpl<COPOSDeviceMonitor>::SetClientSite
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnAmbientPropertyChange@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dispid$ = 12						; size = 4
?OnAmbientPropertyChange@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJ@Z PROC ; ATL::IOleControlImpl<COPOSDeviceMonitor>::OnAmbientPropertyChange, COMDAT

; 2129 : 		UNREFERENCED_PARAMETER(dispid);
; 2130 : 		ATLTRACE(atlTraceControls,2,_T("IOleControlImpl::OnAmbientPropertyChange\n"));
; 2131 : 		ATLTRACE(atlTraceControls,2,_T(" -- DISPID = %d\n"), dispid);
; 2132 : 		return S_OK;

  00000	33 c0		 xor	 eax, eax

; 2133 : 	}

  00002	c2 08 00	 ret	 8
?OnAmbientPropertyChange@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJJ@Z ENDP ; ATL::IOleControlImpl<COPOSDeviceMonitor>::OnAmbientPropertyChange
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnMnemonic@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?OnMnemonic@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z PROC ; ATL::IOleControlImpl<COPOSDeviceMonitor>::OnMnemonic, COMDAT

; 2125 : 		ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2126 : 	}

  00005	c2 08 00	 ret	 8
?OnMnemonic@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagMSG@@@Z ENDP ; ATL::IOleControlImpl<COPOSDeviceMonitor>::OnMnemonic
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetControlInfo@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCONTROLINFO@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetControlInfo@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCONTROLINFO@@@Z PROC ; ATL::IOleControlImpl<COPOSDeviceMonitor>::GetControlInfo, COMDAT

; 2121 : 		ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo"));

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 2122 : 	}

  00005	c2 08 00	 ret	 8
?GetControlInfo@?$IOleControlImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUtagCONTROLINFO@@@Z ENDP ; ATL::IOleControlImpl<COPOSDeviceMonitor>::GetControlInfo
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?IPersistStreamInit_Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@HPBUATL_PROPMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_dispparamsNoArgs$1 = -52				; size = 16
_var$2 = -36						; size = 16
_dw$3 = -20						; size = 4
_i$1$ = -16						; size = 4
_piidOld$1$ = -12					; size = 4
tv604 = -8						; size = 4
_bstrWrite$4 = -8					; size = 4
_pDispatch$5 = -4					; size = 4
_pStm$ = 8						; size = 4
_fClearDirty$ = 12					; size = 4
_pMap$ = 16						; size = 4
?IPersistStreamInit_Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@HPBUATL_PROPMAP_ENTRY@2@@Z PROC ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IPersistStreamInit_Save, COMDAT
; _this$ = ecx

; 736  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 6808 : 	if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)

  0000b	8b 7d 08	 mov	 edi, DWORD PTR _pStm$[ebp]
  0000e	8d 43 90	 lea	 eax, DWORD PTR [ebx-112]
  00011	f7 db		 neg	 ebx
  00013	1b db		 sbb	 ebx, ebx
  00015	23 d8		 and	 ebx, eax
  00017	85 ff		 test	 edi, edi
  00019	0f 84 b0 01 00
	00		 je	 $LN14@IPersistSt
  0001f	83 7d 10 00	 cmp	 DWORD PTR _pMap$[ebp], 0
  00023	0f 84 a6 01 00
	00		 je	 $LN14@IPersistSt
  00029	85 db		 test	 ebx, ebx
  0002b	0f 84 9e 01 00
	00		 je	 $LN14@IPersistSt

; 6810 : 
; 6811 : 	DWORD dw = _ATL_VER;
; 6812 : 	HRESULT hr = pStm->Write(&dw, sizeof(DWORD), NULL);

  00031	8b 07		 mov	 eax, DWORD PTR [edi]
  00033	8d 4d ec	 lea	 ecx, DWORD PTR _dw$3[ebp]
  00036	6a 00		 push	 0
  00038	6a 04		 push	 4
  0003a	51		 push	 ecx
  0003b	57		 push	 edi
  0003c	c7 45 ec 00 0e
	00 00		 mov	 DWORD PTR _dw$3[ebp], 3584 ; 00000e00H
  00043	ff 50 10	 call	 DWORD PTR [eax+16]
  00046	8b f0		 mov	 esi, eax

; 6813 : 	if (FAILED(hr))

  00048	85 f6		 test	 esi, esi
  0004a	0f 88 84 01 00
	00		 js	 $LN6@IPersistSt

; 6818 : ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
; 6819 : 	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)

  00050	8b 45 10	 mov	 eax, DWORD PTR _pMap$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00053	33 c9		 xor	 ecx, ecx
  00055	89 4d fc	 mov	 DWORD PTR _pDispatch$5[ebp], ecx
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6817 : 	const IID* piidOld = NULL;

  00058	89 4d f4	 mov	 DWORD PTR _piidOld$1$[ebp], ecx

; 6818 : ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
; 6819 : 	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)

  0005b	89 4d f0	 mov	 DWORD PTR _i$1$[ebp], ecx
  0005e	39 48 04	 cmp	 DWORD PTR [eax+4], ecx
  00061	0f 84 6d 01 00
	00		 je	 $LN6@IPersistSt
  00067	89 45 f8	 mov	 DWORD PTR tv604[ebp], eax
  0006a	8b c8		 mov	 ecx, eax
$LL9@IPersistSt:

; 6820 : ATLPREFAST_UNSUPPRESS()
; 6821 : 	{
; 6822 : 		if (pMap[i].szDesc == NULL)

  0006c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0006f	0f 84 03 01 00
	00		 je	 $LN7@IPersistSt

; 6823 : 			continue;
; 6824 : 
; 6825 : 		// check if raw data entry
; 6826 : 		if (pMap[i].dwSizeData != 0)

  00075	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00078	85 d2		 test	 edx, edx
  0007a	74 4a		 je	 SHORT $LN17@IPersistSt

; 6827 : 		{
; 6828 : 			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);

  0007c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0007f	03 cb		 add	 ecx, ebx

; 6829 : 			// call CComBSTR::WriteToStream for BSTRs
; 6830 : 			if (pMap[i].vt == VT_BSTR)

  00081	66 83 78 20 08	 cmp	 WORD PTR [eax+32], 8
  00086	75 2d		 jne	 SHORT $LN18@IPersistSt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  00088	83 65 f8 00	 and	 DWORD PTR _bstrWrite$4[ebp], 0
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6833 : 				bstrWrite.Attach(*(BSTR*)pData);

  0008c	8b 31		 mov	 esi, DWORD PTR [ecx]
  0008e	85 f6		 test	 esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 964  :         if (m_str != src)

  00090	74 0b		 je	 SHORT $LN34@IPersistSt

; 965  :         {
; 966  :             ::SysFreeString(m_str);

  00092	6a 00		 push	 0
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 967  :             m_str = src;

  0009a	89 75 f8	 mov	 DWORD PTR _bstrWrite$4[ebp], esi
$LN34@IPersistSt:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6834 : 				hr = bstrWrite.WriteToStream(pStm);

  0009d	57		 push	 edi
  0009e	8d 4d f8	 lea	 ecx, DWORD PTR _bstrWrite$4[ebp]
  000a1	e8 00 00 00 00	 call	 ?WriteToStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z ; ATL::CComBSTR::WriteToStream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 1674 :     ::SysFreeString(m_str);

  000a6	6a 00		 push	 0
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6834 : 				hr = bstrWrite.WriteToStream(pStm);

  000a8	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 1674 :     ::SysFreeString(m_str);

  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6836 : 			}

  000b0	e9 bc 00 00 00	 jmp	 $LN19@IPersistSt
$LN18@IPersistSt:

; 6837 : 			else
; 6838 : 				hr = pStm->Write(pData, pMap[i].dwSizeData, NULL);

  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	6a 00		 push	 0
  000b9	52		 push	 edx
  000ba	51		 push	 ecx
  000bb	57		 push	 edi
  000bc	ff 50 10	 call	 DWORD PTR [eax+16]
  000bf	8b f0		 mov	 esi, eax

; 6839 : 			if (FAILED(hr))
; 6840 : 				return hr;
; 6841 : 			continue;

  000c1	e9 ab 00 00 00	 jmp	 $LN19@IPersistSt
$LN17@IPersistSt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  000c6	33 c0		 xor	 eax, eax
  000c8	8d 7d dc	 lea	 edi, DWORD PTR _var$2[ebp]
  000cb	ab		 stosd
  000cc	ab		 stosd
  000cd	ab		 stosd
  000ce	ab		 stosd

; 2161 :         ::VariantInit(this);

  000cf	8d 45 dc	 lea	 eax, DWORD PTR _var$2[ebp]
  000d2	50		 push	 eax
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6845 : 		if (pMap[i].piidDispatch != piidOld)

  000d9	8b 75 f8	 mov	 esi, DWORD PTR tv604[ebp]
  000dc	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000df	3b 55 f4	 cmp	 edx, DWORD PTR _piidOld$1$[ebp]
  000e2	74 34		 je	 SHORT $LN21@IPersistSt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 229  :         T* pTemp = p;

  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _pDispatch$5[ebp]
  000e7	85 c9		 test	 ecx, ecx

; 230  :         if (pTemp)

  000e9	74 0d		 je	 SHORT $LN12@IPersistSt

; 231  :         {
; 232  :             p = NULL;

  000eb	83 65 fc 00	 and	 DWORD PTR _pDispatch$5[ebp], 0

; 233  :             pTemp->Release();

  000ef	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f1	51		 push	 ecx
  000f2	ff 50 08	 call	 DWORD PTR [eax+8]
  000f5	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
$LN12@IPersistSt:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6848 : 			ATLENSURE_RETURN(pMap[i].piidDispatch);

  000f8	85 d2		 test	 edx, edx
  000fa	0f 84 a0 00 00
	00		 je	 $LN88@IPersistSt

; 6849 : 			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))

  00100	8b 03		 mov	 eax, DWORD PTR [ebx]
  00102	8d 4d fc	 lea	 ecx, DWORD PTR _pDispatch$5[ebp]
  00105	51		 push	 ecx
  00106	52		 push	 edx
  00107	53		 push	 ebx
  00108	ff 10		 call	 DWORD PTR [eax]
  0010a	85 c0		 test	 eax, eax
  0010c	0f 88 ac 00 00
	00		 js	 $LN90@IPersistSt

; 6850 : 			{
; 6851 : 				ATLTRACE(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
; 6852 : 				hr = E_FAIL;
; 6853 : 				break;
; 6854 : 			}
; 6855 : 			piidOld = pMap[i].piidDispatch;

  00112	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00115	89 45 f4	 mov	 DWORD PTR _piidOld$1$[ebp], eax
$LN21@IPersistSt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 583  :         if (pDispatch == NULL)

  00118	8b 45 fc	 mov	 eax, DWORD PTR _pDispatch$5[ebp]
  0011b	85 c0		 test	 eax, eax
  0011d	0f 84 9b 00 00
	00		 je	 $LN90@IPersistSt

; 584  :             return E_INVALIDARG;
; 585  : 
; 586  :         ATLTRACE(atlTraceCOM, 2, _T("CPropertyHelper::GetProperty\n"));
; 587  :         DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
; 588  :         return pDispatch->Invoke(dwDispID, IID_NULL,

  00123	8b 08		 mov	 ecx, DWORD PTR [eax]
  00125	33 d2		 xor	 edx, edx
  00127	52		 push	 edx
  00128	52		 push	 edx
  00129	89 55 cc	 mov	 DWORD PTR _dispparamsNoArgs$1[ebp], edx
  0012c	89 55 d0	 mov	 DWORD PTR _dispparamsNoArgs$1[ebp+4], edx
  0012f	89 55 d4	 mov	 DWORD PTR _dispparamsNoArgs$1[ebp+8], edx
  00132	89 55 d8	 mov	 DWORD PTR _dispparamsNoArgs$1[ebp+12], edx
  00135	8d 55 dc	 lea	 edx, DWORD PTR _var$2[ebp]
  00138	52		 push	 edx
  00139	8d 55 cc	 lea	 edx, DWORD PTR _dispparamsNoArgs$1[ebp]
  0013c	52		 push	 edx
  0013d	6a 02		 push	 2
  0013f	68 00 04 00 00	 push	 1024			; 00000400H
  00144	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  00149	ff 76 14	 push	 DWORD PTR [esi+20]
  0014c	50		 push	 eax
  0014d	ff 51 18	 call	 DWORD PTR [ecx+24]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6858 : 		if (FAILED(pDispatch.GetProperty(pMap[i].dispid, &var)))

  00150	85 c0		 test	 eax, eax
  00152	78 6a		 js	 SHORT $LN90@IPersistSt

; 6859 : 		{
; 6860 : 			ATLTRACE(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
; 6861 : 			hr = E_FAIL;
; 6862 : 			break;
; 6863 : 		}
; 6864 : 
; 6865 : 		hr = var.WriteToStream(pStm, pMap[i].vt);

  00154	0f b7 46 20	 movzx	 eax, WORD PTR [esi+32]
  00158	8d 4d dc	 lea	 ecx, DWORD PTR _var$2[ebp]
  0015b	8b 7d 08	 mov	 edi, DWORD PTR _pStm$[ebp]
  0015e	50		 push	 eax
  0015f	57		 push	 edi
  00160	e8 00 00 00 00	 call	 ?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@G@Z ; ATL::CComVariant::WriteToStream
  00165	8b f0		 mov	 esi, eax

; 6866 : 		if (FAILED(hr))

  00167	8d 45 dc	 lea	 eax, DWORD PTR _var$2[ebp]
  0016a	50		 push	 eax
  0016b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN19@IPersistSt:

; 6818 : ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
; 6819 : 	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)

  00171	85 f6		 test	 esi, esi
  00173	78 1c		 js	 SHORT $LN87@IPersistSt
  00175	8b 4d 10	 mov	 ecx, DWORD PTR _pMap$[ebp]
$LN7@IPersistSt:
  00178	8b 45 f0	 mov	 eax, DWORD PTR _i$1$[ebp]
  0017b	40		 inc	 eax
  0017c	89 45 f0	 mov	 DWORD PTR _i$1$[ebp], eax
  0017f	6b c0 24	 imul	 eax, eax, 36
  00182	03 c1		 add	 eax, ecx
  00184	89 45 f8	 mov	 DWORD PTR tv604[ebp], eax
  00187	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0018b	0f 85 db fe ff
	ff		 jne	 $LL9@IPersistSt
$LN87@IPersistSt:

; 737  : 		T* pT = static_cast<T*>(this);
; 738  : 		HRESULT hr;
; 739  : 		hr = AtlIPersistStreamInit_Save(pStm, fClearDirty, pMap, pT, pT->GetUnknown());
; 740  : 		if (fClearDirty && SUCCEEDED(hr))

  00191	8b 45 fc	 mov	 eax, DWORD PTR _pDispatch$5[ebp]
  00194	85 c0		 test	 eax, eax
  00196	74 3c		 je	 SHORT $LN6@IPersistSt
  00198	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019a	50		 push	 eax
  0019b	ff 51 08	 call	 DWORD PTR [ecx+8]
  0019e	eb 34		 jmp	 SHORT $LN6@IPersistSt
$LN88@IPersistSt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2865 :         return ::VariantClear(this);

  001a0	8d 45 dc	 lea	 eax, DWORD PTR _var$2[ebp]
  001a3	50		 push	 eax
  001a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 183  :         if (p)

  001aa	8b 45 fc	 mov	 eax, DWORD PTR _pDispatch$5[ebp]
  001ad	85 c0		 test	 eax, eax
  001af	74 06		 je	 SHORT $LN57@IPersistSt

; 184  :             p->Release();

  001b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b3	50		 push	 eax
  001b4	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN57@IPersistSt:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6848 : 			ATLENSURE_RETURN(pMap[i].piidDispatch);

  001b7	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
  001bc	eb 16		 jmp	 SHORT $LN6@IPersistSt
$LN90@IPersistSt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  001be	8d 45 dc	 lea	 eax, DWORD PTR _var$2[ebp]
  001c1	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
  001c6	50		 push	 eax
  001c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6869 : 	return hr;

  001cd	eb c2		 jmp	 SHORT $LN87@IPersistSt
$LN14@IPersistSt:

; 6809 : 		return E_INVALIDARG;

  001cf	be 57 00 07 80	 mov	 esi, -2147024809	; 80070057H
$LN6@IPersistSt:

; 737  : 		T* pT = static_cast<T*>(this);
; 738  : 		HRESULT hr;
; 739  : 		hr = AtlIPersistStreamInit_Save(pStm, fClearDirty, pMap, pT, pT->GetUnknown());
; 740  : 		if (fClearDirty && SUCCEEDED(hr))

  001d4	83 7d 0c 00	 cmp	 DWORD PTR _fClearDirty$[ebp], 0
  001d8	74 0b		 je	 SHORT $LN2@IPersistSt
  001da	85 f6		 test	 esi, esi
  001dc	78 07		 js	 SHORT $LN2@IPersistSt

; 741  : 		{
; 742  : 			pT->m_bRequiresSave=FALSE;

  001de	81 63 48 7f ff
	ff ff		 and	 DWORD PTR [ebx+72], -129 ; ffffff7fH
$LN2@IPersistSt:

; 743  : 		}
; 744  : 		return hr;

  001e5	5f		 pop	 edi
  001e6	8b c6		 mov	 eax, esi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx

; 745  : 
; 746  : 	}

  001ea	c9		 leave
  001eb	c2 0c 00	 ret	 12			; 0000000cH
?IPersistStreamInit_Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@HPBUATL_PROPMAP_ENTRY@2@@Z ENDP ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IPersistStreamInit_Save
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?IPersistStreamInit_Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@PBUATL_PROPMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_dispparams$1 = -60					; size = 16
_var$2 = -44						; size = 16
_pData$1$ = -28						; size = 4
_dispidPut$3 = -28					; size = 4
_dwVer$4 = -24						; size = 4
_piidOld$1$ = -20					; size = 4
tv689 = -16						; size = 4
_dwDispID$1$ = -16					; size = 4
_bstrRead$5 = -16					; size = 4
_i$1$ = -12						; size = 4
_cbRead$6 = -8						; size = 4
_pDispatch$7 = -4					; size = 4
_pStm$ = 8						; size = 4
_pMap$ = 12						; size = 4
?IPersistStreamInit_Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@PBUATL_PROPMAP_ENTRY@2@@Z PROC ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IPersistStreamInit_Load, COMDAT
; _this$ = ecx

; 724  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 6710 : 	if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pStm$[ebp]

; 724  : 	{

  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 6710 : 	if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)

  0000e	8d 43 90	 lea	 eax, DWORD PTR [ebx-112]
  00011	f7 db		 neg	 ebx
  00013	1b db		 sbb	 ebx, ebx
  00015	23 d8		 and	 ebx, eax
  00017	85 c9		 test	 ecx, ecx
  00019	0f 84 48 02 00
	00		 je	 $LN14@IPersistSt
  0001f	8b 7d 0c	 mov	 edi, DWORD PTR _pMap$[ebp]
  00022	85 ff		 test	 edi, edi
  00024	0f 84 3d 02 00
	00		 je	 $LN14@IPersistSt
  0002a	85 db		 test	 ebx, ebx
  0002c	0f 84 35 02 00
	00		 je	 $LN14@IPersistSt

; 6713 : 	}
; 6714 : 
; 6715 : 	ULONG cbRead = 0;
; 6716 : 	DWORD dwVer;
; 6717 : 	HRESULT hr = pStm->Read(&dwVer, sizeof(DWORD), &cbRead);

  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	8d 55 f8	 lea	 edx, DWORD PTR _cbRead$6[ebp]
  00037	83 65 f8 00	 and	 DWORD PTR _cbRead$6[ebp], 0
  0003b	52		 push	 edx
  0003c	6a 04		 push	 4
  0003e	8d 55 e8	 lea	 edx, DWORD PTR _dwVer$4[ebp]
  00041	52		 push	 edx
  00042	51		 push	 ecx
  00043	ff 50 0c	 call	 DWORD PTR [eax+12]
  00046	8b f0		 mov	 esi, eax

; 6718 : 
; 6719 : 	if (FAILED(hr))

  00048	85 f6		 test	 esi, esi
  0004a	0f 88 1c 02 00
	00		 js	 $LN2@IPersistSt

; 6720 : 	{
; 6721 : 		return hr;
; 6722 : 	}
; 6723 : 	else if (sizeof(DWORD) != cbRead)

  00050	83 7d f8 04	 cmp	 DWORD PTR _cbRead$6[ebp], 4
  00054	74 0a		 je	 SHORT $LN17@IPersistSt
$LN109@IPersistSt:

; 729  : 		return hr;

  00056	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
  0005b	e9 0c 02 00 00	 jmp	 $LN2@IPersistSt
$LN17@IPersistSt:

; 6728 : 	if (dwVer > _ATL_VER)

  00060	81 7d e8 00 0e
	00 00		 cmp	 DWORD PTR _dwVer$4[ebp], 3584 ; 00000e00H
  00067	77 ed		 ja	 SHORT $LN109@IPersistSt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00069	83 65 fc 00	 and	 DWORD PTR _pDispatch$7[ebp], 0
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6734 : 	const IID* piidOld = NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	89 45 ec	 mov	 DWORD PTR _piidOld$1$[ebp], eax

; 6737 : 	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)

  00072	89 45 f4	 mov	 DWORD PTR _i$1$[ebp], eax
  00075	39 47 04	 cmp	 DWORD PTR [edi+4], eax
  00078	0f 84 dc 01 00
	00		 je	 $LN93@IPersistSt
  0007e	89 7d f0	 mov	 DWORD PTR tv689[ebp], edi
  00081	8b cf		 mov	 ecx, edi
$LL9@IPersistSt:

; 6738 : ATLPREFAST_UNSUPPRESS()
; 6739 : 	{
; 6740 : 		if (pMap[i].szDesc == NULL)

  00083	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00086	0f 84 79 01 00
	00		 je	 $LN7@IPersistSt

; 6741 : 			continue;
; 6742 : 
; 6743 : 		// check if raw data entry
; 6744 : 		if (pMap[i].dwSizeData != 0)

  0008c	83 7f 1c 00	 cmp	 DWORD PTR [edi+28], 0
  00090	74 68		 je	 SHORT $LN20@IPersistSt

; 6745 : 		{
; 6746 : 			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);

  00092	8b 57 18	 mov	 edx, DWORD PTR [edi+24]

; 6747 : 			// call CComBSTR::ReadFromStream for BSTRs
; 6748 : 			if (pMap[i].vt == VT_BSTR)

  00095	6a 08		 push	 8
  00097	03 d3		 add	 edx, ebx
  00099	58		 pop	 eax
  0009a	89 55 e4	 mov	 DWORD PTR _pData$1$[ebp], edx
  0009d	66 39 47 20	 cmp	 WORD PTR [edi+32], ax
  000a1	75 23		 jne	 SHORT $LN21@IPersistSt

; 6751 : 				hr = bstrRead.ReadFromStream(pStm);

  000a3	ff 75 08	 push	 DWORD PTR _pStm$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  000a6	83 65 f0 00	 and	 DWORD PTR _bstrRead$5[ebp], 0
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6751 : 				hr = bstrRead.ReadFromStream(pStm);

  000aa	8d 4d f0	 lea	 ecx, DWORD PTR _bstrRead$5[ebp]
  000ad	e8 00 00 00 00	 call	 ?ReadFromStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z ; ATL::CComBSTR::ReadFromStream

; 6752 : 				(*(BSTR*)pData) = bstrRead.Detach();

  000b2	8b 4d e4	 mov	 ecx, DWORD PTR _pData$1$[ebp]
  000b5	8b f0		 mov	 esi, eax
  000b7	8b 45 f0	 mov	 eax, DWORD PTR _bstrRead$5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 1674 :     ::SysFreeString(m_str);

  000ba	6a 00		 push	 0
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6752 : 				(*(BSTR*)pData) = bstrRead.Detach();

  000bc	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 1674 :     ::SysFreeString(m_str);

  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6753 : 			}

  000c4	eb 27		 jmp	 SHORT $LN23@IPersistSt
$LN21@IPersistSt:

; 6754 : 			else
; 6755 : 			{
; 6756 : 				hr = pStm->Read(pData, pMap[i].dwSizeData, &cbRead);

  000c6	8b 4d 08	 mov	 ecx, DWORD PTR _pStm$[ebp]
  000c9	8d 75 f8	 lea	 esi, DWORD PTR _cbRead$6[ebp]
  000cc	56		 push	 esi
  000cd	ff 77 1c	 push	 DWORD PTR [edi+28]
  000d0	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d2	52		 push	 edx
  000d3	51		 push	 ecx
  000d4	ff 50 0c	 call	 DWORD PTR [eax+12]
  000d7	8b f0		 mov	 esi, eax

; 6757 : 
; 6758 : 				if (SUCCEEDED(hr) && cbRead != pMap[i].dwSizeData)

  000d9	85 f6		 test	 esi, esi
  000db	0f 88 6c 01 00
	00		 js	 $LN8@IPersistSt
  000e1	8b 45 f8	 mov	 eax, DWORD PTR _cbRead$6[ebp]
  000e4	3b 47 1c	 cmp	 eax, DWORD PTR [edi+28]
  000e7	0f 85 2f 01 00
	00		 jne	 $LN96@IPersistSt
$LN23@IPersistSt:

; 6759 : 				{
; 6760 : 					return E_FAIL;
; 6761 : 				}
; 6762 : 			}
; 6763 : 
; 6764 : 			if (FAILED(hr))

  000ed	85 f6		 test	 esi, esi
  000ef	0f 88 58 01 00
	00		 js	 $LN8@IPersistSt

; 6765 : 			{
; 6766 : 				return hr;
; 6767 : 			}
; 6768 : 			continue;

  000f5	e9 05 01 00 00	 jmp	 $LN108@IPersistSt
$LN20@IPersistSt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  000fa	33 c0		 xor	 eax, eax
  000fc	8d 7d d4	 lea	 edi, DWORD PTR _var$2[ebp]
  000ff	ab		 stosd
  00100	ab		 stosd
  00101	ab		 stosd
  00102	ab		 stosd

; 2161 :         ::VariantInit(this);

  00103	8d 45 d4	 lea	 eax, DWORD PTR _var$2[ebp]
  00106	50		 push	 eax
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6773 : 		hr = var.ReadFromStream(pStm, pMap[i].vt, pMap[i].rgclsidAllowed, pMap[i].cclsidAllowed);

  0010d	8b 7d f0	 mov	 edi, DWORD PTR tv689[ebp]
  00110	8d 4d d4	 lea	 ecx, DWORD PTR _var$2[ebp]
  00113	ff 77 10	 push	 DWORD PTR [edi+16]
  00116	0f b7 47 20	 movzx	 eax, WORD PTR [edi+32]
  0011a	ff 77 0c	 push	 DWORD PTR [edi+12]
  0011d	50		 push	 eax
  0011e	ff 75 08	 push	 DWORD PTR _pStm$[ebp]
  00121	e8 00 00 00 00	 call	 ?ReadFromStream@CComVariant@ATL@@QAEJPAUIStream@@GTClassesAllowedInStream@2@K@Z ; ATL::CComVariant::ReadFromStream
  00126	8b f0		 mov	 esi, eax

; 6774 : 		if (FAILED(hr))

  00128	85 f6		 test	 esi, esi
  0012a	0f 88 13 01 00
	00		 js	 $LN98@IPersistSt

; 6775 : 			break;
; 6776 : 
; 6777 : 		if (pMap[i].piidDispatch != piidOld)

  00130	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00133	3b 4d ec	 cmp	 ecx, DWORD PTR _piidOld$1$[ebp]
  00136	74 34		 je	 SHORT $LN26@IPersistSt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 229  :         T* pTemp = p;

  00138	8b 55 fc	 mov	 edx, DWORD PTR _pDispatch$7[ebp]
  0013b	85 d2		 test	 edx, edx

; 230  :         if (pTemp)

  0013d	74 0d		 je	 SHORT $LN12@IPersistSt

; 231  :         {
; 232  :             p = NULL;

  0013f	83 65 fc 00	 and	 DWORD PTR _pDispatch$7[ebp], 0

; 233  :             pTemp->Release();

  00143	8b 02		 mov	 eax, DWORD PTR [edx]
  00145	52		 push	 edx
  00146	ff 50 08	 call	 DWORD PTR [eax+8]
  00149	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
$LN12@IPersistSt:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6780 : 			ATLENSURE_RETURN(pMap[i].piidDispatch);

  0014c	85 c9		 test	 ecx, ecx
  0014e	0f 84 de 00 00
	00		 je	 $LN99@IPersistSt

; 6781 : 			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))

  00154	8b 03		 mov	 eax, DWORD PTR [ebx]
  00156	8d 55 fc	 lea	 edx, DWORD PTR _pDispatch$7[ebp]
  00159	52		 push	 edx
  0015a	51		 push	 ecx
  0015b	53		 push	 ebx
  0015c	ff 10		 call	 DWORD PTR [eax]
  0015e	85 c0		 test	 eax, eax
  00160	0f 88 d8 00 00
	00		 js	 $LN101@IPersistSt

; 6782 : 			{
; 6783 : 				ATLTRACE(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
; 6784 : 				hr = E_FAIL;
; 6785 : 				break;
; 6786 : 			}
; 6787 : 			piidOld = pMap[i].piidDispatch;

  00166	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00169	89 45 ec	 mov	 DWORD PTR _piidOld$1$[ebp], eax
$LN26@IPersistSt:

; 6790 : 		if (FAILED(pDispatch.PutProperty(pMap[i].dispid, &var)))

  0016c	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 447  :         return PutProperty(this->p, dwDispID, pVar);

  0016f	8b 7d fc	 mov	 edi, DWORD PTR _pDispatch$7[ebp]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6790 : 		if (FAILED(pDispatch.PutProperty(pMap[i].dispid, &var)))

  00172	89 4d f0	 mov	 DWORD PTR _dwDispID$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 447  :         return PutProperty(this->p, dwDispID, pVar);

  00175	85 ff		 test	 edi, edi

; 550  :         if (pDispatch == NULL)

  00177	0f 84 c1 00 00
	00		 je	 $LN101@IPersistSt

; 551  :             return E_INVALIDARG;
; 552  : 
; 553  :         ATLTRACE(atlTraceCOM, 2, _T("CPropertyHelper::PutProperty\n"));
; 554  :         DISPPARAMS dispparams = {NULL, NULL, 1, 1};

  0017d	33 c0		 xor	 eax, eax

; 555  :         dispparams.rgvarg = pVar;
; 556  :         DISPID dispidPut = DISPID_PROPERTYPUT;

  0017f	c7 45 e4 fd ff
	ff ff		 mov	 DWORD PTR _dispidPut$3[ebp], -3 ; fffffffdH
  00186	40		 inc	 eax

; 557  :         dispparams.rgdispidNamedArgs = &dispidPut;
; 558  : 
; 559  :         if (pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH ||
; 560  :             (pVar->vt & VT_ARRAY) || (pVar->vt & VT_BYREF))

  00187	66 83 7d d4 0d	 cmp	 WORD PTR _var$2[ebp], 13 ; 0000000dH
  0018c	89 45 cc	 mov	 DWORD PTR _dispparams$1[ebp+8], eax
  0018f	89 45 d0	 mov	 DWORD PTR _dispparams$1[ebp+12], eax
  00192	8d 45 d4	 lea	 eax, DWORD PTR _var$2[ebp]
  00195	89 45 c4	 mov	 DWORD PTR _dispparams$1[ebp], eax
  00198	8d 45 e4	 lea	 eax, DWORD PTR _dispidPut$3[ebp]
  0019b	89 45 c8	 mov	 DWORD PTR _dispparams$1[ebp+4], eax
  0019e	74 10		 je	 SHORT $LN79@IPersistSt
  001a0	66 83 7d d4 09	 cmp	 WORD PTR _var$2[ebp], 9
  001a5	74 09		 je	 SHORT $LN79@IPersistSt
  001a7	f7 45 d4 00 60
	00 00		 test	 DWORD PTR _var$2[ebp], 24576 ; 00006000H
  001ae	74 25		 je	 SHORT $LN80@IPersistSt
$LN79@IPersistSt:

; 561  :         {
; 562  :             HRESULT hr = pDispatch->Invoke(dwDispID, IID_NULL,

  001b0	8b 07		 mov	 eax, DWORD PTR [edi]
  001b2	33 d2		 xor	 edx, edx
  001b4	52		 push	 edx
  001b5	52		 push	 edx
  001b6	52		 push	 edx
  001b7	8d 55 c4	 lea	 edx, DWORD PTR _dispparams$1[ebp]
  001ba	52		 push	 edx
  001bb	6a 08		 push	 8
  001bd	5a		 pop	 edx
  001be	52		 push	 edx
  001bf	68 00 04 00 00	 push	 1024			; 00000400H
  001c4	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  001c9	51		 push	 ecx
  001ca	57		 push	 edi
  001cb	ff 50 18	 call	 DWORD PTR [eax+24]

; 563  :                 LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUTREF,
; 564  :                 &dispparams, NULL, NULL, NULL);
; 565  :             if (SUCCEEDED(hr))

  001ce	85 c0		 test	 eax, eax
  001d0	79 23		 jns	 SHORT $LN107@IPersistSt
  001d2	8b 4d f0	 mov	 ecx, DWORD PTR _dwDispID$1$[ebp]
$LN80@IPersistSt:

; 566  :                 return hr;
; 567  :         }
; 568  :         return pDispatch->Invoke(dwDispID, IID_NULL,

  001d5	8b 07		 mov	 eax, DWORD PTR [edi]
  001d7	33 d2		 xor	 edx, edx
  001d9	52		 push	 edx
  001da	52		 push	 edx
  001db	52		 push	 edx
  001dc	8d 55 c4	 lea	 edx, DWORD PTR _dispparams$1[ebp]
  001df	52		 push	 edx
  001e0	6a 04		 push	 4
  001e2	68 00 04 00 00	 push	 1024			; 00000400H
  001e7	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  001ec	51		 push	 ecx
  001ed	57		 push	 edi
  001ee	ff 50 18	 call	 DWORD PTR [eax+24]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6790 : 		if (FAILED(pDispatch.PutProperty(pMap[i].dispid, &var)))

  001f1	85 c0		 test	 eax, eax
  001f3	78 49		 js	 SHORT $LN101@IPersistSt
$LN107@IPersistSt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2865 :         return ::VariantClear(this);

  001f5	8d 45 d4	 lea	 eax, DWORD PTR _var$2[ebp]
  001f8	50		 push	 eax
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN108@IPersistSt:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6737 : 	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)

  001ff	8b 45 f4	 mov	 eax, DWORD PTR _i$1$[ebp]
  00202	8b 4d 0c	 mov	 ecx, DWORD PTR _pMap$[ebp]
$LN7@IPersistSt:
  00205	40		 inc	 eax
  00206	6b f8 24	 imul	 edi, eax, 36
  00209	89 45 f4	 mov	 DWORD PTR _i$1$[ebp], eax
  0020c	03 f9		 add	 edi, ecx
  0020e	89 7d f0	 mov	 DWORD PTR tv689[ebp], edi
  00211	83 7f 04 00	 cmp	 DWORD PTR [edi+4], 0
  00215	74 36		 je	 SHORT $LN8@IPersistSt
  00217	e9 67 fe ff ff	 jmp	 $LL9@IPersistSt
$LN96@IPersistSt:

; 729  : 		return hr;

  0021c	8b 45 fc	 mov	 eax, DWORD PTR _pDispatch$7[ebp]
  0021f	85 c0		 test	 eax, eax
  00221	0f 84 2f fe ff
	ff		 je	 $LN109@IPersistSt
  00227	8b 08		 mov	 ecx, DWORD PTR [eax]
  00229	50		 push	 eax
  0022a	ff 51 08	 call	 DWORD PTR [ecx+8]
  0022d	e9 24 fe ff ff	 jmp	 $LN109@IPersistSt
$LN99@IPersistSt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2865 :         return ::VariantClear(this);

  00232	8d 45 d4	 lea	 eax, DWORD PTR _var$2[ebp]
  00235	50		 push	 eax
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 6780 : 			ATLENSURE_RETURN(pMap[i].piidDispatch);

  0023c	eb de		 jmp	 SHORT $LN96@IPersistSt
$LN101@IPersistSt:

; 725  : 		T* pT = static_cast<T*>(this);
; 726  : 		HRESULT hr = AtlIPersistStreamInit_Load(pStm, pMap, pT, pT->GetUnknown());
; 727  : 		if (SUCCEEDED(hr))

  0023e	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
$LN98@IPersistSt:
  00243	8d 45 d4	 lea	 eax, DWORD PTR _var$2[ebp]
  00246	50		 push	 eax
  00247	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN8@IPersistSt:
  0024d	8b 45 fc	 mov	 eax, DWORD PTR _pDispatch$7[ebp]
  00250	85 c0		 test	 eax, eax
  00252	74 06		 je	 SHORT $LN93@IPersistSt
  00254	8b 08		 mov	 ecx, DWORD PTR [eax]
  00256	50		 push	 eax
  00257	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN93@IPersistSt:
  0025a	85 f6		 test	 esi, esi
  0025c	78 0e		 js	 SHORT $LN2@IPersistSt

; 728  : 			pT->m_bRequiresSave = FALSE;

  0025e	81 63 48 7f ff
	ff ff		 and	 DWORD PTR [ebx+72], -129 ; ffffff7fH
  00265	eb 05		 jmp	 SHORT $LN2@IPersistSt
$LN14@IPersistSt:

; 6712 : 		return E_INVALIDARG;

  00267	be 57 00 07 80	 mov	 esi, -2147024809	; 80070057H
$LN2@IPersistSt:

; 729  : 		return hr;

  0026c	5f		 pop	 edi
  0026d	8b c6		 mov	 eax, esi
  0026f	5e		 pop	 esi
  00270	5b		 pop	 ebx

; 730  : 
; 731  : 	}

  00271	c9		 leave
  00272	c2 08 00	 ret	 8
?IPersistStreamInit_Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@PBUATL_PROPMAP_ENTRY@2@@Z ENDP ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IPersistStreamInit_Load
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?InitNew@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?InitNew@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ PROC ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::InitNew, COMDAT

; 714  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 715  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::InitNew\n"));
; 716  : 		T* pT = static_cast<T*>(this);
; 717  : 		pT->m_bRequiresSave = TRUE;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	6a 48		 push	 72			; 00000048H
  0000a	5a		 pop	 edx
  0000b	8d 48 d8	 lea	 ecx, DWORD PTR [eax-40]
  0000e	0f 44 ca	 cmove	 ecx, edx
  00011	81 09 80 00 00
	00		 or	 DWORD PTR [ecx], 128	; 00000080H

; 718  : 		return S_OK;

  00017	33 c0		 xor	 eax, eax

; 719  : 	}

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?InitNew@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ENDP ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::InitNew
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetSizeMax@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT
_dispparamsNoArgs$1 = -60				; size = 16
_var$2 = -44						; size = 16
_nVarSize$3 = -28					; size = 8
_nSize$ = -20						; size = 8
tv588 = -12						; size = 4
_i$1$ = -8						; size = 4
_piidOld$1$ = -4					; size = 4
_pDispatch$ = 8						; size = 4
_this$ = 8						; size = 4
_pcbSize$ = 12						; size = 4
?GetSizeMax@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAT_ULARGE_INTEGER@@@Z PROC ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::GetSizeMax, COMDAT

; 621  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 622  : 		HRESULT hr = S_OK;

  00006	33 c9		 xor	 ecx, ecx
  00008	53		 push	 ebx

; 623  : 		T* pT = static_cast<T*>(this);
; 624  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::GetSizeMax\n"));
; 625  : 
; 626  : 		ATLASSERT(pcbSize != NULL);
; 627  : 		if (pcbSize == NULL)

  00009	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	8d 43 90	 lea	 eax, DWORD PTR [ebx-112]
  00012	f7 db		 neg	 ebx
  00014	1b db		 sbb	 ebx, ebx
  00016	23 d8		 and	 ebx, eax
  00018	39 4d 0c	 cmp	 DWORD PTR _pcbSize$[ebp], ecx
  0001b	75 0a		 jne	 SHORT $LN14@GetSizeMax

; 628  : 		{
; 629  : 			return E_POINTER;

  0001d	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00022	e9 b2 01 00 00	 jmp	 $LN1@GetSizeMax
$LN14@GetSizeMax:
  00027	57		 push	 edi

; 641  : 		for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)

  00028	8b f9		 mov	 edi, ecx
  0002a	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR _nSize$[ebp], 4
  00031	89 4d f0	 mov	 DWORD PTR _nSize$[ebp+4], ecx
  00034	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00036	89 4d 08	 mov	 DWORD PTR _pDispatch$[ebp], ecx
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 640  : 		const IID* piidOld = NULL;

  00039	89 4d fc	 mov	 DWORD PTR _piidOld$1$[ebp], ecx

; 641  : 		for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)

  0003c	89 7d f8	 mov	 DWORD PTR _i$1$[ebp], edi
  0003f	89 4d f4	 mov	 DWORD PTR tv588[ebp], ecx
$LL7@GetSizeMax:

; 642  : 		{
; 643  : 			ULARGE_INTEGER nVarSize;
; 644  : 			nVarSize.QuadPart = 0;

  00042	0f 57 c0	 xorps	 xmm0, xmm0
  00045	66 0f 13 45 e4	 movlpd	 QWORD PTR _nVarSize$3[ebp], xmm0

; 645  : 
; 646  : 			if (pMap[i].szDesc == NULL)

  0004a	39 88 00 00 00
	00		 cmp	 DWORD PTR ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B[eax], ecx
  00050	0f 84 2d 01 00
	00		 je	 $LN5@GetSizeMax

; 647  : 			{
; 648  : 				continue;
; 649  : 			}
; 650  : 
; 651  : 			// check if raw data entry
; 652  : 			if (pMap[i].dwSizeData != 0)

  00056	8b 88 1c 00 00
	00		 mov	 ecx, DWORD PTR ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B[eax+28]
  0005c	85 c9		 test	 ecx, ecx
  0005e	74 43		 je	 SHORT $LN17@GetSizeMax

; 653  : 			{
; 654  : 				//Calculate stream size for BSTRs special case
; 655  : 				if (pMap[i].vt == VT_BSTR)

  00060	66 83 b8 20 00
	00 00 08	 cmp	 WORD PTR ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B[eax+32], 8
  00068	0f 85 f5 00 00
	00		 jne	 $LN18@GetSizeMax

; 656  : 				{
; 657  : 					void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pT);

  0006e	8b 80 18 00 00
	00		 mov	 eax, DWORD PTR ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B[eax+24]
  00074	8d 0c 18	 lea	 ecx, DWORD PTR [eax+ebx]

; 658  : 					ATLENSURE_RETURN( pData >= (void*)(DWORD_PTR)pMap[i].dwOffsetData

  00077	3b c8		 cmp	 ecx, eax
  00079	0f 82 26 01 00
	00		 jb	 $LN89@GetSizeMax
  0007f	3b cb		 cmp	 ecx, ebx
  00081	0f 82 1e 01 00
	00		 jb	 $LN89@GetSizeMax

; 659  : 									&& pData >= (void*)(DWORD_PTR)pT );
; 660  : 					BSTR bstr = *reinterpret_cast<BSTR*>(pData);

  00087	8b 01		 mov	 eax, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 1662 :         ULONG ulSize = sizeof(ULONG);

  00089	6a 04		 push	 4
  0008b	59		 pop	 ecx

; 1663 :         if (bstr != NULL)

  0008c	85 c0		 test	 eax, eax
  0008e	0f 84 cf 00 00
	00		 je	 $LN18@GetSizeMax

; 1664 :         {
; 1665 :             ulSize += SysStringByteLen(bstr) + sizeof(OLECHAR);

  00094	50		 push	 eax
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysStringByteLen@4
  0009b	8d 48 06	 lea	 ecx, DWORD PTR [eax+6]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 663  : 				}

  0009e	e9 c0 00 00 00	 jmp	 $LN18@GetSizeMax
$LN17@GetSizeMax:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  000a3	33 c0		 xor	 eax, eax
  000a5	8d 7d d4	 lea	 edi, DWORD PTR _var$2[ebp]
  000a8	ab		 stosd
  000a9	ab		 stosd
  000aa	ab		 stosd
  000ab	ab		 stosd

; 2161 :         ::VariantInit(this);

  000ac	8d 45 d4	 lea	 eax, DWORD PTR _var$2[ebp]
  000af	50		 push	 eax
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 672  : 				if (pMap[i].piidDispatch != piidOld)

  000b6	8b 7d f4	 mov	 edi, DWORD PTR tv588[ebp]
  000b9	8b 97 08 00 00
	00		 mov	 edx, DWORD PTR ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B[edi+8]
  000bf	3b 55 fc	 cmp	 edx, DWORD PTR _piidOld$1$[ebp]
  000c2	74 3c		 je	 SHORT $LN22@GetSizeMax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 229  :         T* pTemp = p;

  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _pDispatch$[ebp]
  000c7	85 c9		 test	 ecx, ecx

; 230  :         if (pTemp)

  000c9	74 10		 je	 SHORT $LN13@GetSizeMax

; 231  :         {
; 232  :             p = NULL;

  000cb	83 65 08 00	 and	 DWORD PTR _pDispatch$[ebp], 0

; 233  :             pTemp->Release();

  000cf	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d1	51		 push	 ecx
  000d2	ff 50 08	 call	 DWORD PTR [eax+8]
  000d5	8b 97 08 00 00
	00		 mov	 edx, DWORD PTR ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B[edi+8]
$LN13@GetSizeMax:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 675  : 					ATLENSURE_RETURN(pMap[i].piidDispatch);

  000db	85 d2		 test	 edx, edx
  000dd	0f 84 b8 00 00
	00		 je	 $LN90@GetSizeMax

; 676  : 
; 677  : 					hr = pT->GetUnknown()->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch);

  000e3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000e5	8d 4d 08	 lea	 ecx, DWORD PTR _pDispatch$[ebp]
  000e8	51		 push	 ecx
  000e9	52		 push	 edx
  000ea	53		 push	 ebx
  000eb	ff 10		 call	 DWORD PTR [eax]
  000ed	8b f0		 mov	 esi, eax

; 678  : 					if (FAILED(hr))

  000ef	85 f6		 test	 esi, esi
  000f1	0f 88 ba 00 00
	00		 js	 $LN92@GetSizeMax

; 679  : 					{
; 680  : 						ATLTRACE(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
; 681  : 						break;
; 682  : 					}
; 683  : 					piidOld = pMap[i].piidDispatch;

  000f7	8b 87 08 00 00
	00		 mov	 eax, DWORD PTR ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B[edi+8]
  000fd	89 45 fc	 mov	 DWORD PTR _piidOld$1$[ebp], eax
$LN22@GetSizeMax:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 583  :         if (pDispatch == NULL)

  00100	8b 45 08	 mov	 eax, DWORD PTR _pDispatch$[ebp]
  00103	85 c0		 test	 eax, eax
  00105	0f 84 a1 00 00
	00		 je	 $LN100@GetSizeMax

; 584  :             return E_INVALIDARG;
; 585  : 
; 586  :         ATLTRACE(atlTraceCOM, 2, _T("CPropertyHelper::GetProperty\n"));
; 587  :         DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
; 588  :         return pDispatch->Invoke(dwDispID, IID_NULL,

  0010b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010d	33 d2		 xor	 edx, edx
  0010f	52		 push	 edx
  00110	52		 push	 edx
  00111	89 55 c4	 mov	 DWORD PTR _dispparamsNoArgs$1[ebp], edx
  00114	89 55 c8	 mov	 DWORD PTR _dispparamsNoArgs$1[ebp+4], edx
  00117	89 55 cc	 mov	 DWORD PTR _dispparamsNoArgs$1[ebp+8], edx
  0011a	89 55 d0	 mov	 DWORD PTR _dispparamsNoArgs$1[ebp+12], edx
  0011d	8d 55 d4	 lea	 edx, DWORD PTR _var$2[ebp]
  00120	52		 push	 edx
  00121	8d 55 c4	 lea	 edx, DWORD PTR _dispparamsNoArgs$1[ebp]
  00124	52		 push	 edx
  00125	6a 02		 push	 2
  00127	68 00 04 00 00	 push	 1024			; 00000400H
  0012c	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  00131	ff b7 14 00 00
	00		 push	 DWORD PTR ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B[edi+20]
  00137	50		 push	 eax
  00138	ff 51 18	 call	 DWORD PTR [ecx+24]
  0013b	8b f0		 mov	 esi, eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 687  : 				if (FAILED(hr))

  0013d	85 f6		 test	 esi, esi
  0013f	78 70		 js	 SHORT $LN92@GetSizeMax

; 688  : 				{
; 689  : 					ATLTRACE(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
; 690  : 					break;
; 691  : 				}
; 692  : 
; 693  : 				hr = var.GetSizeMax(&nVarSize);

  00141	8d 45 e4	 lea	 eax, DWORD PTR _nVarSize$3[ebp]
  00144	50		 push	 eax
  00145	8d 4d d4	 lea	 ecx, DWORD PTR _var$2[ebp]
  00148	e8 00 00 00 00	 call	 ?GetSizeMax@CComVariant@ATL@@QBEJPAT_ULARGE_INTEGER@@@Z ; ATL::CComVariant::GetSizeMax
  0014d	8b f0		 mov	 esi, eax

; 694  : 				if (FAILED(hr))

  0014f	8d 45 d4	 lea	 eax, DWORD PTR _var$2[ebp]
  00152	50		 push	 eax
  00153	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
  00159	85 f6		 test	 esi, esi
  0015b	78 5e		 js	 SHORT $LN94@GetSizeMax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2865 :         return ::VariantClear(this);

  0015d	8b 4d e4	 mov	 ecx, DWORD PTR _nVarSize$3[ebp]
  00160	8b 7d f8	 mov	 edi, DWORD PTR _i$1$[ebp]
$LN18@GetSizeMax:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 701  : 			hr = AtlAdd(&nSize.QuadPart, nSize.QuadPart, nVarSize.QuadPart);

  00163	ff 75 e8	 push	 DWORD PTR _nVarSize$3[ebp+4]
  00166	8b 45 f0	 mov	 eax, DWORD PTR _nSize$[ebp+4]
  00169	51		 push	 ecx
  0016a	50		 push	 eax
  0016b	8b 45 ec	 mov	 eax, DWORD PTR _nSize$[ebp]
  0016e	50		 push	 eax
  0016f	8d 45 ec	 lea	 eax, DWORD PTR _nSize$[ebp]
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 ??$AtlAdd@_K@ATL@@YAJPA_K_K1@Z ; ATL::AtlAdd<unsigned __int64>
  00178	8b f0		 mov	 esi, eax
  0017a	83 c4 14	 add	 esp, 20			; 00000014H

; 702  : 			if (FAILED(hr))

  0017d	85 f6		 test	 esi, esi
  0017f	78 3a		 js	 SHORT $LN94@GetSizeMax
  00181	33 c9		 xor	 ecx, ecx
$LN5@GetSizeMax:

; 641  : 		for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)

  00183	47		 inc	 edi
  00184	6b c7 24	 imul	 eax, edi, 36
  00187	89 7d f8	 mov	 DWORD PTR _i$1$[ebp], edi
  0018a	89 45 f4	 mov	 DWORD PTR tv588[ebp], eax
  0018d	39 88 04 00 00
	00		 cmp	 DWORD PTR ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B[eax+4], ecx
  00193	0f 85 a9 fe ff
	ff		 jne	 $LL7@GetSizeMax
  00199	eb 20		 jmp	 SHORT $LN94@GetSizeMax
$LN90@GetSizeMax:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2865 :         return ::VariantClear(this);

  0019b	8d 45 d4	 lea	 eax, DWORD PTR _var$2[ebp]
  0019e	50		 push	 eax
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN89@GetSizeMax:

; 183  :         if (p)

  001a5	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
  001aa	eb 1d		 jmp	 SHORT $LN34@GetSizeMax
$LN100@GetSizeMax:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 686  : 				hr = pDispatch.GetProperty(pMap[i].dispid, &var);

  001ac	be 57 00 07 80	 mov	 esi, -2147024809	; 80070057H
$LN92@GetSizeMax:

; 703  : 			{
; 704  : 				ATLTRACE(atlTraceCOM, 0, _T("Result overflow after adding property #%i\n"), i);
; 705  : 				break;
; 706  : 			}
; 707  : 		}
; 708  : 		*pcbSize = nSize;

  001b1	8d 45 d4	 lea	 eax, DWORD PTR _var$2[ebp]
  001b4	50		 push	 eax
  001b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN94@GetSizeMax:
  001bb	8b 4d 0c	 mov	 ecx, DWORD PTR _pcbSize$[ebp]
  001be	8b 45 ec	 mov	 eax, DWORD PTR _nSize$[ebp]
  001c1	89 01		 mov	 DWORD PTR [ecx], eax
  001c3	8b 45 f0	 mov	 eax, DWORD PTR _nSize$[ebp+4]
  001c6	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN34@GetSizeMax:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  001c9	8b 4d 08	 mov	 ecx, DWORD PTR _pDispatch$[ebp]
  001cc	5f		 pop	 edi
  001cd	85 c9		 test	 ecx, ecx
  001cf	74 06		 je	 SHORT $LN86@GetSizeMax

; 184  :             p->Release();

  001d1	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d3	51		 push	 ecx
  001d4	ff 52 08	 call	 DWORD PTR [edx+8]
$LN86@GetSizeMax:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 709  : 		return hr;

  001d7	8b c6		 mov	 eax, esi
$LN1@GetSizeMax:
  001d9	5e		 pop	 esi

; 710  : 	}

  001da	5b		 pop	 ebx
  001db	c9		 leave
  001dc	c2 08 00	 ret	 8
?GetSizeMax@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAT_ULARGE_INTEGER@@@Z ENDP ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::GetSizeMax
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@H@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pStm$ = 12						; size = 4
_fClearDirty$ = 16					; size = 4
?Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@H@Z PROC ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::Save, COMDAT

; 615  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 616  : 		T* pT = static_cast<T*>(this);
; 617  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::Save\n"));
; 618  : 		return pT->IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap());

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	68 00 00 00 00	 push	 OFFSET ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B ; `COPOSDeviceMonitor::GetPropertyMap'::`2'::pPropMap
  0000d	ff 75 10	 push	 DWORD PTR _fClearDirty$[ebp]
  00010	ff 75 0c	 push	 DWORD PTR _pStm$[ebp]
  00013	6a 70		 push	 112			; 00000070H
  00015	58		 pop	 eax
  00016	0f 44 c8	 cmove	 ecx, eax
  00019	e8 00 00 00 00	 call	 ?IPersistStreamInit_Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@HPBUATL_PROPMAP_ENTRY@2@@Z ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IPersistStreamInit_Save

; 619  : 	}

  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
?Save@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@H@Z ENDP ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::Save
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pStm$ = 12						; size = 4
?Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@@Z PROC ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::Load, COMDAT

; 608  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 609  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::Load\n"));
; 610  : 
; 611  : 		T* pT = static_cast<T*>(this);
; 612  : 		return pT->IPersistStreamInit_Load(pStm, T::GetPropertyMap());

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	68 00 00 00 00	 push	 OFFSET ?pPropMap@?1??GetPropertyMap@COPOSDeviceMonitor@@SAPBUATL_PROPMAP_ENTRY@ATL@@XZ@4QBU34@B ; `COPOSDeviceMonitor::GetPropertyMap'::`2'::pPropMap
  0000d	ff 75 0c	 push	 DWORD PTR _pStm$[ebp]
  00010	6a 70		 push	 112			; 00000070H
  00012	58		 pop	 eax
  00013	0f 44 c8	 cmove	 ecx, eax
  00016	e8 00 00 00 00	 call	 ?IPersistStreamInit_Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@QAEJPAUIStream@@PBUATL_PROPMAP_ENTRY@2@@Z ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IPersistStreamInit_Load

; 613  : 	}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?Load@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAUIStream@@@Z ENDP ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::Load
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?IsDirty@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?IsDirty@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ PROC ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IsDirty, COMDAT

; 602  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 603  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::IsDirty\n"));
; 604  : 		T* pT = static_cast<T*>(this);
; 605  : 		return (pT->m_bRequiresSave) ? S_OK : S_FALSE;

  00003	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	6a 48		 push	 72			; 00000048H
  0000a	5a		 pop	 edx
  0000b	8d 48 d8	 lea	 ecx, DWORD PTR [eax-40]
  0000e	0f 44 ca	 cmove	 ecx, edx
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	c1 e8 07	 shr	 eax, 7
  00016	f7 d0		 not	 eax
  00018	83 e0 01	 and	 eax, 1

; 606  : 	}

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?IsDirty@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJXZ ENDP ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::IsDirty
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetClassID@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pClassID$ = 12						; size = 4
?GetClassID@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z PROC ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::GetClassID, COMDAT

; 592  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 593  : 		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::GetClassID\n"));
; 594  : 		if (pClassID == NULL)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _pClassID$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 07		 jne	 SHORT $LN2@GetClassID

; 595  : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 0d		 jmp	 SHORT $LN1@GetClassID
$LN2@GetClassID:
  00012	56		 push	 esi

; 596  : 		*pClassID = T::GetObjectCLSID();

  00013	be 00 00 00 00	 mov	 esi, OFFSET _CLSID_OPOSDeviceMonitor

; 597  : 		return S_OK;

  00018	33 c0		 xor	 eax, eax
  0001a	a5		 movsd
  0001b	a5		 movsd
  0001c	a5		 movsd
  0001d	a5		 movsd
  0001e	5e		 pop	 esi
$LN1@GetClassID:
  0001f	5f		 pop	 edi

; 598  : 	}

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
?GetClassID@?$IPersistStreamInitImpl@VCOPOSDeviceMonitor@@@ATL@@UAGJPAU_GUID@@@Z ENDP ; ATL::IPersistStreamInitImpl<COPOSDeviceMonitor>::GetClassID
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?ProcessWindowMessage@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEHPAUHWND__@@IIJAAJK@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_lResult$ = 24						; size = 4
_bHandled$ = 28						; size = 4
_dwMsgMapID$ = 28					; size = 4
?ProcessWindowMessage@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEHPAUHWND__@@IIJAAJK@Z PROC ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::ProcessWindowMessage, COMDAT
; _this$ = ecx

; 1636 : 	BEGIN_MSG_MAP(thisClass)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 7d 1c 00	 cmp	 DWORD PTR _dwMsgMapID$[ebp], 0
  00007	0f 85 8c 00 00
	00		 jne	 $LN12@ProcessWin

; 1637 : 		__if_not_exists(WinBase::m_wndReflector)
; 1638 : 		{
; 1639 : 		MESSAGE_HANDLER(WM_PAINT, CComControlBase::OnPaint)

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _uMsg$[ebp]
  00010	83 c1 b8	 add	 ecx, -72		; ffffffb8H
  00013	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00016	75 1b		 jne	 SHORT $LN15@ProcessWin
  00018	8d 45 1c	 lea	 eax, DWORD PTR _bHandled$[ebp]
  0001b	50		 push	 eax
  0001c	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  0001f	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00022	6a 0f		 push	 15			; 0000000fH
  00024	e8 00 00 00 00	 call	 ?OnPaint@CComControlBase@ATL@@QAEJIIJAAH@Z ; ATL::CComControlBase::OnPaint
  00029	8b 4d 18	 mov	 ecx, DWORD PTR _lResult$[ebp]
  0002c	89 01		 mov	 DWORD PTR [ecx], eax
$LN18@ProcessWin:

; 1644 : 		__if_exists(WinBase::m_wndReflector)
; 1645 : 		{
; 1646 : 			CHAIN_MSG_MAP(baseWinClass)
; 1647 : 		}
; 1648 : 	END_MSG_MAP()

  0002e	33 c0		 xor	 eax, eax
  00030	40		 inc	 eax
  00031	eb 68		 jmp	 SHORT $LN1@ProcessWin
$LN15@ProcessWin:

; 1640 : 		}
; 1641 : 		MESSAGE_HANDLER(WM_SETFOCUS, CComControlBase::OnSetFocus)

  00033	83 f8 07	 cmp	 eax, 7
  00036	75 1a		 jne	 SHORT $LN8@ProcessWin
  00038	8d 45 1c	 lea	 eax, DWORD PTR _bHandled$[ebp]
  0003b	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR _bHandled$[ebp], 1
  00042	50		 push	 eax
  00043	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00046	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00049	6a 07		 push	 7
  0004b	e8 00 00 00 00	 call	 ?OnSetFocus@CComControlBase@ATL@@QAEJIIJAAH@Z ; ATL::CComControlBase::OnSetFocus
  00050	eb 3c		 jmp	 SHORT $LN17@ProcessWin
$LN8@ProcessWin:

; 1642 : 		MESSAGE_HANDLER(WM_KILLFOCUS, CComControlBase::OnKillFocus)

  00052	83 f8 08	 cmp	 eax, 8
  00055	75 1a		 jne	 SHORT $LN10@ProcessWin
  00057	8d 45 1c	 lea	 eax, DWORD PTR _bHandled$[ebp]
  0005a	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR _bHandled$[ebp], 1
  00061	50		 push	 eax
  00062	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00065	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00068	6a 08		 push	 8
  0006a	e8 00 00 00 00	 call	 ?OnKillFocus@CComControlBase@ATL@@QAEJIIJAAH@Z ; ATL::CComControlBase::OnKillFocus
  0006f	eb 1d		 jmp	 SHORT $LN17@ProcessWin
$LN10@ProcessWin:

; 1643 : 		MESSAGE_HANDLER(WM_MOUSEACTIVATE, CComControlBase::OnMouseActivate)

  00071	83 f8 21	 cmp	 eax, 33			; 00000021H
  00074	75 23		 jne	 SHORT $LN12@ProcessWin
  00076	8d 45 1c	 lea	 eax, DWORD PTR _bHandled$[ebp]
  00079	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR _bHandled$[ebp], 1
  00080	50		 push	 eax
  00081	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00084	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00087	6a 21		 push	 33			; 00000021H
  00089	e8 00 00 00 00	 call	 ?OnMouseActivate@CComControlBase@ATL@@QAEJIIJAAH@Z ; ATL::CComControlBase::OnMouseActivate
$LN17@ProcessWin:
  0008e	83 7d 1c 00	 cmp	 DWORD PTR _bHandled$[ebp], 0
  00092	8b 4d 18	 mov	 ecx, DWORD PTR _lResult$[ebp]
  00095	89 01		 mov	 DWORD PTR [ecx], eax
  00097	75 95		 jne	 SHORT $LN18@ProcessWin
$LN12@ProcessWin:

; 1644 : 		__if_exists(WinBase::m_wndReflector)
; 1645 : 		{
; 1646 : 			CHAIN_MSG_MAP(baseWinClass)
; 1647 : 		}
; 1648 : 	END_MSG_MAP()

  00099	33 c0		 xor	 eax, eax
$LN1@ProcessWin:
  0009b	5d		 pop	 ebp
  0009c	c2 18 00	 ret	 24			; 00000018H
?ProcessWindowMessage@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEHPAUHWND__@@IIJAAJK@Z ENDP ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::ProcessWindowMessage
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?ControlQueryInterface@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_iid$ = 8						; size = 4
_ppv$ = 12						; size = 4
?ControlQueryInterface@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEJABU_GUID@@PAPAX@Z PROC ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::ControlQueryInterface, COMDAT
; _this$ = ecx

; 1616 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1617 : 		T* pT = static_cast<T*>(this);
; 1618 : 		return pT->GetUnknown()->QueryInterface(iid, ppv);

  00003	ff 75 0c	 push	 DWORD PTR _ppv$[ebp]
  00006	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00009	f7 d9		 neg	 ecx
  0000b	ff 75 08	 push	 DWORD PTR _iid$[ebp]
  0000e	1b c9		 sbb	 ecx, ecx
  00010	23 c8		 and	 ecx, eax
  00012	51		 push	 ecx
  00013	8b 01		 mov	 eax, DWORD PTR [ecx]
  00015	ff 10		 call	 DWORD PTR [eax]

; 1619 : 	}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?ControlQueryInterface@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEJABU_GUID@@PAPAX@Z ENDP ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::ControlQueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?CreateControlWindow@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEPAUHWND__@@PAU3@AAUtagRECT@@@Z
_TEXT	SEGMENT
_hWndParent$ = 8					; size = 4
_rcPos$ = 12						; size = 4
?CreateControlWindow@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEPAUHWND__@@PAU3@AAUtagRECT@@@Z PROC ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::CreateControlWindow, COMDAT
; _this$ = ecx

; 1597 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b d1		 mov	 edx, ecx

; 1599 : 		return pT->Create(hWndParent, rcPos);

  00005	33 c9		 xor	 ecx, ecx
  00007	51		 push	 ecx
  00008	51		 push	 ecx
  00009	8b c4		 mov	 eax, esp
  0000b	85 d2		 test	 edx, edx
  0000d	51		 push	 ecx
  0000e	51		 push	 ecx
  0000f	51		 push	 ecx
  00010	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 121  : 	_U_MENUorID(_In_ UINT nID) : m_hMenu((HMENU)(UINT_PTR)nID)

  00011	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1599 : 		return pT->Create(hWndParent, rcPos);

  00013	8b cc		 mov	 ecx, esp
  00015	ff 75 08	 push	 DWORD PTR _hWndParent$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 109  : 	_U_RECT(_In_ RECT& rc) : m_lpRect(&rc)

  00018	8b 45 0c	 mov	 eax, DWORD PTR _rcPos$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1599 : 		return pT->Create(hWndParent, rcPos);

  0001b	6a 4c		 push	 76			; 0000004cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 109  : 	_U_RECT(_In_ RECT& rc) : m_lpRect(&rc)

  0001d	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1599 : 		return pT->Create(hWndParent, rcPos);

  0001f	8d 4a 48	 lea	 ecx, DWORD PTR [edx+72]
  00022	58		 pop	 eax
  00023	0f 44 c8	 cmove	 ecx, eax
  00026	e8 00 00 00 00	 call	 ?atlCreate@?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@PAX@Z ; ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> >::atlCreate

; 1600 : 	}

  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
?CreateControlWindow@?$CComControl@VCOPOSDeviceMonitor@@V?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@@ATL@@UAEPAUHWND__@@PAU3@AAUtagRECT@@@Z ENDP ; ATL::CComControl<COPOSDeviceMonitor,ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> > >::CreateControlWindow
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?atlCreate@?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@PAX@Z
_TEXT	SEGMENT
_hWndParent$ = 8					; size = 4
_rect$ = 12						; size = 4
_szWindowName$ = 16					; size = 4
_dwStyle$ = 20						; size = 4
_dwExStyle$ = 24					; size = 4
_MenuOrID$ = 28						; size = 4
_lpCreateParam$ = 32					; size = 4
?atlCreate@?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@PAX@Z PROC ; ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> >::atlCreate, COMDAT
; _this$ = ecx

; 3707 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3708 : 		if (T::GetWndClassInfo().m_lpszOrigName == NULL)
; 3709 : 			T::GetWndClassInfo().m_lpszOrigName = this->GetWndClassName();
; 3710 : 		ATOM atom = T::GetWndClassInfo().Register(&this->m_pfnSuperWindowProc);

  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?wc@?1??GetWndClassInfo@?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@SAAAU_ATL_WNDCLASSINFOW@3@XZ@4U43@A ; `ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> >::GetWndClassInfo'::`2'::wc
  0000b	8d 46 20	 lea	 eax, DWORD PTR [esi+32]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?Register@_ATL_WNDCLASSINFOW@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z ; ATL::_ATL_WNDCLASSINFOW::Register

; 3711 : 
; 3712 : 		dwStyle = T::GetWndStyle(dwStyle);
; 3713 : 		dwExStyle = T::GetWndExStyle(dwExStyle);
; 3714 : 
; 3715 : 		// set caption
; 3716 : 		if (szWindowName == NULL)
; 3717 : 			szWindowName = T::GetWndCaption();
; 3718 : 
; 3719 : 		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rect, szWindowName,

  00014	ff 75 20	 push	 DWORD PTR _lpCreateParam$[ebp]
  00017	0f b7 c0	 movzx	 eax, ax

; 3184 : 		return dwStyle == 0 ? t_dwStyle : dwStyle;

  0001a	b9 00 00 00 56	 mov	 ecx, 1442840576		; 56000000H

; 3711 : 
; 3712 : 		dwStyle = T::GetWndStyle(dwStyle);
; 3713 : 		dwExStyle = T::GetWndExStyle(dwExStyle);
; 3714 : 
; 3715 : 		// set caption
; 3716 : 		if (szWindowName == NULL)
; 3717 : 			szWindowName = T::GetWndCaption();
; 3718 : 
; 3719 : 		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rect, szWindowName,

  0001f	50		 push	 eax
  00020	ff 75 1c	 push	 DWORD PTR _MenuOrID$[ebp]

; 3184 : 		return dwStyle == 0 ? t_dwStyle : dwStyle;

  00023	8b 45 14	 mov	 eax, DWORD PTR _dwStyle$[ebp]
  00026	85 c0		 test	 eax, eax

; 3711 : 
; 3712 : 		dwStyle = T::GetWndStyle(dwStyle);
; 3713 : 		dwExStyle = T::GetWndExStyle(dwExStyle);
; 3714 : 
; 3715 : 		// set caption
; 3716 : 		if (szWindowName == NULL)
; 3717 : 			szWindowName = T::GetWndCaption();
; 3718 : 
; 3719 : 		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rect, szWindowName,

  00028	ff 75 18	 push	 DWORD PTR _dwExStyle$[ebp]

; 3184 : 		return dwStyle == 0 ? t_dwStyle : dwStyle;

  0002b	0f 44 c1	 cmove	 eax, ecx

; 3711 : 
; 3712 : 		dwStyle = T::GetWndStyle(dwStyle);
; 3713 : 		dwExStyle = T::GetWndExStyle(dwExStyle);
; 3714 : 
; 3715 : 		// set caption
; 3716 : 		if (szWindowName == NULL)
; 3717 : 			szWindowName = T::GetWndCaption();
; 3718 : 
; 3719 : 		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rect, szWindowName,

  0002e	8b ce		 mov	 ecx, esi
  00030	50		 push	 eax
  00031	ff 75 10	 push	 DWORD PTR _szWindowName$[ebp]
  00034	ff 75 0c	 push	 DWORD PTR _rect$[ebp]
  00037	ff 75 08	 push	 DWORD PTR _hWndParent$[ebp]
  0003a	e8 00 00 00 00	 call	 ?atlCreate@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@GPAX@Z ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::atlCreate
  0003f	5e		 pop	 esi

; 3720 : 			dwStyle, dwExStyle, MenuOrID, atom, lpCreateParam);
; 3721 : 	}

  00040	5d		 pop	 ebp
  00041	c2 1c 00	 ret	 28			; 0000001cH
?atlCreate@?$CWindowImpl@VCOPOSDeviceMonitor@@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@3@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@PAX@Z ENDP ; ATL::CWindowImpl<COPOSDeviceMonitor,ATL::CWindow,ATL::CWinTraits<1442840576,0> >::atlCreate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Invoke@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dispidMember$ = 12					; size = 4
_riid$ = 16						; size = 4
_lcid$ = 20						; size = 4
_wFlags$ = 24						; size = 2
_pdispparams$ = 28					; size = 4
_pvarResult$ = 32					; size = 4
_pexcepinfo$ = 36					; size = 4
_puArgErr$ = 40						; size = 4
?Invoke@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z PROC ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::Invoke, COMDAT

; 5192 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5193 : 		return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_tih@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::_tih

; 5194 : 		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
; 5195 : 	}

  00008	5d		 pop	 ebp

; 5193 : 		return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,

  00009	e9 00 00 00 00	 jmp	 ?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ; ATL::CComTypeInfoHolder::Invoke
?Invoke@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJJABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ENDP ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::Invoke
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetIDsOfNames@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPA_WIKPAJ@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_rgszNames$ = 16					; size = 4
_cNames$ = 20						; size = 4
_lcid$ = 24						; size = 4
_rgdispid$ = 28						; size = 4
?GetIDsOfNames@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPA_WIKPAJ@Z PROC ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetIDsOfNames, COMDAT

; 5180 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5181 : 		return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);

  00003	ff 75 1c	 push	 DWORD PTR _rgdispid$[ebp]
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?_tih@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::_tih
  0000b	ff 75 18	 push	 DWORD PTR _lcid$[ebp]
  0000e	ff 75 14	 push	 DWORD PTR _cNames$[ebp]
  00011	ff 75 10	 push	 DWORD PTR _rgszNames$[ebp]
  00014	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  00017	e8 00 00 00 00	 call	 ?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z ; ATL::CComTypeInfoHolder::GetIDsOfNames

; 5182 : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 18 00	 ret	 24			; 00000018H
?GetIDsOfNames@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJABU_GUID@@PAPA_WIKPAJ@Z ENDP ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetIDsOfNames
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetTypeInfo@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_itinfo$ = 12						; size = 4
_lcid$ = 16						; size = 4
_pptinfo$ = 20						; size = 4
?GetTypeInfo@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z PROC ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetTypeInfo, COMDAT

; 5171 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4151 : 		if (itinfo != 0)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _itinfo$[ebp], 0
  00007	74 07		 je	 SHORT $LN4@GetTypeInf

; 4152 : 		{
; 4153 : 			return DISP_E_BADINDEX;

  00009	b8 0b 00 02 80	 mov	 eax, -2147352565	; 8002000bH
  0000e	eb 10		 jmp	 SHORT $LN3@GetTypeInf
$LN4@GetTypeInf:

; 4154 : 		}
; 4155 : 		return GetTI(lcid, pptinfo);

  00010	ff 75 14	 push	 DWORD PTR _pptinfo$[ebp]
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?_tih@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@1VCComTypeInfoHolder@2@A ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::_tih
  00018	ff 75 10	 push	 DWORD PTR _lcid$[ebp]
  0001b	e8 00 00 00 00	 call	 ?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::GetTI
$LN3@GetTypeInf:

; 5172 : 		return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
; 5173 : 	}

  00020	5d		 pop	 ebp
  00021	c2 10 00	 ret	 16			; 00000010H
?GetTypeInfo@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJIKPAPAUITypeInfo@@@Z ENDP ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetTypeInfo
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetTypeInfoCount@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pctinfo$ = 12						; size = 4
?GetTypeInfoCount@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z PROC ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetTypeInfoCount, COMDAT

; 5161 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5162 : 		if (pctinfo == NULL)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pctinfo$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	75 07		 jne	 SHORT $LN2@GetTypeInf

; 5163 : 			return E_POINTER;

  0000a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000f	eb 08		 jmp	 SHORT $LN1@GetTypeInf
$LN2@GetTypeInf:

; 5164 : 		*pctinfo = 1;

  00011	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 5165 : 		return S_OK;

  00017	33 c0		 xor	 eax, eax
$LN1@GetTypeInf:

; 5166 : 	}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?GetTypeInfoCount@?$IDispatchImpl@UIOPOSDeviceMonitor@@$1?IID_IOPOSDeviceMonitor@@3U_GUID@@B$1?LIBID_OposDeviceMonitor_CCO@@3U3@B$00$0A@VCComTypeInfoHolder@ATL@@@ATL@@UAGJPAI@Z ENDP ; ATL::IDispatchImpl<IOPOSDeviceMonitor,&IID_IOPOSDeviceMonitor,&LIBID_OposDeviceMonitor_CCO,1,0,ATL::CComTypeInfoHolder>::GetTypeInfoCount
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
;	COMDAT ??1OposVariant@@QAE@XZ
_TEXT	SEGMENT
??1OposVariant@@QAE@XZ PROC				; OposVariant::~OposVariant, COMDAT
; _this$ = ecx

; 78   :     ~OposVariant() { if (_bNeedClear) Clear(); }

  00000	80 79 10 00	 cmp	 BYTE PTR [ecx+16], 0
  00004	74 0b		 je	 SHORT $LN2@OposVarian

; 79   :     HRESULT Clear() { _bNeedClear = false; return VariantClear(this); }

  00006	51		 push	 ecx
  00007	c6 41 10 00	 mov	 BYTE PTR [ecx+16], 0
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN2@OposVarian:

; 78   :     ~OposVariant() { if (_bNeedClear) Clear(); }

  00011	c3		 ret	 0
??1OposVariant@@QAE@XZ ENDP				; OposVariant::~OposVariant
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\OposVariant.h
;	COMDAT ??0OposVariant@@QAE@XZ
_TEXT	SEGMENT
??0OposVariant@@QAE@XZ PROC				; OposVariant::OposVariant, COMDAT
; _this$ = ecx

; 77   :     OposVariant() { vt = VT_EMPTY; _bNeedClear = false; }

  00000	33 c0		 xor	 eax, eax
  00002	66 89 01	 mov	 WORD PTR [ecx], ax
  00005	88 41 10	 mov	 BYTE PTR [ecx+16], al
  00008	8b c1		 mov	 eax, ecx
  0000a	c3		 ret	 0
??0OposVariant@@QAE@XZ ENDP				; OposVariant::OposVariant
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??0?$CComQIPtr@UIOleControlSite@@$1?_GUID_b196b289_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??0?$CComQIPtr@UIOleControlSite@@$1?_GUID_b196b289_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z PROC ; ATL::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>, COMDAT
; _this$ = ecx

; 630  :     CComQIPtr(_Inout_opt_ IUnknown* lp) throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 631  :     {
; 632  :         if (lp != NULL)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _lp$[ebp]

; 165  :         p = NULL;

  00009	83 26 00	 and	 DWORD PTR [esi], 0

; 631  :     {
; 632  :         if (lp != NULL)

  0000c	85 c9		 test	 ecx, ecx
  0000e	74 12		 je	 SHORT $LN3@CComQIPtr

; 633  :         {
; 634  :             if (FAILED(lp->QueryInterface(*piid, (void **)&this->p)))

  00010	8b 01		 mov	 eax, DWORD PTR [ecx]
  00012	56		 push	 esi
  00013	68 00 00 00 00	 push	 OFFSET __GUID_b196b289_bab4_101a_b69c_00aa00341d07
  00018	51		 push	 ecx
  00019	ff 10		 call	 DWORD PTR [eax]
  0001b	85 c0		 test	 eax, eax
  0001d	79 03		 jns	 SHORT $LN3@CComQIPtr

; 635  :                 this->p = NULL;

  0001f	83 26 00	 and	 DWORD PTR [esi], 0
$LN3@CComQIPtr:

; 636  :         }
; 637  :     }

  00022	8b c6		 mov	 eax, esi
  00024	5e		 pop	 esi
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??0?$CComQIPtr@UIOleControlSite@@$1?_GUID_b196b289_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ENDP ; ATL::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnDrawAdvanced@CComControlBase@ATL@@UAEJAAUATL_DRAWINFO@@@Z
_TEXT	SEGMENT
tv274 = -32						; size = 4
_this$GSCopy$1$ = -28					; size = 4
_bDeleteDC$1$ = -24					; size = 4
_rectBoundsDP$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_di$ = 8						; size = 4
?OnDrawAdvanced@CComControlBase@ATL@@UAEJAAUATL_DRAWINFO@@@Z PROC ; ATL::CComControlBase::OnDrawAdvanced, COMDAT
; _this$ = ecx

; 1528 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1529 : 	BOOL bDeleteDC = FALSE;

  00010	83 65 e8 00	 and	 DWORD PTR _bDeleteDC$1$[ebp], 0
  00014	53		 push	 ebx
  00015	8b 5d 08	 mov	 ebx, DWORD PTR _di$[ebp]
  00018	56		 push	 esi
  00019	89 4d e4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx

; 1530 : 	if (di.hicTargetDev == NULL)

  0001c	83 7b 10 00	 cmp	 DWORD PTR [ebx+16], 0
  00020	75 1d		 jne	 SHORT $LN7@OnDrawAdva

; 1531 : 	{
; 1532 : 		di.hicTargetDev = AtlCreateTargetDC(di.hdcDraw, di.ptd);

  00022	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00025	ff 73 14	 push	 DWORD PTR [ebx+20]
  00028	e8 00 00 00 00	 call	 ?AtlCreateTargetDC@ATL@@YGPAUHDC__@@PAU2@PAUtagDVTARGETDEVICE@@@Z ; ATL::AtlCreateTargetDC

; 1533 : 		bDeleteDC = (di.hicTargetDev != di.hdcDraw);

  0002d	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  00030	33 c9		 xor	 ecx, ecx
  00032	3b c2		 cmp	 eax, edx
  00034	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  00037	0f 95 c1	 setne	 cl
  0003a	89 4d e8	 mov	 DWORD PTR _bDeleteDC$1$[ebp], ecx
  0003d	eb 03		 jmp	 SHORT $LN2@OnDrawAdva
$LN7@OnDrawAdva:
  0003f	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
$LN2@OnDrawAdva:

; 1534 : 	}
; 1535 : 	RECTL rectBoundsDP = *di.prcBounds;

  00042	8b 73 18	 mov	 esi, DWORD PTR [ebx+24]
  00045	57		 push	 edi
  00046	8d 7d ec	 lea	 edi, DWORD PTR _rectBoundsDP$[ebp]

; 1536 : 	BOOL bMetafile = GetDeviceCaps(di.hdcDraw, TECHNOLOGY) == DT_METAFILE;

  00049	6a 02		 push	 2
  0004b	a5		 movsd
  0004c	52		 push	 edx
  0004d	a5		 movsd
  0004e	a5		 movsd
  0004f	a5		 movsd
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8
  00056	33 c9		 xor	 ecx, ecx
  00058	83 f8 05	 cmp	 eax, 5
  0005b	0f 94 c1	 sete	 cl
  0005e	89 4d e0	 mov	 DWORD PTR tv274[ebp], ecx

; 1537 : 	if (!bMetafile)

  00061	74 42		 je	 SHORT $LN3@OnDrawAdva

; 1538 : 	{
; 1539 : 		::LPtoDP(di.hdcDraw, (LPPOINT)&rectBoundsDP, 2);

  00063	6a 02		 push	 2
  00065	8d 45 ec	 lea	 eax, DWORD PTR _rectBoundsDP$[ebp]
  00068	50		 push	 eax
  00069	ff 73 14	 push	 DWORD PTR [ebx+20]
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LPtoDP@12

; 1540 : 		SaveDC(di.hdcDraw);

  00072	ff 73 14	 push	 DWORD PTR [ebx+20]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SaveDC@4

; 1541 : 		SetMapMode(di.hdcDraw, MM_TEXT);

  0007b	33 f6		 xor	 esi, esi
  0007d	46		 inc	 esi
  0007e	56		 push	 esi
  0007f	ff 73 14	 push	 DWORD PTR [ebx+20]
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetMapMode@8

; 1542 : 		SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);

  00088	33 ff		 xor	 edi, edi
  0008a	57		 push	 edi
  0008b	57		 push	 edi
  0008c	57		 push	 edi
  0008d	ff 73 14	 push	 DWORD PTR [ebx+20]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowOrgEx@16

; 1543 : 		SetViewportOrgEx(di.hdcDraw, 0, 0, NULL);

  00096	57		 push	 edi
  00097	57		 push	 edi
  00098	57		 push	 edi
  00099	ff 73 14	 push	 DWORD PTR [ebx+20]
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetViewportOrgEx@16

; 1544 : 		di.bOptimize = TRUE; //since we save the DC we can do this

  000a2	89 73 20	 mov	 DWORD PTR [ebx+32], esi
$LN3@OnDrawAdva:

; 1545 : 	}
; 1546 : 	di.prcBounds = &rectBoundsDP;
; 1547 : 	GetZoomInfo(di);

  000a5	8b 75 e4	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  000a8	8d 45 ec	 lea	 eax, DWORD PTR _rectBoundsDP$[ebp]
  000ab	53		 push	 ebx
  000ac	8b ce		 mov	 ecx, esi
  000ae	89 43 18	 mov	 DWORD PTR [ebx+24], eax
  000b1	e8 00 00 00 00	 call	 ?GetZoomInfo@CComControlBase@ATL@@QAEXAAUATL_DRAWINFO@@@Z ; ATL::CComControlBase::GetZoomInfo

; 1548 : 
; 1549 : 	HRESULT hRes = OnDraw(di);

  000b6	8b 06		 mov	 eax, DWORD PTR [esi]
  000b8	8b ce		 mov	 ecx, esi
  000ba	53		 push	 ebx
  000bb	ff 50 10	 call	 DWORD PTR [eax+16]

; 1550 : 	if (bDeleteDC)

  000be	83 7d e8 00	 cmp	 DWORD PTR _bDeleteDC$1$[ebp], 0
  000c2	8b f0		 mov	 esi, eax
  000c4	5f		 pop	 edi
  000c5	74 09		 je	 SHORT $LN4@OnDrawAdva

; 1551 : 		::DeleteDC(di.hicTargetDev);

  000c7	ff 73 10	 push	 DWORD PTR [ebx+16]
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteDC@4
$LN4@OnDrawAdva:

; 1552 : 	if (!bMetafile)

  000d0	83 7d e0 00	 cmp	 DWORD PTR tv274[ebp], 0
  000d4	75 0b		 jne	 SHORT $LN5@OnDrawAdva

; 1553 : 		RestoreDC(di.hdcDraw, -1);

  000d6	6a ff		 push	 -1
  000d8	ff 73 14	 push	 DWORD PTR [ebx+20]
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RestoreDC@8
$LN5@OnDrawAdva:

; 1554 : 	return hRes;
; 1555 : }

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e4	8b c6		 mov	 eax, esi
  000e6	5e		 pop	 esi
  000e7	33 cd		 xor	 ecx, ebp
  000e9	5b		 pop	 ebx
  000ea	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ef	c9		 leave
  000f0	c2 04 00	 ret	 4
?OnDrawAdvanced@CComControlBase@ATL@@UAEJAAUATL_DRAWINFO@@@Z ENDP ; ATL::CComControlBase::OnDrawAdvanced
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnPaint@CComControlBase@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT
_di$ = -144						; size = 60
_ps$ = -84						; size = 64
_rc$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
_wParam$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?OnPaint@CComControlBase@ATL@@QAEJIIJAAH@Z PROC		; ATL::CComControlBase::OnPaint, COMDAT
; _this$ = ecx

; 1562 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	8b 7d 0c	 mov	 edi, DWORD PTR _wParam$[ebp]
  00019	8b f1		 mov	 esi, ecx

; 1563 : 	RECT rc;
; 1564 : 	PAINTSTRUCT ps;
; 1565 : 
; 1566 : 	HDC hdc = (wParam != 0) ? (HDC)wParam : ::BeginPaint(m_hWndCD, &ps);

  0001b	85 ff		 test	 edi, edi
  0001d	74 04		 je	 SHORT $LN5@OnPaint
  0001f	8b df		 mov	 ebx, edi
  00021	eb 15		 jmp	 SHORT $LN2@OnPaint
$LN5@OnPaint:
  00023	8d 45 ac	 lea	 eax, DWORD PTR _ps$[ebp]
  00026	50		 push	 eax
  00027	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0002a	ff 30		 push	 DWORD PTR [eax]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__BeginPaint@8
  00032	8b d8		 mov	 ebx, eax

; 1567 : 	if (hdc == NULL)

  00034	85 db		 test	 ebx, ebx
  00036	74 67		 je	 SHORT $LN3@OnPaint
$LN2@OnPaint:

; 1568 : 		return 0;
; 1569 : 	::GetClientRect(m_hWndCD, &rc);

  00038	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  0003b	8d 45 ec	 lea	 eax, DWORD PTR _rc$[ebp]
  0003e	50		 push	 eax
  0003f	ff 31		 push	 DWORD PTR [ecx]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClientRect@8

; 1570 : 
; 1571 : 	ATL_DRAWINFO di;
; 1572 : 	memset(&di, 0, sizeof(di));

  00047	6a 3c		 push	 60			; 0000003cH
  00049	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _di$[ebp]
  0004f	6a 00		 push	 0
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 _memset

; 1573 : 	di.cbSize = sizeof(di);
; 1574 : 	di.dwDrawAspect = DVASPECT_CONTENT;
; 1575 : 	di.lindex = -1;

  00057	83 8d 78 ff ff
	ff ff		 or	 DWORD PTR _di$[ebp+8], -1

; 1576 : 	di.hdcDraw = hdc;
; 1577 : 	di.prcBounds = (LPCRECTL)&rc;

  0005e	8d 45 ec	 lea	 eax, DWORD PTR _rc$[ebp]
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	89 45 88	 mov	 DWORD PTR _di$[ebp+24], eax

; 1578 : 
; 1579 : 	OnDrawAdvanced(di);

  00067	8b 06		 mov	 eax, DWORD PTR [esi]
  00069	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _di$[ebp]
  0006f	c7 85 70 ff ff
	ff 3c 00 00 00	 mov	 DWORD PTR _di$[ebp], 60	; 0000003cH
  00079	c7 85 74 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _di$[ebp+4], 1
  00083	51		 push	 ecx
  00084	8b ce		 mov	 ecx, esi
  00086	89 5d 84	 mov	 DWORD PTR _di$[ebp+20], ebx
  00089	ff 50 0c	 call	 DWORD PTR [eax+12]

; 1580 : 	if (wParam == 0)

  0008c	85 ff		 test	 edi, edi
  0008e	75 0f		 jne	 SHORT $LN3@OnPaint

; 1581 : 		::EndPaint(m_hWndCD, &ps);

  00090	8d 45 ac	 lea	 eax, DWORD PTR _ps$[ebp]
  00093	50		 push	 eax
  00094	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00097	ff 30		 push	 DWORD PTR [eax]
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EndPaint@8
$LN3@OnPaint:

; 1582 : 	return 0;
; 1583 : }

  0009f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a2	33 c0		 xor	 eax, eax
  000a4	5f		 pop	 edi
  000a5	5e		 pop	 esi
  000a6	33 cd		 xor	 ecx, ebp
  000a8	5b		 pop	 ebx
  000a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ae	c9		 leave
  000af	c2 10 00	 ret	 16			; 00000010H
?OnPaint@CComControlBase@ATL@@QAEJIIJAAH@Z ENDP		; ATL::CComControlBase::OnPaint
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?FireViewChange@CComControlBase@ATL@@QAEJXZ
_TEXT	SEGMENT
?FireViewChange@CComControlBase@ATL@@QAEJXZ PROC	; ATL::CComControlBase::FireViewChange, COMDAT
; _this$ = ecx

; 1487 : 	if (m_bInPlaceActive)

  00000	f6 41 44 04	 test	 BYTE PTR [ecx+68], 4
  00004	74 2f		 je	 SHORT $LN2@FireViewCh

; 1488 : 	{
; 1489 : 		// Active
; 1490 : 		if (m_hWndCD != NULL)

  00006	8b 41 3c	 mov	 eax, DWORD PTR [ecx+60]
  00009	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000c	74 0e		 je	 SHORT $LN4@FireViewCh

; 1491 : 			::InvalidateRect(m_hWndCD, NULL, TRUE); // Window based

  0000e	6a 01		 push	 1
  00010	6a 00		 push	 0
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InvalidateRect@12
  0001a	eb 2a		 jmp	 SHORT $LN13@FireViewCh
$LN4@FireViewCh:

; 1492 : 		else if (m_bWndLess && m_spInPlaceSite != NULL)

  0001c	f6 41 44 02	 test	 BYTE PTR [ecx+68], 2
  00020	74 24		 je	 SHORT $LN13@FireViewCh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00022	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00025	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1492 : 		else if (m_bWndLess && m_spInPlaceSite != NULL)

  00027	74 1d		 je	 SHORT $LN13@FireViewCh

; 1493 : 			m_spInPlaceSite->InvalidateRect(NULL, TRUE); // Windowless

  00029	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002b	6a 01		 push	 1
  0002d	6a 00		 push	 0
  0002f	51		 push	 ecx
  00030	ff 50 64	 call	 DWORD PTR [eax+100]

; 1494 : 	}

  00033	eb 11		 jmp	 SHORT $LN13@FireViewCh
$LN2@FireViewCh:

; 260  : 		if (m_spAdviseSink)

  00035	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00038	85 c9		 test	 ecx, ecx
  0003a	74 0a		 je	 SHORT $LN13@FireViewCh

; 261  : 			m_spAdviseSink->OnViewChange(dwAspect, lindex);

  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	6a ff		 push	 -1
  00040	6a 01		 push	 1
  00042	51		 push	 ecx
  00043	ff 50 10	 call	 DWORD PTR [eax+16]
$LN13@FireViewCh:

; 1495 : 	else // Inactive
; 1496 : 		SendOnViewChange(DVASPECT_CONTENT);
; 1497 : 	return S_OK;

  00046	33 c0		 xor	 eax, eax

; 1498 : }

  00048	c3		 ret	 0
?FireViewChange@CComControlBase@ATL@@QAEJXZ ENDP	; ATL::CComControlBase::FireViewChange
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IDataObject_GetData@CComControlBase@ATL@@QAEJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z
_TEXT	SEGMENT
_di$ = -100						; size = 60
_size$ = -40						; size = 8
_sizeMetric$1$ = -32					; size = 4
_sizeMetric$ = -28					; size = 8
_hMF$1$ = -24						; size = 4
_rectl$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_pformatetcIn$ = 8					; size = 4
_pmedium$ = 12						; size = 4
?IDataObject_GetData@CComControlBase@ATL@@QAEJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z PROC ; ATL::CComControlBase::IDataObject_GetData, COMDAT
; _this$ = ecx

; 1415 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _pmedium$[ebp]
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx

; 1416 : 	if (pmedium == NULL)

  00017	85 db		 test	 ebx, ebx
  00019	75 0a		 jne	 SHORT $LN8@IDataObjec

; 1417 : 		return E_POINTER;

  0001b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00020	e9 66 01 00 00	 jmp	 $LN1@IDataObjec
$LN8@IDataObjec:
  00025	57		 push	 edi

; 1418 : 	memset(pmedium, 0, sizeof(STGMEDIUM));

  00026	33 c0		 xor	 eax, eax
  00028	8b fb		 mov	 edi, ebx
  0002a	ab		 stosd
  0002b	ab		 stosd
  0002c	ab		 stosd

; 1419 : 	ATLTRACE(atlTraceControls,2,_T("Format = %x\n"), pformatetcIn->cfFormat);
; 1420 : 	ATLTRACE(atlTraceControls,2,_T("TYMED = %x\n"), pformatetcIn->tymed);
; 1421 : 
; 1422 : 	if ((pformatetcIn->tymed & TYMED_MFPICT) == 0)

  0002d	8b 45 08	 mov	 eax, DWORD PTR _pformatetcIn$[ebp]
  00030	f6 40 10 20	 test	 BYTE PTR [eax+16], 32	; 00000020H
  00034	75 0a		 jne	 SHORT $LN9@IDataObjec

; 1423 : 		return DATA_E_FORMATETC;

  00036	b8 64 00 04 80	 mov	 eax, -2147221404	; 80040064H
  0003b	e9 4a 01 00 00	 jmp	 $LN18@IDataObjec
$LN9@IDataObjec:

; 1424 : 
; 1425 : 	SIZEL sizeMetric, size;
; 1426 : 	if (m_bDrawFromNatural)

  00040	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00043	f7 c1 00 10 00
	00		 test	 ecx, 4096		; 00001000H
  00049	74 08		 je	 SHORT $LN10@IDataObjec

; 1427 : 		sizeMetric = m_sizeNatural;

  0004b	8b 7e 1c	 mov	 edi, DWORD PTR [esi+28]
  0004e	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00051	eb 06		 jmp	 SHORT $LN20@IDataObjec
$LN10@IDataObjec:

; 1428 : 	else
; 1429 : 		sizeMetric = m_sizeExtent;

  00053	8b 7e 24	 mov	 edi, DWORD PTR [esi+36]
  00056	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
$LN20@IDataObjec:

; 1430 : 	if (!m_bDrawGetDataInHimetric)

  00059	89 45 e8	 mov	 DWORD PTR _sizeMetric$[ebp+4], eax
  0005c	89 7d e4	 mov	 DWORD PTR _sizeMetric$[ebp], edi
  0005f	89 45 e0	 mov	 DWORD PTR _sizeMetric$1$[ebp], eax
  00062	f7 c1 00 20 00
	00		 test	 ecx, 8192		; 00002000H
  00068	75 18		 jne	 SHORT $LN12@IDataObjec

; 1431 : 		AtlHiMetricToPixel(&sizeMetric, &size);

  0006a	8d 45 d8	 lea	 eax, DWORD PTR _size$[ebp]
  0006d	50		 push	 eax
  0006e	8d 45 e4	 lea	 eax, DWORD PTR _sizeMetric$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ?AtlHiMetricToPixel@ATL@@YGXPBUtagSIZE@@PAU2@@Z ; ATL::AtlHiMetricToPixel
  00077	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  0007a	8b 45 dc	 mov	 eax, DWORD PTR _size$[ebp+4]
  0007d	8b 55 d8	 mov	 edx, DWORD PTR _size$[ebp]
  00080	eb 02		 jmp	 SHORT $LN13@IDataObjec
$LN12@IDataObjec:

; 1432 : 	else
; 1433 : 		size = sizeMetric;

  00082	8b d7		 mov	 edx, edi
$LN13@IDataObjec:

; 1434 : 	RECTL rectl = {0 ,0, size.cx, size.cy};

  00084	83 65 ec 00	 and	 DWORD PTR _rectl$[ebp], 0
  00088	0f 57 c0	 xorps	 xmm0, xmm0
  0008b	83 65 f0 00	 and	 DWORD PTR _rectl$[ebp+4], 0

; 1435 : 
; 1436 : 	ATL_DRAWINFO di;
; 1437 : 	memset(&di, 0, sizeof(di));
; 1438 : 	di.cbSize = sizeof(di);
; 1439 : 	di.dwDrawAspect = DVASPECT_CONTENT;
; 1440 : 	di.lindex = -1;

  0008f	83 4d a4 ff	 or	 DWORD PTR _di$[ebp+8], -1
  00093	89 55 f4	 mov	 DWORD PTR _rectl$[ebp+8], edx
  00096	33 d2		 xor	 edx, edx
  00098	89 45 f8	 mov	 DWORD PTR _rectl$[ebp+12], eax
  0009b	42		 inc	 edx
  0009c	33 c0		 xor	 eax, eax

; 1441 : 	di.ptd = NULL;
; 1442 : 	di.hicTargetDev = NULL;
; 1443 : 	di.prcBounds = &rectl;
; 1444 : 	di.prcWBounds = &rectl;
; 1445 : 	di.bOptimize = TRUE; //we do a SaveDC/RestoreDC
; 1446 : 	di.bRectInHimetric = m_bDrawGetDataInHimetric;

  0009e	c1 e9 0d	 shr	 ecx, 13			; 0000000dH
  000a1	89 45 b0	 mov	 DWORD PTR _di$[ebp+20], eax
  000a4	23 ca		 and	 ecx, edx
  000a6	89 45 c0	 mov	 DWORD PTR _di$[ebp+36], eax
  000a9	89 45 a8	 mov	 DWORD PTR _di$[ebp+12], eax
  000ac	89 45 ac	 mov	 DWORD PTR _di$[ebp+16], eax
  000af	8d 45 ec	 lea	 eax, DWORD PTR _rectl$[ebp]

; 1447 : 	// create appropriate memory metafile DC
; 1448 : 	di.hdcDraw = CreateMetaFile(NULL);

  000b2	6a 00		 push	 0
  000b4	66 0f 13 45 c8	 movlpd	 QWORD PTR _di$[ebp+44], xmm0
  000b9	66 0f 13 45 d0	 movlpd	 QWORD PTR _di$[ebp+52], xmm0
  000be	c7 45 9c 3c 00
	00 00		 mov	 DWORD PTR _di$[ebp], 60	; 0000003cH
  000c5	89 55 a0	 mov	 DWORD PTR _di$[ebp+4], edx
  000c8	89 45 b4	 mov	 DWORD PTR _di$[ebp+24], eax
  000cb	89 45 b8	 mov	 DWORD PTR _di$[ebp+28], eax
  000ce	89 55 bc	 mov	 DWORD PTR _di$[ebp+32], edx
  000d1	89 4d c4	 mov	 DWORD PTR _di$[ebp+40], ecx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateMetaFileW@4

; 1449 : 
; 1450 : 	// create attribute DC according to pformatetcIn->ptd
; 1451 : 
; 1452 : 	SaveDC(di.hdcDraw);

  000da	50		 push	 eax
  000db	89 45 b0	 mov	 DWORD PTR _di$[ebp+20], eax
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SaveDC@4

; 1453 : 	SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);

  000e4	33 c0		 xor	 eax, eax
  000e6	50		 push	 eax
  000e7	50		 push	 eax
  000e8	50		 push	 eax
  000e9	ff 75 b0	 push	 DWORD PTR _di$[ebp+20]
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowOrgEx@16

; 1454 : 	SetWindowExtEx(di.hdcDraw, rectl.right, rectl.bottom, NULL);

  000f2	6a 00		 push	 0
  000f4	ff 75 f8	 push	 DWORD PTR _rectl$[ebp+12]
  000f7	ff 75 f4	 push	 DWORD PTR _rectl$[ebp+8]
  000fa	ff 75 b0	 push	 DWORD PTR _di$[ebp+20]
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowExtEx@16

; 1455 : 	OnDrawAdvanced(di);

  00103	8b 06		 mov	 eax, DWORD PTR [esi]
  00105	8d 4d 9c	 lea	 ecx, DWORD PTR _di$[ebp]
  00108	51		 push	 ecx
  00109	8b ce		 mov	 ecx, esi
  0010b	ff 50 0c	 call	 DWORD PTR [eax+12]

; 1456 : 	RestoreDC(di.hdcDraw, -1);

  0010e	6a ff		 push	 -1
  00110	ff 75 b0	 push	 DWORD PTR _di$[ebp+20]
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RestoreDC@8

; 1457 : 
; 1458 : 	HMETAFILE hMF = CloseMetaFile(di.hdcDraw);

  00119	ff 75 b0	 push	 DWORD PTR _di$[ebp+20]
  0011c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseMetaFile@4
  00122	89 45 e8	 mov	 DWORD PTR _hMF$1$[ebp], eax

; 1459 : 	if (hMF == NULL)

  00125	85 c0		 test	 eax, eax
  00127	75 07		 jne	 SHORT $LN14@IDataObjec

; 1460 : 		return E_UNEXPECTED;

  00129	b8 ff ff 00 80	 mov	 eax, -2147418113	; 8000ffffH
  0012e	eb 5a		 jmp	 SHORT $LN18@IDataObjec
$LN14@IDataObjec:

; 1461 : 
; 1462 : 	HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(METAFILEPICT));

  00130	6a 10		 push	 16			; 00000010H
  00132	68 02 20 00 00	 push	 8194			; 00002002H
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalAlloc@8
  0013d	8b f0		 mov	 esi, eax

; 1463 : 
; 1464 : 	if (NULL==hMem)

  0013f	85 f6		 test	 esi, esi
  00141	75 11		 jne	 SHORT $LN15@IDataObjec

; 1465 : 	{
; 1466 : 		DeleteMetaFile(hMF);

  00143	8b 4d e8	 mov	 ecx, DWORD PTR _hMF$1$[ebp]
  00146	51		 push	 ecx
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteMetaFile@4

; 1467 : 		return ResultFromScode(STG_E_MEDIUMFULL);

  0014d	b8 70 00 03 80	 mov	 eax, -2147286928	; 80030070H
  00152	eb 36		 jmp	 SHORT $LN18@IDataObjec
$LN15@IDataObjec:

; 1468 : 	}
; 1469 : 
; 1470 : 	LPMETAFILEPICT pMF=(LPMETAFILEPICT)GlobalLock(hMem);

  00154	56		 push	 esi
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4

; 1471 : 	ATLENSURE(pMF);

  0015b	85 c0		 test	 eax, eax
  0015d	74 3c		 je	 SHORT $LN22@IDataObjec

; 1472 : 	pMF->hMF=hMF;

  0015f	8b 4d e8	 mov	 ecx, DWORD PTR _hMF$1$[ebp]
  00162	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 1473 : 	pMF->mm=MM_ANISOTROPIC;
; 1474 : 	pMF->xExt=sizeMetric.cx;
; 1475 : 	pMF->yExt=sizeMetric.cy;

  00165	8b 4d e0	 mov	 ecx, DWORD PTR _sizeMetric$1$[ebp]

; 1476 : 	GlobalUnlock(hMem);

  00168	56		 push	 esi
  00169	c7 00 08 00 00
	00		 mov	 DWORD PTR [eax], 8
  0016f	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00172	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 1477 : 
; 1478 : 	pmedium->tymed = TYMED_MFPICT;
; 1479 : 	pmedium->hGlobal = hMem;
; 1480 : 	pmedium->pUnkForRelease = NULL;

  0017b	83 63 08 00	 and	 DWORD PTR [ebx+8], 0

; 1481 : 
; 1482 : 	return S_OK;

  0017f	33 c0		 xor	 eax, eax
  00181	c7 03 20 00 00
	00		 mov	 DWORD PTR [ebx], 32	; 00000020H
  00187	89 73 04	 mov	 DWORD PTR [ebx+4], esi
$LN18@IDataObjec:
  0018a	5f		 pop	 edi
$LN1@IDataObjec:

; 1483 : }

  0018b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018e	5e		 pop	 esi
  0018f	33 cd		 xor	 ecx, ebp
  00191	5b		 pop	 ebx
  00192	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00197	c9		 leave
  00198	c2 08 00	 ret	 8
$LN22@IDataObjec:

; 1471 : 	ATLENSURE(pMF);

  0019b	68 05 40 00 80	 push	 -2147467259		; 80004005H
  001a0	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN19@IDataObjec:
  001a5	cc		 int	 3
?IDataObject_GetData@CComControlBase@ATL@@QAEJPAUtagFORMATETC@@PAUtagSTGMEDIUM@@@Z ENDP ; ATL::CComControlBase::IDataObject_GetData
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IViewObject_Draw@CComControlBase@ATL@@QAEJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3@Z
_TEXT	SEGMENT
_di$ = -60						; size = 60
_dwDrawAspect$ = 8					; size = 4
_lindex$ = 12						; size = 4
_pvAspect$ = 16						; size = 4
_ptd$ = 20						; size = 4
_hicTargetDev$ = 24					; size = 4
_hdcDraw$ = 28						; size = 4
_prcBounds$ = 32					; size = 4
_prcWBounds$ = 36					; size = 4
?IViewObject_Draw@CComControlBase@ATL@@QAEJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3@Z PROC ; ATL::CComControlBase::IViewObject_Draw, COMDAT
; _this$ = ecx

; 1353 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	56		 push	 esi

; 1354 : 	ATLTRACE(atlTraceControls,2,_T("Draw dwDrawAspect=%x lindex=%d ptd=%x hic=%x hdc=%x\n"),
; 1355 : 		dwDrawAspect, lindex, reinterpret_cast<ULONG_PTR>(ptd),
; 1356 : 			reinterpret_cast<ULONG_PTR>(hicTargetDev), reinterpret_cast<ULONG_PTR>(hdcDraw));
; 1357 : #ifdef _DEBUG
; 1358 : 	if (prcBounds == NULL)
; 1359 : 		ATLTRACE(atlTraceControls,2,_T("\tprcBounds=NULL\n"));
; 1360 : 	else
; 1361 : 		ATLTRACE(atlTraceControls,2,_T("\tprcBounds=%d,%d,%d,%d\n"), prcBounds->left,
; 1362 : 			prcBounds->top, prcBounds->right, prcBounds->bottom);
; 1363 : 	if (prcWBounds == NULL)
; 1364 : 		ATLTRACE(atlTraceControls,2,_T("\tprcWBounds=NULL\n"));
; 1365 : 	else
; 1366 : 		ATLTRACE(atlTraceControls,2,_T("\tprcWBounds=%d,%d,%d,%d\n"), prcWBounds->left,
; 1367 : 			prcWBounds->top, prcWBounds->right, prcWBounds->bottom);
; 1368 : #endif
; 1369 : 
; 1370 : 	if (prcBounds == NULL)

  00007	8b 75 20	 mov	 esi, DWORD PTR _prcBounds$[ebp]
  0000a	85 f6		 test	 esi, esi
  0000c	75 13		 jne	 SHORT $LN4@IViewObjec

; 1371 : 	{
; 1372 : 		if (!m_bWndLess)

  0000e	f6 41 44 02	 test	 BYTE PTR [ecx+68], 2
  00012	75 0a		 jne	 SHORT $LN5@IViewObjec

; 1373 : 			return E_INVALIDARG;

  00014	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00019	e9 85 00 00 00	 jmp	 $LN1@IViewObjec
$LN5@IViewObjec:

; 1374 : 		prcBounds = (RECTL*)&m_rcPos;

  0001e	8d 71 2c	 lea	 esi, DWORD PTR [ecx+44]
$LN4@IViewObjec:
  00021	53		 push	 ebx

; 1375 : 	}
; 1376 : 
; 1377 : 	// support the aspects required for multi-pass drawing
; 1378 : 	switch (dwDrawAspect)

  00022	8b 5d 08	 mov	 ebx, DWORD PTR _dwDrawAspect$[ebp]
  00025	8b c3		 mov	 eax, ebx
  00027	83 e8 01	 sub	 eax, 1
  0002a	74 11		 je	 SHORT $LN6@IViewObjec
  0002c	83 e8 0f	 sub	 eax, 15			; 0000000fH
  0002f	74 0c		 je	 SHORT $LN6@IViewObjec
  00031	83 e8 10	 sub	 eax, 16			; 00000010H
  00034	74 07		 je	 SHORT $LN6@IViewObjec

; 1379 : 	{
; 1380 : 		case DVASPECT_CONTENT:
; 1381 : 		case DVASPECT_OPAQUE:
; 1382 : 		case DVASPECT_TRANSPARENT:
; 1383 : 			break;
; 1384 : 		default:
; 1385 : 			ATLASSERT(FALSE);
; 1386 : 			return DV_E_DVASPECT;

  00036	b8 6b 00 04 80	 mov	 eax, -2147221397	; 8004006bH
  0003b	eb 65		 jmp	 SHORT $LN11@IViewObjec
$LN6@IViewObjec:

; 1387 : 			break;
; 1388 : 	}
; 1389 : 
; 1390 : 	// make sure nobody forgets to do this
; 1391 : 	if (ptd == NULL)
; 1392 : 		hicTargetDev = NULL;
; 1393 : 
; 1394 : 	BOOL bOptimize = FALSE;
; 1395 : 	if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb >= sizeof(DVASPECTINFO))

  0003d	8b 45 10	 mov	 eax, DWORD PTR _pvAspect$[ebp]
  00040	57		 push	 edi
  00041	33 ff		 xor	 edi, edi
  00043	39 7d 14	 cmp	 DWORD PTR _ptd$[ebp], edi
  00046	0f 45 7d 18	 cmovne	 edi, DWORD PTR _hicTargetDev$[ebp]
  0004a	33 d2		 xor	 edx, edx
  0004c	85 c0		 test	 eax, eax
  0004e	74 0b		 je	 SHORT $LN9@IViewObjec
  00050	83 38 08	 cmp	 DWORD PTR [eax], 8
  00053	72 06		 jb	 SHORT $LN9@IViewObjec

; 1396 : 		bOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE);

  00055	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00058	83 e2 01	 and	 edx, 1
$LN9@IViewObjec:

; 1397 : 
; 1398 : 	ATL_DRAWINFO di;
; 1399 : 	memset(&di, 0, sizeof(di));
; 1400 : 	di.cbSize = sizeof(di);
; 1401 : 	di.dwDrawAspect = dwDrawAspect;
; 1402 : 	di.lindex = lindex;

  0005b	8b 45 0c	 mov	 eax, DWORD PTR _lindex$[ebp]
  0005e	0f 57 c0	 xorps	 xmm0, xmm0
  00061	89 45 cc	 mov	 DWORD PTR _di$[ebp+8], eax

; 1403 : 	di.ptd = ptd;

  00064	8b 45 14	 mov	 eax, DWORD PTR _ptd$[ebp]
  00067	89 45 d0	 mov	 DWORD PTR _di$[ebp+12], eax

; 1404 : 	di.hicTargetDev = hicTargetDev;
; 1405 : 	di.hdcDraw = hdcDraw;

  0006a	8b 45 1c	 mov	 eax, DWORD PTR _hdcDraw$[ebp]
  0006d	89 45 d8	 mov	 DWORD PTR _di$[ebp+20], eax

; 1406 : 	di.prcBounds = prcBounds;
; 1407 : 	di.prcWBounds = prcWBounds;

  00070	8b 45 24	 mov	 eax, DWORD PTR _prcWBounds$[ebp]
  00073	89 45 e0	 mov	 DWORD PTR _di$[ebp+28], eax

; 1408 : 	di.bOptimize = bOptimize;
; 1409 : 	return OnDrawAdvanced(di);

  00076	8b 01		 mov	 eax, DWORD PTR [ecx]
  00078	89 55 e4	 mov	 DWORD PTR _di$[ebp+32], edx
  0007b	8d 55 c4	 lea	 edx, DWORD PTR _di$[ebp]
  0007e	52		 push	 edx
  0007f	66 0f 13 45 e8	 movlpd	 QWORD PTR _di$[ebp+36], xmm0
  00084	66 0f 13 45 f0	 movlpd	 QWORD PTR _di$[ebp+44], xmm0
  00089	66 0f 13 45 f8	 movlpd	 QWORD PTR _di$[ebp+52], xmm0
  0008e	c7 45 c4 3c 00
	00 00		 mov	 DWORD PTR _di$[ebp], 60	; 0000003cH
  00095	89 5d c8	 mov	 DWORD PTR _di$[ebp+4], ebx
  00098	89 7d d4	 mov	 DWORD PTR _di$[ebp+16], edi
  0009b	89 75 dc	 mov	 DWORD PTR _di$[ebp+24], esi
  0009e	ff 50 0c	 call	 DWORD PTR [eax+12]
  000a1	5f		 pop	 edi
$LN11@IViewObjec:
  000a2	5b		 pop	 ebx
$LN1@IViewObjec:
  000a3	5e		 pop	 esi

; 1410 : }

  000a4	c9		 leave
  000a5	c2 20 00	 ret	 32			; 00000020H
?IViewObject_Draw@CComControlBase@ATL@@QAEJKJPAXPAUtagDVTARGETDEVICE@@PAUHDC__@@2PBU_RECTL@@3@Z ENDP ; ATL::CComControlBase::IViewObject_Draw
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IOleInPlaceObject_SetObjectRects@CComControlBase@ATL@@QAEJPBUtagRECT@@0@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -24					; size = 4
_rcIXect$2 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_prcPos$ = 8						; size = 4
_prcClip$ = 12						; size = 4
?IOleInPlaceObject_SetObjectRects@CComControlBase@ATL@@QAEJPBUtagRECT@@0@Z PROC ; ATL::CComControlBase::IOleInPlaceObject_SetObjectRects, COMDAT
; _this$ = ecx

; 1277 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _prcClip$[ebp]
  00013	8b c1		 mov	 eax, ecx
  00015	53		 push	 ebx
  00016	8b 5d 08	 mov	 ebx, DWORD PTR _prcPos$[ebp]
  00019	89 45 e8	 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax

; 1278 : 	if (prcPos == NULL || prcClip == NULL)

  0001c	85 db		 test	 ebx, ebx
  0001e	0f 84 95 00 00
	00		 je	 $LN3@IOleInPlac
  00024	85 d2		 test	 edx, edx
  00026	0f 84 8d 00 00
	00		 je	 $LN3@IOleInPlac

; 1280 : 
; 1281 : 	m_rcPos = *prcPos;

  0002c	56		 push	 esi
  0002d	57		 push	 edi
  0002e	8b f3		 mov	 esi, ebx
  00030	8d 78 2c	 lea	 edi, DWORD PTR [eax+44]

; 1282 : 	if (m_hWndCD)

  00033	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00036	a5		 movsd
  00037	a5		 movsd
  00038	a5		 movsd
  00039	a5		 movsd
  0003a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003d	74 74		 je	 SHORT $LN4@IOleInPlac

; 1283 : 	{
; 1284 : 		// the container wants us to clip, so figure out if we really
; 1285 : 		// need to
; 1286 : 		//
; 1287 : 		RECT rcIXect;
; 1288 : 		BOOL b = IntersectRect(&rcIXect, prcPos, prcClip);

  0003f	52		 push	 edx
  00040	53		 push	 ebx
  00041	8d 45 ec	 lea	 eax, DWORD PTR _rcIXect$2[ebp]

; 1289 : 		HRGN tempRgn = NULL;

  00044	33 f6		 xor	 esi, esi
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IntersectRect@12

; 1290 : 		if (b && !EqualRect(&rcIXect, prcPos))

  0004d	85 c0		 test	 eax, eax
  0004f	74 30		 je	 SHORT $LN5@IOleInPlac
  00051	53		 push	 ebx
  00052	8d 45 ec	 lea	 eax, DWORD PTR _rcIXect$2[ebp]
  00055	50		 push	 eax
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EqualRect@8
  0005c	85 c0		 test	 eax, eax
  0005e	75 21		 jne	 SHORT $LN5@IOleInPlac

; 1291 : 		{
; 1292 : 			OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));

  00060	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00063	f7 d8		 neg	 eax
  00065	50		 push	 eax
  00066	8b 03		 mov	 eax, DWORD PTR [ebx]
  00068	f7 d8		 neg	 eax
  0006a	50		 push	 eax
  0006b	8d 45 ec	 lea	 eax, DWORD PTR _rcIXect$2[ebp]
  0006e	50		 push	 eax
  0006f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OffsetRect@12

; 1293 : 			tempRgn = CreateRectRgnIndirect(&rcIXect);

  00075	8d 45 ec	 lea	 eax, DWORD PTR _rcIXect$2[ebp]
  00078	50		 push	 eax
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateRectRgnIndirect@4
  0007f	8b f0		 mov	 esi, eax
$LN5@IOleInPlac:

; 1294 : 		}
; 1295 : 
; 1296 : 		SetWindowRgn(m_hWndCD, tempRgn, TRUE);

  00081	6a 01		 push	 1
  00083	56		 push	 esi
  00084	8b 75 e8	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00087	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0008a	ff 30		 push	 DWORD PTR [eax]
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowRgn@12

; 1297 : 
; 1298 : 		// set our control's location, but don't change it's size at all
; 1299 : 		// [people for whom zooming is important should set that up here]
; 1300 : 		//
; 1301 : 		SIZEL size = {prcPos->right - prcPos->left, prcPos->bottom - prcPos->top};

  00092	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00095	2b 43 04	 sub	 eax, DWORD PTR [ebx+4]
  00098	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0009b	2b 0b		 sub	 ecx, DWORD PTR [ebx]

; 1302 : 		SetWindowPos(m_hWndCD, NULL, prcPos->left,

  0009d	6a 14		 push	 20			; 00000014H
  0009f	50		 push	 eax
  000a0	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  000a3	51		 push	 ecx
  000a4	ff 73 04	 push	 DWORD PTR [ebx+4]
  000a7	ff 33		 push	 DWORD PTR [ebx]
  000a9	6a 00		 push	 0
  000ab	ff 30		 push	 DWORD PTR [eax]
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowPos@28
$LN4@IOleInPlac:

; 1303 : 					 prcPos->top, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
; 1304 : 	}
; 1305 : 
; 1306 : 	return S_OK;

  000b3	5f		 pop	 edi
  000b4	33 c0		 xor	 eax, eax
  000b6	5e		 pop	 esi
  000b7	eb 05		 jmp	 SHORT $LN1@IOleInPlac
$LN3@IOleInPlac:

; 1279 : 		return E_POINTER;

  000b9	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@IOleInPlac:

; 1307 : }

  000be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c1	33 cd		 xor	 ecx, ebp
  000c3	5b		 pop	 ebx
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	c9		 leave
  000ca	c2 08 00	 ret	 8
?IOleInPlaceObject_SetObjectRects@CComControlBase@ATL@@QAEJPBUtagRECT@@0@Z ENDP ; ATL::CComControlBase::IOleInPlaceObject_SetObjectRects
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IOleInPlaceObject_UIDeactivate@CComControlBase@ATL@@QAEJXZ
_TEXT	SEGMENT
_frameInfo$1 = -68					; size = 20
_hwndParent$ = -48					; size = 4
_spInPlaceFrame$2 = -44					; size = 4
_spInPlaceUIWindow$3 = -40				; size = 4
_rcPos$4 = -36						; size = 16
_rcClip$5 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?IOleInPlaceObject_UIDeactivate@CComControlBase@ATL@@QAEJXZ PROC ; ATL::CComControlBase::IOleInPlaceObject_UIDeactivate, COMDAT
; _this$ = ecx

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b f1		 mov	 esi, ecx

; 1241 : 	// if we're not UIActive, not much to do.
; 1242 : 	if (!m_bUIActive)

  00013	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00016	a8 08		 test	 al, 8
  00018	0f 84 95 00 00
	00		 je	 $LN3@IOleInPlac

; 1243 : 		return S_OK;
; 1244 : 
; 1245 : 	m_bUIActive = FALSE;
; 1246 : 
; 1247 : 	HWND hwndParent;
; 1248 : 	// This call to GetWindow is a fix for Delphi
; 1249 : 	if (m_spInPlaceSite)

  0001e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00021	83 e0 f7	 and	 eax, -9			; fffffff7H
  00024	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00027	85 c9		 test	 ecx, ecx
  00029	0f 84 84 00 00
	00		 je	 $LN3@IOleInPlac

; 1250 : 	{
; 1251 : 		if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)

  0002f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00031	8d 55 d0	 lea	 edx, DWORD PTR _hwndParent$[ebp]
  00034	57		 push	 edi
  00035	52		 push	 edx
  00036	51		 push	 ecx
  00037	ff 50 0c	 call	 DWORD PTR [eax+12]
  0003a	33 ff		 xor	 edi, edi
  0003c	85 c0		 test	 eax, eax
  0003e	75 68		 jne	 SHORT $LN24@IOleInPlac

; 1260 : 			m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,

  00040	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00043	8d 55 bc	 lea	 edx, DWORD PTR _frameInfo$1[ebp]
  00046	52		 push	 edx
  00047	8d 55 ec	 lea	 edx, DWORD PTR _rcClip$5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0004a	89 7d d4	 mov	 DWORD PTR _spInPlaceFrame$2[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1260 : 			m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,

  0004d	52		 push	 edx
  0004e	8d 55 dc	 lea	 edx, DWORD PTR _rcPos$4[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00051	89 7d d8	 mov	 DWORD PTR _spInPlaceUIWindow$3[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1260 : 			m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,

  00054	52		 push	 edx
  00055	8d 55 d8	 lea	 edx, DWORD PTR _spInPlaceUIWindow$3[ebp]
  00058	c7 45 bc 14 00
	00 00		 mov	 DWORD PTR _frameInfo$1[ebp], 20 ; 00000014H
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	52		 push	 edx
  00062	8d 55 d4	 lea	 edx, DWORD PTR _spInPlaceFrame$2[ebp]
  00065	52		 push	 edx
  00066	50		 push	 eax
  00067	ff 51 20	 call	 DWORD PTR [ecx+32]

; 1261 : 				&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
; 1262 : 			if (spInPlaceUIWindow)

  0006a	8b 4d d8	 mov	 ecx, DWORD PTR _spInPlaceUIWindow$3[ebp]
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 0b		 je	 SHORT $LN5@IOleInPlac

; 1263 : 				spInPlaceUIWindow->SetActiveObject(NULL, NULL);

  00071	8b 01		 mov	 eax, DWORD PTR [ecx]
  00073	57		 push	 edi
  00074	57		 push	 edi
  00075	51		 push	 ecx
  00076	ff 50 20	 call	 DWORD PTR [eax+32]
  00079	8b 4d d8	 mov	 ecx, DWORD PTR _spInPlaceUIWindow$3[ebp]
$LN5@IOleInPlac:

; 1264 : 			if (spInPlaceFrame)

  0007c	8b 45 d4	 mov	 eax, DWORD PTR _spInPlaceFrame$2[ebp]
  0007f	85 c0		 test	 eax, eax
  00081	74 0e		 je	 SHORT $LN6@IOleInPlac

; 1265 : 				spInPlaceFrame->SetActiveObject(NULL, NULL);

  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	57		 push	 edi
  00086	57		 push	 edi
  00087	50		 push	 eax
  00088	ff 51 20	 call	 DWORD PTR [ecx+32]
  0008b	8b 45 d4	 mov	 eax, DWORD PTR _spInPlaceFrame$2[ebp]
  0008e	8b 4d d8	 mov	 ecx, DWORD PTR _spInPlaceUIWindow$3[ebp]
$LN6@IOleInPlac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00091	85 c9		 test	 ecx, ecx
  00093	74 09		 je	 SHORT $LN19@IOleInPlac

; 184  :             p->Release();

  00095	8b 01		 mov	 eax, DWORD PTR [ecx]
  00097	51		 push	 ecx
  00098	ff 50 08	 call	 DWORD PTR [eax+8]
  0009b	8b 45 d4	 mov	 eax, DWORD PTR _spInPlaceFrame$2[ebp]
$LN19@IOleInPlac:

; 183  :         if (p)

  0009e	85 c0		 test	 eax, eax
  000a0	74 06		 je	 SHORT $LN24@IOleInPlac

; 184  :             p->Release();

  000a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a4	50		 push	 eax
  000a5	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN24@IOleInPlac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1269 : 		m_spInPlaceSite->OnUIDeactivate(FALSE);

  000a8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ab	57		 push	 edi
  000ac	50		 push	 eax
  000ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  000af	ff 51 28	 call	 DWORD PTR [ecx+40]
  000b2	5f		 pop	 edi
$LN3@IOleInPlac:

; 1270 : 	}
; 1271 : 	return S_OK;
; 1272 : }

  000b3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b6	33 c0		 xor	 eax, eax
  000b8	33 cd		 xor	 ecx, ebp
  000ba	5e		 pop	 esi
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	c9		 leave
  000c1	c3		 ret	 0
?IOleInPlaceObject_UIDeactivate@CComControlBase@ATL@@QAEJXZ ENDP ; ATL::CComControlBase::IOleInPlaceObject_UIDeactivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IOleInPlaceObject_InPlaceDeactivate@CComControlBase@ATL@@QAEJXZ
_TEXT	SEGMENT
_pIPO$1 = -4						; size = 4
?IOleInPlaceObject_InPlaceDeactivate@CComControlBase@ATL@@QAEJXZ PROC ; ATL::CComControlBase::IOleInPlaceObject_InPlaceDeactivate, COMDAT
; _this$ = ecx

; 1210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1211 : 	if (!m_bInPlaceActive)

  00007	f6 46 44 04	 test	 BYTE PTR [esi+68], 4
  0000b	74 6a		 je	 SHORT $LN13@IOleInPlac

; 1212 : 		return S_OK;
; 1213 : 
; 1214 : 	if(m_bUIActive) {

  0000d	f6 46 44 08	 test	 BYTE PTR [esi+68], 8
  00011	74 2e		 je	 SHORT $LN26@IOleInPlac

; 1216 : 		ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
  00015	8d 4d fc	 lea	 ecx, DWORD PTR _pIPO$1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00018	83 65 fc 00	 and	 DWORD PTR _pIPO$1[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1216 : 		ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);

  0001c	51		 push	 ecx
  0001d	68 00 00 00 00	 push	 OFFSET __GUID_00000113_0000_0000_c000_000000000046
  00022	8b ce		 mov	 ecx, esi
  00024	ff 50 08	 call	 DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _pIPO$1[ebp]
  0002a	85 c0		 test	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1217 : 		ATLENSURE(pIPO != NULL);

  0002c	74 4e		 je	 SHORT $LN30@IOleInPlac

; 1218 : 		pIPO->UIDeactivate();

  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	ff 51 18	 call	 DWORD PTR [ecx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00034	8b 45 fc	 mov	 eax, DWORD PTR _pIPO$1[ebp]
  00037	85 c0		 test	 eax, eax
  00039	74 06		 je	 SHORT $LN26@IOleInPlac

; 184  :             p->Release();

  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	50		 push	 eax
  0003e	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN26@IOleInPlac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1225 : 	if (m_hWndCD)

  00041	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00044	83 66 44 fb	 and	 DWORD PTR [esi+68], -5	; fffffffbH
  00048	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004b	74 1d		 je	 SHORT $LN11@IOleInPlac

; 1226 : 	{
; 1227 : 		ATLTRACE(atlTraceControls,2,_T("Destroying Window\n"));
; 1228 : 		if (::IsWindow(m_hWndCD))

  0004d	ff 30		 push	 DWORD PTR [eax]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWindow@4
  00055	85 c0		 test	 eax, eax
  00057	74 0b		 je	 SHORT $LN12@IOleInPlac

; 1229 : 			DestroyWindow(m_hWndCD);

  00059	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0005c	ff 30		 push	 DWORD PTR [eax]
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$LN12@IOleInPlac:

; 1230 : 		m_hWndCD = NULL;

  00064	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00067	83 20 00	 and	 DWORD PTR [eax], 0
$LN11@IOleInPlac:

; 1231 : 	}
; 1232 : 
; 1233 : 	if (m_spInPlaceSite)

  0006a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 06		 je	 SHORT $LN13@IOleInPlac

; 1234 : 		m_spInPlaceSite->OnInPlaceDeactivate();

  00071	8b 01		 mov	 eax, DWORD PTR [ecx]
  00073	51		 push	 ecx
  00074	ff 50 2c	 call	 DWORD PTR [eax+44]
$LN13@IOleInPlac:

; 1235 : 
; 1236 : 	return S_OK;

  00077	33 c0		 xor	 eax, eax
  00079	5e		 pop	 esi

; 1237 : }

  0007a	c9		 leave
  0007b	c3		 ret	 0
$LN30@IOleInPlac:

; 1217 : 		ATLENSURE(pIPO != NULL);

  0007c	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00081	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN28@IOleInPlac:
  00086	cc		 int	 3
?IOleInPlaceObject_InPlaceDeactivate@CComControlBase@ATL@@QAEJXZ ENDP ; ATL::CComControlBase::IOleInPlaceObject_InPlaceDeactivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IOleObject_SetExtent@CComControlBase@ATL@@QAEJKPAUtagSIZE@@@Z
_TEXT	SEGMENT
_dwDrawAspect$ = 8					; size = 4
_psizel$ = 12						; size = 4
?IOleObject_SetExtent@CComControlBase@ATL@@QAEJKPAUtagSIZE@@@Z PROC ; ATL::CComControlBase::IOleObject_SetExtent, COMDAT
; _this$ = ecx

; 1312 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1313 : 	if (dwDrawAspect != DVASPECT_CONTENT)

  00003	83 7d 08 01	 cmp	 DWORD PTR _dwDrawAspect$[ebp], 1
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 0a		 je	 SHORT $LN2@IOleObject

; 1314 : 		return DV_E_DVASPECT;

  0000c	b8 6b 00 04 80	 mov	 eax, -2147221397	; 8004006bH
  00011	e9 97 00 00 00	 jmp	 $LN1@IOleObject
$LN2@IOleObject:

; 1315 : 	if (psizel == NULL)

  00016	8b 55 0c	 mov	 edx, DWORD PTR _psizel$[ebp]
  00019	85 d2		 test	 edx, edx
  0001b	75 0a		 jne	 SHORT $LN3@IOleObject

; 1316 : 		return E_POINTER;

  0001d	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00022	e9 86 00 00 00	 jmp	 $LN1@IOleObject
$LN3@IOleObject:

; 1317 : 
; 1318 : 	BOOL bSizeMatchesNatural =

  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	57		 push	 edi
  0002a	3b 46 1c	 cmp	 eax, DWORD PTR [esi+28]
  0002d	75 0d		 jne	 SHORT $LN9@IOleObject
  0002f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00032	3b 46 20	 cmp	 eax, DWORD PTR [esi+32]
  00035	75 05		 jne	 SHORT $LN9@IOleObject
  00037	33 ff		 xor	 edi, edi
  00039	47		 inc	 edi
  0003a	eb 02		 jmp	 SHORT $LN10@IOleObject
$LN9@IOleObject:
  0003c	33 ff		 xor	 edi, edi
$LN10@IOleObject:

; 1319 : 		memcmp(psizel, &m_sizeNatural, sizeof(SIZE)) == 0;
; 1320 : 
; 1321 : 	if (m_bAutoSize) //object can't do any other size

  0003e	33 c9		 xor	 ecx, ecx
  00040	f7 46 44 00 02
	00 00		 test	 DWORD PTR [esi+68], 512	; 00000200H
  00047	74 0c		 je	 SHORT $LN4@IOleObject

; 1322 : 		return (bSizeMatchesNatural) ? S_OK : E_FAIL;

  00049	85 ff		 test	 edi, edi
  0004b	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00050	0f 45 c1	 cmovne	 eax, ecx
  00053	eb 57		 jmp	 SHORT $LN12@IOleObject
$LN4@IOleObject:

; 1323 : 
; 1324 : 	BOOL bResized = FALSE;
; 1325 : 	if (memcmp(psizel, &m_sizeExtent, sizeof(SIZE)) != 0)

  00055	8b 02		 mov	 eax, DWORD PTR [edx]
  00057	3b 46 24	 cmp	 eax, DWORD PTR [esi+36]
  0005a	75 08		 jne	 SHORT $LN11@IOleObject
  0005c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005f	3b 46 28	 cmp	 eax, DWORD PTR [esi+40]
  00062	74 0e		 je	 SHORT $LN5@IOleObject
$LN11@IOleObject:

; 1326 : 	{
; 1327 : 		m_sizeExtent = *psizel;

  00064	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	89 4e 28	 mov	 DWORD PTR [esi+40], ecx

; 1328 : 		bResized = TRUE;

  0006c	33 c9		 xor	 ecx, ecx
  0006e	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00071	41		 inc	 ecx
$LN5@IOleObject:

; 1329 : 	}
; 1330 : 	if (m_bResizeNatural && !bSizeMatchesNatural)

  00072	f7 46 44 00 08
	00 00		 test	 DWORD PTR [esi+68], 2048 ; 00000800H
  00079	74 12		 je	 SHORT $LN6@IOleObject
  0007b	85 ff		 test	 edi, edi
  0007d	75 0e		 jne	 SHORT $LN6@IOleObject

; 1331 : 	{
; 1332 : 		m_sizeNatural = *psizel;

  0007f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00082	8b 02		 mov	 eax, DWORD PTR [edx]
  00084	89 4e 20	 mov	 DWORD PTR [esi+32], ecx

; 1333 : 		bResized = TRUE;

  00087	33 c9		 xor	 ecx, ecx
  00089	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  0008c	41		 inc	 ecx
$LN6@IOleObject:

; 1334 : 	}
; 1335 : 
; 1336 : 	if (m_bRecomposeOnResize && bResized)

  0008d	f7 46 44 00 04
	00 00		 test	 DWORD PTR [esi+68], 1024 ; 00000400H
  00094	74 14		 je	 SHORT $LN7@IOleObject
  00096	85 c9		 test	 ecx, ecx
  00098	74 10		 je	 SHORT $LN7@IOleObject

; 1337 : 	{
; 1338 : 		SendOnDataChange();

  0009a	6a 00		 push	 0
  0009c	8b ce		 mov	 ecx, esi
  0009e	e8 00 00 00 00	 call	 ?SendOnDataChange@CComControlBase@ATL@@QAEJK@Z ; ATL::CComControlBase::SendOnDataChange

; 1339 : 		FireViewChange();

  000a3	8b ce		 mov	 ecx, esi
  000a5	e8 00 00 00 00	 call	 ?FireViewChange@CComControlBase@ATL@@QAEJXZ ; ATL::CComControlBase::FireViewChange
$LN7@IOleObject:

; 1340 : 	}
; 1341 : 	return S_OK;

  000aa	33 c0		 xor	 eax, eax
$LN12@IOleObject:
  000ac	5f		 pop	 edi
$LN1@IOleObject:
  000ad	5e		 pop	 esi

; 1342 : }

  000ae	5d		 pop	 ebp
  000af	c2 08 00	 ret	 8
?IOleObject_SetExtent@CComControlBase@ATL@@QAEJKPAUtagSIZE@@@Z ENDP ; ATL::CComControlBase::IOleObject_SetExtent
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IOleObject_Close@CComControlBase@ATL@@QAEJK@Z
_TEXT	SEGMENT
_pIPO$1 = -4						; size = 4
_dwSaveOption$ = 8					; size = 4
?IOleObject_Close@CComControlBase@ATL@@QAEJK@Z PROC	; ATL::CComControlBase::IOleObject_Close, COMDAT
; _this$ = ecx

; 1166 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 1167 : 	if (m_hWndCD)

  00008	33 db		 xor	 ebx, ebx
  0000a	57		 push	 edi
  0000b	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0000e	39 18		 cmp	 DWORD PTR [eax], ebx
  00010	74 0e		 je	 SHORT $LN3@IOleObject

; 1168 : 	{
; 1169 : 		if (m_spClientSite)

  00012	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00015	85 c9		 test	 ecx, ecx
  00017	74 07		 je	 SHORT $LN3@IOleObject

; 1170 : 			m_spClientSite->OnShowWindow(FALSE);

  00019	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001b	53		 push	 ebx
  0001c	51		 push	 ecx
  0001d	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN3@IOleObject:

; 1171 : 	}
; 1172 : 
; 1173 : 	if (m_bInPlaceActive)

  00020	f6 46 44 04	 test	 BYTE PTR [esi+68], 4
  00024	74 43		 je	 SHORT $LN24@IOleObject

; 1176 : 		ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);

  00026	8b 06		 mov	 eax, DWORD PTR [esi]
  00028	8d 4d fc	 lea	 ecx, DWORD PTR _pIPO$1[ebp]
  0002b	51		 push	 ecx
  0002c	68 00 00 00 00	 push	 OFFSET __GUID_00000113_0000_0000_c000_000000000046
  00031	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00033	89 5d fc	 mov	 DWORD PTR _pIPO$1[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1176 : 		ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);

  00036	ff 50 08	 call	 DWORD PTR [eax+8]

; 1177 : 		ATLASSERT(pIPO != NULL);
; 1178 : 		HRESULT hr = pIPO->InPlaceDeactivate();

  00039	8b 45 fc	 mov	 eax, DWORD PTR _pIPO$1[ebp]
  0003c	50		 push	 eax
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	ff 51 14	 call	 DWORD PTR [ecx+20]
  00042	8b f8		 mov	 edi, eax

; 1179 : 		if (FAILED(hr))

  00044	85 ff		 test	 edi, edi
  00046	79 14		 jns	 SHORT $LN5@IOleObject
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _pIPO$1[ebp]
  0004b	85 c9		 test	 ecx, ecx
  0004d	74 06		 je	 SHORT $LN19@IOleObject

; 184  :             p->Release();

  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	51		 push	 ecx
  00052	ff 52 08	 call	 DWORD PTR [edx+8]
$LN19@IOleObject:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1180 : 			return hr;

  00055	8b c7		 mov	 eax, edi
  00057	e9 81 00 00 00	 jmp	 $LN1@IOleObject
$LN5@IOleObject:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _pIPO$1[ebp]
  0005f	85 c0		 test	 eax, eax
  00061	74 06		 je	 SHORT $LN24@IOleObject

; 184  :             p->Release();

  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	50		 push	 eax
  00066	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN24@IOleObject:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1183 : 	if (m_hWndCD)

  00069	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0006c	39 18		 cmp	 DWORD PTR [eax], ebx
  0006e	74 1c		 je	 SHORT $LN6@IOleObject

; 1184 : 	{
; 1185 : 		ATLTRACE(atlTraceControls,2,_T("Destroying Window\n"));
; 1186 : 		if (::IsWindow(m_hWndCD))

  00070	ff 30		 push	 DWORD PTR [eax]
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsWindow@4
  00078	85 c0		 test	 eax, eax
  0007a	74 0b		 je	 SHORT $LN7@IOleObject

; 1187 : 			DestroyWindow(m_hWndCD);

  0007c	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0007f	ff 30		 push	 DWORD PTR [eax]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DestroyWindow@4
$LN7@IOleObject:

; 1188 : 		m_hWndCD = NULL;

  00087	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0008a	89 18		 mov	 DWORD PTR [eax], ebx
$LN6@IOleObject:

; 1189 : 	}
; 1190 : 
; 1191 : 	// handle the save flag.
; 1192 : 	//
; 1193 : 	if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY ||
; 1194 : 		dwSaveOption == OLECLOSE_PROMPTSAVE) && m_bRequiresSave)

  0008c	39 5d 08	 cmp	 DWORD PTR _dwSaveOption$[ebp], ebx
  0008f	74 06		 je	 SHORT $LN9@IOleObject
  00091	83 7d 08 02	 cmp	 DWORD PTR _dwSaveOption$[ebp], 2
  00095	75 20		 jne	 SHORT $LN27@IOleObject
$LN9@IOleObject:
  00097	f6 46 44 80	 test	 BYTE PTR [esi+68], 128	; 00000080H
  0009b	74 1a		 je	 SHORT $LN27@IOleObject

; 1195 : 	{
; 1196 : 		if (m_spClientSite)

  0009d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  000a0	85 c9		 test	 ecx, ecx
  000a2	74 06		 je	 SHORT $LN10@IOleObject

; 1197 : 			m_spClientSite->SaveObject();

  000a4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a6	51		 push	 ecx
  000a7	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN10@IOleObject:

; 243  : 		if (m_spOleAdviseHolder)

  000aa	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  000ad	85 c9		 test	 ecx, ecx
  000af	74 06		 je	 SHORT $LN27@IOleObject

; 244  : 			hRes = m_spOleAdviseHolder->SendOnSave();

  000b1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b3	51		 push	 ecx
  000b4	ff 50 1c	 call	 DWORD PTR [eax+28]
$LN27@IOleObject:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 229  :         T* pTemp = p;

  000b7	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 230  :         if (pTemp)

  000ba	85 c9		 test	 ecx, ecx
  000bc	74 09		 je	 SHORT $LN30@IOleObject

; 231  :         {
; 232  :             p = NULL;

  000be	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 233  :             pTemp->Release();

  000c1	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c3	51		 push	 ecx
  000c4	ff 50 08	 call	 DWORD PTR [eax+8]
$LN30@IOleObject:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1204 : 	m_bInPlaceSiteEx = FALSE;

  000c7	83 66 44 dc	 and	 DWORD PTR [esi+68], -36	; ffffffdcH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 229  :         T* pTemp = p;

  000cb	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 230  :         if (pTemp)

  000ce	85 c9		 test	 ecx, ecx
  000d0	74 09		 je	 SHORT $LN33@IOleObject

; 231  :         {
; 232  :             p = NULL;

  000d2	89 5e 14	 mov	 DWORD PTR [esi+20], ebx

; 233  :             pTemp->Release();

  000d5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000d7	51		 push	 ecx
  000d8	ff 50 08	 call	 DWORD PTR [eax+8]
$LN33@IOleObject:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1206 : 	return S_OK;

  000db	33 c0		 xor	 eax, eax
$LN1@IOleObject:
  000dd	5f		 pop	 edi

; 1207 : }

  000de	5e		 pop	 esi
  000df	5b		 pop	 ebx
  000e0	c9		 leave
  000e1	c2 04 00	 ret	 4
?IOleObject_Close@CComControlBase@ATL@@QAEJK@Z ENDP	; ATL::CComControlBase::IOleObject_Close
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IOleObject_Advise@CComControlBase@ATL@@QAEJPAUIAdviseSink@@PAK@Z
_TEXT	SEGMENT
_pAdvSink$ = 8						; size = 4
_pdwConnection$ = 12					; size = 4
?IOleObject_Advise@CComControlBase@ATL@@QAEJPAUIAdviseSink@@PAK@Z PROC ; ATL::CComControlBase::IOleObject_Advise, COMDAT
; _this$ = ecx

; 1156 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00004	8d 71 0c	 lea	 esi, DWORD PTR [ecx+12]
  00007	83 3e 00	 cmp	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1158 : 	if (m_spOleAdviseHolder == NULL)

  0000a	75 0b		 jne	 SHORT $LN7@IOleObject

; 1159 : 		hr = CreateOleAdviseHolder(&m_spOleAdviseHolder);

  0000c	56		 push	 esi
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateOleAdviseHolder@4

; 1160 : 	if (SUCCEEDED(hr))

  00013	85 c0		 test	 eax, eax
  00015	78 0e		 js	 SHORT $LN3@IOleObject
$LN7@IOleObject:

; 1161 : 		hr = m_spOleAdviseHolder->Advise(pAdvSink, pdwConnection);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
  00019	ff 75 0c	 push	 DWORD PTR _pdwConnection$[ebp]
  0001c	ff 75 08	 push	 DWORD PTR _pAdvSink$[ebp]
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	50		 push	 eax
  00022	ff 51 0c	 call	 DWORD PTR [ecx+12]
$LN3@IOleObject:

; 1162 : 	return hr;

  00025	5e		 pop	 esi

; 1163 : }

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?IOleObject_Advise@CComControlBase@ATL@@QAEJPAUIAdviseSink@@PAK@Z ENDP ; ATL::CComControlBase::IOleObject_Advise
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IOleObject_GetClientSite@CComControlBase@ATL@@QAEJPAPAUIOleClientSite@@@Z
_TEXT	SEGMENT
_ppClientSite$ = 8					; size = 4
?IOleObject_GetClientSite@CComControlBase@ATL@@QAEJPAPAUIOleClientSite@@@Z PROC ; ATL::CComControlBase::IOleObject_GetClientSite, COMDAT
; _this$ = ecx

; 1142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1143 : 	ATLASSERT(ppClientSite);
; 1144 : 	if (ppClientSite == NULL)

  00003	8b 55 08	 mov	 edx, DWORD PTR _ppClientSite$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	75 07		 jne	 SHORT $LN2@IOleObject

; 1145 : 		return E_POINTER;

  0000a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000f	eb 14		 jmp	 SHORT $LN1@IOleObject
$LN2@IOleObject:

; 1146 : 
; 1147 : 	*ppClientSite = m_spClientSite;

  00011	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00014	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00016	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00019	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1148 : 	if (m_spClientSite != NULL)

  0001b	74 06		 je	 SHORT $LN3@IOleObject

; 1149 : 		m_spClientSite.p->AddRef();

  0001d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001f	51		 push	 ecx
  00020	ff 50 04	 call	 DWORD PTR [eax+4]
$LN3@IOleObject:

; 1150 : 	return S_OK;

  00023	33 c0		 xor	 eax, eax
$LN1@IOleObject:

; 1151 : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?IOleObject_GetClientSite@CComControlBase@ATL@@QAEJPAPAUIOleClientSite@@@Z ENDP ; ATL::CComControlBase::IOleObject_GetClientSite
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IOleObject_SetClientSite@CComControlBase@ATL@@QAEJPAUIOleClientSite@@@Z
_TEXT	SEGMENT
_pClientSite$ = 8					; size = 4
?IOleObject_SetClientSite@CComControlBase@ATL@@QAEJPAUIOleClientSite@@@Z PROC ; ATL::CComControlBase::IOleObject_SetClientSite, COMDAT
; _this$ = ecx

; 1129 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 1130 : 	ATLASSERT(pClientSite == NULL || m_spClientSite == NULL);
; 1131 : 	m_spClientSite = pClientSite;

  00007	ff 75 08	 push	 DWORD PTR _pClientSite$[ebp]
  0000a	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  0000d	8b cf		 mov	 ecx, edi
  0000f	e8 00 00 00 00	 call	 ??4?$CComPtr@UIOleClientSite@@@ATL@@QAEPAUIOleClientSite@@PAU2@@Z ; ATL::CComPtr<IOleClientSite>::operator=

; 1132 : 	m_spAmbientDispatch.Release();

  00014	83 c6 18	 add	 esi, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 229  :         T* pTemp = p;

  00017	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 230  :         if (pTemp)

  00019	85 c9		 test	 ecx, ecx
  0001b	74 09		 je	 SHORT $LN5@IOleObject

; 231  :         {
; 232  :             p = NULL;

  0001d	83 26 00	 and	 DWORD PTR [esi], 0

; 233  :             pTemp->Release();

  00020	8b 01		 mov	 eax, DWORD PTR [ecx]
  00022	51		 push	 ecx
  00023	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@IOleObject:

; 223  :         return p == pT;

  00026	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00028	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1133 : 	if (m_spClientSite != NULL)

  0002a	74 0b		 je	 SHORT $LN2@IOleObject

; 1134 : 	{
; 1135 : 		m_spClientSite->QueryInterface(__uuidof(IDispatch),

  0002c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002e	56		 push	 esi
  0002f	68 00 00 00 00	 push	 OFFSET __GUID_00020400_0000_0000_c000_000000000046
  00034	51		 push	 ecx
  00035	ff 10		 call	 DWORD PTR [eax]
$LN2@IOleObject:

; 1136 : 			(void**) &m_spAmbientDispatch.p);
; 1137 : 	}
; 1138 : 	return S_OK;

  00037	5f		 pop	 edi
  00038	33 c0		 xor	 eax, eax
  0003a	5e		 pop	 esi

; 1139 : }

  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?IOleObject_SetClientSite@CComControlBase@ATL@@QAEJPAUIOleClientSite@@@Z ENDP ; ATL::CComControlBase::IOleObject_SetClientSite
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?InPlaceActivate@CComControlBase@ATL@@QAEJJPBUtagRECT@@@Z
_TEXT	SEGMENT
_frameInfo$ = -80					; size = 20
_hwndParent$ = -60					; size = 4
_bNoRedraw$1 = -56					; size = 4
_pIPO$ = -52						; size = 4
_spActiveObject$ = -48					; size = 4
_spInPlaceFrame$ = -44					; size = 4
_spInPlaceUIWindow$ = -40				; size = 4
_rcClip$ = -36						; size = 16
_rcPos$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_iVerb$ = 8						; size = 4
___formal$ = 12						; size = 4
?InPlaceActivate@CComControlBase@ATL@@QAEJJPBUtagRECT@@@Z PROC ; ATL::CComControlBase::InPlaceActivate, COMDAT
; _this$ = ecx

; 970  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00014	33 db		 xor	 ebx, ebx
  00016	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 973  : 	if (m_spClientSite == NULL)

  00019	75 07		 jne	 SHORT $LN5@InPlaceAct

; 974  : 		return S_OK;

  0001b	33 c0		 xor	 eax, eax
  0001d	e9 3f 02 00 00	 jmp	 $LN1@InPlaceAct
$LN5@InPlaceAct:

; 977  : 	ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);

  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	8d 4d cc	 lea	 ecx, DWORD PTR _pIPO$[ebp]
  00027	57		 push	 edi
  00028	51		 push	 ecx
  00029	68 00 00 00 00	 push	 OFFSET __GUID_00000113_0000_0000_c000_000000000046
  0002e	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00030	89 5d cc	 mov	 DWORD PTR _pIPO$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 977  : 	ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);

  00033	ff 50 08	 call	 DWORD PTR [eax+8]

; 978  : 	ATLASSERT(pIPO != NULL);
; 979  : 
; 980  : 	if (!m_bNegotiatedWnd)

  00036	f6 46 44 01	 test	 BYTE PTR [esi+68], 1
  0003a	75 67		 jne	 SHORT $LN4@InPlaceAct

; 981  : 	{
; 982  : 		if (!m_bWindowOnly)

  0003c	f6 46 44 40	 test	 BYTE PTR [esi+68], 64	; 00000040H
  00040	75 11		 jne	 SHORT $LN7@InPlaceAct

; 983  : 			// Try for windowless site
; 984  : 			hr = m_spClientSite->QueryInterface(__uuidof(IOleInPlaceSiteWindowless), (void **)&m_spInPlaceSite);

  00042	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00045	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00048	50		 push	 eax
  00049	68 00 00 00 00	 push	 OFFSET __GUID_922eada0_3424_11cf_b670_00aa004cd6d8
  0004e	51		 push	 ecx
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	ff 12		 call	 DWORD PTR [edx]
$LN7@InPlaceAct:

; 985  : 
; 986  : 		if (m_spInPlaceSite)

  00053	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00056	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00058	85 c9		 test	 ecx, ecx
  0005a	74 21		 je	 SHORT $LN8@InPlaceAct

; 987  : 		{
; 988  : 			m_bInPlaceSiteEx = TRUE;

  0005c	83 4e 44 20	 or	 DWORD PTR [esi+68], 32	; 00000020H

; 989  : 			// CanWindowlessActivate returns S_OK or S_FALSE
; 990  : 			if ( m_spInPlaceSite->CanWindowlessActivate() == S_OK )

  00060	8b 01		 mov	 eax, DWORD PTR [ecx]
  00062	51		 push	 ecx
  00063	ff 50 48	 call	 DWORD PTR [eax+72]
  00066	8b 4e 44	 mov	 ecx, DWORD PTR [esi+68]
  00069	85 c0		 test	 eax, eax
  0006b	75 08		 jne	 SHORT $LN10@InPlaceAct

; 991  : 			{
; 992  : 				m_bWndLess = TRUE;
; 993  : 				m_bWasOnceWindowless = TRUE;

  0006d	81 c9 02 01 00
	00		 or	 ecx, 258		; 00000102H

; 994  : 			}

  00073	eb 03		 jmp	 SHORT $LN11@InPlaceAct
$LN10@InPlaceAct:

; 995  : 			else
; 996  : 			{
; 997  : 				m_bWndLess = FALSE;

  00075	83 e1 fd	 and	 ecx, -3			; fffffffdH
$LN11@InPlaceAct:

; 998  : 			}
; 999  : 		}

  00078	89 4e 44	 mov	 DWORD PTR [esi+68], ecx
  0007b	eb 26		 jmp	 SHORT $LN4@InPlaceAct
$LN8@InPlaceAct:

; 1000 : 		else
; 1001 : 		{
; 1002 : 			m_spClientSite->QueryInterface(__uuidof(IOleInPlaceSiteEx), (void **)&m_spInPlaceSite);

  0007d	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00080	57		 push	 edi
  00081	68 00 00 00 00	 push	 OFFSET __GUID_9c2cad80_3424_11cf_b670_00aa004cd6d8
  00086	50		 push	 eax
  00087	8b 08		 mov	 ecx, DWORD PTR [eax]
  00089	ff 11		 call	 DWORD PTR [ecx]

; 1003 : 			if (m_spInPlaceSite)

  0008b	39 1f		 cmp	 DWORD PTR [edi], ebx
  0008d	74 06		 je	 SHORT $LN12@InPlaceAct

; 1004 : 				m_bInPlaceSiteEx = TRUE;

  0008f	83 4e 44 20	 or	 DWORD PTR [esi+68], 32	; 00000020H
  00093	eb 0e		 jmp	 SHORT $LN4@InPlaceAct
$LN12@InPlaceAct:

; 1005 : 			else
; 1006 : 				hr = m_spClientSite->QueryInterface(__uuidof(IOleInPlaceSite), (void **)&m_spInPlaceSite);

  00095	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00098	57		 push	 edi
  00099	68 00 00 00 00	 push	 OFFSET __GUID_00000119_0000_0000_c000_000000000046
  0009e	50		 push	 eax
  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	ff 11		 call	 DWORD PTR [ecx]
$LN4@InPlaceAct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 209  :         return (p == NULL);

  000a3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000a6	85 c0		 test	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1011 : 	if (!m_spInPlaceSite)

  000a8	74 3a		 je	 SHORT $LN150@InPlaceAct

; 1012 : 		return E_FAIL;
; 1013 : 
; 1014 : 	m_bNegotiatedWnd = TRUE;

  000aa	83 4e 44 01	 or	 DWORD PTR [esi+68], 1

; 1015 : 
; 1016 : 	if (!m_bInPlaceActive)

  000ae	f6 46 44 04	 test	 BYTE PTR [esi+68], 4
  000b2	75 43		 jne	 SHORT $LN19@InPlaceAct

; 1017 : 	{
; 1018 : 
; 1019 : 		BOOL bNoRedraw = FALSE;
; 1020 : 		if (m_bWndLess)

  000b4	f6 46 44 02	 test	 BYTE PTR [esi+68], 2
  000b8	89 5d c8	 mov	 DWORD PTR _bNoRedraw$1[ebp], ebx
  000bb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bd	74 04		 je	 SHORT $LN16@InPlaceAct

; 1021 : 			m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);

  000bf	6a 01		 push	 1
  000c1	eb 07		 jmp	 SHORT $LN149@InPlaceAct
$LN16@InPlaceAct:

; 1022 : 		else
; 1023 : 		{
; 1024 : 			if (m_bInPlaceSiteEx)

  000c3	f6 46 44 20	 test	 BYTE PTR [esi+68], 32	; 00000020H
  000c7	74 0b		 je	 SHORT $LN18@InPlaceAct

; 1025 : 				m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);

  000c9	53		 push	 ebx
$LN149@InPlaceAct:

; 1038 : 			}
; 1039 : 		}
; 1040 : 	}
; 1041 : 
; 1042 : 	m_bInPlaceActive = TRUE;

  000ca	8d 55 c8	 lea	 edx, DWORD PTR _bNoRedraw$1[ebp]
  000cd	52		 push	 edx
  000ce	50		 push	 eax
  000cf	ff 51 3c	 call	 DWORD PTR [ecx+60]
  000d2	eb 23		 jmp	 SHORT $LN19@InPlaceAct
$LN18@InPlaceAct:

; 1026 : 			else
; 1027 : 			{
; 1028 : 				hr = m_spInPlaceSite->CanInPlaceActivate();

  000d4	50		 push	 eax
  000d5	ff 51 14	 call	 DWORD PTR [ecx+20]
  000d8	8b f8		 mov	 edi, eax

; 1029 : 				// CanInPlaceActivate returns S_FALSE or S_OK
; 1030 : 				if (FAILED(hr))

  000da	85 ff		 test	 edi, edi
  000dc	0f 88 6f 01 00
	00		 js	 $LN141@InPlaceAct

; 1031 : 					return hr;
; 1032 : 				if ( hr != S_OK )

  000e2	74 0a		 je	 SHORT $LN21@InPlaceAct
$LN150@InPlaceAct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  000e4	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
  000e9	e9 63 01 00 00	 jmp	 $LN141@InPlaceAct
$LN21@InPlaceAct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1037 : 				m_spInPlaceSite->OnInPlaceActivate();

  000ee	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000f1	50		 push	 eax
  000f2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f4	ff 51 18	 call	 DWORD PTR [ecx+24]
$LN19@InPlaceAct:

; 1052 : 	HWND hwndParent;
; 1053 : 	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)

  000f7	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000fa	8d 55 c4	 lea	 edx, DWORD PTR _hwndParent$[ebp]
  000fd	83 4e 44 04	 or	 DWORD PTR [esi+68], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00101	89 5d d4	 mov	 DWORD PTR _spInPlaceFrame$[ebp], ebx
  00104	89 5d d8	 mov	 DWORD PTR _spInPlaceUIWindow$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1051 : 	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

  00107	c7 45 b0 14 00
	00 00		 mov	 DWORD PTR _frameInfo$[ebp], 20 ; 00000014H

; 1052 : 	HWND hwndParent;
; 1053 : 	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)

  0010e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00110	52		 push	 edx
  00111	50		 push	 eax
  00112	ff 51 0c	 call	 DWORD PTR [ecx+12]
  00115	85 c0		 test	 eax, eax
  00117	75 4f		 jne	 SHORT $LN22@InPlaceAct

; 1054 : 	{
; 1055 : 		hr = m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,

  00119	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0011c	8d 55 b0	 lea	 edx, DWORD PTR _frameInfo$[ebp]
  0011f	52		 push	 edx
  00120	8d 55 dc	 lea	 edx, DWORD PTR _rcClip$[ebp]
  00123	52		 push	 edx
  00124	8b 08		 mov	 ecx, DWORD PTR [eax]
  00126	8d 55 ec	 lea	 edx, DWORD PTR _rcPos$[ebp]
  00129	52		 push	 edx
  0012a	8d 55 d8	 lea	 edx, DWORD PTR _spInPlaceUIWindow$[ebp]
  0012d	52		 push	 edx
  0012e	8d 55 d4	 lea	 edx, DWORD PTR _spInPlaceFrame$[ebp]
  00131	52		 push	 edx
  00132	50		 push	 eax
  00133	ff 51 20	 call	 DWORD PTR [ecx+32]
  00136	8b f8		 mov	 edi, eax

; 1056 : 			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
; 1057 : 		if (FAILED(hr))

  00138	85 ff		 test	 edi, edi
  0013a	0f 88 f7 00 00
	00		 js	 $LN131@InPlaceAct

; 1058 : 			return hr;
; 1059 : 
; 1060 : 		if (!m_bWndLess)

  00140	f6 46 44 02	 test	 BYTE PTR [esi+68], 2
  00144	75 11		 jne	 SHORT $LN27@InPlaceAct

; 1061 : 		{
; 1062 : 			if (m_hWndCD)

  00146	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00149	39 18		 cmp	 DWORD PTR [eax], ebx
  0014b	74 66		 je	 SHORT $LN25@InPlaceAct

; 1063 : 				ShowWindow(m_hWndCD, SW_SHOW);

  0014d	6a 05		 push	 5
  0014f	ff 30		 push	 DWORD PTR [eax]
  00151	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ShowWindow@8
$LN27@InPlaceAct:

; 1071 : 			}
; 1072 : 		}
; 1073 : 
; 1074 : 		pIPO->SetObjectRects(&rcPos, &rcClip);

  00157	8b 45 cc	 mov	 eax, DWORD PTR _pIPO$[ebp]
  0015a	8d 55 dc	 lea	 edx, DWORD PTR _rcClip$[ebp]
  0015d	52		 push	 edx
  0015e	8d 55 ec	 lea	 edx, DWORD PTR _rcPos$[ebp]
  00161	52		 push	 edx
  00162	8b 08		 mov	 ecx, DWORD PTR [eax]
  00164	50		 push	 eax
  00165	ff 51 1c	 call	 DWORD PTR [ecx+28]
$LN22@InPlaceAct:

; 1078 : 	ControlQueryInterface(__uuidof(IOleInPlaceActiveObject), (void**)&spActiveObject);

  00168	8b 06		 mov	 eax, DWORD PTR [esi]
  0016a	8d 4d d0	 lea	 ecx, DWORD PTR _spActiveObject$[ebp]
  0016d	51		 push	 ecx
  0016e	68 00 00 00 00	 push	 OFFSET __GUID_00000117_0000_0000_c000_000000000046
  00173	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00175	89 5d d0	 mov	 DWORD PTR _spActiveObject$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1078 : 	ControlQueryInterface(__uuidof(IOleInPlaceActiveObject), (void**)&spActiveObject);

  00178	ff 50 08	 call	 DWORD PTR [eax+8]

; 1079 : 
; 1080 : 	// Gone active by now, take care of UIACTIVATE
; 1081 : 	if (DoesVerbUIActivate(iVerb))

  0017b	ff 75 08	 push	 DWORD PTR _iVerb$[ebp]
  0017e	8b ce		 mov	 ecx, esi
  00180	e8 00 00 00 00	 call	 ?DoesVerbUIActivate@CComControlBase@ATL@@QAEHJ@Z ; ATL::CComControlBase::DoesVerbUIActivate
  00185	85 c0		 test	 eax, eax
  00187	0f 84 92 00 00
	00		 je	 $LN35@InPlaceAct

; 1082 : 	{
; 1083 : 		if (!m_bUIActive)

  0018d	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  00190	a8 08		 test	 al, 8
  00192	0f 85 87 00 00
	00		 jne	 $LN35@InPlaceAct

; 1084 : 		{
; 1085 : 			m_bUIActive = TRUE;

  00198	83 c8 08	 or	 eax, 8
  0019b	89 46 44	 mov	 DWORD PTR [esi+68], eax

; 1086 : 			hr = m_spInPlaceSite->OnUIActivate();

  0019e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  001a1	50		 push	 eax
  001a2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a4	ff 51 1c	 call	 DWORD PTR [ecx+28]
  001a7	8b f8		 mov	 edi, eax

; 1087 : 			if (FAILED(hr))

  001a9	85 ff		 test	 edi, edi
  001ab	79 1f		 jns	 SHORT $LN30@InPlaceAct

; 1088 : 			{
; 1089 : 				m_bUIActive = FALSE;

  001ad	83 66 44 f7	 and	 DWORD PTR [esi+68], -9	; fffffff7H
  001b1	eb 77		 jmp	 SHORT $LN42@InPlaceAct
$LN25@InPlaceAct:

; 1064 : 			else
; 1065 : 			{
; 1066 : 				HWND h = CreateControlWindow(hwndParent, rcPos);

  001b3	8b 06		 mov	 eax, DWORD PTR [esi]
  001b5	8d 4d ec	 lea	 ecx, DWORD PTR _rcPos$[ebp]
  001b8	51		 push	 ecx
  001b9	ff 75 c4	 push	 DWORD PTR _hwndParent$[ebp]
  001bc	8b ce		 mov	 ecx, esi
  001be	ff 50 04	 call	 DWORD PTR [eax+4]

; 1067 : 				ATLASSERT(h != NULL);	// will assert if creation failed
; 1068 : 				ATLASSERT(h == m_hWndCD);
; 1069 : 				if(h == NULL)

  001c1	85 c0		 test	 eax, eax
  001c3	75 92		 jne	 SHORT $LN27@InPlaceAct

; 1070 : 					return E_FAIL;

  001c5	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
  001ca	eb 6b		 jmp	 SHORT $LN131@InPlaceAct
$LN30@InPlaceAct:

; 1090 : 				return hr;
; 1091 : 			}
; 1092 : 
; 1093 : 			SetControlFocus(TRUE);

  001cc	6a 01		 push	 1
  001ce	8b ce		 mov	 ecx, esi
  001d0	e8 00 00 00 00	 call	 ?SetControlFocus@CComControlBase@ATL@@QAEHH@Z ; ATL::CComControlBase::SetControlFocus

; 1094 : 			// set ourselves up in the host.
; 1095 : 			//
; 1096 : 			if (spActiveObject)

  001d5	8b 55 d0	 mov	 edx, DWORD PTR _spActiveObject$[ebp]
  001d8	8b 4d d4	 mov	 ecx, DWORD PTR _spInPlaceFrame$[ebp]
  001db	85 d2		 test	 edx, edx
  001dd	74 24		 je	 SHORT $LN148@InPlaceAct

; 1097 : 			{
; 1098 : 				if (spInPlaceFrame)

  001df	85 c9		 test	 ecx, ecx
  001e1	74 0e		 je	 SHORT $LN32@InPlaceAct

; 1099 : 					spInPlaceFrame->SetActiveObject(spActiveObject, NULL);

  001e3	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e5	53		 push	 ebx
  001e6	52		 push	 edx
  001e7	51		 push	 ecx
  001e8	ff 50 20	 call	 DWORD PTR [eax+32]
  001eb	8b 4d d4	 mov	 ecx, DWORD PTR _spInPlaceFrame$[ebp]
  001ee	8b 55 d0	 mov	 edx, DWORD PTR _spActiveObject$[ebp]
$LN32@InPlaceAct:

; 1100 : 				if (spInPlaceUIWindow)

  001f1	8b 45 d8	 mov	 eax, DWORD PTR _spInPlaceUIWindow$[ebp]
  001f4	85 c0		 test	 eax, eax
  001f6	74 0e		 je	 SHORT $LN33@InPlaceAct

; 1101 : 					spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);

  001f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fa	53		 push	 ebx
  001fb	52		 push	 edx
  001fc	50		 push	 eax
  001fd	ff 51 20	 call	 DWORD PTR [ecx+32]
  00200	8b 4d d4	 mov	 ecx, DWORD PTR _spInPlaceFrame$[ebp]
$LN148@InPlaceAct:

; 1102 : 			}
; 1103 : 
; 1104 : 			if (spInPlaceFrame)

  00203	8b 45 d8	 mov	 eax, DWORD PTR _spInPlaceUIWindow$[ebp]
$LN33@InPlaceAct:
  00206	85 c9		 test	 ecx, ecx
  00208	74 0a		 je	 SHORT $LN34@InPlaceAct

; 1105 : 				spInPlaceFrame->SetBorderSpace(NULL);

  0020a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0020c	53		 push	 ebx
  0020d	51		 push	 ecx
  0020e	ff 50 1c	 call	 DWORD PTR [eax+28]
  00211	8b 45 d8	 mov	 eax, DWORD PTR _spInPlaceUIWindow$[ebp]
$LN34@InPlaceAct:

; 1106 : 			if (spInPlaceUIWindow)

  00214	85 c0		 test	 eax, eax
  00216	74 07		 je	 SHORT $LN35@InPlaceAct

; 1107 : 				spInPlaceUIWindow->SetBorderSpace(NULL);

  00218	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021a	53		 push	 ebx
  0021b	50		 push	 eax
  0021c	ff 51 1c	 call	 DWORD PTR [ecx+28]
$LN35@InPlaceAct:

; 1108 : 		}
; 1109 : 	}
; 1110 : 
; 1111 : 	m_spClientSite->ShowObject();

  0021f	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00222	50		 push	 eax
  00223	8b 08		 mov	 ecx, DWORD PTR [eax]
  00225	ff 51 18	 call	 DWORD PTR [ecx+24]

; 1113 : 	return S_OK;

  00228	8b fb		 mov	 edi, ebx
$LN42@InPlaceAct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0022a	8b 45 d0	 mov	 eax, DWORD PTR _spActiveObject$[ebp]
  0022d	85 c0		 test	 eax, eax
  0022f	74 06		 je	 SHORT $LN131@InPlaceAct

; 184  :             p->Release();

  00231	8b 08		 mov	 ecx, DWORD PTR [eax]
  00233	50		 push	 eax
  00234	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN131@InPlaceAct:

; 183  :         if (p)

  00237	8b 45 d8	 mov	 eax, DWORD PTR _spInPlaceUIWindow$[ebp]
  0023a	85 c0		 test	 eax, eax
  0023c	74 06		 je	 SHORT $LN136@InPlaceAct

; 184  :             p->Release();

  0023e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00240	50		 push	 eax
  00241	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN136@InPlaceAct:

; 183  :         if (p)

  00244	8b 45 d4	 mov	 eax, DWORD PTR _spInPlaceFrame$[ebp]
  00247	85 c0		 test	 eax, eax
  00249	74 06		 je	 SHORT $LN141@InPlaceAct

; 184  :             p->Release();

  0024b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0024d	50		 push	 eax
  0024e	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN141@InPlaceAct:

; 183  :         if (p)

  00251	8b 4d cc	 mov	 ecx, DWORD PTR _pIPO$[ebp]
  00254	85 c9		 test	 ecx, ecx
  00256	74 06		 je	 SHORT $LN146@InPlaceAct

; 184  :             p->Release();

  00258	8b 11		 mov	 edx, DWORD PTR [ecx]
  0025a	51		 push	 ecx
  0025b	ff 52 08	 call	 DWORD PTR [edx+8]
$LN146@InPlaceAct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1113 : 	return S_OK;

  0025e	8b c7		 mov	 eax, edi
  00260	5f		 pop	 edi
$LN1@InPlaceAct:

; 1114 : }

  00261	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00264	5e		 pop	 esi
  00265	33 cd		 xor	 ecx, ebp
  00267	5b		 pop	 ebx
  00268	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026d	c9		 leave
  0026e	c2 08 00	 ret	 8
?InPlaceActivate@CComControlBase@ATL@@QAEJJPBUtagRECT@@@Z ENDP ; ATL::CComControlBase::InPlaceActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DoVerbProperties@CComControlBase@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z
_TEXT	SEGMENT
_pages$ = -32						; size = 8
_lcid$1 = -24						; size = 4
_spSite$ = -20						; size = 4
_szTitle$2 = -16					; size = 4
_spPages$ = -12						; size = 4
_spObj$ = -8						; size = 4
_pUnk$ = -4						; size = 4
___formal$ = 8						; size = 4
_hwndParent$ = 12					; size = 4
?DoVerbProperties@CComControlBase@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z PROC ; ATL::CComControlBase::DoVerbProperties, COMDAT
; _this$ = ecx

; 912  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0000a	33 f6		 xor	 esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 912  : {

  0000c	57		 push	 edi

; 916  : 	CComQIPtr <IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);

  0000d	8d 4d ec	 lea	 ecx, DWORD PTR _spSite$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00010	89 75 f4	 mov	 DWORD PTR _spPages$[ebp], esi
  00013	89 75 f8	 mov	 DWORD PTR _spObj$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 916  : 	CComQIPtr <IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);

  00016	ff 73 10	 push	 DWORD PTR [ebx+16]
  00019	e8 00 00 00 00	 call	 ??0?$CComQIPtr@UIOleControlSite@@$1?_GUID_b196b289_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>

; 917  : 
; 918  : 	if (spSite)

  0001e	8b 45 ec	 mov	 eax, DWORD PTR _spSite$[ebp]
  00021	85 c0		 test	 eax, eax
  00023	74 10		 je	 SHORT $LN3@DoVerbProp

; 919  : 	{
; 920  : 		hr = spSite->ShowPropertyFrame();

  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	50		 push	 eax
  00028	ff 51 24	 call	 DWORD PTR [ecx+36]
  0002b	8b f8		 mov	 edi, eax

; 921  : 		if (SUCCEEDED(hr))

  0002d	85 ff		 test	 edi, edi
  0002f	0f 89 1a 01 00
	00		 jns	 $LN68@DoVerbProp
$LN3@DoVerbProp:

; 926  : 	ControlQueryInterface(__uuidof(IUnknown), (void**)&pUnk);

  00035	8b 03		 mov	 eax, DWORD PTR [ebx]
  00037	8d 4d fc	 lea	 ecx, DWORD PTR _pUnk$[ebp]
  0003a	51		 push	 ecx
  0003b	68 00 00 00 00	 push	 OFFSET __GUID_00000000_0000_0000_c000_000000000046
  00040	8b cb		 mov	 ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00042	89 75 fc	 mov	 DWORD PTR _pUnk$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 926  : 	ControlQueryInterface(__uuidof(IUnknown), (void**)&pUnk);

  00045	ff 50 08	 call	 DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 661  :         if(this->p!=lp)

  00048	8b 45 fc	 mov	 eax, DWORD PTR _pUnk$[ebp]
  0004b	8b 75 f4	 mov	 esi, DWORD PTR _spPages$[ebp]
  0004e	3b f0		 cmp	 esi, eax
  00050	74 2a		 je	 SHORT $LN55@DoVerbProp

; 58   :     if (lp == NULL || FAILED(lp->QueryInterface(riid, (void**)pp)))

  00052	85 c0		 test	 eax, eax
  00054	74 15		 je	 SHORT $LN54@DoVerbProp
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	8d 55 f4	 lea	 edx, DWORD PTR _spPages$[ebp]
  0005b	52		 push	 edx
  0005c	68 00 00 00 00	 push	 OFFSET __GUID_b196b28b_bab4_101a_b69c_00aa00341d07
  00061	50		 push	 eax
  00062	ff 11		 call	 DWORD PTR [ecx]
  00064	85 c0		 test	 eax, eax
  00066	8b 45 fc	 mov	 eax, DWORD PTR _pUnk$[ebp]
  00069	79 04		 jns	 SHORT $LN53@DoVerbProp
$LN54@DoVerbProp:

; 59   :         *pp = NULL;

  0006b	83 65 f4 00	 and	 DWORD PTR _spPages$[ebp], 0
$LN53@DoVerbProp:

; 60   : 
; 61   :     if (pTemp)

  0006f	85 f6		 test	 esi, esi
  00071	74 09		 je	 SHORT $LN55@DoVerbProp

; 62   :         pTemp->Release();

  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	56		 push	 esi
  00076	ff 50 08	 call	 DWORD PTR [eax+8]
  00079	8b 45 fc	 mov	 eax, DWORD PTR _pUnk$[ebp]
$LN55@DoVerbProp:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 930  : 	if (spPages)

  0007c	8b 75 f4	 mov	 esi, DWORD PTR _spPages$[ebp]
  0007f	85 f6		 test	 esi, esi
  00081	0f 84 b9 00 00
	00		 je	 $LN4@DoVerbProp

; 931  : 	{
; 932  : 		hr = spPages->GetPages(&pages);

  00087	8b 06		 mov	 eax, DWORD PTR [esi]
  00089	8d 4d e0	 lea	 ecx, DWORD PTR _pages$[ebp]
  0008c	51		 push	 ecx
  0008d	56		 push	 esi
  0008e	ff 50 0c	 call	 DWORD PTR [eax+12]
  00091	8b f8		 mov	 edi, eax

; 933  : 		if (SUCCEEDED(hr))

  00093	85 ff		 test	 edi, edi
  00095	0f 88 a0 00 00
	00		 js	 $LN93@DoVerbProp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 661  :         if(this->p!=lp)

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _spObj$[ebp]
  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _pUnk$[ebp]
  000a1	3b c1		 cmp	 eax, ecx
  000a3	74 2f		 je	 SHORT $LN63@DoVerbProp

; 56   :     IUnknown* pTemp = *pp; // takes ownership

  000a5	8b f0		 mov	 esi, eax

; 57   : 
; 58   :     if (lp == NULL || FAILED(lp->QueryInterface(riid, (void**)pp)))

  000a7	85 c9		 test	 ecx, ecx
  000a9	74 17		 je	 SHORT $LN62@DoVerbProp
  000ab	8b 01		 mov	 eax, DWORD PTR [ecx]
  000ad	8d 55 f8	 lea	 edx, DWORD PTR _spObj$[ebp]
  000b0	52		 push	 edx
  000b1	68 00 00 00 00	 push	 OFFSET __GUID_00000112_0000_0000_c000_000000000046
  000b6	51		 push	 ecx
  000b7	ff 10		 call	 DWORD PTR [eax]
  000b9	85 c0		 test	 eax, eax
  000bb	78 05		 js	 SHORT $LN62@DoVerbProp
  000bd	8b 45 f8	 mov	 eax, DWORD PTR _spObj$[ebp]
  000c0	eb 05		 jmp	 SHORT $LN61@DoVerbProp
$LN62@DoVerbProp:

; 59   :         *pp = NULL;

  000c2	33 c0		 xor	 eax, eax
  000c4	89 45 f8	 mov	 DWORD PTR _spObj$[ebp], eax
$LN61@DoVerbProp:

; 60   : 
; 61   :     if (pTemp)

  000c7	85 f6		 test	 esi, esi
  000c9	74 09		 je	 SHORT $LN63@DoVerbProp

; 62   :         pTemp->Release();

  000cb	8b 06		 mov	 eax, DWORD PTR [esi]
  000cd	56		 push	 esi
  000ce	ff 50 08	 call	 DWORD PTR [eax+8]
  000d1	8b 45 f8	 mov	 eax, DWORD PTR _spObj$[ebp]
$LN63@DoVerbProp:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 936  : 			if (spObj)

  000d4	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CoTaskMemFree@4
  000da	85 c0		 test	 eax, eax
  000dc	74 53		 je	 SHORT $LN7@DoVerbProp

; 937  : 			{
; 938  : 				LPOLESTR szTitle = NULL;
; 939  : 
; 940  : 				hr = spObj->GetUserType(USERCLASSTYPE_SHORT, &szTitle);

  000de	8d 55 f0	 lea	 edx, DWORD PTR _szTitle$2[ebp]
  000e1	33 ff		 xor	 edi, edi
  000e3	52		 push	 edx
  000e4	89 7d f0	 mov	 DWORD PTR _szTitle$2[ebp], edi
  000e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e9	6a 02		 push	 2
  000eb	50		 push	 eax
  000ec	ff 51 40	 call	 DWORD PTR [ecx+64]

; 941  : 				_Analysis_assume_(SUCCEEDED(hr) || (szTitle = NULL) == NULL);
; 942  : 
; 943  : 				LCID lcid;
; 944  : 				if (FAILED(GetAmbientLocaleID(lcid)))

  000ef	8d 45 e8	 lea	 eax, DWORD PTR _lcid$1[ebp]
  000f2	8b cb		 mov	 ecx, ebx
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ?GetAmbientLocaleID@CComControlBase@ATL@@QAEJAAK@Z ; ATL::CComControlBase::GetAmbientLocaleID
  000fa	8b 4d e8	 mov	 ecx, DWORD PTR _lcid$1[ebp]
  000fd	85 c0		 test	 eax, eax

; 945  : 					lcid = LOCALE_USER_DEFAULT;
; 946  : 
; 947  : 				hr = OleCreatePropertyFrame(hwndParent, m_rcPos.top, m_rcPos.left, szTitle,

  000ff	57		 push	 edi
  00100	57		 push	 edi
  00101	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00106	8d 45 fc	 lea	 eax, DWORD PTR _pUnk$[ebp]
  00109	0f 48 ca	 cmovs	 ecx, edx
  0010c	51		 push	 ecx
  0010d	ff 75 e4	 push	 DWORD PTR _pages$[ebp+4]
  00110	ff 75 e0	 push	 DWORD PTR _pages$[ebp]
  00113	50		 push	 eax
  00114	6a 01		 push	 1
  00116	ff 75 f0	 push	 DWORD PTR _szTitle$2[ebp]
  00119	ff 73 2c	 push	 DWORD PTR [ebx+44]
  0011c	ff 73 30	 push	 DWORD PTR [ebx+48]
  0011f	ff 75 0c	 push	 DWORD PTR _hwndParent$[ebp]
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleCreatePropertyFrame@44

; 948  : 					1, &pUnk.p, pages.cElems, pages.pElems, lcid, 0, 0);
; 949  : 
; 950  : 				CoTaskMemFree(szTitle);

  00128	ff 75 f0	 push	 DWORD PTR _szTitle$2[ebp]
  0012b	8b f8		 mov	 edi, eax
  0012d	ff d6		 call	 esi

; 951  : 			}

  0012f	eb 05		 jmp	 SHORT $LN8@DoVerbProp
$LN7@DoVerbProp:

; 952  : 			else
; 953  : 			{
; 954  : 				hr = OLEOBJ_S_CANNOT_DOVERB_NOW;

  00131	bf 81 01 04 00	 mov	 edi, 262529		; 00040181H
$LN8@DoVerbProp:

; 955  : 			}
; 956  : 			CoTaskMemFree(pages.pElems);

  00136	ff 75 e4	 push	 DWORD PTR _pages$[ebp+4]
  00139	ff d6		 call	 esi
$LN93@DoVerbProp:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0013b	8b 45 fc	 mov	 eax, DWORD PTR _pUnk$[ebp]
  0013e	eb 05		 jmp	 SHORT $LN5@DoVerbProp
$LN4@DoVerbProp:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 961  : 		hr = OLEOBJ_S_CANNOT_DOVERB_NOW;

  00140	bf 81 01 04 00	 mov	 edi, 262529		; 00040181H
$LN5@DoVerbProp:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00145	85 c0		 test	 eax, eax
  00147	74 06		 je	 SHORT $LN68@DoVerbProp

; 184  :             p->Release();

  00149	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014b	50		 push	 eax
  0014c	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN68@DoVerbProp:

; 183  :         if (p)

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _spSite$[ebp]
  00152	85 c0		 test	 eax, eax
  00154	74 06		 je	 SHORT $LN75@DoVerbProp

; 184  :             p->Release();

  00156	8b 08		 mov	 ecx, DWORD PTR [eax]
  00158	50		 push	 eax
  00159	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN75@DoVerbProp:

; 183  :         if (p)

  0015c	8b 45 f8	 mov	 eax, DWORD PTR _spObj$[ebp]
  0015f	85 c0		 test	 eax, eax
  00161	74 06		 je	 SHORT $LN82@DoVerbProp

; 184  :             p->Release();

  00163	8b 08		 mov	 ecx, DWORD PTR [eax]
  00165	50		 push	 eax
  00166	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN82@DoVerbProp:

; 183  :         if (p)

  00169	8b 75 f4	 mov	 esi, DWORD PTR _spPages$[ebp]
  0016c	85 f6		 test	 esi, esi
  0016e	74 06		 je	 SHORT $LN89@DoVerbProp

; 184  :             p->Release();

  00170	8b 06		 mov	 eax, DWORD PTR [esi]
  00172	56		 push	 esi
  00173	ff 50 08	 call	 DWORD PTR [eax+8]
$LN89@DoVerbProp:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 964  : 	return hr;

  00176	8b c7		 mov	 eax, edi
  00178	5f		 pop	 edi
  00179	5e		 pop	 esi
  0017a	5b		 pop	 ebx

; 965  : }

  0017b	c9		 leave
  0017c	c2 08 00	 ret	 8
?DoVerbProperties@CComControlBase@ATL@@QAEJPBUtagRECT@@PAUHWND__@@@Z ENDP ; ATL::CComControlBase::DoVerbProperties
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?IQuickActivate_QuickActivate@CComControlBase@ATL@@QAEJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z
_TEXT	SEGMENT
_pQACont$GSCopy$1$ = -52				; size = 4
_this$GSCopy$1$ = -48					; size = 4
_pPCI$ = -48						; size = 4
_pQACtrl$GSCopy$1$ = -44				; size = 4
_pPI$ = -40						; size = 4
_pCP$1 = -36						; size = 4
_pCP$2 = -36						; size = 4
_pVOEX$ = -32						; size = 4
_pOO$ = -28						; size = 4
_pCPC$ = -24						; size = 4
_iidDefaultSrc$3 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_pQACont$ = 8						; size = 4
_pQACtrl$ = 12						; size = 4
?IQuickActivate_QuickActivate@CComControlBase@ATL@@QAEJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z PROC ; ATL::CComControlBase::IQuickActivate_QuickActivate, COMDAT
; _this$ = ecx

; 801  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _pQACtrl$[ebp]
  00013	57		 push	 edi
  00014	8b 7d 08	 mov	 edi, DWORD PTR _pQACont$[ebp]
  00017	89 4d d0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  0001a	89 7d cc	 mov	 DWORD PTR _pQACont$GSCopy$1$[ebp], edi
  0001d	89 45 d4	 mov	 DWORD PTR _pQACtrl$GSCopy$1$[ebp], eax

; 802  : 	ATLASSERT(pQACont != NULL);
; 803  : 	ATLASSERT(pQACtrl != NULL);
; 804  : 	if (!pQACont || !pQACtrl)

  00020	85 ff		 test	 edi, edi
  00022	0f 84 06 02 00
	00		 je	 $LN3@IQuickActi
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 fe 01 00
	00		 je	 $LN3@IQuickActi

; 806  : 
; 807  : 	HRESULT hRes;
; 808  : 	ULONG uCB = pQACtrl->cbSize;

  00030	53		 push	 ebx
  00031	56		 push	 esi
  00032	8b 30		 mov	 esi, DWORD PTR [eax]

; 809  : 	memset(pQACtrl, 0, uCB);

  00034	33 db		 xor	 ebx, ebx
  00036	56		 push	 esi
  00037	53		 push	 ebx
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _memset

; 810  : 	pQACtrl->cbSize = uCB;

  0003e	8b 45 d4	 mov	 eax, DWORD PTR _pQACtrl$GSCopy$1$[ebp]

; 811  : 
; 812  : 	// get all interfaces we are going to need
; 813  : 	CComPtr<IOleObject> pOO;
; 814  : 	ControlQueryInterface(__uuidof(IOleObject), (void**)&pOO);

  00041	8d 4d e4	 lea	 ecx, DWORD PTR _pOO$[ebp]
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00047	89 5d e4	 mov	 DWORD PTR _pOO$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 810  : 	pQACtrl->cbSize = uCB;

  0004a	89 30		 mov	 DWORD PTR [eax], esi

; 811  : 
; 812  : 	// get all interfaces we are going to need
; 813  : 	CComPtr<IOleObject> pOO;
; 814  : 	ControlQueryInterface(__uuidof(IOleObject), (void**)&pOO);

  0004c	8b 75 d0	 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  0004f	51		 push	 ecx
  00050	68 00 00 00 00	 push	 OFFSET __GUID_00000112_0000_0000_c000_000000000046
  00055	8b ce		 mov	 ecx, esi
  00057	8b 06		 mov	 eax, DWORD PTR [esi]
  00059	ff 50 08	 call	 DWORD PTR [eax+8]

; 816  : 	ControlQueryInterface(__uuidof(IViewObjectEx), (void**)&pVOEX);

  0005c	8b 06		 mov	 eax, DWORD PTR [esi]
  0005e	8d 4d e0	 lea	 ecx, DWORD PTR _pVOEX$[ebp]
  00061	51		 push	 ecx
  00062	68 00 00 00 00	 push	 OFFSET __GUID_3af24292_0c96_11ce_a0cf_00aa00600ab8
  00067	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00069	89 5d e0	 mov	 DWORD PTR _pVOEX$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 816  : 	ControlQueryInterface(__uuidof(IViewObjectEx), (void**)&pVOEX);

  0006c	ff 50 08	 call	 DWORD PTR [eax+8]

; 818  : 	ControlQueryInterface(__uuidof(IPointerInactive), (void**)&pPI);

  0006f	8b 06		 mov	 eax, DWORD PTR [esi]
  00071	8d 4d d8	 lea	 ecx, DWORD PTR _pPI$[ebp]
  00074	51		 push	 ecx
  00075	68 00 00 00 00	 push	 OFFSET __GUID_55980ba0_35aa_11cf_b671_00aa004cd6d8
  0007a	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0007c	89 5d d8	 mov	 DWORD PTR _pPI$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 818  : 	ControlQueryInterface(__uuidof(IPointerInactive), (void**)&pPI);

  0007f	ff 50 08	 call	 DWORD PTR [eax+8]

; 820  : 	ControlQueryInterface(__uuidof(IProvideClassInfo2), (void**)&pPCI);

  00082	8b 06		 mov	 eax, DWORD PTR [esi]
  00084	8d 4d d0	 lea	 ecx, DWORD PTR _pPCI$[ebp]
  00087	51		 push	 ecx
  00088	68 00 00 00 00	 push	 OFFSET __GUID_a6bc3ac0_dbaa_11ce_9de3_00aa004bb851
  0008d	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0008f	89 5d d0	 mov	 DWORD PTR _pPCI$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 820  : 	ControlQueryInterface(__uuidof(IProvideClassInfo2), (void**)&pPCI);

  00092	ff 50 08	 call	 DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00095	8b 4d e4	 mov	 ecx, DWORD PTR _pOO$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 822  : 	if (pOO == NULL || pVOEX == NULL)

  00098	8b 55 e0	 mov	 edx, DWORD PTR _pVOEX$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  0009b	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 822  : 	if (pOO == NULL || pVOEX == NULL)

  0009d	0f 84 40 01 00
	00		 je	 $LN5@IQuickActi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  000a3	85 d2		 test	 edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 822  : 	if (pOO == NULL || pVOEX == NULL)

  000a5	0f 84 38 01 00
	00		 je	 $LN5@IQuickActi

; 823  : 		return E_FAIL;
; 824  : 
; 825  : 	pOO->SetClientSite(pQACont->pClientSite);

  000ab	ff 77 04	 push	 DWORD PTR [edi+4]
  000ae	8b 01		 mov	 eax, DWORD PTR [ecx]
  000b0	51		 push	 ecx
  000b1	ff 50 0c	 call	 DWORD PTR [eax+12]

; 826  : 
; 827  : 	if (pQACont->pAdviseSink != NULL)

  000b4	39 5f 08	 cmp	 DWORD PTR [edi+8], ebx
  000b7	74 0f		 je	 SHORT $LN6@IQuickActi

; 828  : 	{
; 829  : 		ATLTRACE(atlTraceControls,2,_T("Setting up IOleObject Advise\n"));
; 830  : 		pVOEX->SetAdvise(DVASPECT_CONTENT, 0, pQACont->pAdviseSink);

  000b9	8b 45 e0	 mov	 eax, DWORD PTR _pVOEX$[ebp]
  000bc	ff 77 08	 push	 DWORD PTR [edi+8]
  000bf	53		 push	 ebx
  000c0	8b 10		 mov	 edx, DWORD PTR [eax]
  000c2	6a 01		 push	 1
  000c4	50		 push	 eax
  000c5	ff 52 1c	 call	 DWORD PTR [edx+28]
$LN6@IQuickActi:

; 834  : 	ControlQueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);

  000c8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ca	8d 4d e8	 lea	 ecx, DWORD PTR _pCPC$[ebp]
  000cd	51		 push	 ecx
  000ce	68 00 00 00 00	 push	 OFFSET __GUID_b196b284_bab4_101a_b69c_00aa00341d07
  000d3	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  000d5	89 5d e8	 mov	 DWORD PTR _pCPC$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 834  : 	ControlQueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);

  000d8	ff 50 08	 call	 DWORD PTR [eax+8]

; 835  : 
; 836  : 	if (pQACont->pPropertyNotifySink)

  000db	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  000de	74 3d		 je	 SHORT $LN127@IQuickActi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  000e0	8b 45 e8	 mov	 eax, DWORD PTR _pCPC$[ebp]

; 165  :         p = NULL;

  000e3	89 5d dc	 mov	 DWORD PTR _pCP$2[ebp], ebx

; 223  :         return p == pT;

  000e6	85 c0		 test	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 840  : 		if (pCPC != NULL)

  000e8	74 36		 je	 SHORT $LN75@IQuickActi

; 841  : 		{
; 842  : 			hRes = pCPC->FindConnectionPoint(__uuidof(IPropertyNotifySink), &pCP);

  000ea	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ec	8d 55 dc	 lea	 edx, DWORD PTR _pCP$2[ebp]
  000ef	52		 push	 edx
  000f0	68 00 00 00 00	 push	 OFFSET __GUID_9bfbbc02_eff1_101a_84ed_00aa00341d07
  000f5	50		 push	 eax
  000f6	ff 51 10	 call	 DWORD PTR [ecx+16]

; 843  : 			if (SUCCEEDED(hRes))

  000f9	85 c0		 test	 eax, eax
  000fb	78 13		 js	 SHORT $LN9@IQuickActi

; 844  : 				pCP->Advise(pQACont->pPropertyNotifySink, &pQACtrl->dwPropNotifyCookie);

  000fd	8b 45 dc	 mov	 eax, DWORD PTR _pCP$2[ebp]
  00100	8b 4d d4	 mov	 ecx, DWORD PTR _pQACtrl$GSCopy$1$[ebp]
  00103	83 c1 10	 add	 ecx, 16			; 00000010H
  00106	51		 push	 ecx
  00107	ff 77 0c	 push	 DWORD PTR [edi+12]
  0010a	8b 10		 mov	 edx, DWORD PTR [eax]
  0010c	50		 push	 eax
  0010d	ff 52 14	 call	 DWORD PTR [edx+20]
$LN9@IQuickActi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00110	8b 45 dc	 mov	 eax, DWORD PTR _pCP$2[ebp]
  00113	85 c0		 test	 eax, eax
  00115	74 06		 je	 SHORT $LN127@IQuickActi

; 184  :             p->Release();

  00117	8b 08		 mov	 ecx, DWORD PTR [eax]
  00119	50		 push	 eax
  0011a	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN127@IQuickActi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 848  : 	if (pPCI)

  0011d	8b 45 e8	 mov	 eax, DWORD PTR _pCPC$[ebp]
$LN75@IQuickActi:
  00120	8b 7d d0	 mov	 edi, DWORD PTR _pPCI$[ebp]
  00123	85 ff		 test	 edi, edi
  00125	74 57		 je	 SHORT $LN88@IQuickActi

; 849  : 	{
; 850  : 		GUID iidDefaultSrc;
; 851  : 		if (SUCCEEDED(pPCI->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,

  00127	8b 07		 mov	 eax, DWORD PTR [edi]
  00129	8d 4d ec	 lea	 ecx, DWORD PTR _iidDefaultSrc$3[ebp]
  0012c	51		 push	 ecx
  0012d	6a 01		 push	 1
  0012f	57		 push	 edi
  00130	ff 50 10	 call	 DWORD PTR [eax+16]
  00133	85 c0		 test	 eax, eax
  00135	78 44		 js	 SHORT $LN128@IQuickActi

; 852  : 			&iidDefaultSrc)))
; 853  : 		{
; 854  : 			if (pQACont->pUnkEventSink)

  00137	8b 75 cc	 mov	 esi, DWORD PTR _pQACont$GSCopy$1$[ebp]
  0013a	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
  0013d	74 3c		 je	 SHORT $LN128@IQuickActi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  0013f	8b 45 e8	 mov	 eax, DWORD PTR _pCPC$[ebp]

; 165  :         p = NULL;

  00142	89 5d dc	 mov	 DWORD PTR _pCP$1[ebp], ebx

; 223  :         return p == pT;

  00145	85 c0		 test	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 858  : 				if (pCPC != NULL)

  00147	74 35		 je	 SHORT $LN88@IQuickActi

; 859  : 				{
; 860  : 					hRes = pCPC->FindConnectionPoint(iidDefaultSrc, &pCP);

  00149	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014b	8d 55 dc	 lea	 edx, DWORD PTR _pCP$1[ebp]
  0014e	52		 push	 edx
  0014f	8d 55 ec	 lea	 edx, DWORD PTR _iidDefaultSrc$3[ebp]
  00152	52		 push	 edx
  00153	50		 push	 eax
  00154	ff 51 10	 call	 DWORD PTR [ecx+16]

; 861  : 					if (SUCCEEDED(hRes))

  00157	85 c0		 test	 eax, eax
  00159	78 13		 js	 SHORT $LN14@IQuickActi

; 862  : 						pCP->Advise(pQACont->pUnkEventSink, &pQACtrl->dwEventCookie);

  0015b	8b 45 dc	 mov	 eax, DWORD PTR _pCP$1[ebp]
  0015e	8b 4d d4	 mov	 ecx, DWORD PTR _pQACtrl$GSCopy$1$[ebp]
  00161	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00164	51		 push	 ecx
  00165	ff 76 10	 push	 DWORD PTR [esi+16]
  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	50		 push	 eax
  0016b	ff 52 14	 call	 DWORD PTR [edx+20]
$LN14@IQuickActi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0016e	8b 45 dc	 mov	 eax, DWORD PTR _pCP$1[ebp]
  00171	85 c0		 test	 eax, eax
  00173	74 06		 je	 SHORT $LN128@IQuickActi

; 184  :             p->Release();

  00175	8b 08		 mov	 ecx, DWORD PTR [eax]
  00177	50		 push	 eax
  00178	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN128@IQuickActi:

; 223  :         return p == pT;

  0017b	8b 45 e8	 mov	 eax, DWORD PTR _pCPC$[ebp]
$LN88@IQuickActi:
  0017e	8b 4d e4	 mov	 ecx, DWORD PTR _pOO$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 868  : 	if (pOO != NULL)

  00181	8b 7d d4	 mov	 edi, DWORD PTR _pQACtrl$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00184	85 c9		 test	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 868  : 	if (pOO != NULL)

  00186	74 12		 je	 SHORT $LN15@IQuickActi

; 869  : 		pOO->GetMiscStatus(DVASPECT_CONTENT, &pQACtrl->dwMiscStatus);

  00188	8b 11		 mov	 edx, DWORD PTR [ecx]
  0018a	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0018d	50		 push	 eax
  0018e	6a 01		 push	 1
  00190	51		 push	 ecx
  00191	ff 52 58	 call	 DWORD PTR [edx+88]
  00194	8b 4d e4	 mov	 ecx, DWORD PTR _pOO$[ebp]
  00197	8b 45 e8	 mov	 eax, DWORD PTR _pCPC$[ebp]
$LN15@IQuickActi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  0019a	8b 55 e0	 mov	 edx, DWORD PTR _pVOEX$[ebp]
  0019d	85 d2		 test	 edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 871  : 	if (pVOEX != NULL)

  0019f	74 13		 je	 SHORT $LN16@IQuickActi

; 872  : 		pVOEX->GetViewStatus(&pQACtrl->dwViewStatus);

  001a1	8b 0a		 mov	 ecx, DWORD PTR [edx]
  001a3	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  001a6	50		 push	 eax
  001a7	52		 push	 edx
  001a8	ff 51 2c	 call	 DWORD PTR [ecx+44]
  001ab	8b 4d e4	 mov	 ecx, DWORD PTR _pOO$[ebp]
  001ae	8b 55 e0	 mov	 edx, DWORD PTR _pVOEX$[ebp]
  001b1	8b 45 e8	 mov	 eax, DWORD PTR _pCPC$[ebp]
$LN16@IQuickActi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  001b4	8b 75 d8	 mov	 esi, DWORD PTR _pPI$[ebp]
  001b7	85 f6		 test	 esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 874  : 	if (pPI != NULL)

  001b9	74 16		 je	 SHORT $LN17@IQuickActi

; 875  : 		pPI->GetActivationPolicy(&pQACtrl->dwPointerActivationPolicy);

  001bb	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001bd	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  001c0	50		 push	 eax
  001c1	56		 push	 esi
  001c2	ff 51 0c	 call	 DWORD PTR [ecx+12]
  001c5	8b 4d e4	 mov	 ecx, DWORD PTR _pOO$[ebp]
  001c8	8b 55 e0	 mov	 edx, DWORD PTR _pVOEX$[ebp]
  001cb	8b 75 d8	 mov	 esi, DWORD PTR _pPI$[ebp]
  001ce	8b 45 e8	 mov	 eax, DWORD PTR _pCPC$[ebp]
$LN17@IQuickActi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  001d1	85 c0		 test	 eax, eax
  001d3	74 16		 je	 SHORT $LN105@IQuickActi

; 184  :             p->Release();

  001d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d7	50		 push	 eax
  001d8	ff 51 08	 call	 DWORD PTR [ecx+8]
  001db	8b 4d e4	 mov	 ecx, DWORD PTR _pOO$[ebp]
  001de	8b 55 e0	 mov	 edx, DWORD PTR _pVOEX$[ebp]
  001e1	eb 05		 jmp	 SHORT $LN131@IQuickActi
$LN5@IQuickActi:
  001e3	bb 05 40 00 80	 mov	 ebx, -2147467259	; 80004005H
$LN131@IQuickActi:

; 183  :         if (p)

  001e8	8b 75 d8	 mov	 esi, DWORD PTR _pPI$[ebp]
$LN105@IQuickActi:
  001eb	8b 7d d0	 mov	 edi, DWORD PTR _pPCI$[ebp]
  001ee	85 ff		 test	 edi, edi
  001f0	74 0f		 je	 SHORT $LN110@IQuickActi

; 184  :             p->Release();

  001f2	8b 07		 mov	 eax, DWORD PTR [edi]
  001f4	57		 push	 edi
  001f5	ff 50 08	 call	 DWORD PTR [eax+8]
  001f8	8b 4d e4	 mov	 ecx, DWORD PTR _pOO$[ebp]
  001fb	8b 55 e0	 mov	 edx, DWORD PTR _pVOEX$[ebp]
  001fe	8b 75 d8	 mov	 esi, DWORD PTR _pPI$[ebp]
$LN110@IQuickActi:

; 183  :         if (p)

  00201	85 f6		 test	 esi, esi
  00203	74 0c		 je	 SHORT $LN115@IQuickActi

; 184  :             p->Release();

  00205	8b 06		 mov	 eax, DWORD PTR [esi]
  00207	56		 push	 esi
  00208	ff 50 08	 call	 DWORD PTR [eax+8]
  0020b	8b 4d e4	 mov	 ecx, DWORD PTR _pOO$[ebp]
  0020e	8b 55 e0	 mov	 edx, DWORD PTR _pVOEX$[ebp]
$LN115@IQuickActi:

; 183  :         if (p)

  00211	85 d2		 test	 edx, edx
  00213	74 09		 je	 SHORT $LN120@IQuickActi

; 184  :             p->Release();

  00215	8b 02		 mov	 eax, DWORD PTR [edx]
  00217	52		 push	 edx
  00218	ff 50 08	 call	 DWORD PTR [eax+8]
  0021b	8b 4d e4	 mov	 ecx, DWORD PTR _pOO$[ebp]
$LN120@IQuickActi:

; 183  :         if (p)

  0021e	85 c9		 test	 ecx, ecx
  00220	74 06		 je	 SHORT $LN125@IQuickActi

; 184  :             p->Release();

  00222	8b 11		 mov	 edx, DWORD PTR [ecx]
  00224	51		 push	 ecx
  00225	ff 52 08	 call	 DWORD PTR [edx+8]
$LN125@IQuickActi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 876  : 	return S_OK;

  00228	5e		 pop	 esi
  00229	8b c3		 mov	 eax, ebx
  0022b	5b		 pop	 ebx
  0022c	eb 05		 jmp	 SHORT $LN1@IQuickActi
$LN3@IQuickActi:

; 805  : 		return E_POINTER;

  0022e	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@IQuickActi:

; 877  : }

  00233	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00236	33 cd		 xor	 ecx, ebp
  00238	5f		 pop	 edi
  00239	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023e	c9		 leave
  0023f	c2 08 00	 ret	 8
?IQuickActivate_QuickActivate@CComControlBase@ATL@@QAEJPAUtagQACONTAINER@@PAUtagQACONTROL@@@Z ENDP ; ATL::CComControlBase::IQuickActivate_QuickActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SetControlFocus@CComControlBase@ATL@@QAEHH@Z
_TEXT	SEGMENT
_bGrab$ = 8						; size = 4
?SetControlFocus@CComControlBase@ATL@@QAEHH@Z PROC	; ATL::CComControlBase::SetControlFocus, COMDAT
; _this$ = ecx

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 881  : 	if (m_bWndLess)

  00007	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  0000a	f6 c2 02	 test	 dl, 2
  0000d	74 2b		 je	 SHORT $LN2@SetControl

; 882  : 	{
; 883  : 		if (!m_bUIActive && bGrab)

  0000f	f6 c2 08	 test	 dl, 8
  00012	75 13		 jne	 SHORT $LN5@SetControl
  00014	83 7d 08 00	 cmp	 DWORD PTR _bGrab$[ebp], 0
  00018	74 0d		 je	 SHORT $LN5@SetControl

; 884  : 			if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE)))

  0001a	6a 00		 push	 0
  0001c	6a fc		 push	 -4			; fffffffcH
  0001e	e8 00 00 00 00	 call	 ?InPlaceActivate@CComControlBase@ATL@@QAEJJPBUtagRECT@@@Z ; ATL::CComControlBase::InPlaceActivate
  00023	85 c0		 test	 eax, eax
  00025	78 6e		 js	 SHORT $LN8@SetControl
$LN5@SetControl:

; 885  : 				return FALSE;
; 886  : 
; 887  : 		return (m_spInPlaceSite->SetFocus(bGrab) == S_OK);

  00027	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002a	ff 75 08	 push	 DWORD PTR _bGrab$[ebp]
  0002d	50		 push	 eax
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	ff 51 58	 call	 DWORD PTR [ecx+88]
  00033	f7 d8		 neg	 eax
  00035	1b c0		 sbb	 eax, eax
  00037	40		 inc	 eax
  00038	eb 5d		 jmp	 SHORT $LN1@SetControl
$LN2@SetControl:

; 888  : 	}
; 889  : 	else
; 890  : 	{
; 891  : 		// we've got a window.
; 892  : 		//
; 893  : 		if (m_bInPlaceActive)

  0003a	f6 c2 04	 test	 dl, 4
  0003d	74 56		 je	 SHORT $LN8@SetControl

; 894  : 		{
; 895  : 			HWND hwnd = (bGrab) ? m_hWndCD : ::GetParent(m_hWndCD);

  0003f	83 7d 08 00	 cmp	 DWORD PTR _bGrab$[ebp], 0
  00043	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00046	8b 38		 mov	 edi, DWORD PTR [eax]
  00048	75 0c		 jne	 SHORT $LN12@SetControl
  0004a	57		 push	 edi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetParent@4
  00051	8b 56 44	 mov	 edx, DWORD PTR [esi+68]
  00054	8b f8		 mov	 edi, eax
$LN12@SetControl:

; 896  : 			if (!m_bUIActive && bGrab)

  00056	f6 c2 08	 test	 dl, 8
  00059	75 1c		 jne	 SHORT $LN7@SetControl
  0005b	83 7d 08 00	 cmp	 DWORD PTR _bGrab$[ebp], 0
  0005f	74 16		 je	 SHORT $LN7@SetControl

; 897  : 				return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));

  00061	6a 00		 push	 0
  00063	6a fc		 push	 -4			; fffffffcH
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?InPlaceActivate@CComControlBase@ATL@@QAEJJPBUtagRECT@@@Z ; ATL::CComControlBase::InPlaceActivate
  0006c	33 c9		 xor	 ecx, ecx
  0006e	85 c0		 test	 eax, eax
  00070	0f 99 c1	 setns	 cl
  00073	8b c1		 mov	 eax, ecx
  00075	eb 20		 jmp	 SHORT $LN1@SetControl
$LN7@SetControl:

; 898  : 			else
; 899  : 			{
; 900  : 				if (!::IsChild(hwnd, ::GetFocus()))

  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  0007d	50		 push	 eax
  0007e	57		 push	 edi
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsChild@8
  00085	85 c0		 test	 eax, eax
  00087	75 07		 jne	 SHORT $LN9@SetControl

; 901  : 					::SetFocus(hwnd);

  00089	57		 push	 edi
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFocus@4
$LN9@SetControl:

; 902  : 				return TRUE;

  00090	33 c0		 xor	 eax, eax
  00092	40		 inc	 eax
  00093	eb 02		 jmp	 SHORT $LN1@SetControl
$LN8@SetControl:

; 903  : 			}
; 904  : 		}
; 905  : 	}
; 906  : 	return FALSE;

  00095	33 c0		 xor	 eax, eax
$LN1@SetControl:
  00097	5f		 pop	 edi

; 907  : }

  00098	5e		 pop	 esi
  00099	5d		 pop	 ebp
  0009a	c2 04 00	 ret	 4
?SetControlFocus@CComControlBase@ATL@@QAEHH@Z ENDP	; ATL::CComControlBase::SetControlFocus
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DoesVerbActivate@CComControlBase@ATL@@QAEHJ@Z
_TEXT	SEGMENT
_iVerb$ = 8						; size = 4
?DoesVerbActivate@CComControlBase@ATL@@QAEHJ@Z PROC	; ATL::CComControlBase::DoesVerbActivate, COMDAT
; _this$ = ecx

; 689  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 690  : 		BOOL b = FALSE;
; 691  : 		switch (iVerb)

  00003	8b 45 08	 mov	 eax, DWORD PTR _iVerb$[ebp]
  00006	33 c9		 xor	 ecx, ecx
  00008	83 f8 fb	 cmp	 eax, -5			; fffffffbH
  0000b	7c 0e		 jl	 SHORT $LN2@DoesVerbAc
  0000d	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00010	7e 06		 jle	 SHORT $LN4@DoesVerbAc
  00012	40		 inc	 eax
  00013	83 f8 01	 cmp	 eax, 1
  00016	77 03		 ja	 SHORT $LN2@DoesVerbAc
$LN4@DoesVerbAc:

; 692  : 		{
; 693  : 			case OLEIVERB_UIACTIVATE:
; 694  : 			case OLEIVERB_PRIMARY:
; 695  : 			case OLEIVERB_SHOW:
; 696  : 			case OLEIVERB_INPLACEACTIVATE:
; 697  : 				b = TRUE;

  00018	33 c9		 xor	 ecx, ecx
  0001a	41		 inc	 ecx
$LN2@DoesVerbAc:

; 698  : 				break;
; 699  : 		}
; 700  : 		return b;

  0001b	8b c1		 mov	 eax, ecx

; 701  : 	}

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?DoesVerbActivate@CComControlBase@ATL@@QAEHJ@Z ENDP	; ATL::CComControlBase::DoesVerbActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?DoesVerbUIActivate@CComControlBase@ATL@@QAEHJ@Z
_TEXT	SEGMENT
_iVerb$ = 8						; size = 4
?DoesVerbUIActivate@CComControlBase@ATL@@QAEHJ@Z PROC	; ATL::CComControlBase::DoesVerbUIActivate, COMDAT
; _this$ = ecx

; 673  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 674  : 		BOOL b = FALSE;
; 675  : 		switch (iVerb)

  00003	8b 45 08	 mov	 eax, DWORD PTR _iVerb$[ebp]
  00006	53		 push	 ebx
  00007	33 db		 xor	 ebx, ebx
  00009	56		 push	 esi
  0000a	33 f6		 xor	 esi, esi
  0000c	43		 inc	 ebx
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx
  00010	83 f8 fc	 cmp	 eax, -4			; fffffffcH
  00013	74 04		 je	 SHORT $LN4@DoesVerbUI
  00015	85 c0		 test	 eax, eax
  00017	75 02		 jne	 SHORT $LN2@DoesVerbUI
$LN4@DoesVerbUI:

; 676  : 		{
; 677  : 			case OLEIVERB_UIACTIVATE:
; 678  : 			case OLEIVERB_PRIMARY:
; 679  : 				b = TRUE;

  00019	8b f3		 mov	 esi, ebx
$LN2@DoesVerbUI:

; 680  : 				break;
; 681  : 		}
; 682  : 		// if no ambient dispatch then in old style OLE container
; 683  : 		if (DoesVerbActivate(iVerb) && m_spAmbientDispatch.p == NULL)

  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?DoesVerbActivate@CComControlBase@ATL@@QAEHJ@Z ; ATL::CComControlBase::DoesVerbActivate
  00021	85 c0		 test	 eax, eax
  00023	74 07		 je	 SHORT $LN5@DoesVerbUI
  00025	83 7f 18 00	 cmp	 DWORD PTR [edi+24], 0
  00029	0f 44 f3	 cmove	 esi, ebx
$LN5@DoesVerbUI:

; 684  : 			b = TRUE;
; 685  : 		return b;

  0002c	5f		 pop	 edi
  0002d	8b c6		 mov	 eax, esi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx

; 686  : 	}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?DoesVerbUIActivate@CComControlBase@ATL@@QAEHJ@Z ENDP	; ATL::CComControlBase::DoesVerbUIActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetAmbientUserMode@CComControlBase@ATL@@QAEJAAH@Z
_TEXT	SEGMENT
_var$ = -16						; size = 16
_bUserMode$ = 8						; size = 4
?GetAmbientUserMode@CComControlBase@ATL@@QAEJAAH@Z PROC	; ATL::CComControlBase::GetAmbientUserMode, COMDAT
; _this$ = ecx

; 475  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  00006	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 475  : 	{

  00008	56		 push	 esi
  00009	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  0000a	8d 7d f0	 lea	 edi, DWORD PTR _var$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 475  : 	{

  0000d	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  0000f	ab		 stosd
  00010	ab		 stosd
  00011	ab		 stosd
  00012	ab		 stosd

; 2161 :         ::VariantInit(this);

  00013	8d 45 f0	 lea	 eax, DWORD PTR _var$[ebp]
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 328  : 		if (m_spAmbientDispatch.p != NULL)

  0001d	83 7e 18 00	 cmp	 DWORD PTR [esi+24], 0
  00021	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
  00026	74 36		 je	 SHORT $LN2@GetAmbient
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 429  :         return GetProperty(this->p, dwDispID, pVar);

  00028	8d 45 f0	 lea	 eax, DWORD PTR _var$[ebp]
  0002b	50		 push	 eax
  0002c	68 3b fd ff ff	 push	 -709			; fffffd3bH
  00031	ff 76 18	 push	 DWORD PTR [esi+24]
  00034	e8 00 00 00 00	 call	 ?GetProperty@?$CComPtr@UIDispatch@@@ATL@@SAJPAUIDispatch@@JPAUtagVARIANT@@@Z ; ATL::CComPtr<IDispatch>::GetProperty
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 329  : 			hRes = m_spAmbientDispatch.GetProperty(dispid, &var);

  00039	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 429  :         return GetProperty(this->p, dwDispID, pVar);

  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 478  : 		if(SUCCEEDED(hRes))

  0003e	85 ff		 test	 edi, edi
  00040	78 1c		 js	 SHORT $LN2@GetAmbient

; 479  : 		{
; 480  : 			ATLASSERT(var.vt == VT_BOOL);
; 481  : 			if(var.vt != VT_BOOL)

  00042	66 83 7d f0 0b	 cmp	 WORD PTR _var$[ebp], 11	; 0000000bH
  00047	74 07		 je	 SHORT $LN3@GetAmbient
  00049	bf 05 00 02 80	 mov	 edi, -2147352571	; 80020005H
  0004e	eb 0e		 jmp	 SHORT $LN2@GetAmbient
$LN3@GetAmbient:

; 482  : 				return DISP_E_TYPEMISMATCH;
; 483  : 			bUserMode = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _bUserMode$[ebp]
  00053	33 d2		 xor	 edx, edx
  00055	66 39 55 f8	 cmp	 WORD PTR _var$[ebp+8], dx
  00059	0f 95 c2	 setne	 dl
  0005c	89 11		 mov	 DWORD PTR [ecx], edx
$LN2@GetAmbient:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2865 :         return ::VariantClear(this);

  0005e	8d 45 f0	 lea	 eax, DWORD PTR _var$[ebp]
  00061	50		 push	 eax
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 485  : 		return hRes;

  00068	8b c7		 mov	 eax, edi
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi

; 486  : 	}

  0006c	c9		 leave
  0006d	c2 04 00	 ret	 4
?GetAmbientUserMode@CComControlBase@ATL@@QAEJAAH@Z ENDP	; ATL::CComControlBase::GetAmbientUserMode
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetAmbientLocaleID@CComControlBase@ATL@@QAEJAAK@Z
_TEXT	SEGMENT
_var$ = -16						; size = 16
_lcid$ = 8						; size = 4
?GetAmbientLocaleID@CComControlBase@ATL@@QAEJAAK@Z PROC	; ATL::CComControlBase::GetAmbientLocaleID, COMDAT
; _this$ = ecx

; 430  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  00006	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 430  : 	{

  00008	56		 push	 esi
  00009	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  0000a	8d 7d f0	 lea	 edi, DWORD PTR _var$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 430  : 	{

  0000d	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  0000f	ab		 stosd
  00010	ab		 stosd
  00011	ab		 stosd
  00012	ab		 stosd

; 2161 :         ::VariantInit(this);

  00013	8d 45 f0	 lea	 eax, DWORD PTR _var$[ebp]
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 328  : 		if (m_spAmbientDispatch.p != NULL)

  0001d	83 7e 18 00	 cmp	 DWORD PTR [esi+24], 0
  00021	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
  00026	74 22		 je	 SHORT $LN2@GetAmbient
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 429  :         return GetProperty(this->p, dwDispID, pVar);

  00028	8d 45 f0	 lea	 eax, DWORD PTR _var$[ebp]
  0002b	50		 push	 eax
  0002c	68 3f fd ff ff	 push	 -705			; fffffd3fH
  00031	ff 76 18	 push	 DWORD PTR [esi+24]
  00034	e8 00 00 00 00	 call	 ?GetProperty@?$CComPtr@UIDispatch@@@ATL@@SAJPAUIDispatch@@JPAUtagVARIANT@@@Z ; ATL::CComPtr<IDispatch>::GetProperty
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 329  : 			hRes = m_spAmbientDispatch.GetProperty(dispid, &var);

  00039	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 429  :         return GetProperty(this->p, dwDispID, pVar);

  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 434  : 		if (SUCCEEDED(hRes))

  0003e	85 ff		 test	 edi, edi
  00040	78 08		 js	 SHORT $LN2@GetAmbient

; 435  : 			lcid = var.lVal;

  00042	8b 55 08	 mov	 edx, DWORD PTR _lcid$[ebp]
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _var$[ebp+8]
  00048	89 0a		 mov	 DWORD PTR [edx], ecx
$LN2@GetAmbient:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 2865 :         return ::VariantClear(this);

  0004a	8d 45 f0	 lea	 eax, DWORD PTR _var$[ebp]
  0004d	50		 push	 eax
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 436  : 		return hRes;

  00054	8b c7		 mov	 eax, edi
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 437  : 	}

  00058	c9		 leave
  00059	c2 04 00	 ret	 4
?GetAmbientLocaleID@CComControlBase@ATL@@QAEJAAK@Z ENDP	; ATL::CComControlBase::GetAmbientLocaleID
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnMouseActivate@CComControlBase@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT
_pOleObject$1 = -4					; size = 4
_bUserMode$ = -4					; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_bHandled$ = 20						; size = 4
?OnMouseActivate@CComControlBase@ATL@@QAEJIIJAAH@Z PROC	; ATL::CComControlBase::OnMouseActivate, COMDAT
; _this$ = ecx

; 301  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 302  : 		BOOL bUserMode = TRUE;
; 303  : 		HRESULT hRet = GetAmbientUserMode(bUserMode);

  00006	8d 45 fc	 lea	 eax, DWORD PTR _bUserMode$[ebp]
  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bUserMode$[ebp], 1
  00010	50		 push	 eax
  00011	8b f1		 mov	 esi, ecx
  00013	e8 00 00 00 00	 call	 ?GetAmbientUserMode@CComControlBase@ATL@@QAEJAAH@Z ; ATL::CComControlBase::GetAmbientUserMode

; 304  : 		// UI activate if in user mode only
; 305  : 		// allow activation if we can't determine mode
; 306  : 		if (FAILED(hRet) || bUserMode)

  00018	33 ff		 xor	 edi, edi
  0001a	85 c0		 test	 eax, eax
  0001c	78 05		 js	 SHORT $LN3@OnMouseAct
  0001e	39 7d fc	 cmp	 DWORD PTR _bUserMode$[ebp], edi
  00021	74 3d		 je	 SHORT $LN17@OnMouseAct
$LN3@OnMouseAct:

; 309  : 			ControlQueryInterface(__uuidof(IOleObject), (void**)&pOleObject);

  00023	8b 06		 mov	 eax, DWORD PTR [esi]
  00025	8d 4d fc	 lea	 ecx, DWORD PTR _pOleObject$1[ebp]
  00028	51		 push	 ecx
  00029	68 00 00 00 00	 push	 OFFSET __GUID_00000112_0000_0000_c000_000000000046
  0002e	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00030	89 7d fc	 mov	 DWORD PTR _pOleObject$1[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 309  : 			ControlQueryInterface(__uuidof(IOleObject), (void**)&pOleObject);

  00033	ff 50 08	 call	 DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _pOleObject$1[ebp]
  00039	85 c0		 test	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 310  : 			if (pOleObject != NULL)

  0003b	74 23		 je	 SHORT $LN17@OnMouseAct

; 311  : 				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);

  0003d	8b 10		 mov	 edx, DWORD PTR [eax]
  0003f	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00042	51		 push	 ecx
  00043	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00046	ff 31		 push	 DWORD PTR [ecx]
  00048	57		 push	 edi
  00049	ff 76 10	 push	 DWORD PTR [esi+16]
  0004c	57		 push	 edi
  0004d	6a fc		 push	 -4			; fffffffcH
  0004f	50		 push	 eax
  00050	ff 52 2c	 call	 DWORD PTR [edx+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00053	8b 4d fc	 mov	 ecx, DWORD PTR _pOleObject$1[ebp]
  00056	85 c9		 test	 ecx, ecx
  00058	74 06		 je	 SHORT $LN17@OnMouseAct

; 184  :             p->Release();

  0005a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005c	51		 push	 ecx
  0005d	ff 52 08	 call	 DWORD PTR [edx+8]
$LN17@OnMouseAct:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 313  : 		bHandled = FALSE;

  00060	8b 4d 14	 mov	 ecx, DWORD PTR _bHandled$[ebp]

; 314  : 		return 1;

  00063	33 c0		 xor	 eax, eax
  00065	40		 inc	 eax
  00066	89 39		 mov	 DWORD PTR [ecx], edi
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi

; 315  : 	}

  0006a	c9		 leave
  0006b	c2 10 00	 ret	 16			; 00000010H
?OnMouseActivate@CComControlBase@ATL@@QAEJIIJAAH@Z ENDP	; ATL::CComControlBase::OnMouseActivate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnKillFocus@CComControlBase@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT
_spSite$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_bHandled$ = 20						; size = 4
?OnKillFocus@CComControlBase@ATL@@QAEJIIJAAH@Z PROC	; ATL::CComControlBase::OnKillFocus, COMDAT
; _this$ = ecx

; 289  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 290  : 		CComQIPtr<IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);

  00007	8d 4d fc	 lea	 ecx, DWORD PTR _spSite$[ebp]
  0000a	ff 76 10	 push	 DWORD PTR [esi+16]
  0000d	e8 00 00 00 00	 call	 ??0?$CComQIPtr@UIOleControlSite@@$1?_GUID_b196b289_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>

; 291  : 		if (m_bInPlaceActive && spSite != NULL && !::IsChild(m_hWndCD, ::GetFocus()))

  00012	f6 46 44 04	 test	 BYTE PTR [esi+68], 4
  00016	74 28		 je	 SHORT $LN15@OnKillFocu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _spSite$[ebp]
  0001b	85 c0		 test	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 291  : 		if (m_bInPlaceActive && spSite != NULL && !::IsChild(m_hWndCD, ::GetFocus()))

  0001d	74 24		 je	 SHORT $LN2@OnKillFocu
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFocus@0
  00025	50		 push	 eax
  00026	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00029	ff 30		 push	 DWORD PTR [eax]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IsChild@8
  00031	85 c0		 test	 eax, eax
  00033	75 0b		 jne	 SHORT $LN15@OnKillFocu

; 292  : 			spSite->OnFocus(FALSE);

  00035	8b 45 fc	 mov	 eax, DWORD PTR _spSite$[ebp]
  00038	6a 00		 push	 0
  0003a	50		 push	 eax
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	ff 51 20	 call	 DWORD PTR [ecx+32]
$LN15@OnKillFocu:

; 293  : 		bHandled = FALSE;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _spSite$[ebp]
$LN2@OnKillFocu:
  00043	8b 4d 14	 mov	 ecx, DWORD PTR _bHandled$[ebp]
  00046	5e		 pop	 esi
  00047	83 21 00	 and	 DWORD PTR [ecx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0004a	85 c0		 test	 eax, eax
  0004c	74 06		 je	 SHORT $LN13@OnKillFocu

; 184  :             p->Release();

  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	50		 push	 eax
  00051	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN13@OnKillFocu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 294  : 		return 1;

  00054	33 c0		 xor	 eax, eax
  00056	40		 inc	 eax

; 295  : 	}

  00057	c9		 leave
  00058	c2 10 00	 ret	 16			; 00000010H
?OnKillFocus@CComControlBase@ATL@@QAEJIIJAAH@Z ENDP	; ATL::CComControlBase::OnKillFocus
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?OnSetFocus@CComControlBase@ATL@@QAEJIIJAAH@Z
_TEXT	SEGMENT
_spSite$1 = -8						; size = 4
_pOleObject$2 = -4					; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_bHandled$ = 20						; size = 4
?OnSetFocus@CComControlBase@ATL@@QAEJIIJAAH@Z PROC	; ATL::CComControlBase::OnSetFocus, COMDAT
; _this$ = ecx

; 270  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi

; 271  : 		if (m_bInPlaceActive)

  00009	33 ff		 xor	 edi, edi
  0000b	f6 46 44 04	 test	 BYTE PTR [esi+68], 4
  0000f	74 6a		 je	 SHORT $LN28@OnSetFocus

; 274  : 			ControlQueryInterface(__uuidof(IOleObject), (void**)&pOleObject);

  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	8d 4d fc	 lea	 ecx, DWORD PTR _pOleObject$2[ebp]
  00016	51		 push	 ecx
  00017	68 00 00 00 00	 push	 OFFSET __GUID_00000112_0000_0000_c000_000000000046
  0001c	8b ce		 mov	 ecx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0001e	89 7d fc	 mov	 DWORD PTR _pOleObject$2[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 274  : 			ControlQueryInterface(__uuidof(IOleObject), (void**)&pOleObject);

  00021	ff 50 08	 call	 DWORD PTR [eax+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _pOleObject$2[ebp]
  00027	85 c0		 test	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 275  : 			if (pOleObject != NULL)

  00029	74 16		 je	 SHORT $LN3@OnSetFocus

; 276  : 				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);

  0002b	8b 10		 mov	 edx, DWORD PTR [eax]
  0002d	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00030	51		 push	 ecx
  00031	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00034	ff 31		 push	 DWORD PTR [ecx]
  00036	57		 push	 edi
  00037	ff 76 10	 push	 DWORD PTR [esi+16]
  0003a	57		 push	 edi
  0003b	6a fc		 push	 -4			; fffffffcH
  0003d	50		 push	 eax
  0003e	ff 52 2c	 call	 DWORD PTR [edx+44]
$LN3@OnSetFocus:

; 277  : 			CComQIPtr<IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);

  00041	ff 76 10	 push	 DWORD PTR [esi+16]
  00044	8d 4d f8	 lea	 ecx, DWORD PTR _spSite$1[ebp]
  00047	e8 00 00 00 00	 call	 ??0?$CComQIPtr@UIOleControlSite@@$1?_GUID_b196b289_bab4_101a_b69c_00aa00341d07@@3U__s_GUID@@B@ATL@@QAE@PAUIUnknown@@@Z ; ATL::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>::CComQIPtr<IOleControlSite,&_GUID_b196b289_bab4_101a_b69c_00aa00341d07>

; 278  : 			if (m_bInPlaceActive && spSite != NULL)

  0004c	f6 46 44 04	 test	 BYTE PTR [esi+68], 4
  00050	74 0f		 je	 SHORT $LN4@OnSetFocus
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 223  :         return p == pT;

  00052	8b 45 f8	 mov	 eax, DWORD PTR _spSite$1[ebp]
  00055	85 c0		 test	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 278  : 			if (m_bInPlaceActive && spSite != NULL)

  00057	74 15		 je	 SHORT $LN23@OnSetFocus

; 279  : 				spSite->OnFocus(TRUE);

  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	6a 01		 push	 1
  0005d	50		 push	 eax
  0005e	ff 51 20	 call	 DWORD PTR [ecx+32]
$LN4@OnSetFocus:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00061	8b 45 f8	 mov	 eax, DWORD PTR _spSite$1[ebp]
  00064	85 c0		 test	 eax, eax
  00066	74 06		 je	 SHORT $LN23@OnSetFocus

; 184  :             p->Release();

  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	50		 push	 eax
  0006b	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN23@OnSetFocus:

; 183  :         if (p)

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _pOleObject$2[ebp]
  00071	85 c9		 test	 ecx, ecx
  00073	74 06		 je	 SHORT $LN28@OnSetFocus

; 184  :             p->Release();

  00075	8b 11		 mov	 edx, DWORD PTR [ecx]
  00077	51		 push	 ecx
  00078	ff 52 08	 call	 DWORD PTR [edx+8]
$LN28@OnSetFocus:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 281  : 		bHandled = FALSE;

  0007b	8b 4d 14	 mov	 ecx, DWORD PTR _bHandled$[ebp]

; 282  : 		return 1;

  0007e	33 c0		 xor	 eax, eax
  00080	40		 inc	 eax
  00081	89 39		 mov	 DWORD PTR [ecx], edi
  00083	5f		 pop	 edi
  00084	5e		 pop	 esi

; 283  : 	}

  00085	c9		 leave
  00086	c2 10 00	 ret	 16			; 00000010H
?OnSetFocus@CComControlBase@ATL@@QAEJIIJAAH@Z ENDP	; ATL::CComControlBase::OnSetFocus
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?SendOnDataChange@CComControlBase@ATL@@QAEJK@Z
_TEXT	SEGMENT
_pdo$1 = -4						; size = 4
_advf$ = 8						; size = 4
?SendOnDataChange@CComControlBase@ATL@@QAEJK@Z PROC	; ATL::CComControlBase::SendOnDataChange, COMDAT
; _this$ = ecx

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1118 : 	HRESULT hRes = S_OK;

  00008	33 f6		 xor	 esi, esi

; 1119 : 	if (m_spDataAdviseHolder)

  0000a	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  0000d	74 36		 je	 SHORT $LN12@SendOnData

; 1122 : 		if (SUCCEEDED(ControlQueryInterface(__uuidof(IDataObject), (void**)&pdo)))

  0000f	8b 07		 mov	 eax, DWORD PTR [edi]
  00011	8d 4d fc	 lea	 ecx, DWORD PTR _pdo$1[ebp]
  00014	51		 push	 ecx
  00015	68 00 00 00 00	 push	 OFFSET __GUID_0000010e_0000_0000_c000_000000000046
  0001a	8b cf		 mov	 ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0001c	89 75 fc	 mov	 DWORD PTR _pdo$1[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1122 : 		if (SUCCEEDED(ControlQueryInterface(__uuidof(IDataObject), (void**)&pdo)))

  0001f	ff 50 08	 call	 DWORD PTR [eax+8]
  00022	85 c0		 test	 eax, eax
  00024	78 12		 js	 SHORT $LN3@SendOnData

; 1123 : 			hRes = m_spDataAdviseHolder->SendOnDataChange(pdo, 0, advf);

  00026	ff 75 08	 push	 DWORD PTR _advf$[ebp]
  00029	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0002c	56		 push	 esi
  0002d	ff 75 fc	 push	 DWORD PTR _pdo$1[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	50		 push	 eax
  00033	ff 51 18	 call	 DWORD PTR [ecx+24]
  00036	8b f0		 mov	 esi, eax
$LN3@SendOnData:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _pdo$1[ebp]
  0003b	85 c9		 test	 ecx, ecx
  0003d	74 06		 je	 SHORT $LN12@SendOnData

; 184  :             p->Release();

  0003f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00041	51		 push	 ecx
  00042	ff 52 08	 call	 DWORD PTR [edx+8]
$LN12@SendOnData:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h

; 1125 : 	return hRes;

  00045	5f		 pop	 edi
  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 1126 : }

  00049	c9		 leave
  0004a	c2 04 00	 ret	 4
?SendOnDataChange@CComControlBase@ATL@@QAEJK@Z ENDP	; ATL::CComControlBase::SendOnDataChange
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlctl.h
;	COMDAT ?GetZoomInfo@CComControlBase@ATL@@QAEXAAUATL_DRAWINFO@@@Z
_TEXT	SEGMENT
_sizeDen$ = -8						; size = 8
_di$ = 8						; size = 4
?GetZoomInfo@CComControlBase@ATL@@QAEXAAUATL_DRAWINFO@@@Z PROC ; ATL::CComControlBase::GetZoomInfo, COMDAT
; _this$ = ecx

; 1501 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1502 : 	const RECTL& rcPos = *di.prcBounds;
; 1503 : 	SIZEL sizeDen;
; 1504 : 	if (m_bDrawFromNatural)

  00005	f7 41 44 00 10
	00 00		 test	 DWORD PTR [ecx+68], 4096 ; 00001000H
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _di$[ebp]
  00011	57		 push	 edi
  00012	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]
  00015	74 08		 je	 SHORT $LN2@GetZoomInf

; 1505 : 		sizeDen = m_sizeNatural;

  00017	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0001a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0001d	eb 06		 jmp	 SHORT $LN12@GetZoomInf
$LN2@GetZoomInf:

; 1506 : 	else
; 1507 : 		sizeDen = m_sizeExtent;

  0001f	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00022	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
$LN12@GetZoomInf:

; 1508 : 	if (!di.bRectInHimetric)

  00025	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00029	89 45 fc	 mov	 DWORD PTR _sizeDen$[ebp+4], eax
  0002c	89 55 f8	 mov	 DWORD PTR _sizeDen$[ebp], edx
  0002f	75 10		 jne	 SHORT $LN4@GetZoomInf

; 1509 : 		AtlHiMetricToPixel(&sizeDen, &sizeDen);

  00031	8d 45 f8	 lea	 eax, DWORD PTR _sizeDen$[ebp]
  00034	50		 push	 eax
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?AtlHiMetricToPixel@ATL@@YGXPBUtagSIZE@@PAU2@@Z ; ATL::AtlHiMetricToPixel
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _sizeDen$[ebp+4]
  0003e	8b 55 f8	 mov	 edx, DWORD PTR _sizeDen$[ebp]
$LN4@GetZoomInf:

; 1510 : 	SIZEL sizeNum = {rcPos.right-rcPos.left, rcPos.bottom-rcPos.top};

  00041	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]
  00044	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00047	2b 3b		 sub	 edi, DWORD PTR [ebx]
  00049	2b 4b 04	 sub	 ecx, DWORD PTR [ebx+4]

; 1511 : 	di.ZoomNum.cx = sizeNum.cx;

  0004c	89 7e 2c	 mov	 DWORD PTR [esi+44], edi

; 1512 : 	di.ZoomNum.cy = sizeNum.cy;

  0004f	89 4e 30	 mov	 DWORD PTR [esi+48], ecx

; 1513 : 	di.ZoomDen.cx = sizeDen.cx;

  00052	89 56 34	 mov	 DWORD PTR [esi+52], edx

; 1514 : 	di.ZoomDen.cy = sizeDen.cy;

  00055	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1515 : 	if (sizeDen.cx == 0 || sizeDen.cy == 0 ||
; 1516 : 		sizeNum.cx == 0 || sizeNum.cy == 0)

  00058	85 d2		 test	 edx, edx
  0005a	74 1d		 je	 SHORT $LN7@GetZoomInf
  0005c	85 c0		 test	 eax, eax
  0005e	74 19		 je	 SHORT $LN7@GetZoomInf
  00060	85 ff		 test	 edi, edi
  00062	74 15		 je	 SHORT $LN7@GetZoomInf
  00064	85 c9		 test	 ecx, ecx
  00066	74 11		 je	 SHORT $LN7@GetZoomInf

; 1519 : 		di.bZoomed = FALSE;
; 1520 : 	}
; 1521 : 	else if (sizeNum.cx != sizeDen.cx || sizeNum.cy != sizeDen.cy)

  00068	3b fa		 cmp	 edi, edx
  0006a	75 04		 jne	 SHORT $LN10@GetZoomInf
  0006c	3b c8		 cmp	 ecx, eax
  0006e	74 18		 je	 SHORT $LN13@GetZoomInf
$LN10@GetZoomInf:

; 1522 : 		di.bZoomed = TRUE;

  00070	c7 46 24 01 00
	00 00		 mov	 DWORD PTR [esi+36], 1
  00077	eb 13		 jmp	 SHORT $LN9@GetZoomInf
$LN7@GetZoomInf:

; 1517 : 	{
; 1518 : 		di.ZoomNum.cx = di.ZoomNum.cy = di.ZoomDen.cx = di.ZoomDen.cy = 1;

  00079	33 c0		 xor	 eax, eax
  0007b	40		 inc	 eax
  0007c	89 46 38	 mov	 DWORD PTR [esi+56], eax
  0007f	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00082	89 46 30	 mov	 DWORD PTR [esi+48], eax
  00085	89 46 2c	 mov	 DWORD PTR [esi+44], eax
$LN13@GetZoomInf:

; 1523 : 	else
; 1524 : 		di.bZoomed = FALSE;
; 1525 : }

  00088	83 66 24 00	 and	 DWORD PTR [esi+36], 0
$LN9@GetZoomInf:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	c9		 leave
  00090	c2 04 00	 ret	 4
?GetZoomInfo@CComControlBase@ATL@@QAEXAAUATL_DRAWINFO@@@Z ENDP ; ATL::CComControlBase::GetZoomInfo
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ??$AtlModuleRegisterWndClassInfoT@VAtlModuleRegisterWndClassInfoParamW@ATL@@@ATL@@YAGPAU_ATL_BASE_MODULE70@0@PAU_ATL_WIN_MODULE70@0@PAU_ATL_WNDCLASSINFOW@0@PAP6GJPAUHWND__@@IIJ@ZVAtlModuleRegisterWndClassInfoParamW@0@@Z
_TEXT	SEGMENT
_wcTemp$2 = -108					; size = 48
_wc$3 = -60						; size = 48
_proc$1$ = -12						; size = 4
$T4 = -8						; size = 4
_lock$1$sroa$270$1$ = -4				; size = 4
_pBaseModule$ = 8					; size = 4
_pWinModule$ = 12					; size = 4
_p$ = 16						; size = 4
_pProc$ = 20						; size = 4
___formal$ = 24						; size = 1
??$AtlModuleRegisterWndClassInfoT@VAtlModuleRegisterWndClassInfoParamW@ATL@@@ATL@@YAGPAU_ATL_BASE_MODULE70@0@PAU_ATL_WIN_MODULE70@0@PAU_ATL_WNDCLASSINFOW@0@PAP6GJPAUHWND__@@IIJ@ZVAtlModuleRegisterWndClassInfoParamW@0@@Z PROC ; ATL::AtlModuleRegisterWndClassInfoT<ATL::AtlModuleRegisterWndClassInfoParamW>, COMDAT

; 5293 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 5294 : 	if (pBaseModule == NULL || pWinModule == NULL || p == NULL || pProc == NULL)

  00008	8b 75 08	 mov	 esi, DWORD PTR _pBaseModule$[ebp]
  0000b	57		 push	 edi
  0000c	85 f6		 test	 esi, esi
  0000e	74 7e		 je	 SHORT $LN3@AtlModuleR
  00010	8b 45 0c	 mov	 eax, DWORD PTR _pWinModule$[ebp]
  00013	85 c0		 test	 eax, eax
  00015	74 77		 je	 SHORT $LN3@AtlModuleR
  00017	8b 5d 10	 mov	 ebx, DWORD PTR _p$[ebp]
  0001a	85 db		 test	 ebx, ebx
  0001c	74 70		 je	 SHORT $LN3@AtlModuleR
  0001e	8b 4d 14	 mov	 ecx, DWORD PTR _pProc$[ebp]
  00021	85 c9		 test	 ecx, ecx
  00023	74 69		 je	 SHORT $LN3@AtlModuleR

; 5295 : 	{
; 5296 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Invalid Arguments to AtlModuleRegisterWndClassInfoT\n"));
; 5297 : 		ATLASSERT(0);
; 5298 : 		return 0;
; 5299 : 	}
; 5300 : 
; 5301 : 	if (p->m_atom == 0)

  00025	33 ff		 xor	 edi, edi
  00027	66 39 7b 40	 cmp	 WORD PTR [ebx+64], di
  0002b	0f 85 0a 01 00
	00		 jne	 $LN72@AtlModuleR

; 5303 : 		ATL::CComCritSecLock<ATL::CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);

  00031	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  00034	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 5303 : 		ATL::CComCritSecLock<ATL::CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);

  00035	89 45 fc	 mov	 DWORD PTR _lock$1$sroa$270$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 5310 : 		if(p->m_atom == 0)

  0003e	66 39 7b 40	 cmp	 WORD PTR [ebx+64], di
  00042	0f 85 e7 00 00
	00		 jne	 $LN12@AtlModuleR

; 5311 : 		{
; 5312 : 			if (p->m_lpszOrigName != NULL)

  00048	39 7b 30	 cmp	 DWORD PTR [ebx+48], edi
  0004b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetClassInfoExW@12
  00051	74 63		 je	 SHORT $LN7@AtlModuleR

; 5313 : 			{
; 5314 : 				ATLASSERT(pProc != NULL);
; 5315 : 				typename T::PCXSTR lpsz = p->m_wc.lpszClassName;

  00053	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  00056	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax

; 5316 : 				WNDPROC proc = p->m_wc.lpfnWndProc;

  00059	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0005c	89 45 f4	 mov	 DWORD PTR _proc$1$[ebp], eax

; 5210 : 		return ::GetClassInfoExW(hinst, lpszClass, lpwcx);

  0005f	8d 45 c4	 lea	 eax, DWORD PTR _wc$3[ebp]
  00062	50		 push	 eax
  00063	ff 73 30	 push	 DWORD PTR [ebx+48]

; 5317 : 
; 5318 : 				typename T::WNDCLASSEX wc;
; 5319 : 				wc.cbSize = sizeof(T::WNDCLASSEX);

  00066	c7 45 c4 30 00
	00 00		 mov	 DWORD PTR _wc$3[ebp], 48 ; 00000030H

; 5210 : 		return ::GetClassInfoExW(hinst, lpszClass, lpwcx);

  0006d	6a 00		 push	 0
  0006f	ff d7		 call	 edi

; 5320 : 				// Try global class
; 5321 : 				if(!T::GetClassInfoEx(NULL, p->m_lpszOrigName, &wc))

  00071	85 c0		 test	 eax, eax
  00073	75 20		 jne	 SHORT $LN10@AtlModuleR

; 5210 : 		return ::GetClassInfoExW(hinst, lpszClass, lpwcx);

  00075	8d 45 c4	 lea	 eax, DWORD PTR _wc$3[ebp]
  00078	50		 push	 eax
  00079	ff 73 30	 push	 DWORD PTR [ebx+48]
  0007c	ff 76 04	 push	 DWORD PTR [esi+4]
  0007f	ff d7		 call	 edi

; 5322 : 				{
; 5323 : 					// try process local
; 5324 : 					if(!T::GetClassInfoEx(pBaseModule->m_hInst, p->m_lpszOrigName, &wc))

  00081	85 c0		 test	 eax, eax
  00083	75 10		 jne	 SHORT $LN10@AtlModuleR
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  00085	ff 75 fc	 push	 DWORD PTR _lock$1$sroa$270$1$[ebp]
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN3@AtlModuleR:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 5365 : }

  0008e	33 c0		 xor	 eax, eax
$LN1@AtlModuleR:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	c9		 leave
  00094	c3		 ret	 0
$LN10@AtlModuleR:

; 5325 : 					{
; 5326 : 						ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Could not obtain Window Class information for %Ts\n"), p->m_lpszOrigName);
; 5327 : 						return 0;
; 5328 : 					}
; 5329 : 				}
; 5330 : 				p->m_wc = wc;

  00095	6a 0c		 push	 12			; 0000000cH
  00097	59		 pop	 ecx
  00098	8d 75 c4	 lea	 esi, DWORD PTR _wc$3[ebp]
  0009b	8b fb		 mov	 edi, ebx
  0009d	f3 a5		 rep movsd

; 5331 : 				p->pWndProc = p->m_wc.lpfnWndProc;

  0009f	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]

; 5332 : 				p->m_wc.lpszClassName = lpsz;
; 5333 : 				p->m_wc.lpfnWndProc = proc;

  000a2	8b 4d f4	 mov	 ecx, DWORD PTR _proc$1$[ebp]

; 5334 : 			}

  000a5	8b 75 08	 mov	 esi, DWORD PTR _pBaseModule$[ebp]
  000a8	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  000ab	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  000ae	89 43 28	 mov	 DWORD PTR [ebx+40], eax
  000b1	89 4b 08	 mov	 DWORD PTR [ebx+8], ecx
  000b4	eb 1d		 jmp	 SHORT $LN8@AtlModuleR
$LN7@AtlModuleR:

; 5335 : 			else
; 5336 : 			{
; 5337 : 				p->m_wc.hCursor = T::LoadCursor(p->m_bSystemCursor ? NULL : pBaseModule->m_hInstResource,

  000b6	83 7b 3c 00	 cmp	 DWORD PTR [ebx+60], 0
  000ba	74 04		 je	 SHORT $LN15@AtlModuleR
  000bc	33 c0		 xor	 eax, eax
  000be	eb 03		 jmp	 SHORT $LN16@AtlModuleR
$LN15@AtlModuleR:
  000c0	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
$LN16@AtlModuleR:

; 5240 : 		return ::LoadCursorW(hInstance, lpCursorName);

  000c3	ff 73 38	 push	 DWORD PTR [ebx+56]
  000c6	50		 push	 eax
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadCursorW@8

; 5335 : 			else
; 5336 : 			{
; 5337 : 				p->m_wc.hCursor = T::LoadCursor(p->m_bSystemCursor ? NULL : pBaseModule->m_hInstResource,

  000cd	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  000d0	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
$LN8@AtlModuleR:

; 5338 : 					p->m_lpszCursorID);
; 5339 : 			}
; 5340 : 
; 5341 : 			p->m_wc.hInstance = pBaseModule->m_hInst;

  000d3	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 5342 : 			p->m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes

  000d6	81 63 04 ff bf
	ff ff		 and	 DWORD PTR [ebx+4], -16385 ; ffffbfffH
  000dd	89 53 14	 mov	 DWORD PTR [ebx+20], edx

; 5343 : 			if (p->m_wc.lpszClassName == NULL)

  000e0	85 c0		 test	 eax, eax
  000e2	75 1d		 jne	 SHORT $LN11@AtlModuleR

; 5233 : 		swprintf_s(szBuffer, dwBuffSize, L"ATL:%p", unique);

  000e4	53		 push	 ebx
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_1O@GBFKGNEO@?$AAA?$AAT?$AAL?$AA?3?$AA?$CF?$AAp@

; 5344 : 			{
; 5345 : 				T::FormatWindowClassName(p->m_szAutoName, _countof(p->m_szAutoName), &p->m_wc);

  000ea	8d 73 42	 lea	 esi, DWORD PTR [ebx+66]

; 5233 : 		swprintf_s(szBuffer, dwBuffSize, L"ATL:%p", unique);

  000ed	6a 25		 push	 37			; 00000025H
  000ef	56		 push	 esi
  000f0	e8 00 00 00 00	 call	 _swprintf_s

; 5346 : 				p->m_wc.lpszClassName = p->m_szAutoName;

  000f5	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  000f8	8d 43 42	 lea	 eax, DWORD PTR [ebx+66]

; 5233 : 		swprintf_s(szBuffer, dwBuffSize, L"ATL:%p", unique);

  000fb	83 c4 10	 add	 esp, 16			; 00000010H

; 5346 : 				p->m_wc.lpszClassName = p->m_szAutoName;

  000fe	89 73 28	 mov	 DWORD PTR [ebx+40], esi
$LN11@AtlModuleR:

; 5347 : 			}
; 5348 : 			typename T::WNDCLASSEX wcTemp;
; 5349 : 			wcTemp = p->m_wc;

  00101	6a 0c		 push	 12			; 0000000cH
  00103	59		 pop	 ecx
  00104	8b f3		 mov	 esi, ebx
  00106	8d 7d 94	 lea	 edi, DWORD PTR _wcTemp$2[ebp]
  00109	f3 a5		 rep movsd

; 5210 : 		return ::GetClassInfoExW(hinst, lpszClass, lpwcx);

  0010b	8d 4d 94	 lea	 ecx, DWORD PTR _wcTemp$2[ebp]
  0010e	51		 push	 ecx
  0010f	50		 push	 eax
  00110	52		 push	 edx
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClassInfoExW@12

; 5350 : 			p->m_atom = static_cast<ATOM>(T::GetClassInfoEx(p->m_wc.hInstance, p->m_wc.lpszClassName, &wcTemp));

  00117	66 89 43 40	 mov	 WORD PTR [ebx+64], ax

; 5351 : 			if (p->m_atom == 0)

  0011b	66 85 c0	 test	 ax, ax
  0011e	75 0d		 jne	 SHORT $LN84@AtlModuleR

; 5247 : 		return AtlWinModuleRegisterClassExW(pWinModule, lpwcx);

  00120	53		 push	 ebx
  00121	ff 75 0c	 push	 DWORD PTR _pWinModule$[ebp]
  00124	e8 00 00 00 00	 call	 ?AtlWinModuleRegisterClassExW@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PBUtagWNDCLASSEXW@@@Z ; ATL::AtlWinModuleRegisterClassExW

; 5352 : 			{
; 5353 : 				p->m_atom = T::RegisterClassEx(pWinModule, &p->m_wc);

  00129	66 89 43 40	 mov	 WORD PTR [ebx+64], ax
$LN84@AtlModuleR:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  0012d	33 ff		 xor	 edi, edi
$LN12@AtlModuleR:
  0012f	ff 75 fc	 push	 DWORD PTR _lock$1$sroa$270$1$[ebp]
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00138	8b 4d 14	 mov	 ecx, DWORD PTR _pProc$[ebp]
$LN72@AtlModuleR:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 5358 : 	if (p->m_lpszOrigName != NULL)

  0013b	39 7b 30	 cmp	 DWORD PTR [ebx+48], edi
  0013e	74 05		 je	 SHORT $LN13@AtlModuleR

; 5359 : 	{
; 5360 : 		ATLASSERT(pProc != NULL);
; 5361 : 		ATLASSERT(p->pWndProc != NULL);
; 5362 : 		*pProc = p->pWndProc;

  00140	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00143	89 01		 mov	 DWORD PTR [ecx], eax
$LN13@AtlModuleR:

; 5363 : 	}
; 5364 : 	return p->m_atom;

  00145	66 8b 43 40	 mov	 ax, WORD PTR [ebx+64]
  00149	e9 42 ff ff ff	 jmp	 $LN1@AtlModuleR
??$AtlModuleRegisterWndClassInfoT@VAtlModuleRegisterWndClassInfoParamW@ATL@@@ATL@@YAGPAU_ATL_BASE_MODULE70@0@PAU_ATL_WIN_MODULE70@0@PAU_ATL_WNDCLASSINFOW@0@PAP6GJPAUHWND__@@IIJ@ZVAtlModuleRegisterWndClassInfoParamW@0@@Z ENDP ; ATL::AtlModuleRegisterWndClassInfoT<ATL::AtlModuleRegisterWndClassInfoParamW>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??4?$CComPtr@UIAdviseSink@@@ATL@@QAEPAUIAdviseSink@@PAU2@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??4?$CComPtr@UIAdviseSink@@@ATL@@QAEPAUIAdviseSink@@PAU2@@Z PROC ; ATL::CComPtr<IAdviseSink>::operator=, COMDAT
; _this$ = ecx

; 328  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 329  :         if(this->p!=lp)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lp$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	3b c6		 cmp	 eax, esi
  0000e	74 1e		 je	 SHORT $LN14@operator

; 169  :         p = lp;

  00010	8b d0		 mov	 edx, eax

; 170  :         if (p != NULL)

  00012	85 f6		 test	 esi, esi
  00014	74 08		 je	 SHORT $LN7@operator

; 171  :             p->AddRef();

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	56		 push	 esi
  00019	ff 50 04	 call	 DWORD PTR [eax+4]
  0001c	8b 17		 mov	 edx, DWORD PTR [edi]
$LN7@operator:

; 177  :         other.p = pTemp;

  0001e	89 37		 mov	 DWORD PTR [edi], esi
  00020	8b c6		 mov	 eax, esi

; 183  :         if (p)

  00022	85 d2		 test	 edx, edx
  00024	74 08		 je	 SHORT $LN14@operator

; 184  :             p->Release();

  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	52		 push	 edx
  00029	ff 50 08	 call	 DWORD PTR [eax+8]
  0002c	8b 07		 mov	 eax, DWORD PTR [edi]
$LN14@operator:

; 330  :         {
; 331  :             CComPtr(lp).Swap(*this);
; 332  :         }
; 333  :         return *this;

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 334  :     }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??4?$CComPtr@UIAdviseSink@@@ATL@@QAEPAUIAdviseSink@@PAU2@@Z ENDP ; ATL::CComPtr<IAdviseSink>::operator=
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??4?$CComPtr@UIOleClientSite@@@ATL@@QAEPAUIOleClientSite@@PAU2@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??4?$CComPtr@UIOleClientSite@@@ATL@@QAEPAUIOleClientSite@@PAU2@@Z PROC ; ATL::CComPtr<IOleClientSite>::operator=, COMDAT
; _this$ = ecx

; 328  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 329  :         if(this->p!=lp)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lp$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	3b c6		 cmp	 eax, esi
  0000e	74 1e		 je	 SHORT $LN14@operator

; 169  :         p = lp;

  00010	8b d0		 mov	 edx, eax

; 170  :         if (p != NULL)

  00012	85 f6		 test	 esi, esi
  00014	74 08		 je	 SHORT $LN7@operator

; 171  :             p->AddRef();

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	56		 push	 esi
  00019	ff 50 04	 call	 DWORD PTR [eax+4]
  0001c	8b 17		 mov	 edx, DWORD PTR [edi]
$LN7@operator:

; 177  :         other.p = pTemp;

  0001e	89 37		 mov	 DWORD PTR [edi], esi
  00020	8b c6		 mov	 eax, esi

; 183  :         if (p)

  00022	85 d2		 test	 edx, edx
  00024	74 08		 je	 SHORT $LN14@operator

; 184  :             p->Release();

  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	52		 push	 edx
  00029	ff 50 08	 call	 DWORD PTR [eax+8]
  0002c	8b 07		 mov	 eax, DWORD PTR [edi]
$LN14@operator:

; 330  :         {
; 331  :             CComPtr(lp).Swap(*this);
; 332  :         }
; 333  :         return *this;

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 334  :     }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??4?$CComPtr@UIOleClientSite@@@ATL@@QAEPAUIOleClientSite@@PAU2@@Z ENDP ; ATL::CComPtr<IOleClientSite>::operator=
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?IsEqualObject@?$CComPtrBase@UIOleClientSite@@@ATL@@QAE_NPAUIUnknown@@@Z
_TEXT	SEGMENT
_punk2$ = -4						; size = 4
_punk1$ = 8						; size = 4
_pOther$ = 8						; size = 4
?IsEqualObject@?$CComPtrBase@UIOleClientSite@@@ATL@@QAE_NPAUIUnknown@@@Z PROC ; ATL::CComPtrBase<IOleClientSite>::IsEqualObject, COMDAT
; _this$ = ecx

; 597  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 598  :     if (p == NULL && pOther == NULL)

  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	56		 push	 esi
  00007	85 c9		 test	 ecx, ecx
  00009	75 09		 jne	 SHORT $LN26@IsEqualObj
  0000b	39 4d 08	 cmp	 DWORD PTR _pOther$[ebp], ecx
  0000e	75 56		 jne	 SHORT $LN4@IsEqualObj

; 599  :         return true;	// They are both NULL objects

  00010	b0 01		 mov	 al, 1
  00012	eb 54		 jmp	 SHORT $LN1@IsEqualObj
$LN26@IsEqualObj:

; 600  : 
; 601  :     if (p == NULL || pOther == NULL)

  00014	8b 75 08	 mov	 esi, DWORD PTR _pOther$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	74 4b		 je	 SHORT $LN4@IsEqualObj

; 165  :         p = NULL;

  0001b	83 65 08 00	 and	 DWORD PTR _punk1$[ebp], 0

; 603  : 
; 604  :     CComPtr<IUnknown> punk1;
; 605  :     CComPtr<IUnknown> punk2;
; 606  :     p->QueryInterface(__uuidof(IUnknown), (void**)&punk1);

  0001f	8d 55 08	 lea	 edx, DWORD PTR _punk1$[ebp]

; 165  :         p = NULL;

  00022	83 65 fc 00	 and	 DWORD PTR _punk2$[ebp], 0

; 603  : 
; 604  :     CComPtr<IUnknown> punk1;
; 605  :     CComPtr<IUnknown> punk2;
; 606  :     p->QueryInterface(__uuidof(IUnknown), (void**)&punk1);

  00026	8b 01		 mov	 eax, DWORD PTR [ecx]

; 165  :         p = NULL;

  00028	53		 push	 ebx
  00029	57		 push	 edi

; 603  : 
; 604  :     CComPtr<IUnknown> punk1;
; 605  :     CComPtr<IUnknown> punk2;
; 606  :     p->QueryInterface(__uuidof(IUnknown), (void**)&punk1);

  0002a	52		 push	 edx
  0002b	bf 00 00 00 00	 mov	 edi, OFFSET __GUID_00000000_0000_0000_c000_000000000046
  00030	57		 push	 edi
  00031	51		 push	 ecx
  00032	ff 10		 call	 DWORD PTR [eax]

; 607  :     pOther->QueryInterface(__uuidof(IUnknown), (void**)&punk2);

  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	8d 4d fc	 lea	 ecx, DWORD PTR _punk2$[ebp]
  00039	51		 push	 ecx
  0003a	57		 push	 edi
  0003b	56		 push	 esi
  0003c	ff 10		 call	 DWORD PTR [eax]

; 223  :         return p == pT;

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _punk2$[ebp]
  00041	8b 45 08	 mov	 eax, DWORD PTR _punk1$[ebp]
  00044	3b c1		 cmp	 eax, ecx
  00046	0f 94 c3	 sete	 bl

; 183  :         if (p)

  00049	85 c9		 test	 ecx, ecx
  0004b	74 09		 je	 SHORT $LN19@IsEqualObj

; 184  :             p->Release();

  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	51		 push	 ecx
  00050	ff 50 08	 call	 DWORD PTR [eax+8]
  00053	8b 45 08	 mov	 eax, DWORD PTR _punk1$[ebp]
$LN19@IsEqualObj:

; 183  :         if (p)

  00056	85 c0		 test	 eax, eax
  00058	74 06		 je	 SHORT $LN24@IsEqualObj

; 184  :             p->Release();

  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	50		 push	 eax
  0005d	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN24@IsEqualObj:

; 608  :     return punk1 == punk2;

  00060	5f		 pop	 edi
  00061	8a c3		 mov	 al, bl
  00063	5b		 pop	 ebx
  00064	eb 02		 jmp	 SHORT $LN1@IsEqualObj
$LN4@IsEqualObj:

; 602  :         return false;	// One is NULL the other is not

  00066	32 c0		 xor	 al, al
$LN1@IsEqualObj:
  00068	5e		 pop	 esi

; 609  : }

  00069	c9		 leave
  0006a	c2 04 00	 ret	 4
?IsEqualObject@?$CComPtrBase@UIOleClientSite@@@ATL@@QAE_NPAUIUnknown@@@Z ENDP ; ATL::CComPtrBase<IOleClientSite>::IsEqualObject
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z PROC ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::OnFinalMessage, COMDAT
; _this$ = ecx

; 3516 : 		// override to do something, if needed
; 3517 : 	}

  00000	c2 04 00	 ret	 4
?OnFinalMessage@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEXPAUHWND__@@@Z ENDP ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::OnFinalMessage
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?atlCreate@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@GPAX@Z
_TEXT	SEGMENT
_hWndParent$ = 8					; size = 4
_rect$ = 12						; size = 4
_szWindowName$ = 16					; size = 4
_dwStyle$ = 20						; size = 4
_dwExStyle$ = 24					; size = 4
_MenuOrID$ = 28						; size = 4
_atom$ = 32						; size = 2
_lpCreateParam$ = 36					; size = 4
?atlCreate@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@GPAX@Z PROC ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::atlCreate, COMDAT
; _this$ = ecx

; 3612 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2661 : 		return thunk.Init((DWORD_PTR)proc, pThis);

  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0000d	e8 00 00 00 00	 call	 ?Init@CDynamicStdCallThunk2@ATL@@QAEHKPAX@Z ; ATL::CDynamicStdCallThunk2::Init

; 3613 : 	ATLASSUME(this->m_hWnd == NULL);
; 3614 : 
; 3615 : 	// Allocate the thunk structure here, where we can fail gracefully.
; 3616 : 	BOOL result = this->m_thunk.Init(NULL,NULL);
; 3617 : 	if (result == FALSE) {

  00012	85 c0		 test	 eax, eax
  00014	75 0c		 jne	 SHORT $LN8@atlCreate

; 3618 : 		SetLastError(ERROR_OUTOFMEMORY);

  00016	6a 0e		 push	 14			; 0000000eH
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 3619 : 		return NULL;

  0001e	33 c0		 xor	 eax, eax
  00020	eb 75		 jmp	 SHORT $LN1@atlCreate
$LN8@atlCreate:
  00022	57		 push	 edi

; 3620 : 	}
; 3621 : 
; 3622 : 	if(atom == 0)

  00023	66 8b 7d 20	 mov	 di, WORD PTR _atom$[ebp]
  00027	66 85 ff	 test	 di, di
  0002a	75 04		 jne	 SHORT $LN9@atlCreate

; 3623 : 		return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 66		 jmp	 SHORT $LN17@atlCreate
$LN9@atlCreate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2962 : 		AtlWinModuleAddCreateWndData(this, pData, pObject);

  00030	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 3625 : 	_AtlWinModule.AddCreateWndData(&this->m_thunk.cd, this);

  00031	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2962 : 		AtlWinModuleAddCreateWndData(this, pData, pObject);

  00034	50		 push	 eax
  00035	68 00 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  0003a	e8 00 00 00 00	 call	 ?AtlWinModuleAddCreateWndData@ATL@@YGXPAU_ATL_WIN_MODULE70@1@PAU_AtlCreateWndData@1@PAX@Z ; ATL::AtlWinModuleAddCreateWndData
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 3627 : 	if(MenuOrID.m_hMenu == NULL && (dwStyle & WS_CHILD))

  0003f	8b 4d 1c	 mov	 ecx, DWORD PTR _MenuOrID$[ebp]
  00042	85 c9		 test	 ecx, ecx
  00044	75 0d		 jne	 SHORT $LN10@atlCreate
  00046	f7 45 14 00 00
	00 40		 test	 DWORD PTR _dwStyle$[ebp], 1073741824 ; 40000000H
  0004d	0f 45 ce	 cmovne	 ecx, esi
  00050	89 4d 1c	 mov	 DWORD PTR _MenuOrID$[ebp], ecx
$LN10@atlCreate:

; 3628 : 		MenuOrID.m_hMenu = (HMENU)(UINT_PTR)this;
; 3629 : 	if(rect.m_lpRect == NULL)
; 3630 : 		rect.m_lpRect = &TBase::rcDefault;
; 3631 : 
; 3632 : 	HWND hWnd = ::CreateWindowEx(dwExStyle, MAKEINTATOM(atom), szWindowName,

  00053	ff 75 24	 push	 DWORD PTR _lpCreateParam$[ebp]
  00056	83 7d 0c 00	 cmp	 DWORD PTR _rect$[ebp], 0
  0005a	b8 00 00 00 00	 mov	 eax, OFFSET ?rcDefault@CWindow@ATL@@2UtagRECT@@A ; ATL::CWindow::rcDefault
  0005f	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00065	0f 45 45 0c	 cmovne	 eax, DWORD PTR _rect$[ebp]
  00069	51		 push	 ecx
  0006a	ff 75 08	 push	 DWORD PTR _hWndParent$[ebp]
  0006d	89 45 0c	 mov	 DWORD PTR _rect$[ebp], eax
  00070	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00073	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00076	8b 30		 mov	 esi, DWORD PTR [eax]
  00078	2b ca		 sub	 ecx, edx
  0007a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007d	51		 push	 ecx
  0007e	2b c6		 sub	 eax, esi
  00080	50		 push	 eax
  00081	52		 push	 edx
  00082	56		 push	 esi
  00083	ff 75 14	 push	 DWORD PTR _dwStyle$[ebp]
  00086	0f b7 c7	 movzx	 eax, di
  00089	ff 75 10	 push	 DWORD PTR _szWindowName$[ebp]
  0008c	50		 push	 eax
  0008d	ff 75 18	 push	 DWORD PTR _dwExStyle$[ebp]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateWindowExW@48
$LN17@atlCreate:
  00096	5f		 pop	 edi
$LN1@atlCreate:
  00097	5e		 pop	 esi

; 3633 : 		dwStyle, rect.m_lpRect->left, rect.m_lpRect->top, rect.m_lpRect->right - rect.m_lpRect->left,
; 3634 : 		rect.m_lpRect->bottom - rect.m_lpRect->top, hWndParent, MenuOrID.m_hMenu,
; 3635 : 		_AtlBaseModule.GetModuleInstance(), lpCreateParam);
; 3636 : 
; 3637 : 	ATLASSUME(this->m_hWnd == hWnd);
; 3638 : 
; 3639 : 	return hWnd;
; 3640 : }

  00098	5d		 pop	 ebp
  00099	c2 20 00	 ret	 32			; 00000020H
?atlCreate@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@QAEPAUHWND__@@PAU3@V_U_RECT@2@PB_WKKV_U_MENUorID@2@GPAX@Z ENDP ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::atlCreate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_msg$ = -40						; size = 36
_pfnWndProc$1$ = -4					; size = 4
_lRes$ = 8						; size = 4
_hWnd$ = 8						; size = 4
_pOldMsg$1$ = 12					; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z PROC ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::WindowProc, COMDAT

; 3559 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi

; 3560 : 	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)hWnd;
; 3561 : 	// set a ptr to this message and save the old value
; 3562 : 	_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);

  00007	8b 75 08	 mov	 esi, DWORD PTR _hWnd$[ebp]
  0000a	8d 4d d8	 lea	 ecx, DWORD PTR _msg$[ebp]
  0000d	57		 push	 edi
  0000e	8b 7d 0c	 mov	 edi, DWORD PTR _uMsg$[ebp]
  00011	6a 01		 push	 1
  00013	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00016	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00019	57		 push	 edi
  0001a	ff 76 04	 push	 DWORD PTR [esi+4]
  0001d	e8 00 00 00 00	 call	 ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z ; ATL::_ATL_MSG::_ATL_MSG

; 3563 : 	const _ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;

  00022	8b 46 18	 mov	 eax, DWORD PTR [esi+24]

; 3564 : 	pThis->m_pCurrentMsg = &msg;
; 3565 : 	// pass to the message map to process
; 3566 : 	LRESULT lRes = 0;
; 3567 : 	BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);

  00025	8d 4d 08	 lea	 ecx, DWORD PTR _lRes$[ebp]
  00028	83 65 08 00	 and	 DWORD PTR _lRes$[ebp], 0
  0002c	6a 00		 push	 0
  0002e	51		 push	 ecx
  0002f	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00032	89 45 0c	 mov	 DWORD PTR _pOldMsg$1$[ebp], eax
  00035	8b ce		 mov	 ecx, esi
  00037	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  0003a	8d 45 d8	 lea	 eax, DWORD PTR _msg$[ebp]
  0003d	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	57		 push	 edi
  00043	ff 76 04	 push	 DWORD PTR [esi+4]
  00046	ff 10		 call	 DWORD PTR [eax]

; 3568 : 	// restore saved value for the current message
; 3569 : 	ATLASSERT(pThis->m_pCurrentMsg == &msg);
; 3570 : 
; 3571 : 	// do the default processing if message was not handled
; 3572 : 	if(!bRet)

  00048	85 c0		 test	 eax, eax
  0004a	75 73		 jne	 SHORT $LN20@WindowProc

; 3573 : 	{
; 3574 : 		if(uMsg != WM_NCDESTROY)

  0004c	81 ff 82 00 00
	00		 cmp	 edi, 130		; 00000082H
  00052	74 18		 je	 SHORT $LN3@WindowProc

; 3508 : 		return ::CallWindowProc(m_pfnSuperWindowProc, this->m_hWnd, uMsg, wParam, lParam);

  00054	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00057	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  0005a	57		 push	 edi
  0005b	ff 76 04	 push	 DWORD PTR [esi+4]
  0005e	ff 76 20	 push	 DWORD PTR [esi+32]
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcW@20

; 3575 : 			lRes = pThis->DefWindowProc(uMsg, wParam, lParam);

  00067	89 45 08	 mov	 DWORD PTR _lRes$[ebp], eax
  0006a	eb 53		 jmp	 SHORT $LN20@WindowProc
$LN3@WindowProc:

; 87   : 	return( ::GetWindowLongW( hWnd, nIndex ) );

  0006c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetWindowLongW@8
  00072	6a fc		 push	 -4			; fffffffcH
  00074	ff 76 04	 push	 DWORD PTR [esi+4]
  00077	ff d7		 call	 edi

; 3508 : 		return ::CallWindowProc(m_pfnSuperWindowProc, this->m_hWnd, uMsg, wParam, lParam);

  00079	ff 75 14	 push	 DWORD PTR _lParam$[ebp]

; 3576 : 		else
; 3577 : 		{
; 3578 : 			// unsubclass, if needed
; 3579 : 			LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);

  0007c	89 45 fc	 mov	 DWORD PTR _pfnWndProc$1$[ebp], eax

; 3508 : 		return ::CallWindowProc(m_pfnSuperWindowProc, this->m_hWnd, uMsg, wParam, lParam);

  0007f	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00082	68 82 00 00 00	 push	 130			; 00000082H
  00087	ff 76 04	 push	 DWORD PTR [esi+4]
  0008a	ff 76 20	 push	 DWORD PTR [esi+32]
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcW@20

; 3580 : 			lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
; 3581 : 			if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)

  00093	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  00096	89 45 08	 mov	 DWORD PTR _lRes$[ebp], eax
  00099	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR __imp__DefWindowProcW@16
  0009f	74 1a		 je	 SHORT $LN19@WindowProc

; 87   : 	return( ::GetWindowLongW( hWnd, nIndex ) );

  000a1	6a fc		 push	 -4			; fffffffcH
  000a3	ff 76 04	 push	 DWORD PTR [esi+4]
  000a6	ff d7		 call	 edi

; 3580 : 			lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
; 3581 : 			if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)

  000a8	3b 45 fc	 cmp	 eax, DWORD PTR _pfnWndProc$1$[ebp]
  000ab	75 0e		 jne	 SHORT $LN19@WindowProc

; 67   : 	return( ::SetWindowLongW( hWnd, nIndex, LONG( dwNewLong ) ) );

  000ad	ff 76 20	 push	 DWORD PTR [esi+32]
  000b0	6a fc		 push	 -4			; fffffffcH
  000b2	ff 76 04	 push	 DWORD PTR [esi+4]
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongW@12
$LN19@WindowProc:

; 3582 : 				::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
; 3583 : 			// mark window as destroyed
; 3584 : 			pThis->m_dwState |= CWindowImplRoot<TBase>::WINSTATE_DESTROYED;

  000bb	83 4e 1c 01	 or	 DWORD PTR [esi+28], 1
$LN20@WindowProc:

; 3585 : 		}
; 3586 : 	}
; 3587 : 	if((pThis->m_dwState & CWindowImplRoot<TBase>::WINSTATE_DESTROYED) && pOldMsg== NULL)

  000bf	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  000c2	8b 4d 0c	 mov	 ecx, DWORD PTR _pOldMsg$1$[ebp]
  000c5	a8 01		 test	 al, 1
  000c7	74 1d		 je	 SHORT $LN6@WindowProc
  000c9	85 c9		 test	 ecx, ecx
  000cb	75 19		 jne	 SHORT $LN6@WindowProc

; 3588 : 	{
; 3589 : 		// clear out window handle
; 3590 : 		HWND hWndThis = pThis->m_hWnd;

  000cd	8b 56 04	 mov	 edx, DWORD PTR [esi+4]

; 3591 : 		pThis->m_hWnd = NULL;
; 3592 : 		pThis->m_dwState &= ~CWindowImplRoot<TBase>::WINSTATE_DESTROYED;

  000d0	83 e0 fe	 and	 eax, -2			; fffffffeH
  000d3	21 4e 04	 and	 DWORD PTR [esi+4], ecx

; 3593 : 		// clean up after window is destroyed
; 3594 : 		pThis->m_pCurrentMsg = pOldMsg;

  000d6	21 4e 18	 and	 DWORD PTR [esi+24], ecx

; 3595 : 		pThis->OnFinalMessage(hWndThis);

  000d9	8b ce		 mov	 ecx, esi
  000db	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  000de	8b 06		 mov	 eax, DWORD PTR [esi]
  000e0	52		 push	 edx
  000e1	ff 50 0c	 call	 DWORD PTR [eax+12]

; 3596 : 	}else {

  000e4	eb 03		 jmp	 SHORT $LN7@WindowProc
$LN6@WindowProc:

; 3597 : 		pThis->m_pCurrentMsg = pOldMsg;

  000e6	89 4e 18	 mov	 DWORD PTR [esi+24], ecx
$LN7@WindowProc:

; 3598 : 	}
; 3599 : 	return lRes;

  000e9	8b 45 08	 mov	 eax, DWORD PTR _lRes$[ebp]
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi

; 3600 : }

  000ee	c9		 leave
  000ef	c2 10 00	 ret	 16			; 00000010H
?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z ENDP ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::WindowProc
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlstdthunk.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z PROC ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::StartWindowProc, COMDAT

; 3528 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2967 : 		return AtlWinModuleExtractCreateWndData(this);

  00004	68 00 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00009	e8 00 00 00 00	 call	 ?AtlWinModuleExtractCreateWndData@ATL@@YGPAXPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleExtractCreateWndData
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 3529 : 	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)_AtlWinModule.ExtractCreateWndData();

  0000e	8b d8		 mov	 ebx, eax

; 3530 : 	ATLASSERT(pThis != NULL);
; 3531 : 	if(!pThis)

  00010	85 db		 test	 ebx, ebx
  00012	74 3b		 je	 SHORT $LN1@StartWindo
$LN2@StartWindo:

; 3532 : 	{
; 3533 : 		return 0;
; 3534 : 	}
; 3535 : 	pThis->m_hWnd = hWnd;
; 3536 : 
; 3537 : 	// Initialize the thunk.  This is allocated in CWindowImplBaseT::Create,
; 3538 : 	// so failure is unexpected here.
; 3539 : 
; 3540 : 	pThis->m_thunk.Init(pThis->GetWindowProc(), pThis);

  00014	8b 03		 mov	 eax, DWORD PTR [ebx]
  00016	8b cb		 mov	 ecx, ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b 7d 08	 mov	 edi, DWORD PTR _hWnd$[ebp]
  0001d	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00020	ff 50 08	 call	 DWORD PTR [eax+8]

; 2661 : 		return thunk.Init((DWORD_PTR)proc, pThis);

  00023	53		 push	 ebx
  00024	50		 push	 eax
  00025	8d 4b 14	 lea	 ecx, DWORD PTR [ebx+20]
  00028	e8 00 00 00 00	 call	 ?Init@CDynamicStdCallThunk2@ATL@@QAEHKPAX@Z ; ATL::CDynamicStdCallThunk2::Init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlstdthunk.h

; 289  : 		return AtlThunk_DataToCode(pThunk);

  0002d	ff 73 14	 push	 DWORD PTR [ebx+20]
  00030	e8 00 00 00 00	 call	 _AtlThunk_DataToCode@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h

; 3541 : 	WNDPROC pProc = pThis->m_thunk.GetWNDPROC();

  00035	8b f0		 mov	 esi, eax

; 67   : 	return( ::SetWindowLongW( hWnd, nIndex, LONG( dwNewLong ) ) );

  00037	56		 push	 esi
  00038	6a fc		 push	 -4			; fffffffcH
  0003a	57		 push	 edi
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongW@12

; 3542 : 	WNDPROC pOldProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
; 3543 : #ifdef _DEBUG
; 3544 : 	// check if somebody has subclassed us already since we discard it
; 3545 : 	if(pOldProc != StartWindowProc)
; 3546 : 		ATLTRACE(atlTraceWindowing, 0, _T("Subclassing through a hook discarded.\n"));
; 3547 : #else
; 3548 : 	(pOldProc);	// avoid unused warning
; 3549 : #endif
; 3550 : 	return pProc(hWnd, uMsg, wParam, lParam);

  00041	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00044	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00047	ff 75 0c	 push	 DWORD PTR _uMsg$[ebp]
  0004a	57		 push	 edi
  0004b	ff d6		 call	 esi
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
$LN1@StartWindo:
  0004f	5b		 pop	 ebx

; 3551 : }

  00050	5d		 pop	 ebp
  00051	c2 10 00	 ret	 16			; 00000010H
?StartWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z ENDP ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::StartWindowProc
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ
_TEXT	SEGMENT
?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ PROC ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::GetWindowProc, COMDAT
; _this$ = ecx

; 3453 : 		return WindowProc;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?WindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@SGJPAUHWND__@@IIJ@Z ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::WindowProc

; 3454 : 	}

  00005	c3		 ret	 0
?GetWindowProc@?$CWindowImplBaseT@VCWindow@ATL@@V?$CWinTraits@$0FGAAAAAA@$0A@@2@@ATL@@UAEP6GJPAUHWND__@@IIJ@ZXZ ENDP ; ATL::CWindowImplBaseT<ATL::CWindow,ATL::CWinTraits<1442840576,0> >::GetWindowProc
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?DefaultReflectionHandler@?$CWindowImplRoot@VCWindow@ATL@@@ATL@@SAHPAUHWND__@@IIJAAJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_lResult$ = 24						; size = 4
?DefaultReflectionHandler@?$CWindowImplRoot@VCWindow@ATL@@@ATL@@SAHPAUHWND__@@IIJAAJ@Z PROC ; ATL::CWindowImplRoot<ATL::CWindow>::DefaultReflectionHandler, COMDAT

; 3402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3403 : 	switch(uMsg)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _uMsg$[ebp]
  00006	b9 11 21 00 00	 mov	 ecx, 8465		; 00002111H
  0000b	3b c1		 cmp	 eax, ecx
  0000d	77 22		 ja	 SHORT $LN7@DefaultRef
  0000f	74 43		 je	 SHORT $LN4@DefaultRef
  00011	3d 2b 20 00 00	 cmp	 eax, 8235		; 0000202bH
  00016	72 15		 jb	 SHORT $LN5@DefaultRef
  00018	3d 2f 20 00 00	 cmp	 eax, 8239		; 0000202fH
  0001d	76 35		 jbe	 SHORT $LN4@DefaultRef
  0001f	3d 39 20 00 00	 cmp	 eax, 8249		; 00002039H
  00024	74 2e		 je	 SHORT $LN4@DefaultRef
  00026	3d 4e 20 00 00	 cmp	 eax, 8270		; 0000204eH
  0002b	74 27		 je	 SHORT $LN4@DefaultRef
$LN5@DefaultRef:

; 3425 : 	default:
; 3426 : 		break;
; 3427 : 	}
; 3428 : 	return FALSE;

  0002d	33 c0		 xor	 eax, eax

; 3429 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN7@DefaultRef:

; 3403 : 	switch(uMsg)

  00031	3d 14 21 00 00	 cmp	 eax, 8468		; 00002114H
  00036	72 f5		 jb	 SHORT $LN5@DefaultRef
  00038	3d 15 21 00 00	 cmp	 eax, 8469		; 00002115H
  0003d	76 15		 jbe	 SHORT $LN4@DefaultRef
  0003f	3d 31 21 00 00	 cmp	 eax, 8497		; 00002131H
  00044	76 e7		 jbe	 SHORT $LN5@DefaultRef
  00046	3d 38 21 00 00	 cmp	 eax, 8504		; 00002138H
  0004b	76 07		 jbe	 SHORT $LN4@DefaultRef
  0004d	3d 10 22 00 00	 cmp	 eax, 8720		; 00002210H
  00052	75 d9		 jne	 SHORT $LN5@DefaultRef
$LN4@DefaultRef:

; 3404 : 	{
; 3405 : 	case OCM_COMMAND:
; 3406 : 	case OCM_NOTIFY:
; 3407 : 	case OCM_PARENTNOTIFY:
; 3408 : 	case OCM_DRAWITEM:
; 3409 : 	case OCM_MEASUREITEM:
; 3410 : 	case OCM_COMPAREITEM:
; 3411 : 	case OCM_DELETEITEM:
; 3412 : 	case OCM_VKEYTOITEM:
; 3413 : 	case OCM_CHARTOITEM:
; 3414 : 	case OCM_HSCROLL:
; 3415 : 	case OCM_VSCROLL:
; 3416 : 	case OCM_CTLCOLORBTN:
; 3417 : 	case OCM_CTLCOLORDLG:
; 3418 : 	case OCM_CTLCOLOREDIT:
; 3419 : 	case OCM_CTLCOLORLISTBOX:
; 3420 : 	case OCM_CTLCOLORMSGBOX:
; 3421 : 	case OCM_CTLCOLORSCROLLBAR:
; 3422 : 	case OCM_CTLCOLORSTATIC:
; 3423 : 		lResult = ::DefWindowProc(hWnd, uMsg - OCM__BASE, wParam, lParam);

  00054	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00057	05 00 e0 ff ff	 add	 eax, -8192		; ffffe000H
  0005c	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  0005f	50		 push	 eax
  00060	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcW@16
  00069	8b 4d 18	 mov	 ecx, DWORD PTR _lResult$[ebp]
  0006c	89 01		 mov	 DWORD PTR [ecx], eax

; 3424 : 		return TRUE;

  0006e	33 c0		 xor	 eax, eax
  00070	40		 inc	 eax

; 3429 : }

  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?DefaultReflectionHandler@?$CWindowImplRoot@VCWindow@ATL@@@ATL@@SAHPAUHWND__@@IIJAAJ@Z ENDP ; ATL::CWindowImplRoot<ATL::CWindow>::DefaultReflectionHandler
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?Register@_ATL_WNDCLASSINFOW@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z
_TEXT	SEGMENT
_templateParameter$1 = 8				; size = 1
_p$ = 8							; size = 4
?Register@_ATL_WNDCLASSINFOW@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z PROC ; ATL::_ATL_WNDCLASSINFOW::Register, COMDAT
; _this$ = ecx

; 331  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5386 : 	return AtlModuleRegisterWndClassInfoT<AtlModuleRegisterWndClassInfoParamW>(

  00003	ff 75 08	 push	 DWORD PTR _templateParameter$1[ebp]
  00006	ff 75 08	 push	 DWORD PTR _p$[ebp]
  00009	51		 push	 ecx
  0000a	68 00 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  0000f	68 00 00 00 00	 push	 OFFSET ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A ; ATL::_AtlBaseModule
  00014	e8 00 00 00 00	 call	 ??$AtlModuleRegisterWndClassInfoT@VAtlModuleRegisterWndClassInfoParamW@ATL@@@ATL@@YAGPAU_ATL_BASE_MODULE70@0@PAU_ATL_WIN_MODULE70@0@PAU_ATL_WNDCLASSINFOW@0@PAP6GJPAUHWND__@@IIJ@ZVAtlModuleRegisterWndClassInfoParamW@0@@Z ; ATL::AtlModuleRegisterWndClassInfoT<ATL::AtlModuleRegisterWndClassInfoParamW>
  00019	83 c4 14	 add	 esp, 20			; 00000014H

; 332  : 		return AtlWinModuleRegisterWndClassInfoW(&_AtlWinModule, &_AtlBaseModule, this, p);
; 333  : 	}

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?Register@_ATL_WNDCLASSINFOW@ATL@@QAEGPAP6GJPAUHWND__@@IIJ@Z@Z ENDP ; ATL::_ATL_WNDCLASSINFOW::Register
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParamIn$ = 16						; size = 4
_lParamIn$ = 20						; size = 4
_bHandledIn$ = 24					; size = 4
??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z PROC		; ATL::_ATL_MSG::_ATL_MSG, COMDAT
; _this$ = ecx

; 282  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 281  : 		cbSize(sizeof(_ATL_MSG)), bHandled(bHandledIn)

  00003	8b 45 18	 mov	 eax, DWORD PTR _bHandledIn$[ebp]
  00006	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 283  : 		hwnd = hWnd;

  00009	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax

; 284  : 		message = uMsg;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _uMsg$[ebp]
  00011	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 285  : 		wParam = wParamIn;

  00014	8b 45 10	 mov	 eax, DWORD PTR _wParamIn$[ebp]
  00017	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 286  : 		lParam = lParamIn;

  0001a	8b 45 14	 mov	 eax, DWORD PTR _lParamIn$[ebp]
  0001d	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 287  : 		time = 0;

  00020	33 c0		 xor	 eax, eax
  00022	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 288  : 		pt.x = pt.y = 0;

  00025	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00028	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 289  : 	}

  0002b	8b c1		 mov	 eax, ecx
  0002d	c7 41 1c 24 00
	00 00		 mov	 DWORD PTR [ecx+28], 36	; 00000024H
  00034	5d		 pop	 ebp
  00035	c2 14 00	 ret	 20			; 00000014H
??0_ATL_MSG@ATL@@QAE@PAUHWND__@@IIJH@Z ENDP		; ATL::_ATL_MSG::_ATL_MSG
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?AtlHiMetricToPixel@ATL@@YGXPBUtagSIZE@@PAU2@@Z
_TEXT	SEGMENT
_nPixelsPerInchY$1$ = -4				; size = 4
_lpSizeInHiMetric$ = 8					; size = 4
_lpSizeInPix$ = 12					; size = 4
?AtlHiMetricToPixel@ATL@@YGXPBUtagSIZE@@PAU2@@Z PROC	; ATL::AtlHiMetricToPixel, COMDAT

; 5436 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5437 : 	ATLENSURE_THROW(lpSizeInHiMetric!=NULL, E_POINTER);

  00004	83 7d 08 00	 cmp	 DWORD PTR _lpSizeInHiMetric$[ebp], 0
  00008	74 60		 je	 SHORT $LN20@AtlHiMetri

; 5438 : 	ATLENSURE_THROW(lpSizeInPix!=NULL, E_POINTER);

  0000a	83 7d 0c 00	 cmp	 DWORD PTR _lpSizeInPix$[ebp], 0
  0000e	74 5a		 je	 SHORT $LN20@AtlHiMetri

; 5439 : 	int nPixelsPerInchX;    // Pixels per logical inch along width
; 5440 : 	int nPixelsPerInchY;    // Pixels per logical inch along height
; 5441 : 
; 5442 : 	HDC hDCScreen = GetDC(NULL);

  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	6a 00		 push	 0
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDC@4

; 5443 : 	ATLASSUME(hDCScreen != NULL);
; 5444 : 	nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);

  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetDeviceCaps@8
  00021	8b f8		 mov	 edi, eax
  00023	6a 58		 push	 88			; 00000058H
  00025	57		 push	 edi
  00026	ff d6		 call	 esi

; 5445 : 	nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);

  00028	6a 5a		 push	 90			; 0000005aH
  0002a	57		 push	 edi
  0002b	8b d8		 mov	 ebx, eax
  0002d	ff d6		 call	 esi

; 5446 : 	ReleaseDC(NULL, hDCScreen);

  0002f	57		 push	 edi
  00030	6a 00		 push	 0
  00032	89 45 fc	 mov	 DWORD PTR _nPixelsPerInchY$1$[ebp], eax
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseDC@8

; 5447 : 
; 5448 : 	lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, nPixelsPerInchX);

  0003b	8b 7d 08	 mov	 edi, DWORD PTR _lpSizeInHiMetric$[ebp]
  0003e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__MulDiv@12
  00044	68 ec 09 00 00	 push	 2540			; 000009ecH
  00049	ff 37		 push	 DWORD PTR [edi]
  0004b	53		 push	 ebx
  0004c	ff d6		 call	 esi
  0004e	8b 5d 0c	 mov	 ebx, DWORD PTR _lpSizeInPix$[ebp]

; 5449 : 	lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, nPixelsPerInchY);

  00051	68 ec 09 00 00	 push	 2540			; 000009ecH
  00056	89 03		 mov	 DWORD PTR [ebx], eax
  00058	ff 77 04	 push	 DWORD PTR [edi+4]
  0005b	ff 75 fc	 push	 DWORD PTR _nPixelsPerInchY$1$[ebp]
  0005e	ff d6		 call	 esi
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00065	5b		 pop	 ebx

; 5450 : }

  00066	c9		 leave
  00067	c2 08 00	 ret	 8
$LN20@AtlHiMetri:

; 5438 : 	ATLENSURE_THROW(lpSizeInPix!=NULL, E_POINTER);

  0006a	68 03 40 00 80	 push	 -2147467261		; 80004003H
  0006f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN21@AtlHiMetri:
  00074	cc		 int	 3
?AtlHiMetricToPixel@ATL@@YGXPBUtagSIZE@@PAU2@@Z ENDP	; ATL::AtlHiMetricToPixel
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?AtlCreateTargetDC@ATL@@YGPAUHDC__@@PAU2@PAUtagDVTARGETDEVICE@@@Z
_TEXT	SEGMENT
_hdc$ = 8						; size = 4
_ptd$ = 12						; size = 4
?AtlCreateTargetDC@ATL@@YGPAUHDC__@@PAU2@PAUtagDVTARGETDEVICE@@@Z PROC ; ATL::AtlCreateTargetDC, COMDAT

; 5394 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 5395 : 	USES_CONVERSION_EX;
; 5396 : 
; 5397 : 	// cases  hdc, ptd, hdc is metafile, hic
; 5398 : //  NULL,    NULL,  n/a,    Display
; 5399 : //  NULL,   !NULL,  n/a,    ptd
; 5400 : //  !NULL,   NULL,  FALSE,  hdc
; 5401 : //  !NULL,   NULL,  TRUE,   display
; 5402 : //  !NULL,  !NULL,  FALSE,  ptd
; 5403 : //  !NULL,  !NULL,  TRUE,   ptd
; 5404 : 
; 5405 : 	if (ptd != NULL)

  00004	8b 75 0c	 mov	 esi, DWORD PTR _ptd$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 30		 je	 SHORT $LN2@AtlCreateT

; 5406 : 	{
; 5407 : 		LPDEVMODEOLE lpDevMode;
; 5408 : 		LPOLESTR lpszDriverName;
; 5409 : 		LPOLESTR lpszDeviceName;
; 5410 : 		LPOLESTR lpszPortName;
; 5411 : 
; 5412 : 		if (ptd->tdExtDevmodeOffset == 0)

  0000b	0f b7 46 0a	 movzx	 eax, WORD PTR [esi+10]
  0000f	57		 push	 edi
  00010	66 85 c0	 test	 ax, ax
  00013	75 04		 jne	 SHORT $LN4@AtlCreateT

; 5413 : 			lpDevMode = NULL;

  00015	33 ff		 xor	 edi, edi
  00017	eb 03		 jmp	 SHORT $LN5@AtlCreateT
$LN4@AtlCreateT:

; 5414 : 		else
; 5415 : 			lpDevMode  = (LPDEVMODEOLE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);

  00019	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
$LN5@AtlCreateT:

; 5416 : 
; 5417 : 		lpszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
; 5418 : 		lpszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
; 5419 : 		lpszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

  0001c	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  00020	0f b7 4e 06	 movzx	 ecx, WORD PTR [esi+6]
  00024	03 c6		 add	 eax, esi
  00026	0f b7 56 04	 movzx	 edx, WORD PTR [esi+4]
  0002a	03 ce		 add	 ecx, esi

; 5420 : 
; 5421 : 		return ::CreateDC(OLE2CT_EX_DEF(lpszDriverName), OLE2CT_EX_DEF(lpszDeviceName), OLE2CT_EX_DEF(lpszPortName), DEVMODEOLE2T_EX(lpDevMode));

  0002c	57		 push	 edi
  0002d	50		 push	 eax
  0002e	03 d6		 add	 edx, esi
  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDCW@16
  00038	5f		 pop	 edi
  00039	eb 25		 jmp	 SHORT $LN42@AtlCreateT
$LN2@AtlCreateT:

; 5422 : 	}
; 5423 : 	else if (hdc == NULL || GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)

  0003b	8b 75 08	 mov	 esi, DWORD PTR _hdc$[ebp]
  0003e	85 f6		 test	 esi, esi
  00040	74 0e		 je	 SHORT $LN8@AtlCreateT
  00042	6a 02		 push	 2
  00044	56		 push	 esi
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetDeviceCaps@8
  0004b	83 f8 05	 cmp	 eax, 5
  0004e	75 12		 jne	 SHORT $LL27@AtlCreateT
$LN8@AtlCreateT:

; 5424 : 		return ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);

  00050	33 c0		 xor	 eax, eax
  00052	50		 push	 eax
  00053	50		 push	 eax
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_1BA@PICGEGJB@?$AAD?$AAI?$AAS?$AAP?$AAL?$AAA?$AAY@
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDCW@16
$LN42@AtlCreateT:

; 5425 : 	else
; 5426 : 		return hdc;

  00060	8b f0		 mov	 esi, eax
$LL27@AtlCreateT:
  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi

; 5427 : }

  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
?AtlCreateTargetDC@ATL@@YGPAUHDC__@@PAU2@PAUtagDVTARGETDEVICE@@@Z ENDP ; ATL::AtlCreateTargetDC
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwin.h
;	COMDAT ?AtlWinModuleRegisterClassExW@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PBUtagWNDCLASSEXW@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_atom$ = 12						; size = 2
_lpwc$ = 12						; size = 4
?AtlWinModuleRegisterClassExW@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PBUtagWNDCLASSEXW@@@Z PROC ; ATL::AtlWinModuleRegisterClassExW, COMDAT

; 5271 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 5272 : 	if (pWinModule == NULL || lpwc == NULL)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _pWinModule$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	74 2d		 je	 SHORT $LN3@AtlWinModu
  0000b	83 7d 0c 00	 cmp	 DWORD PTR _lpwc$[ebp], 0
  0000f	74 27		 je	 SHORT $LN3@AtlWinModu

; 5274 : 
; 5275 : 	ATOM atom = ::RegisterClassExW(lpwc);

  00011	56		 push	 esi
  00012	ff 75 0c	 push	 DWORD PTR _lpwc$[ebp]
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterClassExW@4
  0001b	0f b7 f0	 movzx	 esi, ax
  0001e	89 75 0c	 mov	 DWORD PTR _atom$[ebp], esi

; 5276 : 	if (atom != 0)

  00021	66 85 f6	 test	 si, si
  00024	74 0c		 je	 SHORT $LN4@AtlWinModu

; 5277 : 	{
; 5278 : 		BOOL bRet = pWinModule->m_rgWindowClassAtoms.Add(atom);

  00026	8d 45 0c	 lea	 eax, DWORD PTR _atom$[ebp]
  00029	50		 push	 eax
  0002a	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  0002d	e8 00 00 00 00	 call	 ?Add@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEHABG@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::Add
$LN4@AtlWinModu:

; 5279 : 		ATLASSERT(bRet);
; 5280 : 		(bRet);
; 5281 : 	}
; 5282 : 	return atom;

  00032	66 8b c6	 mov	 ax, si
  00035	5e		 pop	 esi
  00036	eb 02		 jmp	 SHORT $LN1@AtlWinModu
$LN3@AtlWinModu:

; 5273 : 		return 0;

  00038	33 c0		 xor	 eax, eax
$LN1@AtlWinModu:
  0003a	5f		 pop	 edi

; 5283 : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
?AtlWinModuleRegisterClassExW@ATL@@YGGPAU_ATL_WIN_MODULE70@1@PBUtagWNDCLASSEXW@@@Z ENDP ; ATL::AtlWinModuleRegisterClassExW
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetAt@CComDynamicUnkArray@ATL@@QAEPAUIUnknown@@H@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetAt@CComDynamicUnkArray@ATL@@QAEPAUIUnknown@@H@Z PROC ; ATL::CComDynamicUnkArray::GetAt, COMDAT
; _this$ = ecx

; 6196 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6197 : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 6198 : 		if (nIndex >= 0 && nIndex < m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0c		 js	 SHORT $LN2@GetAt
  0000a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0000d	7d 07		 jge	 SHORT $LN2@GetAt

; 6199 : 			return m_ppUnk[nIndex];

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00014	eb 02		 jmp	 SHORT $LN3@GetAt
$LN2@GetAt:

; 6200 : 		else
; 6201 : 			return NULL;

  00016	33 c0		 xor	 eax, eax
$LN3@GetAt:

; 6202 : 
; 6203 : 	}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
?GetAt@CComDynamicUnkArray@ATL@@QAEPAUIUnknown@@H@Z ENDP ; ATL::CComDynamicUnkArray::GetAt
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetUnknown@CComDynamicUnkArray@ATL@@QAGPAUIUnknown@@K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwCookie$ = 12						; size = 4
?GetUnknown@CComDynamicUnkArray@ATL@@QAGPAUIUnknown@@K@Z PROC ; ATL::CComDynamicUnkArray::GetUnknown, COMDAT

; 6177 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6178 : #ifndef _ATL_OLEDB_CONFORMANCE_TESTS
; 6179 : 		ATLASSERT(dwCookie != 0 && dwCookie <= (DWORD)m_nSize);
; 6180 : #endif
; 6181 : 		if (dwCookie != 0 && dwCookie <= (DWORD)m_nSize)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _dwCookie$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 11		 je	 SHORT $LN2@GetUnknown
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00010	77 09		 ja	 SHORT $LN2@GetUnknown

; 6182 : 			return GetAt(dwCookie-1); // cookie minus one is an index into the array

  00012	48		 dec	 eax
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ?GetAt@CComDynamicUnkArray@ATL@@QAEPAUIUnknown@@H@Z ; ATL::CComDynamicUnkArray::GetAt
  00019	eb 02		 jmp	 SHORT $LN3@GetUnknown
$LN2@GetUnknown:

; 6183 : 		else
; 6184 : 			return NULL;

  0001b	33 c0		 xor	 eax, eax
$LN3@GetUnknown:

; 6185 : 	}

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
?GetUnknown@CComDynamicUnkArray@ATL@@QAGPAUIUnknown@@K@Z ENDP ; ATL::CComDynamicUnkArray::GetUnknown
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetCookie@CComDynamicUnkArray@ATL@@QAGKPAPAUIUnknown@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_ppFind$ = 12						; size = 4
?GetCookie@CComDynamicUnkArray@ATL@@QAGKPAPAUIUnknown@@@Z PROC ; ATL::CComDynamicUnkArray::GetCookie, COMDAT

; 6160 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6161 : 		ATLASSERT(ppFind && *ppFind);
; 6162 : 		if (ppFind && *ppFind)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _ppFind$[ebp]
  00006	56		 push	 esi
  00007	85 c0		 test	 eax, eax
  00009	74 22		 je	 SHORT $LN3@GetCookie
  0000b	8b 30		 mov	 esi, DWORD PTR [eax]
  0000d	85 f6		 test	 esi, esi
  0000f	74 1c		 je	 SHORT $LN3@GetCookie

; 6163 : 		{
; 6164 : 			IUnknown** ppUnk = NULL;
; 6165 : 			DWORD dwCookie = 1;
; 6166 : 			// find IUnknown* in array
; 6167 : 			for (ppUnk = begin(); ppUnk < end(); ppUnk++)

  00011	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00014	33 d2		 xor	 edx, edx
  00016	42		 inc	 edx
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]

; 6192 : 		return &m_ppUnk[m_nSize];

  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0001f	eb 08		 jmp	 SHORT $LN15@GetCookie
$LL4@GetCookie:

; 6168 : 			{
; 6169 : 				if (*ppUnk == *ppFind)

  00021	39 31		 cmp	 DWORD PTR [ecx], esi
  00023	74 0f		 je	 SHORT $LN11@GetCookie

; 6171 : 				dwCookie++;

  00025	42		 inc	 edx
  00026	83 c1 04	 add	 ecx, 4
$LN15@GetCookie:

; 6163 : 		{
; 6164 : 			IUnknown** ppUnk = NULL;
; 6165 : 			DWORD dwCookie = 1;
; 6166 : 			// find IUnknown* in array
; 6167 : 			for (ppUnk = begin(); ppUnk < end(); ppUnk++)

  00029	3b c8		 cmp	 ecx, eax
  0002b	72 f4		 jb	 SHORT $LL4@GetCookie
$LN3@GetCookie:

; 6172 : 			}
; 6173 : 		}
; 6174 : 		return 0;

  0002d	33 c0		 xor	 eax, eax
$LN1@GetCookie:
  0002f	5e		 pop	 esi

; 6175 : 	}

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
$LN11@GetCookie:

; 6170 : 					return dwCookie; // cookie minus one is an index into the array

  00034	8b c2		 mov	 eax, edx
  00036	eb f7		 jmp	 SHORT $LN1@GetCookie
?GetCookie@CComDynamicUnkArray@ATL@@QAGKPAPAUIUnknown@@@Z ENDP ; ATL::CComDynamicUnkArray::GetCookie
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Remove@CComDynamicUnkArray@ATL@@QAEHK@Z
_TEXT	SEGMENT
_dwCookie$ = 8						; size = 4
?Remove@CComDynamicUnkArray@ATL@@QAEHK@Z PROC		; ATL::CComDynamicUnkArray::Remove, COMDAT
; _this$ = ecx

; 6267 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6268 : 	DWORD idx = dwCookie -1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwCookie$[ebp]
  00006	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]

; 6269 : #ifndef _ATL_OLEDB_CONFORMANCE_TESTS
; 6270 : 	ATLASSERT(idx < dwCookie && idx < (DWORD)m_nSize);
; 6271 : #endif
; 6272 : 	if (idx < dwCookie && idx < (DWORD)m_nSize)

  00009	3b d0		 cmp	 edx, eax
  0000b	73 16		 jae	 SHORT $LN2@Remove
  0000d	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00010	73 11		 jae	 SHORT $LN2@Remove

; 6273 : 	{
; 6274 : 		// cookie minus one is index into array
; 6275 : 		if (m_ppUnk[idx] == NULL)

  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	83 3c 90 00	 cmp	 DWORD PTR [eax+edx*4], 0
  00018	74 09		 je	 SHORT $LN2@Remove

; 6276 : 			return FALSE;
; 6277 : 		m_ppUnk[idx] = NULL;

  0001a	83 24 90 00	 and	 DWORD PTR [eax+edx*4], 0

; 6278 : 		return TRUE;

  0001e	33 c0		 xor	 eax, eax
  00020	40		 inc	 eax
  00021	eb 02		 jmp	 SHORT $LN3@Remove
$LN2@Remove:

; 6279 : 	}
; 6280 : 	else
; 6281 : 		return FALSE;

  00023	33 c0		 xor	 eax, eax
$LN3@Remove:

; 6282 : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?Remove@CComDynamicUnkArray@ATL@@QAEHK@Z ENDP		; ATL::CComDynamicUnkArray::Remove
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Add@CComDynamicUnkArray@ATL@@QAEKPAUIUnknown@@@Z
_TEXT	SEGMENT
_nAlloc$ = -4						; size = 4
_pUnk$ = 8						; size = 4
?Add@CComDynamicUnkArray@ATL@@QAEKPAUIUnknown@@@Z PROC	; ATL::CComDynamicUnkArray::Add, COMDAT
; _this$ = ecx

; 6223 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi

; 6224 : 	IUnknown** pp = NULL;
; 6225 : 	if (m_nSize == 0)

  00009	6a 04		 push	 4
  0000b	5b		 pop	 ebx
  0000c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000f	85 c0		 test	 eax, eax
  00011	75 24		 jne	 SHORT $LN17@Add

; 6226 : 	{
; 6227 : 		// Create array with _DEFAULT_VECTORLENGTH number of items.
; 6228 : 		ATLTRY(pp = (IUnknown**)calloc(sizeof(IUnknown*),_DEFAULT_VECTORLENGTH));

  00013	53		 push	 ebx
  00014	53		 push	 ebx
  00015	e8 00 00 00 00	 call	 _calloc
  0001a	8b d0		 mov	 edx, eax
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx

; 6229 : 		if (pp == NULL)

  0001e	85 d2		 test	 edx, edx
  00020	0f 84 87 00 00
	00		 je	 $LN19@Add

; 6230 : 			return 0;
; 6231 : 		memset(pp, 0, sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);

  00026	33 c0		 xor	 eax, eax

; 6232 : 		m_ppUnk = pp;

  00028	89 16		 mov	 DWORD PTR [esi], edx
  0002a	8b fa		 mov	 edi, edx

; 6233 : 		m_nSize = _DEFAULT_VECTORLENGTH;

  0002c	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0002f	ab		 stosd
  00030	ab		 stosd
  00031	ab		 stosd
  00032	ab		 stosd
  00033	8b c3		 mov	 eax, ebx
  00035	eb 02		 jmp	 SHORT $LN5@Add
$LN17@Add:
  00037	8b 16		 mov	 edx, DWORD PTR [esi]
$LN5@Add:

; 6234 : 	}
; 6235 : 	// Walk array and use empty slots if any.
; 6236 : 	DWORD dwCookie = 1;

  00039	33 ff		 xor	 edi, edi

; 6192 : 		return &m_ppUnk[m_nSize];

  0003b	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]

; 6234 : 	}
; 6235 : 	// Walk array and use empty slots if any.
; 6236 : 	DWORD dwCookie = 1;

  0003e	47		 inc	 edi

; 6192 : 		return &m_ppUnk[m_nSize];

  0003f	eb 0b		 jmp	 SHORT $LN20@Add
$LL4@Add:

; 6238 : 	{
; 6239 : 		if (*pp == NULL)

  00041	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00044	74 5e		 je	 SHORT $LN14@Add

; 6192 : 		return &m_ppUnk[m_nSize];

  00046	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 6243 : 		}
; 6244 : 		dwCookie++;

  00049	47		 inc	 edi
  0004a	03 d3		 add	 edx, ebx
$LN20@Add:

; 6237 : 	for (pp = begin(); pp < end(); pp++)

  0004c	3b d1		 cmp	 edx, ecx
  0004e	72 f1		 jb	 SHORT $LL4@Add

; 6245 : 	}
; 6246 : 	// No empty slots so resize array.
; 6247 : 	// # of new slots is double of current size.
; 6248 : 	int nAlloc = 0;

  00050	83 65 fc 00	 and	 DWORD PTR _nAlloc$[ebp], 0

; 6249 : 	HRESULT hr = AtlMultiply(&nAlloc, m_nSize, 2);

  00054	6a 02		 push	 2
  00056	50		 push	 eax
  00057	8d 45 fc	 lea	 eax, DWORD PTR _nAlloc$[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??$AtlMultiply@H@ATL@@YAJPAHHH@Z ; ATL::AtlMultiply<int>
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6250 : 	if (FAILED(hr))

  00063	85 c0		 test	 eax, eax
  00065	78 46		 js	 SHORT $LN19@Add

; 6251 : 	{
; 6252 : 		return 0;
; 6253 : 	}
; 6254 : 
; 6255 : 	pp = (IUnknown**)_recalloc(m_ppUnk, sizeof(IUnknown*),nAlloc);

  00067	8b 7d fc	 mov	 edi, DWORD PTR _nAlloc$[ebp]
  0006a	57		 push	 edi
  0006b	53		 push	 ebx
  0006c	ff 36		 push	 DWORD PTR [esi]
  0006e	e8 00 00 00 00	 call	 __recalloc
  00073	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6256 : 	if (pp == NULL)

  00076	85 c0		 test	 eax, eax
  00078	74 33		 je	 SHORT $LN19@Add

; 6258 : 	m_ppUnk = pp;
; 6259 : 	memset(&m_ppUnk[m_nSize], 0, sizeof(IUnknown*)*m_nSize);

  0007a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0007d	c1 e1 02	 shl	 ecx, 2
  00080	51		 push	 ecx
  00081	89 06		 mov	 DWORD PTR [esi], eax
  00083	03 c1		 add	 eax, ecx
  00085	6a 00		 push	 0
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 _memset

; 6260 : 	m_ppUnk[m_nSize] = pUnk;

  0008d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
  00093	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00095	8b 45 08	 mov	 eax, DWORD PTR _pUnk$[ebp]
  00098	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 6261 : 	dwCookie = m_nSize+1;

  0009b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0009e	40		 inc	 eax

; 6262 : 	m_nSize = nAlloc;

  0009f	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 6263 : 	return dwCookie; // cookie minus one is index into array

  000a2	eb 0b		 jmp	 SHORT $LN1@Add
$LN14@Add:

; 6240 : 		{
; 6241 : 			*pp = pUnk;

  000a4	8b 4d 08	 mov	 ecx, DWORD PTR _pUnk$[ebp]

; 6242 : 			return dwCookie; // cookie minus one is index into array

  000a7	8b c7		 mov	 eax, edi
  000a9	89 0a		 mov	 DWORD PTR [edx], ecx
  000ab	eb 02		 jmp	 SHORT $LN1@Add
$LN19@Add:

; 6257 : 		return 0;

  000ad	33 c0		 xor	 eax, eax
$LN1@Add:
  000af	5f		 pop	 edi

; 6264 : }

  000b0	5e		 pop	 esi
  000b1	5b		 pop	 ebx
  000b2	c9		 leave
  000b3	c2 04 00	 ret	 4
?Add@CComDynamicUnkArray@ATL@@QAEKPAUIUnknown@@@Z ENDP	; ATL::CComDynamicUnkArray::Add
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?copy@?$_Copy@UtagCONNECTDATA@@@ATL@@SAJPAUtagCONNECTDATA@@PBU3@@Z
_TEXT	SEGMENT
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
?copy@?$_Copy@UtagCONNECTDATA@@@ATL@@SAJPAUtagCONNECTDATA@@PBU3@@Z PROC ; ATL::_Copy<tagCONNECTDATA>::copy, COMDAT

; 5422 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5423 : 		ATLENSURE(p1 != NULL && p2 != NULL);

  00003	8b 55 08	 mov	 edx, DWORD PTR _p1$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	74 21		 je	 SHORT $LN11@copy
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR _p2$[ebp]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 1a		 je	 SHORT $LN11@copy

; 5424 : 		*p1 = *p2;

  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00016	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 5425 : 		if (p1->pUnk)

  00019	8b c8		 mov	 ecx, eax
  0001b	89 02		 mov	 DWORD PTR [edx], eax
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 06		 je	 SHORT $LN9@copy

; 5426 : 		{
; 5427 : 			p1->pUnk->AddRef();

  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	51		 push	 ecx
  00024	ff 50 04	 call	 DWORD PTR [eax+4]
$LN9@copy:

; 5428 : 		}
; 5429 : 		return S_OK;

  00027	33 c0		 xor	 eax, eax

; 5430 : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN11@copy:

; 5423 : 		ATLENSURE(p1 != NULL && p2 != NULL);

  0002b	68 05 40 00 80	 push	 -2147467259		; 80004005H
  00030	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN13@copy:
  00035	cc		 int	 3
?copy@?$_Copy@UtagCONNECTDATA@@@ATL@@SAJPAUtagCONNECTDATA@@PBU3@@Z ENDP ; ATL::_Copy<tagCONNECTDATA>::copy
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z PROC ; ATL::CComPtr<ITypeInfo>::operator=<ITypeInfo2>, COMDAT
; _this$ = ecx

; 337  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 338  :         if(!this->IsEqualObject(lp) )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lp$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	ff 37		 push	 DWORD PTR [edi]
  0000c	e8 00 00 00 00	 call	 ?IsEqualObject@?$CComPtrBase@UITypeInfo@@@ATL@@QAE_NPAUIUnknown@@@Z ; ATL::CComPtrBase<ITypeInfo>::IsEqualObject
  00011	84 c0		 test	 al, al
  00013	75 10		 jne	 SHORT $LN2@operator

; 339  :         {
; 340  :             AtlComQIPtrAssign2((IUnknown**)&this->p, lp, __uuidof(T));

  00015	68 00 00 00 00	 push	 OFFSET __GUID_00020401_0000_0000_c000_000000000046
  0001a	ff 37		 push	 DWORD PTR [edi]
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ?AtlComQIPtrAssign2@ATL@@YAXPAPAUIUnknown@@PAU2@ABU_GUID@@@Z ; ATL::AtlComQIPtrAssign2
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@operator:

; 341  :         }
; 342  :         return *this;

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	5f		 pop	 edi
  00028	5e		 pop	 esi

; 343  :     }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z ENDP ; ATL::CComPtr<ITypeInfo>::operator=<ITypeInfo2>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z
_TEXT	SEGMENT
_s$1$ = -20						; size = 4
_pMap$1$ = -16						; size = 4
_i$1$ = -12						; size = 4
_pta$ = -8						; size = 4
_pfd$1 = -4						; size = 4
_bstrName$2 = 8						; size = 4
_pTypeInfo$ = 8						; size = 4
?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z PROC ; ATL::CComTypeInfoHolder::LoadNameCache, COMDAT
; _this$ = ecx

; 4239 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 4240 : 		TYPEATTR* pta;
; 4241 : 		HRESULT hr = pTypeInfo->GetTypeAttr(&pta);

  00008	8b 75 08	 mov	 esi, DWORD PTR _pTypeInfo$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	57		 push	 edi
  0000e	8d 4d f8	 lea	 ecx, DWORD PTR _pta$[ebp]
  00011	51		 push	 ecx
  00012	8b 06		 mov	 eax, DWORD PTR [esi]
  00014	56		 push	 esi
  00015	ff 50 0c	 call	 DWORD PTR [eax+12]

; 4242 : 		if (SUCCEEDED(hr))

  00018	85 c0		 test	 eax, eax
  0001a	0f 88 0c 01 00
	00		 js	 $LN5@LoadNameCa

; 4243 : 		{
; 4244 : 			stringdispid* pMap = NULL;
; 4245 : 			m_nCount = pta->cFuncs;

  00020	8b 45 f8	 mov	 eax, DWORD PTR _pta$[ebp]
  00023	33 c9		 xor	 ecx, ecx

; 4246 : 			m_pMap = NULL;
; 4247 : 			if (m_nCount != 0)

  00025	6a 0c		 push	 12			; 0000000cH
  00027	89 4d f0	 mov	 DWORD PTR _pMap$1$[ebp], ecx
  0002a	5a		 pop	 edx
  0002b	0f b7 78 2c	 movzx	 edi, WORD PTR [eax+44]
  0002f	21 4b 14	 and	 DWORD PTR [ebx+20], ecx
  00032	89 7b 18	 mov	 DWORD PTR [ebx+24], edi
  00035	85 ff		 test	 edi, edi
  00037	74 5c		 je	 SHORT $LN7@LoadNameCa

; 4248 : 			{
; 4249 : 				pMap = _ATL_NEW stringdispid[m_nCount];

  00039	8b c7		 mov	 eax, edi
  0003b	f7 e2		 mul	 edx
  0003d	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00042	0f 90 c1	 seto	 cl
  00045	f7 d9		 neg	 ecx
  00047	0b c8		 or	 ecx, eax
  00049	33 c0		 xor	 eax, eax
  0004b	83 c1 04	 add	 ecx, 4
  0004e	0f 92 c0	 setb	 al
  00051	f7 d8		 neg	 eax
  00053	0b c1		 or	 eax, ecx
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  0005b	59		 pop	 ecx
  0005c	59		 pop	 ecx
  0005d	85 c0		 test	 eax, eax
  0005f	74 21		 je	 SHORT $LN40@LoadNameCa
  00061	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00064	89 38		 mov	 DWORD PTR [eax], edi
  00066	89 4d f0	 mov	 DWORD PTR _pMap$1$[ebp], ecx
  00069	8b c1		 mov	 eax, ecx
$LL14@LoadNameCa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  0006b	83 20 00	 and	 DWORD PTR [eax], 0
  0006e	8d 40 0c	 lea	 eax, DWORD PTR [eax+12]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4108 : 		stringdispid() : nLen(0), id(DISPID_UNKNOWN){}

  00071	83 60 f8 00	 and	 DWORD PTR [eax-8], 0
  00075	83 48 fc ff	 or	 DWORD PTR [eax-4], -1
  00079	83 ef 01	 sub	 edi, 1
  0007c	75 ed		 jne	 SHORT $LL14@LoadNameCa

; 4250 : 				if (pMap == NULL)

  0007e	85 c9		 test	 ecx, ecx
  00080	75 13		 jne	 SHORT $LN7@LoadNameCa
$LN40@LoadNameCa:

; 4251 : 				{
; 4252 : 					pTypeInfo->ReleaseTypeAttr(pta);

  00082	ff 75 f8	 push	 DWORD PTR _pta$[ebp]
  00085	8b 06		 mov	 eax, DWORD PTR [esi]
  00087	56		 push	 esi
  00088	ff 50 4c	 call	 DWORD PTR [eax+76]

; 4253 : 					return E_OUTOFMEMORY;

  0008b	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00090	e9 99 00 00 00	 jmp	 $LN1@LoadNameCa
$LN7@LoadNameCa:

; 4256 : 			for (int i=0; i<m_nCount; i++)

  00095	33 d2		 xor	 edx, edx
  00097	89 55 f4	 mov	 DWORD PTR _i$1$[ebp], edx
  0009a	39 53 18	 cmp	 DWORD PTR [ebx+24], edx
  0009d	7e 7e		 jle	 SHORT $LN3@LoadNameCa
  0009f	8b f9		 mov	 edi, ecx
$LL4@LoadNameCa:

; 4257 : 			{
; 4258 : 				FUNCDESC* pfd;
; 4259 : 				if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))

  000a1	8b 06		 mov	 eax, DWORD PTR [esi]
  000a3	8d 4d fc	 lea	 ecx, DWORD PTR _pfd$1[ebp]
  000a6	51		 push	 ecx
  000a7	52		 push	 edx
  000a8	56		 push	 esi
  000a9	ff 50 14	 call	 DWORD PTR [eax+20]
  000ac	85 c0		 test	 eax, eax
  000ae	78 5e		 js	 SHORT $LN2@LoadNameCa

; 4262 : 					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))

  000b0	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  000b2	33 c0		 xor	 eax, eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4262 : 					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))

  000b4	50		 push	 eax
  000b5	50		 push	 eax
  000b6	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  000b7	89 45 08	 mov	 DWORD PTR _bstrName$2[ebp], eax
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4262 : 					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))

  000ba	8d 45 08	 lea	 eax, DWORD PTR _bstrName$2[ebp]
  000bd	50		 push	 eax
  000be	8b 45 fc	 mov	 eax, DWORD PTR _pfd$1[ebp]
  000c1	ff 30		 push	 DWORD PTR [eax]
  000c3	56		 push	 esi
  000c4	ff 51 30	 call	 DWORD PTR [ecx+48]
  000c7	85 c0		 test	 eax, eax
  000c9	78 30		 js	 SHORT $LN41@LoadNameCa
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 973  :         BSTR s = m_str;

  000cb	8b 4d 08	 mov	 ecx, DWORD PTR _bstrName$2[ebp]

; 974  :         m_str = NULL;

  000ce	83 65 08 00	 and	 DWORD PTR _bstrName$2[ebp], 0

; 964  :         if (m_str != src)

  000d2	8b 07		 mov	 eax, DWORD PTR [edi]

; 973  :         BSTR s = m_str;

  000d4	89 4d ec	 mov	 DWORD PTR _s$1$[ebp], ecx

; 964  :         if (m_str != src)

  000d7	3b c1		 cmp	 eax, ecx
  000d9	74 0c		 je	 SHORT $LN26@LoadNameCa

; 965  :         {
; 966  :             ::SysFreeString(m_str);

  000db	50		 push	 eax
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 967  :             m_str = src;

  000e2	8b 45 ec	 mov	 eax, DWORD PTR _s$1$[ebp]
  000e5	89 07		 mov	 DWORD PTR [edi], eax
$LN26@LoadNameCa:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4265 : 						pMap[i].nLen = SysStringLen(pMap[i].bstr);

  000e7	50		 push	 eax
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysStringLen@4

; 4266 : 						pMap[i].id = pfd->memid;

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _pfd$1[ebp]
  000f1	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000f4	8b 01		 mov	 eax, DWORD PTR [ecx]
  000f6	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000f9	eb 03		 jmp	 SHORT $LN9@LoadNameCa
$LN41@LoadNameCa:

; 4262 : 					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR _pfd$1[ebp]
$LN9@LoadNameCa:

; 4267 : 					}
; 4268 : 					pTypeInfo->ReleaseFuncDesc(pfd);

  000fe	8b 06		 mov	 eax, DWORD PTR [esi]
  00100	51		 push	 ecx
  00101	56		 push	 esi
  00102	ff 50 50	 call	 DWORD PTR [eax+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 1674 :     ::SysFreeString(m_str);

  00105	ff 75 08	 push	 DWORD PTR _bstrName$2[ebp]
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN2@LoadNameCa:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4256 : 			for (int i=0; i<m_nCount; i++)

  0010e	8b 55 f4	 mov	 edx, DWORD PTR _i$1$[ebp]
  00111	83 c7 0c	 add	 edi, 12			; 0000000cH
  00114	42		 inc	 edx
  00115	89 55 f4	 mov	 DWORD PTR _i$1$[ebp], edx
  00118	3b 53 18	 cmp	 edx, DWORD PTR [ebx+24]
  0011b	7c 84		 jl	 SHORT $LL4@LoadNameCa
$LN3@LoadNameCa:

; 4269 : 				}
; 4270 : 			}
; 4271 : 			m_pMap = pMap;

  0011d	8b 45 f0	 mov	 eax, DWORD PTR _pMap$1$[ebp]

; 4272 : 			pTypeInfo->ReleaseTypeAttr(pta);

  00120	ff 75 f8	 push	 DWORD PTR _pta$[ebp]
  00123	89 43 14	 mov	 DWORD PTR [ebx+20], eax
  00126	8b 06		 mov	 eax, DWORD PTR [esi]
  00128	56		 push	 esi
  00129	ff 50 4c	 call	 DWORD PTR [eax+76]
$LN5@LoadNameCa:

; 4273 : 		}
; 4274 : 		return S_OK;

  0012c	33 c0		 xor	 eax, eax
$LN1@LoadNameCa:
  0012e	5f		 pop	 edi

; 4275 : 	}

  0012f	5e		 pop	 esi
  00130	5b		 pop	 ebx
  00131	c9		 leave
  00132	c2 04 00	 ret	 4
?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z ENDP ; ATL::CComTypeInfoHolder::LoadNameCache
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_dispidMember$ = 12					; size = 4
___formal$ = 16						; size = 4
_lcid$ = 20						; size = 4
_wFlags$ = 24						; size = 2
_pdispparams$ = 28					; size = 4
_pvarResult$ = 32					; size = 4
_pexcepinfo$ = 36					; size = 4
_puArgErr$ = 40						; size = 4
?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z PROC ; ATL::CComTypeInfoHolder::Invoke, COMDAT
; _this$ = ecx

; 4230 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 4136 : 		HRESULT hr = S_OK;

  00006	33 c0		 xor	 eax, eax

; 4137 : 		if (m_pInfo == NULL || m_pMap == NULL)

  00008	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0000b	85 d2		 test	 edx, edx
  0000d	74 05		 je	 SHORT $LN6@Invoke
  0000f	39 46 14	 cmp	 DWORD PTR [esi+20], eax
  00012	75 0b		 jne	 SHORT $LN5@Invoke
$LN6@Invoke:

; 4138 : 			hr = GetTI(lcid);

  00014	ff 75 14	 push	 DWORD PTR _lcid$[ebp]
  00017	e8 00 00 00 00	 call	 ?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z ; ATL::CComTypeInfoHolder::GetTI
  0001c	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
$LN5@Invoke:
  0001f	5e		 pop	 esi

; 4231 : 		HRESULT hRes = EnsureTI(lcid);
; 4232 : 		_Analysis_assume_(m_pInfo != NULL || FAILED(hRes));
; 4233 : 		if (m_pInfo != NULL)

  00020	85 d2		 test	 edx, edx
  00022	74 1b		 je	 SHORT $LN2@Invoke

; 4234 : 			hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);

  00024	ff 75 28	 push	 DWORD PTR _puArgErr$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	ff 75 24	 push	 DWORD PTR _pexcepinfo$[ebp]
  0002c	ff 75 20	 push	 DWORD PTR _pvarResult$[ebp]
  0002f	ff 75 1c	 push	 DWORD PTR _pdispparams$[ebp]
  00032	ff 75 18	 push	 DWORD PTR _wFlags$[ebp]
  00035	ff 75 0c	 push	 DWORD PTR _dispidMember$[ebp]
  00038	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0003b	52		 push	 edx
  0003c	ff 50 2c	 call	 DWORD PTR [eax+44]
$LN2@Invoke:

; 4235 : 		return hRes;
; 4236 : 	}

  0003f	5d		 pop	 ebp
  00040	c2 24 00	 ret	 36			; 00000024H
?Invoke@CComTypeInfoHolder@ATL@@QAEJPAUIDispatch@@JABU_GUID@@KGPAUtagDISPPARAMS@@PAUtagVARIANT@@PAUtagEXCEPINFO@@PAI@Z ENDP ; ATL::CComTypeInfoHolder::Invoke
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv351 = -4						; size = 4
___formal$ = 8						; size = 4
_rgszNames$ = 12					; size = 4
_cNames$ = 16						; size = 4
tv348 = 20						; size = 4
_lcid$ = 20						; size = 4
_rgdispid$ = 24						; size = 4
?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z PROC ; ATL::CComTypeInfoHolder::GetIDsOfNames, COMDAT
; _this$ = ecx

; 4164 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	8b d9		 mov	 ebx, ecx

; 4136 : 		HRESULT hr = S_OK;

  00008	33 d2		 xor	 edx, edx
  0000a	8b c2		 mov	 eax, edx

; 4137 : 		if (m_pInfo == NULL || m_pMap == NULL)

  0000c	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  0000f	89 4d fc	 mov	 DWORD PTR tv351[ebp], ecx
  00012	85 c9		 test	 ecx, ecx
  00014	74 05		 je	 SHORT $LN29@GetIDsOfNa
  00016	39 53 14	 cmp	 DWORD PTR [ebx+20], edx
  00019	75 12		 jne	 SHORT $LN14@GetIDsOfNa
$LN29@GetIDsOfNa:

; 4138 : 			hr = GetTI(lcid);

  0001b	ff 75 14	 push	 DWORD PTR _lcid$[ebp]
  0001e	8b cb		 mov	 ecx, ebx
  00020	e8 00 00 00 00	 call	 ?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z ; ATL::CComTypeInfoHolder::GetTI
  00025	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00028	33 d2		 xor	 edx, edx
  0002a	89 4d fc	 mov	 DWORD PTR tv351[ebp], ecx
$LN14@GetIDsOfNa:

; 4165 : 		HRESULT hRes = EnsureTI(lcid);
; 4166 : 		_Analysis_assume_(m_pInfo != NULL || FAILED(hRes));
; 4167 : 		if (m_pInfo != NULL)

  0002d	85 c9		 test	 ecx, ecx
  0002f	0f 84 da 00 00
	00		 je	 $LN11@GetIDsOfNa

; 4168 : 		{
; 4169 : 			hRes = E_FAIL;
; 4170 : 			// Look in cache if
; 4171 : 			//	cache is populated
; 4172 : 			//	parameter names are not requested
; 4173 : 			if (m_pMap != NULL && cNames == 1)

  00035	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00038	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0003b	56		 push	 esi
  0003c	57		 push	 edi
  0003d	85 c0		 test	 eax, eax
  0003f	0f 84 b6 00 00
	00		 je	 $LN30@GetIDsOfNa
  00045	83 7d 10 01	 cmp	 DWORD PTR _cNames$[ebp], 1
  00049	0f 85 ac 00 00
	00		 jne	 $LN30@GetIDsOfNa

; 4174 : 			{
; 4175 : 				int n = int( ocslen(rgszNames[0]) );

  0004f	8b 4d 0c	 mov	 ecx, DWORD PTR _rgszNames$[ebp]
  00052	8b 39		 mov	 edi, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h

; 732  : 	if (x == NULL)

  00054	85 ff		 test	 edi, edi
  00056	75 04		 jne	 SHORT $LN18@GetIDsOfNa

; 733  : 	{
; 734  : 		return 0;

  00058	8b f2		 mov	 esi, edx
  0005a	eb 68		 jmp	 SHORT $LN9@GetIDsOfNa
$LN18@GetIDsOfNa:

; 735  : 	}
; 736  : 
; 737  : 	return static_cast<int>(wcslen(x));

  0005c	8b f7		 mov	 esi, edi
  0005e	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
$LL31@GetIDsOfNa:
  00061	66 8b 06	 mov	 ax, WORD PTR [esi]
  00064	83 c6 02	 add	 esi, 2
  00067	66 3b c2	 cmp	 ax, dx
  0006a	75 f5		 jne	 SHORT $LL31@GetIDsOfNa
  0006c	2b f1		 sub	 esi, ecx
  0006e	d1 fe		 sar	 esi, 1
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4180 : 				if ( n == 5 &&									//	- If length and

  00070	83 fe 05	 cmp	 esi, 5
  00073	75 27		 jne	 SHORT $LN25@GetIDsOfNa
  00075	8b 07		 mov	 eax, DWORD PTR [edi]
  00077	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_Claim@?7??GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z@4PA_WA ; `ATL::CComTypeInfoHolder::GetIDsOfNames'::`8'::s_Claim
  0007c	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0007e	75 41		 jne	 SHORT $LN36@GetIDsOfNa
  00080	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00083	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00086	75 39		 jne	 SHORT $LN36@GetIDsOfNa
  00088	0f b7 47 08	 movzx	 eax, WORD PTR [edi+8]
  0008c	66 3b 41 08	 cmp	 ax, WORD PTR [ecx+8]
  00090	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  00093	75 2f		 jne	 SHORT $LN9@GetIDsOfNa

; 4181 : 					 memcmp(pName, s_Claim, 10 )  == 0 )		//		data match L"Claim",
; 4182 : 				{
; 4183 : 					pName = s_Claim;							//		replace with L"ClaimDevice".

  00095	8b f9		 mov	 edi, ecx

; 4184 : 					n = 11;

  00097	6a 0b		 push	 11			; 0000000bH
$LN39@GetIDsOfNa:

; 4191 : 				}
; 4192 : 				for (int j=m_nCount-1; j>=0; j--)

  00099	5e		 pop	 esi
  0009a	eb 28		 jmp	 SHORT $LN9@GetIDsOfNa
$LN25@GetIDsOfNa:

; 4185 : 				}
; 4186 : 				else if ( n == 7 &&								//	- If length and

  0009c	83 fe 07	 cmp	 esi, 7
  0009f	75 20		 jne	 SHORT $LN36@GetIDsOfNa
  000a1	6a 0e		 push	 14			; 0000000eH
  000a3	68 00 00 00 00	 push	 OFFSET ?s_Release@?7??GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z@4PA_WA ; `ATL::CComTypeInfoHolder::GetIDsOfNames'::`8'::s_Release
  000a8	57		 push	 edi
  000a9	e8 00 00 00 00	 call	 _memcmp
  000ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b1	85 c0		 test	 eax, eax
  000b3	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  000b6	75 0c		 jne	 SHORT $LN9@GetIDsOfNa

; 4187 : 						  memcmp(pName, s_Release, 14 ) == 0 )	//		data match L"Release",
; 4188 : 				{
; 4189 : 					pName = s_Release;							//		replace with L"ReleaseDevice".

  000b8	bf 00 00 00 00	 mov	 edi, OFFSET ?s_Release@?7??GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z@4PA_WA ; `ATL::CComTypeInfoHolder::GetIDsOfNames'::`8'::s_Release

; 4190 : 					n = 13;

  000bd	6a 0d		 push	 13			; 0000000dH

; 4191 : 				}
; 4192 : 				for (int j=m_nCount-1; j>=0; j--)

  000bf	eb d8		 jmp	 SHORT $LN39@GetIDsOfNa
$LN36@GetIDsOfNa:
  000c1	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
$LN9@GetIDsOfNa:
  000c4	8b 5b 18	 mov	 ebx, DWORD PTR [ebx+24]
  000c7	83 eb 01	 sub	 ebx, 1
  000ca	78 2f		 js	 SHORT $LN30@GetIDsOfNa

; 4193 : 				{
; 4194 : 					if ((n == m_pMap[j].nLen) &&

  000cc	6b cb 0c	 imul	 ecx, ebx, 12
  000cf	03 c8		 add	 ecx, eax
  000d1	89 4d 14	 mov	 DWORD PTR tv348[ebp], ecx
$LL4@GetIDsOfNa:
  000d4	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000d7	3b f0		 cmp	 esi, eax
  000d9	75 15		 jne	 SHORT $LN2@GetIDsOfNa
  000db	03 c0		 add	 eax, eax
  000dd	50		 push	 eax
  000de	57		 push	 edi
  000df	ff 31		 push	 DWORD PTR [ecx]
  000e1	e8 00 00 00 00	 call	 _memcmp
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	85 c0		 test	 eax, eax
  000eb	74 27		 je	 SHORT $LN21@GetIDsOfNa
  000ed	8b 4d 14	 mov	 ecx, DWORD PTR tv348[ebp]
$LN2@GetIDsOfNa:

; 4191 : 				}
; 4192 : 				for (int j=m_nCount-1; j>=0; j--)

  000f0	83 e9 0c	 sub	 ecx, 12			; 0000000cH
  000f3	83 eb 01	 sub	 ebx, 1
  000f6	89 4d 14	 mov	 DWORD PTR tv348[ebp], ecx
  000f9	79 d9		 jns	 SHORT $LL4@GetIDsOfNa
$LN30@GetIDsOfNa:

; 4213 : 			{
; 4214 : 				hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);

  000fb	ff 75 18	 push	 DWORD PTR _rgdispid$[ebp]
  000fe	8b 4d fc	 mov	 ecx, DWORD PTR tv351[ebp]
  00101	ff 75 10	 push	 DWORD PTR _cNames$[ebp]
  00104	ff 75 0c	 push	 DWORD PTR _rgszNames$[ebp]
  00107	8b 01		 mov	 eax, DWORD PTR [ecx]
  00109	51		 push	 ecx
  0010a	ff 50 28	 call	 DWORD PTR [eax+40]
$LN37@GetIDsOfNa:
  0010d	5f		 pop	 edi
  0010e	5e		 pop	 esi
$LN11@GetIDsOfNa:

; 4215 : 			}
; 4216 : 		}
; 4217 : 		return hRes;

  0010f	5b		 pop	 ebx

; 4218 : 	}

  00110	c9		 leave
  00111	c2 14 00	 ret	 20			; 00000014H
$LN21@GetIDsOfNa:

; 4195 : 						(memcmp(m_pMap[j].bstr, pName, m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
; 4196 : 				// CRM: End additions to ATL class.
; 4197 : #else			// CRM: Begin replaced code.
; 4198 : 				for (int j=m_nCount-1; j>=0; j--)
; 4199 : 				{
; 4200 : 					if ((n == m_pMap[j].nLen) &&
; 4201 : 						(memcmp(m_pMap[j].bstr, rgszNames[0], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
; 4202 : #endif			// CRM: End replaced code.
; 4203 : 					{
; 4204 : 						rgdispid[0] = m_pMap[j].id;

  00114	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00117	6b c3 0c	 imul	 eax, ebx, 12
  0011a	8b 4c 08 08	 mov	 ecx, DWORD PTR [eax+ecx+8]
  0011e	8b 45 18	 mov	 eax, DWORD PTR _rgdispid$[ebp]
  00121	89 08		 mov	 DWORD PTR [eax], ecx

; 4205 : 						hRes = S_OK;

  00123	33 c0		 xor	 eax, eax

; 4206 : 						break;
; 4207 : 					}
; 4208 : 				}
; 4209 : 			}
; 4210 : 			// if cache is empty or name not in cache or parameter names are requested,
; 4211 : 			// delegate to ITypeInfo::GetIDsOfNames
; 4212 : 			if (FAILED(hRes))

  00125	eb e6		 jmp	 SHORT $LN37@GetIDsOfNa
?GetIDsOfNames@CComTypeInfoHolder@ATL@@QAEJABU_GUID@@PAPA_WIKPAJ@Z ENDP ; ATL::CComTypeInfoHolder::GetIDsOfNames
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z
_TEXT	SEGMENT
_dw$ = 8						; size = 4
?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z PROC		; ATL::CComTypeInfoHolder::Cleanup, COMDAT

; 4279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4280 : 	ATLASSERT(dw != 0);
; 4281 : 	if (dw == 0)

  00004	8b 75 08	 mov	 esi, DWORD PTR _dw$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 23		 je	 SHORT $LN1@Cleanup

; 4282 : 		return;
; 4283 : 
; 4284 : 	CComTypeInfoHolder* p = (CComTypeInfoHolder*) dw;
; 4285 : 	if (p->m_pInfo != NULL)

  0000b	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0000e	85 c9		 test	 ecx, ecx
  00010	74 06		 je	 SHORT $LN3@Cleanup

; 4286 : 		p->m_pInfo->Release();

  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	51		 push	 ecx
  00015	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@Cleanup:

; 4287 : 	p->m_pInfo = NULL;

  00018	83 66 0c 00	 and	 DWORD PTR [esi+12], 0

; 4288 : 	delete [] p->m_pMap;

  0001c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0001f	85 c9		 test	 ecx, ecx
  00021	74 07		 je	 SHORT $LN5@Cleanup
  00023	6a 03		 push	 3
  00025	e8 00 00 00 00	 call	 ??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
$LN5@Cleanup:

; 4289 : 	p->m_pMap = NULL;

  0002a	83 66 14 00	 and	 DWORD PTR [esi+20], 0
$LN1@Cleanup:
  0002e	5e		 pop	 esi

; 4290 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z ENDP		; ATL::CComTypeInfoHolder::Cleanup
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\unknwnbase.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z
_TEXT	SEGMENT
_spTypeInfo2$1 = -540					; size = 4
_spTypeInfo$2 = -536					; size = 4
_pTypeLib$3 = -532					; size = 4
_spInfo$4 = -528					; size = 4
_szFilePath$5 = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_lcid$ = 8						; size = 4
?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z PROC		; ATL::CComTypeInfoHolder::GetTI, COMDAT
; _this$ = ecx

; 4293 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx

; 4294 : 	//If this assert occurs then most likely didn't initialize properly
; 4295 : 	ATLASSUME(m_plibid != NULL && m_pguid != NULL);
; 4296 : 
; 4297 : 	if (m_pInfo != NULL && m_pMap != NULL)

  00016	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  0001a	74 0d		 je	 SHORT $LN109@GetTI
  0001c	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  00020	74 07		 je	 SHORT $LN109@GetTI

; 4298 : 		return S_OK;

  00022	33 c0		 xor	 eax, eax
  00024	e9 a7 01 00 00	 jmp	 $LN1@GetTI
$LN109@GetTI:
  00029	53		 push	 ebx

; 4299 : 
; 4300 : 	CComCritSecLock<CComCriticalSection> lock(_pAtlModule->m_csStaticDataInitAndTypeInfo, false);

  0002a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00030	57		 push	 edi
  00031	83 c3 10	 add	 ebx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  00034	53		 push	 ebx
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4309 : 	if (m_pInfo == NULL)

  0003b	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0003e	bf 05 40 00 80	 mov	 edi, -2147467259	; 80004005H
  00043	85 c0		 test	 eax, eax
  00045	0f 85 68 01 00
	00		 jne	 $LN10@GetTI

; 4310 : 	{
; 4311 : 		ITypeLib* pTypeLib = NULL;
; 4312 : 		if (InlineIsEqualGUID(CAtlModule::m_libid, *m_plibid) && m_wMajor == 0xFFFF && m_wMinor == 0xFFFF)

  0004b	ff 76 04	 push	 DWORD PTR [esi+4]
  0004e	21 85 ec fd ff
	ff		 and	 DWORD PTR _pTypeLib$3[ebp], eax
  00054	68 00 00 00 00	 push	 OFFSET ?m_libid@CAtlModule@ATL@@2U_GUID@@A ; ATL::CAtlModule::m_libid
  00059	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  0005e	59		 pop	 ecx
  0005f	59		 pop	 ecx
  00060	85 c0		 test	 eax, eax
  00062	74 52		 je	 SHORT $LN7@GetTI
  00064	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00069	66 39 46 08	 cmp	 WORD PTR [esi+8], ax
  0006d	75 47		 jne	 SHORT $LN7@GetTI
  0006f	66 39 46 0a	 cmp	 WORD PTR [esi+10], ax
  00073	75 41		 jne	 SHORT $LN7@GetTI

; 4313 : 		{
; 4314 : 			TCHAR szFilePath[MAX_PATH];
; 4315 : 			DWORD dwFLen = ::GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szFilePath, MAX_PATH);

  00075	68 04 01 00 00	 push	 260			; 00000104H
  0007a	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szFilePath$5[ebp]
  00080	50		 push	 eax
  00081	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameW@12

; 4316 : 			if( dwFLen != 0 && dwFLen != MAX_PATH )

  0008d	85 c0		 test	 eax, eax
  0008f	0f 84 15 01 00
	00		 je	 $LN90@GetTI
  00095	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0009a	0f 84 0a 01 00
	00		 je	 $LN90@GetTI

; 4317 : 			{
; 4318 : 				USES_CONVERSION_EX;
; 4319 : 				LPOLESTR pszFile = T2OLE_EX(szFilePath, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 4320 : #ifndef _UNICODE
; 4321 : 				if (pszFile == NULL)
; 4322 : 					return E_OUTOFMEMORY;
; 4323 : #endif
; 4324 : 				hRes = LoadTypeLib(pszFile, &pTypeLib);

  000a0	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pTypeLib$3[ebp]
  000a6	50		 push	 eax
  000a7	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szFilePath$5[ebp]
  000ad	50		 push	 eax
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadTypeLib@8

; 4325 : 			}
; 4326 : 		}

  000b4	eb 1d		 jmp	 SHORT $LN111@GetTI
$LN7@GetTI:

; 4327 : 		else
; 4328 : 		{
; 4329 : 			ATLASSUME(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Module LIBID not initialized. See DECLARE_LIBID documentation.");
; 4330 : 			hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);

  000b6	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _pTypeLib$3[ebp]
  000bc	50		 push	 eax
  000bd	ff 75 08	 push	 DWORD PTR _lcid$[ebp]
  000c0	0f b7 46 0a	 movzx	 eax, WORD PTR [esi+10]
  000c4	50		 push	 eax
  000c5	0f b7 46 08	 movzx	 eax, WORD PTR [esi+8]
  000c9	50		 push	 eax
  000ca	ff 76 04	 push	 DWORD PTR [esi+4]
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadRegTypeLib@20
$LN111@GetTI:

; 4331 : #ifdef _DEBUG
; 4332 : 			if (SUCCEEDED(hRes))
; 4333 : 			{
; 4334 : 				// Trace out an warning if the requested TypelibID is the same as the modules TypelibID
; 4335 : 				// and versions do not match.
; 4336 : 				//
; 4337 : 				// In most cases it is due to wrong version template parameters to IDispatchImpl,
; 4338 : 				// IProvideClassInfoImpl or IProvideClassInfo2Impl.
; 4339 : 				// Set major and minor versions to 0xFFFF if the modules type lib has to be loaded
; 4340 : 				// irrespective of its version.
; 4341 : 				//
; 4342 : 				// Get the module's file path
; 4343 : 				TCHAR szFilePath[MAX_PATH];
; 4344 : 				DWORD dwFLen = ::GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szFilePath, MAX_PATH);
; 4345 : 				if( dwFLen != 0 && dwFLen != MAX_PATH )
; 4346 : 				{
; 4347 : 					USES_CONVERSION_EX;
; 4348 : 					CComPtr<ITypeLib> spTypeLibModule;
; 4349 : 					HRESULT hRes2 = S_OK;
; 4350 : 					LPOLESTR pszFile = T2OLE_EX(szFilePath, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 4351 : 					if (pszFile == NULL)
; 4352 : 						hRes2 = E_OUTOFMEMORY;
; 4353 : 					else
; 4354 : 						hRes2 = LoadTypeLib(pszFile, &spTypeLibModule);
; 4355 : 					if (SUCCEEDED(hRes2))
; 4356 : 					{
; 4357 : 						TLIBATTR* pLibAttr;
; 4358 : 						hRes2 = spTypeLibModule->GetLibAttr(&pLibAttr);
; 4359 : 						if (SUCCEEDED(hRes2))
; 4360 : 						{
; 4361 : 							if (InlineIsEqualGUID(pLibAttr->guid, *m_plibid) &&
; 4362 : 								(pLibAttr->wMajorVerNum != m_wMajor ||
; 4363 : 								pLibAttr->wMinorVerNum != m_wMinor))
; 4364 : 							{
; 4365 : 								ATLTRACE(atlTraceCOM, 0, _T("Warning : CComTypeInfoHolder::GetTI : Loaded typelib does not match the typelib in the module : %Ts\n"), szFilePath);
; 4366 : 								ATLTRACE(atlTraceCOM, 0, _T("\tSee IDispatchImpl overview help topic for more information\n"));
; 4367 : 							}
; 4368 : 							spTypeLibModule->ReleaseTLibAttr(pLibAttr);
; 4369 : 						}
; 4370 : 					}
; 4371 : 				}
; 4372 : 			}
; 4373 : 			else
; 4374 : 			{
; 4375 : 				ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to load Typelibrary. (HRESULT = 0x%x)\n"), hRes);
; 4376 : 				ATLTRACE(atlTraceCOM, 0, _T("\tVerify TypelibID and major version specified with\n"));
; 4377 : 				ATLTRACE(atlTraceCOM, 0, _T("\tIDispatchImpl, CStockPropImpl, IProvideClassInfoImpl or IProvideCLassInfo2Impl\n"));
; 4378 : 			}
; 4379 : #endif
; 4380 : 		}
; 4381 : 		if (SUCCEEDED(hRes))

  000d3	8b f8		 mov	 edi, eax
  000d5	85 ff		 test	 edi, edi
  000d7	0f 88 cd 00 00
	00		 js	 $LN90@GetTI

; 4384 : 			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);

  000dd	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _pTypeLib$3[ebp]
  000e3	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _spTypeInfo$2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  000e9	83 a5 e8 fd ff
	ff 00		 and	 DWORD PTR _spTypeInfo$2[ebp], 0
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4384 : 			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);

  000f0	52		 push	 edx
  000f1	ff 36		 push	 DWORD PTR [esi]
  000f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f5	50		 push	 eax
  000f6	ff 51 18	 call	 DWORD PTR [ecx+24]
  000f9	8b f8		 mov	 edi, eax

; 4385 : 			if (SUCCEEDED(hRes))

  000fb	85 ff		 test	 edi, edi
  000fd	0f 88 8b 00 00
	00		 js	 $LN85@GetTI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 169  :         p = lp;

  00103	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _spTypeInfo$2[ebp]
  00109	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _spInfo$4[ebp], eax

; 170  :         if (p != NULL)

  0010f	85 c0		 test	 eax, eax
  00111	74 0c		 je	 SHORT $LN67@GetTI

; 171  :             p->AddRef();

  00113	8b 08		 mov	 ecx, DWORD PTR [eax]
  00115	50		 push	 eax
  00116	ff 51 04	 call	 DWORD PTR [ecx+4]
  00119	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _spTypeInfo$2[ebp]
$LN67@GetTI:

; 165  :         p = NULL;

  0011f	83 a5 e4 fd ff
	ff 00		 and	 DWORD PTR _spTypeInfo2$1[ebp], 0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\unknwnbase.h

; 130  :                 return QueryInterface(__uuidof(Q), (void **)pp);

  00126	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _spTypeInfo2$1[ebp]
  0012c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012e	52		 push	 edx
  0012f	68 00 00 00 00	 push	 OFFSET __GUID_00020412_0000_0000_c000_000000000046
  00134	50		 push	 eax
  00135	ff 11		 call	 DWORD PTR [ecx]
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4389 : 				if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))

  00137	85 c0		 test	 eax, eax
  00139	78 12		 js	 SHORT $LN17@GetTI

; 4390 : 					spInfo = spTypeInfo2;

  0013b	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _spTypeInfo2$1[ebp]
  00141	50		 push	 eax
  00142	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _spInfo$4[ebp]
  00148	e8 00 00 00 00	 call	 ??$?4UITypeInfo2@@@?$CComPtr@UITypeInfo@@@ATL@@QAEPAUITypeInfo@@ABV?$CComPtr@UITypeInfo2@@@1@@Z ; ATL::CComPtr<ITypeInfo>::operator=<ITypeInfo2>
$LN17@GetTI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 255  :         T* pt = p;

  0014d	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _spInfo$4[ebp]

; 256  :         p = NULL;

  00153	83 a5 f0 fd ff
	ff 00		 and	 DWORD PTR _spInfo$4[ebp], 0
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4393 : 				_pAtlModule->AddTermFunc(Cleanup, (DWORD_PTR)this);

  0015a	56		 push	 esi
  0015b	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  00164	68 00 00 00 00	 push	 OFFSET ?Cleanup@CComTypeInfoHolder@ATL@@SGXK@Z ; ATL::CComTypeInfoHolder::Cleanup
  00169	e8 00 00 00 00	 call	 ?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z ; ATL::CAtlModule::AddTermFunc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0016e	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR _spTypeInfo2$1[ebp]
  00174	85 c0		 test	 eax, eax
  00176	74 06		 je	 SHORT $LN80@GetTI

; 184  :             p->Release();

  00178	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017a	50		 push	 eax
  0017b	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN80@GetTI:

; 183  :         if (p)

  0017e	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR _spInfo$4[ebp]
  00184	85 c0		 test	 eax, eax
  00186	74 06		 je	 SHORT $LN85@GetTI

; 184  :             p->Release();

  00188	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018a	50		 push	 eax
  0018b	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN85@GetTI:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4395 : 			pTypeLib->Release();

  0018e	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _pTypeLib$3[ebp]
  00194	50		 push	 eax
  00195	8b 08		 mov	 ecx, DWORD PTR [eax]
  00197	ff 51 08	 call	 DWORD PTR [ecx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0019a	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR _spTypeInfo$2[ebp]
  001a0	85 c0		 test	 eax, eax
  001a2	74 06		 je	 SHORT $LN90@GetTI

; 184  :             p->Release();

  001a4	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a6	50		 push	 eax
  001a7	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN90@GetTI:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4397 : 	}

  001aa	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 4402 : 	}
; 4403 : 
; 4404 : 	if (m_pInfo != NULL && m_pMap == NULL)

  001ad	85 c0		 test	 eax, eax
  001af	74 14		 je	 SHORT $LN18@GetTI
  001b1	eb 02		 jmp	 SHORT $LN110@GetTI
$LN10@GetTI:

; 4398 : 	else
; 4399 : 	{
; 4400 : 		// Another thread has loaded the typeinfo so we're OK.
; 4401 : 		hRes = S_OK;

  001b3	33 ff		 xor	 edi, edi
$LN110@GetTI:

; 4402 : 	}
; 4403 : 
; 4404 : 	if (m_pInfo != NULL && m_pMap == NULL)

  001b5	83 7e 14 00	 cmp	 DWORD PTR [esi+20], 0
  001b9	75 0a		 jne	 SHORT $LN18@GetTI

; 4405 : 	{
; 4406 : 		hRes=LoadNameCache(m_pInfo);

  001bb	50		 push	 eax
  001bc	8b ce		 mov	 ecx, esi
  001be	e8 00 00 00 00	 call	 ?LoadNameCache@CComTypeInfoHolder@ATL@@QAEJPAUITypeInfo@@@Z ; ATL::CComTypeInfoHolder::LoadNameCache
  001c3	8b f8		 mov	 edi, eax
$LN18@GetTI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  001c5	53		 push	 ebx
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4409 : 	return hRes;

  001cc	8b c7		 mov	 eax, edi
  001ce	5f		 pop	 edi
  001cf	5b		 pop	 ebx
$LN1@GetTI:

; 4410 : }

  001d0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d3	33 cd		 xor	 ecx, ebp
  001d5	5e		 pop	 esi
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	c9		 leave
  001dc	c2 04 00	 ret	 4
?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z ENDP		; ATL::CComTypeInfoHolder::GetTI
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_ppInfo$ = 12						; size = 4
?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z PROC ; ATL::CComTypeInfoHolder::GetTI, COMDAT
; _this$ = ecx

; 4117 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 4118 : 		ATLASSERT(ppInfo != NULL);
; 4119 : 		if (ppInfo == NULL)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _ppInfo$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	85 ff		 test	 edi, edi
  0000c	75 07		 jne	 SHORT $LN2@GetTI

; 4120 : 			return E_POINTER;

  0000e	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00013	eb 27		 jmp	 SHORT $LN1@GetTI
$LN2@GetTI:

; 4121 : 
; 4122 : 		HRESULT hr = S_OK;
; 4123 : 		if (m_pInfo == NULL)

  00015	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00018	33 c0		 xor	 eax, eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	75 0d		 jne	 SHORT $LN3@GetTI

; 4124 : 			hr = GetTI(lcid);

  0001e	ff 75 08	 push	 DWORD PTR _lcid$[ebp]
  00021	8b ce		 mov	 ecx, esi
  00023	e8 00 00 00 00	 call	 ?GetTI@CComTypeInfoHolder@ATL@@QAEJK@Z ; ATL::CComTypeInfoHolder::GetTI
  00028	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
$LN3@GetTI:

; 4125 : 		*ppInfo = m_pInfo;

  0002b	89 0f		 mov	 DWORD PTR [edi], ecx

; 4126 : 		if (m_pInfo != NULL)

  0002d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00030	85 c9		 test	 ecx, ecx
  00032	74 08		 je	 SHORT $LN1@GetTI

; 4127 : 		{
; 4128 : 			m_pInfo->AddRef();

  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	51		 push	 ecx
  00037	ff 50 04	 call	 DWORD PTR [eax+4]

; 4129 : 			hr = S_OK;

  0003a	33 c0		 xor	 eax, eax
$LN1@GetTI:

; 4130 : 		}
; 4131 : 		return hr;
; 4132 : 	}

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
?GetTI@CComTypeInfoHolder@ATL@@QAEJKPAPAUITypeInfo@@@Z ENDP ; ATL::CComTypeInfoHolder::GetTI
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z PROC	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	f6 45 08 02	 test	 BYTE PTR ___flags$[ebp], 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 40		 je	 SHORT $LN2@vector
  0000d	53		 push	 ebx
  0000e	57		 push	 edi
  0000f	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00012	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00014	6b c3 0c	 imul	 eax, ebx, 12
  00017	03 c6		 add	 eax, esi
  00019	85 db		 test	 ebx, ebx
  0001b	74 15		 je	 SHORT $LN19@vector
  0001d	8b f8		 mov	 edi, eax
$LL7@vector:
  0001f	8d 7f f4	 lea	 edi, DWORD PTR [edi-12]

; 1674 :     ::SysFreeString(m_str);

  00022	ff 37		 push	 DWORD PTR [edi]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  0002a	83 eb 01	 sub	 ebx, 1
  0002d	75 f0		 jne	 SHORT $LL7@vector
  0002f	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
$LN19@vector:
  00032	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00036	74 0f		 je	 SHORT $LN3@vector
  00038	6b 0f 0c	 imul	 ecx, DWORD PTR [edi], 12
  0003b	83 c1 04	 add	 ecx, 4
  0003e	51		 push	 ecx
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx
$LN3@vector:
  00047	8b c7		 mov	 eax, edi
  00049	5f		 pop	 edi
  0004a	5b		 pop	 ebx
  0004b	eb 1a		 jmp	 SHORT $LN1@vector
$LN2@vector:
  0004d	ff 36		 push	 DWORD PTR [esi]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  00055	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00059	74 0a		 je	 SHORT $LN4@vector
  0005b	6a 0c		 push	 12			; 0000000cH
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00063	59		 pop	 ecx
  00064	59		 pop	 ecx
$LN4@vector:
  00065	8b c6		 mov	 eax, esi
$LN1@vector:
  00067	5e		 pop	 esi
  00068	c9		 leave
  00069	c2 04 00	 ret	 4
??_Estringdispid@CComTypeInfoHolder@ATL@@QAEPAXI@Z ENDP	; ATL::CComTypeInfoHolder::stringdispid::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ PROC	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid, COMDAT
; _this$ = ecx

; 1674 :     ::SysFreeString(m_str);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  00008	c3		 ret	 0
??1stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ ENDP	; ATL::CComTypeInfoHolder::stringdispid::~stringdispid
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ
_TEXT	SEGMENT
??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ PROC	; ATL::CComTypeInfoHolder::stringdispid::stringdispid, COMDAT
; _this$ = ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  00000	83 21 00	 and	 DWORD PTR [ecx], 0
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 4108 : 		stringdispid() : nLen(0), id(DISPID_UNKNOWN){}

  00003	8b c1		 mov	 eax, ecx
  00005	83 61 04 00	 and	 DWORD PTR [ecx+4], 0
  00009	83 49 08 ff	 or	 DWORD PTR [ecx+8], -1
  0000d	c3		 ret	 0
??0stringdispid@CComTypeInfoHolder@ATL@@QAE@XZ ENDP	; ATL::CComTypeInfoHolder::stringdispid::stringdispid
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??_GCComClassFactory@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCComClassFactory@ATL@@UAEPAXI@Z PROC		; ATL::CComClassFactory::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3730 : 	{

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 3731 : 	}

  00006	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CComClassFactory@ATL@@6B@
  0000f	e8 00 00 00 00	 call	 ??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>
  00014	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00018	74 0a		 je	 SHORT $LN2@scalar
  0001a	6a 28		 push	 40			; 00000028H
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
$LN2@scalar:
  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??_GCComClassFactory@ATL@@UAEPAXI@Z ENDP		; ATL::CComClassFactory::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?LockServer@CComClassFactory@ATL@@UAGJH@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_fLock$ = 12						; size = 4
?LockServer@CComClassFactory@ATL@@UAGJH@Z PROC		; ATL::CComClassFactory::LockServer, COMDAT

; 3758 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3759 : 		if (fLock)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _fLock$[ebp], 0
  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A ; ATL::_pAtlModule
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000f	74 05		 je	 SHORT $LN2@LockServer

; 3760 : 			_pAtlModule->Lock();

  00011	ff 50 04	 call	 DWORD PTR [eax+4]
  00014	eb 03		 jmp	 SHORT $LN3@LockServer
$LN2@LockServer:

; 3761 : 		else
; 3762 : 			_pAtlModule->Unlock();

  00016	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@LockServer:

; 3763 : 		return S_OK;

  00019	33 c0		 xor	 eax, eax

; 3764 : 	}

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?LockServer@CComClassFactory@ATL@@UAGJH@Z ENDP		; ATL::CComClassFactory::LockServer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_pUnkOuter$ = 12					; size = 4
_riid$ = 16						; size = 4
_ppvObj$ = 20						; size = 4
?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z PROC ; ATL::CComClassFactory::CreateInstance, COMDAT

; 3738 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 3739 : 		ATLASSUME(m_pfnCreateInstance != NULL);
; 3740 : 		HRESULT hRes = E_POINTER;
; 3741 : 		if (ppvObj != NULL)

  00004	8b 75 14	 mov	 esi, DWORD PTR _ppvObj$[ebp]
  00007	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  0000c	85 f6		 test	 esi, esi
  0000e	74 29		 je	 SHORT $LN7@CreateInst

; 3742 : 		{
; 3743 : 			*ppvObj = NULL;

  00010	83 26 00	 and	 DWORD PTR [esi], 0

; 3744 : 			// can't ask for anything other than IUnknown when aggregating
; 3745 : 
; 3746 : 			if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))

  00013	83 7d 0c 00	 cmp	 DWORD PTR _pUnkOuter$[ebp], 0
  00017	74 13		 je	 SHORT $LN6@CreateInst
  00019	ff 75 10	 push	 DWORD PTR _riid$[ebp]
  0001c	e8 00 00 00 00	 call	 ?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z ; ATL::InlineIsEqualUnknown
  00021	85 c0		 test	 eax, eax
  00023	75 07		 jne	 SHORT $LN6@CreateInst

; 3747 : 			{
; 3748 : 				ATLTRACE(atlTraceCOM, 0, _T("CComClassFactory: asked for non IUnknown interface while creating an aggregated object"));
; 3749 : 				hRes = CLASS_E_NOAGGREGATION;

  00025	b8 10 01 04 80	 mov	 eax, -2147221232	; 80040110H

; 3750 : 			}

  0002a	eb 0d		 jmp	 SHORT $LN7@CreateInst
$LN6@CreateInst:

; 3751 : 			else
; 3752 : 				hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);

  0002c	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	56		 push	 esi
  00030	ff 75 10	 push	 DWORD PTR _riid$[ebp]
  00033	ff 75 0c	 push	 DWORD PTR _pUnkOuter$[ebp]
  00036	ff 50 24	 call	 DWORD PTR [eax+36]
$LN7@CreateInst:

; 3753 : 		}
; 3754 : 		return hRes;

  00039	5e		 pop	 esi

; 3755 : 	}

  0003a	5d		 pop	 ebp
  0003b	c2 10 00	 ret	 16			; 00000010H
?CreateInstance@CComClassFactory@ATL@@UAGJPAUIUnknown@@ABU_GUID@@PAPAX@Z ENDP ; ATL::CComClassFactory::CreateInstance
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??1CComClassFactory@ATL@@UAE@XZ
_TEXT	SEGMENT
??1CComClassFactory@ATL@@UAE@XZ PROC			; ATL::CComClassFactory::~CComClassFactory, COMDAT
; _this$ = ecx

; 3730 : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CComClassFactory@ATL@@6B@

; 3731 : 	}

  00006	83 c1 04	 add	 ecx, 4
  00009	e9 00 00 00 00	 jmp	 ??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>
??1CComClassFactory@ATL@@UAE@XZ ENDP			; ATL::CComClassFactory::~CComClassFactory
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?_AtlInitialConstruct@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEJXZ
_TEXT	SEGMENT
?_AtlInitialConstruct@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEJXZ PROC ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::_AtlInitialConstruct, COMDAT
; _this$ = ecx

; 2683 : 	{

  00000	56		 push	 esi

; 2684 : 		return m_critsec.Init();

  00001	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 201  : 		HRESULT hr = CComCriticalSection::Init();

  00004	8b ce		 mov	 ecx, esi
  00006	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init

; 202  : 		if (SUCCEEDED(hr))

  0000b	85 c0		 test	 eax, eax
  0000d	78 04		 js	 SHORT $LN4@AtlInitial

; 203  : 		{
; 204  : 			m_bInitialized = true;

  0000f	c6 46 18 01	 mov	 BYTE PTR [esi+24], 1
$LN4@AtlInitial:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2684 : 		return m_critsec.Init();

  00013	5e		 pop	 esi

; 2685 : 	}

  00014	c3		 ret	 0
?_AtlInitialConstruct@?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAEJXZ ENDP ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::_AtlInitialConstruct
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ PROC ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>, COMDAT
; _this$ = ecx

; 2661 : 	}

  00000	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 190  : 		if (!m_bInitialized)

  00003	80 79 18 00	 cmp	 BYTE PTR [ecx+24], 0
  00007	74 0b		 je	 SHORT $LN5@CComObject

; 155  : 		DeleteCriticalSection(&m_sec);

  00009	51		 push	 ecx

; 194  : 		m_bInitialized = false;

  0000a	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0

; 155  : 		DeleteCriticalSection(&m_sec);

  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
$LN5@CComObject:
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h

; 2661 : 	}

  00014	c3		 ret	 0
??1?$CComObjectRootEx@VCComMultiThreadModel@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CComObjectRootEx<ATL::CComMultiThreadModel>::~CComObjectRootEx<ATL::CComMultiThreadModel>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?GetCategoryMap@CComObjectRootBase@ATL@@SAPBU_ATL_CATMAP_ENTRY@2@XZ
_TEXT	SEGMENT
?GetCategoryMap@CComObjectRootBase@ATL@@SAPBU_ATL_CATMAP_ENTRY@2@XZ PROC ; ATL::CComObjectRootBase::GetCategoryMap, COMDAT

; 2468 : 		return NULL;

  00000	33 c0		 xor	 eax, eax

; 2469 : 	}

  00002	c3		 ret	 0
?GetCategoryMap@CComObjectRootBase@ATL@@SAPBU_ATL_CATMAP_ENTRY@2@XZ ENDP ; ATL::CComObjectRootBase::GetCategoryMap
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\Common\ATL\atlcom.h
;	COMDAT ?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z PROC	; ATL::CComObjectRootBase::ObjectMain, COMDAT

; 2618 : }

  00000	c2 04 00	 ret	 4
?ObjectMain@CComObjectRootBase@ATL@@SGX_N@Z ENDP	; ATL::CComObjectRootBase::ObjectMain
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?IsEqualObject@?$CComPtrBase@UITypeInfo@@@ATL@@QAE_NPAUIUnknown@@@Z
_TEXT	SEGMENT
_punk2$ = -4						; size = 4
_punk1$ = 8						; size = 4
_pOther$ = 8						; size = 4
?IsEqualObject@?$CComPtrBase@UITypeInfo@@@ATL@@QAE_NPAUIUnknown@@@Z PROC ; ATL::CComPtrBase<ITypeInfo>::IsEqualObject, COMDAT
; _this$ = ecx

; 597  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 598  :     if (p == NULL && pOther == NULL)

  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	56		 push	 esi
  00007	85 c9		 test	 ecx, ecx
  00009	75 09		 jne	 SHORT $LN26@IsEqualObj
  0000b	39 4d 08	 cmp	 DWORD PTR _pOther$[ebp], ecx
  0000e	75 56		 jne	 SHORT $LN4@IsEqualObj

; 599  :         return true;	// They are both NULL objects

  00010	b0 01		 mov	 al, 1
  00012	eb 54		 jmp	 SHORT $LN1@IsEqualObj
$LN26@IsEqualObj:

; 600  : 
; 601  :     if (p == NULL || pOther == NULL)

  00014	8b 75 08	 mov	 esi, DWORD PTR _pOther$[ebp]
  00017	85 f6		 test	 esi, esi
  00019	74 4b		 je	 SHORT $LN4@IsEqualObj

; 165  :         p = NULL;

  0001b	83 65 08 00	 and	 DWORD PTR _punk1$[ebp], 0

; 603  : 
; 604  :     CComPtr<IUnknown> punk1;
; 605  :     CComPtr<IUnknown> punk2;
; 606  :     p->QueryInterface(__uuidof(IUnknown), (void**)&punk1);

  0001f	8d 55 08	 lea	 edx, DWORD PTR _punk1$[ebp]

; 165  :         p = NULL;

  00022	83 65 fc 00	 and	 DWORD PTR _punk2$[ebp], 0

; 603  : 
; 604  :     CComPtr<IUnknown> punk1;
; 605  :     CComPtr<IUnknown> punk2;
; 606  :     p->QueryInterface(__uuidof(IUnknown), (void**)&punk1);

  00026	8b 01		 mov	 eax, DWORD PTR [ecx]

; 165  :         p = NULL;

  00028	53		 push	 ebx
  00029	57		 push	 edi

; 603  : 
; 604  :     CComPtr<IUnknown> punk1;
; 605  :     CComPtr<IUnknown> punk2;
; 606  :     p->QueryInterface(__uuidof(IUnknown), (void**)&punk1);

  0002a	52		 push	 edx
  0002b	bf 00 00 00 00	 mov	 edi, OFFSET __GUID_00000000_0000_0000_c000_000000000046
  00030	57		 push	 edi
  00031	51		 push	 ecx
  00032	ff 10		 call	 DWORD PTR [eax]

; 607  :     pOther->QueryInterface(__uuidof(IUnknown), (void**)&punk2);

  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	8d 4d fc	 lea	 ecx, DWORD PTR _punk2$[ebp]
  00039	51		 push	 ecx
  0003a	57		 push	 edi
  0003b	56		 push	 esi
  0003c	ff 10		 call	 DWORD PTR [eax]

; 223  :         return p == pT;

  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _punk2$[ebp]
  00041	8b 45 08	 mov	 eax, DWORD PTR _punk1$[ebp]
  00044	3b c1		 cmp	 eax, ecx
  00046	0f 94 c3	 sete	 bl

; 183  :         if (p)

  00049	85 c9		 test	 ecx, ecx
  0004b	74 09		 je	 SHORT $LN19@IsEqualObj

; 184  :             p->Release();

  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	51		 push	 ecx
  00050	ff 50 08	 call	 DWORD PTR [eax+8]
  00053	8b 45 08	 mov	 eax, DWORD PTR _punk1$[ebp]
$LN19@IsEqualObj:

; 183  :         if (p)

  00056	85 c0		 test	 eax, eax
  00058	74 06		 je	 SHORT $LN24@IsEqualObj

; 184  :             p->Release();

  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	50		 push	 eax
  0005d	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN24@IsEqualObj:

; 608  :     return punk1 == punk2;

  00060	5f		 pop	 edi
  00061	8a c3		 mov	 al, bl
  00063	5b		 pop	 ebx
  00064	eb 02		 jmp	 SHORT $LN1@IsEqualObj
$LN4@IsEqualObj:

; 602  :         return false;	// One is NULL the other is not

  00066	32 c0		 xor	 al, al
$LN1@IsEqualObj:
  00068	5e		 pop	 esi

; 609  : }

  00069	c9		 leave
  0006a	c2 04 00	 ret	 4
?IsEqualObject@?$CComPtrBase@UITypeInfo@@@ATL@@QAE_NPAUIUnknown@@@Z ENDP ; ATL::CComPtrBase<ITypeInfo>::IsEqualObject
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlstdthunk.h
;	COMDAT ?Init@CDynamicStdCallThunk2@ATL@@QAEHKPAX@Z
_TEXT	SEGMENT
_proc$ = 8						; size = 4
_pThis$ = 12						; size = 4
?Init@CDynamicStdCallThunk2@ATL@@QAEHKPAX@Z PROC	; ATL::CDynamicStdCallThunk2::Init, COMDAT
; _this$ = ecx

; 263  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 264  : 		if (pThunk == NULL)

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	75 0b		 jne	 SHORT $LN3@Init

; 265  : 		{
; 266  : #ifdef USE_ATL_THUNK2
; 267  : 			pThunk = AtlThunk_AllocateData();

  0000c	e8 00 00 00 00	 call	 _AtlThunk_AllocateData@0
  00011	89 06		 mov	 DWORD PTR [esi], eax

; 268  : #else
; 269  : 			pThunk = new _stdcallthunk;
; 270  : #endif
; 271  : 			if (pThunk == NULL)

  00013	85 c0		 test	 eax, eax
  00015	74 0f		 je	 SHORT $LN1@Init
$LN3@Init:

; 272  : 			{
; 273  : 				return FALSE;
; 274  : 			}
; 275  : 		}
; 276  : 
; 277  : #ifdef USE_ATL_THUNK2
; 278  : 		AtlThunk_InitData(pThunk, (void*)proc, (size_t)pThis);

  00017	ff 75 0c	 push	 DWORD PTR _pThis$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _proc$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _AtlThunk_InitData@12

; 279  : 		return TRUE;

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
$LN1@Init:
  00026	5e		 pop	 esi

; 280  : #else
; 281  : 		return pThunk->Init(proc, pThis);
; 282  : #endif
; 283  : 	}

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
?Init@CDynamicStdCallThunk2@ATL@@QAEHKPAX@Z ENDP	; ATL::CDynamicStdCallThunk2::Init
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 267  : 		free(p);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 _free
  00007	59		 pop	 ecx

; 586  : 		Allocator::Free( m_p );
; 587  : 	}

  00008	c3		 ret	 0
?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 565  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 262  : 		return malloc(nBytes);

  00004	ff 75 08	 push	 DWORD PTR _nBytes$[ebp]

; 565  : 	{

  00007	8b f1		 mov	 esi, ecx

; 262  : 		return malloc(nBytes);

  00009	e8 00 00 00 00	 call	 _malloc
  0000e	59		 pop	 ecx

; 566  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );
; 567  : 		if( p == NULL )

  0000f	85 c0		 test	 eax, eax
  00011	74 07		 je	 SHORT $LN8@AllocateHe

; 570  : 		}
; 571  : 		m_p = p;

  00013	89 06		 mov	 DWORD PTR [esi], eax
  00015	5e		 pop	 esi

; 572  : 	}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN8@AllocateHe:

; 568  : 		{
; 569  : 			AtlThrow( E_OUTOFMEMORY );

  0001a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0001f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN6@AllocateHe:
  00024	cc		 int	 3
?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z PROC ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 510  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 511  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00004	6a 01		 push	 1
  00006	ff 75 08	 push	 DWORD PTR _nElements$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$AtlMultiplyThrow@I@ATL@@YAIII@Z ; ATL::AtlMultiplyThrow<unsigned int>
  00010	59		 pop	 ecx
  00011	59		 pop	 ecx

; 551  : 		if( nBytes > t_nFixedBytes )

  00012	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00017	76 0c		 jbe	 SHORT $LN4@Allocate

; 552  : 		{
; 553  : 			AllocateHeap( nBytes );

  00019	50		 push	 eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::AllocateHeap
  00021	8b 06		 mov	 eax, DWORD PTR [esi]

; 554  : 		}

  00023	eb 05		 jmp	 SHORT $LN5@Allocate
$LN4@Allocate:

; 555  : 		else
; 556  : 		{
; 557  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  00025	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00028	89 06		 mov	 DWORD PTR [esi], eax
$LN5@Allocate:

; 511  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  0002a	5e		 pop	 esi

; 512  : 	}

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ENDP ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?FreeHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 267  : 		free(p);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 _free
  00007	59		 pop	 ecx

; 586  : 		Allocator::Free( m_p );
; 587  : 	}

  00008	c3		 ret	 0
?FreeHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 565  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 262  : 		return malloc(nBytes);

  00004	ff 75 08	 push	 DWORD PTR _nBytes$[ebp]

; 565  : 	{

  00007	8b f1		 mov	 esi, ecx

; 262  : 		return malloc(nBytes);

  00009	e8 00 00 00 00	 call	 _malloc
  0000e	59		 pop	 ecx

; 566  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );
; 567  : 		if( p == NULL )

  0000f	85 c0		 test	 eax, eax
  00011	74 07		 je	 SHORT $LN8@AllocateHe

; 570  : 		}
; 571  : 		m_p = p;

  00013	89 06		 mov	 DWORD PTR [esi], eax
  00015	5e		 pop	 esi

; 572  : 	}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN8@AllocateHe:

; 568  : 		{
; 569  : 			AtlThrow( E_OUTOFMEMORY );

  0001a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0001f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN6@AllocateHe:
  00024	cc		 int	 3
?AllocateHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z PROC ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 510  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 511  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00004	6a 02		 push	 2
  00006	ff 75 08	 push	 DWORD PTR _nElements$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$AtlMultiplyThrow@I@ATL@@YAIII@Z ; ATL::AtlMultiplyThrow<unsigned int>
  00010	59		 pop	 ecx
  00011	59		 pop	 ecx

; 551  : 		if( nBytes > t_nFixedBytes )

  00012	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00017	76 0c		 jbe	 SHORT $LN4@Allocate

; 552  : 		{
; 553  : 			AllocateHeap( nBytes );

  00019	50		 push	 eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::AllocateHeap
  00021	8b 06		 mov	 eax, DWORD PTR [esi]

; 554  : 		}

  00023	eb 05		 jmp	 SHORT $LN5@Allocate
$LN4@Allocate:

; 555  : 		else
; 556  : 		{
; 557  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  00025	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00028	89 06		 mov	 DWORD PTR [esi], eax
$LN5@Allocate:

; 511  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  0002a	5e		 pop	 esi

; 512  : 	}

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?Allocate@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z ENDP ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?FreeHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 267  : 		free(p);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	e8 00 00 00 00	 call	 _free
  00007	59		 pop	 ecx

; 586  : 		Allocator::Free( m_p );
; 587  : 	}

  00008	c3		 ret	 0
?FreeHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 565  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 262  : 		return malloc(nBytes);

  00004	ff 75 08	 push	 DWORD PTR _nBytes$[ebp]

; 565  : 	{

  00007	8b f1		 mov	 esi, ecx

; 262  : 		return malloc(nBytes);

  00009	e8 00 00 00 00	 call	 _malloc
  0000e	59		 pop	 ecx

; 566  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );
; 567  : 		if( p == NULL )

  0000f	85 c0		 test	 eax, eax
  00011	74 07		 je	 SHORT $LN8@AllocateHe

; 570  : 		}
; 571  : 		m_p = p;

  00013	89 06		 mov	 DWORD PTR [esi], eax
  00015	5e		 pop	 esi

; 572  : 	}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN8@AllocateHe:

; 568  : 		{
; 569  : 			AtlThrow( E_OUTOFMEMORY );

  0001a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0001f	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN6@AllocateHe:
  00024	cc		 int	 3
?AllocateHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z PROC ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 510  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 511  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  00004	6a 02		 push	 2
  00006	ff 75 08	 push	 DWORD PTR _nElements$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$AtlMultiplyThrow@I@ATL@@YAIII@Z ; ATL::AtlMultiplyThrow<unsigned int>
  00010	59		 pop	 ecx
  00011	59		 pop	 ecx

; 551  : 		if( nBytes > t_nFixedBytes )

  00012	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  00017	76 0c		 jbe	 SHORT $LN4@Allocate

; 552  : 		{
; 553  : 			AllocateHeap( nBytes );

  00019	50		 push	 eax
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::AllocateHeap
  00021	8b 06		 mov	 eax, DWORD PTR [esi]

; 554  : 		}

  00023	eb 05		 jmp	 SHORT $LN5@Allocate
$LN4@Allocate:

; 555  : 		else
; 556  : 		{
; 557  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  00025	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00028	89 06		 mov	 DWORD PTR [esi], eax
$LN5@Allocate:

; 511  : 		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );

  0002a	5e		 pop	 esi

; 512  : 	}

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?Allocate@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z ENDP ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_GCRegObject@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCRegObject@ATL@@UAEPAXI@Z PROC			; ATL::CRegObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CRegObject@ATL@@UAE@XZ ; ATL::CRegObject::~CRegObject
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0a		 je	 SHORT $LN2@scalar
  00011	6a 14		 push	 20			; 00000014H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx
$LN2@scalar:
  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
??_GCRegObject@ATL@@UAEPAXI@Z ENDP			; ATL::CRegObject::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?RegisterFromResource@CRegObject@ATL@@IAEJPB_W00H@Z
_TEXT	SEGMENT
_parser$ = -1048					; size = 8
_szID$GSCopy$1$ = -1040					; size = 4
_szType$GSCopy$1$ = -1036				; size = 4
_szReg$ = -1032						; size = 1028
__$ArrayPad$ = -4					; size = 4
_bstrFileName$ = 8					; size = 4
_szID$ = 12						; size = 4
_szType$ = 16						; size = 4
_bRegister$ = 20					; size = 4
?RegisterFromResource@CRegObject@ATL@@IAEJPB_W00H@Z PROC ; ATL::CRegObject::RegisterFromResource, COMDAT
; _this$ = ecx

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 04 00
	00		 sub	 esp, 1048		; 00000418H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _szID$[ebp]
  00016	53		 push	 ebx

; 463  : 	hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE | LOAD_LIBRARY_AS_IMAGE_RESOURCE);

  00017	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__LoadLibraryExW@12
  0001d	56		 push	 esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR _bstrFileName$[ebp]
  00021	57		 push	 edi
  00022	89 85 f0 fb ff
	ff		 mov	 DWORD PTR _szID$GSCopy$1$[ebp], eax
  00028	8b 45 10	 mov	 eax, DWORD PTR _szType$[ebp]
  0002b	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _szType$GSCopy$1$[ebp], eax

; 877  : 	m_pchCur = NULL;

  00031	33 c0		 xor	 eax, eax

; 463  : 	hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE | LOAD_LIBRARY_AS_IMAGE_RESOURCE);

  00033	6a 60		 push	 96			; 00000060H
  00035	50		 push	 eax
  00036	56		 push	 esi

; 876  : 	m_pRegObj = pRegObj;

  00037	89 8d ec fb ff
	ff		 mov	 DWORD PTR _parser$[ebp+4], ecx

; 877  : 	m_pchCur = NULL;

  0003d	89 85 e8 fb ff
	ff		 mov	 DWORD PTR _parser$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h

; 481  : 		m_p( NULL )

  00043	89 85 f8 fb ff
	ff		 mov	 DWORD PTR _szReg$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 463  : 	hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE | LOAD_LIBRARY_AS_IMAGE_RESOURCE);

  00049	ff d3		 call	 ebx
  0004b	8b f8		 mov	 edi, eax

; 464  : 
; 465  : 	if (NULL == hInstResDll)

  0004d	85 ff		 test	 edi, edi
  0004f	75 18		 jne	 SHORT $LN3@RegisterFr

; 466  : 	{
; 467  : 		// if library load failed using flags only valid on Vista+, fall back to using flags valid on XP
; 468  : 		hInstResDll = LoadLibraryEx(lpszBSTRFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);

  00051	6a 02		 push	 2
  00053	50		 push	 eax
  00054	56		 push	 esi
  00055	ff d3		 call	 ebx
  00057	8b f8		 mov	 edi, eax

; 469  : 	}
; 470  : 
; 471  : 	if (NULL == hInstResDll)

  00059	85 ff		 test	 edi, edi
  0005b	75 0c		 jne	 SHORT $LN3@RegisterFr

; 472  : 	{
; 473  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %Ts\n"), bstrFileName);
; 474  : 		hr = AtlHresultFromLastError();

  0005d	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError
  00062	8b f0		 mov	 esi, eax

; 475  : 		goto ReturnHR;

  00064	e9 a1 00 00 00	 jmp	 $LN15@RegisterFr
$LN3@RegisterFr:

; 476  : 	}
; 477  : 
; 478  : 	hrscReg =FindResource((HMODULE)hInstResDll, szID, szType);

  00069	ff b5 f4 fb ff
	ff		 push	 DWORD PTR _szType$GSCopy$1$[ebp]
  0006f	ff b5 f0 fb ff
	ff		 push	 DWORD PTR _szID$GSCopy$1$[ebp]
  00075	57		 push	 edi
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FindResourceW@12
  0007c	8b f0		 mov	 esi, eax

; 479  : 
; 480  : 	if (NULL == hrscReg)

  0007e	85 f6		 test	 esi, esi
  00080	75 07		 jne	 SHORT $LN5@RegisterFr
$LN37@RegisterFr:

; 533  : 
; 534  : ReturnHR:
; 535  : 
; 536  : 	if (NULL != hInstResDll)

  00082	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError
  00087	eb 74		 jmp	 SHORT $LN36@RegisterFr
$LN5@RegisterFr:

; 481  : 	{
; 482  : 		ATLTRACE(atlTraceRegistrar, 0, (HIWORD(szID) == 0) ?
; 483  : 			_T("Failed to FindResource on ID:%d TYPE:%Ts\n") :
; 484  : 			_T("Failed to FindResource on ID:%Ts TYPE:%Ts\n"),
; 485  : 			szID, szType);
; 486  : 		hr = AtlHresultFromLastError();
; 487  : 		goto ReturnHR;
; 488  : 	}
; 489  : 	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

  00089	56		 push	 esi
  0008a	57		 push	 edi
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadResource@8
  00091	8b d8		 mov	 ebx, eax

; 490  : 
; 491  : 	if (NULL == hReg)

  00093	85 db		 test	 ebx, ebx
  00095	74 eb		 je	 SHORT $LN37@RegisterFr

; 492  : 	{
; 493  : 		ATLTRACE(atlTraceRegistrar, 0, _T("Failed to LoadResource\n"));
; 494  : 		hr = AtlHresultFromLastError();
; 495  : 		goto ReturnHR;
; 496  : 	}
; 497  : 
; 498  : 	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);

  00097	56		 push	 esi
  00098	57		 push	 edi
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SizeofResource@8
  0009f	8b f0		 mov	 esi, eax

; 499  : 	szRegA = (LPSTR)hReg;
; 500  : 
; 501  : 	// Allocate extra space for NULL.
; 502  : 	if (dwSize + 1 < dwSize)

  000a1	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000a4	3b c6		 cmp	 eax, esi
  000a6	73 07		 jae	 SHORT $LN9@RegisterFr
$LN38@RegisterFr:

; 533  : 
; 534  : ReturnHR:
; 535  : 
; 536  : 	if (NULL != hInstResDll)

  000a8	be 0e 00 07 80	 mov	 esi, -2147024882	; 8007000eH
  000ad	eb 50		 jmp	 SHORT $ReturnHR$40
$LN9@RegisterFr:

; 503  : 	{
; 504  : 		hr = E_OUTOFMEMORY;
; 505  : 		goto ReturnHR;
; 506  : 	}
; 507  : 
; 508  : 	ATLTRY(szReg.Allocate(dwSize + 1));

  000af	50		 push	 eax
  000b0	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szReg$[ebp]
  000b6	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::Allocate

; 509  : 	if (szReg == NULL)

  000bb	83 bd f8 fb ff
	ff 00		 cmp	 DWORD PTR _szReg$[ebp], 0
  000c2	74 e4		 je	 SHORT $LN38@RegisterFr

; 510  : 	{
; 511  : 		hr = E_OUTOFMEMORY;
; 512  : 		goto ReturnHR;
; 513  : 	}
; 514  : 
; 515  : #ifdef _UNICODE
; 516  : 	{
; 517  : 		DWORD uniSize = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, szRegA, dwSize, szReg, dwSize);

  000c4	56		 push	 esi
  000c5	ff b5 f8 fb ff
	ff		 push	 DWORD PTR _szReg$[ebp]
  000cb	56		 push	 esi
  000cc	53		 push	 ebx
  000cd	6a 00		 push	 0
  000cf	6a 03		 push	 3
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  000d7	8b c8		 mov	 ecx, eax

; 518  : 		if (uniSize == 0)

  000d9	85 c9		 test	 ecx, ecx
  000db	74 a5		 je	 SHORT $LN37@RegisterFr

; 519  : 		{
; 520  : 			hr = AtlHresultFromLastError();
; 521  : 			goto ReturnHR;
; 522  : 		}
; 523  : 		// Append a NULL at the end.
; 524  : 		szReg[uniSize] = _T('\0');

  000dd	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _szReg$[ebp]
  000e3	33 d2		 xor	 edx, edx

; 525  : 	}
; 526  : #else
; 527  : 	Checked::memcpy_s(szReg, dwSize, szRegA, dwSize);
; 528  : 	// Append a NULL at the end.
; 529  :    	szReg[dwSize] = _T('\0');
; 530  : #endif
; 531  : 
; 532  : 	hr = parser.RegisterBuffer(szReg, bRegister);

  000e5	ff 75 14	 push	 DWORD PTR _bRegister$[ebp]
  000e8	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
  000ec	8d 8d e8 fb ff
	ff		 lea	 ecx, DWORD PTR _parser$[ebp]
  000f2	ff b5 f8 fb ff
	ff		 push	 DWORD PTR _szReg$[ebp]
  000f8	e8 00 00 00 00	 call	 ?RegisterBuffer@CRegParser@ATL@@QAEJPA_WH@Z ; ATL::CRegParser::RegisterBuffer
$LN36@RegisterFr:

; 533  : 
; 534  : ReturnHR:
; 535  : 
; 536  : 	if (NULL != hInstResDll)

  000fd	8b f0		 mov	 esi, eax
$ReturnHR$40:
  000ff	85 ff		 test	 edi, edi
  00101	74 07		 je	 SHORT $LN15@RegisterFr

; 537  : 		FreeLibrary((HMODULE)hInstResDll);

  00103	57		 push	 edi
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
$LN15@RegisterFr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h

; 493  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  0010a	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szReg$[ebp+4]
  00110	39 85 f8 fb ff
	ff		 cmp	 DWORD PTR _szReg$[ebp], eax
  00116	74 0b		 je	 SHORT $LL27@RegisterFr

; 494  : 		{
; 495  : 			FreeHeap();

  00118	8d 8d f8 fb ff
	ff		 lea	 ecx, DWORD PTR _szReg$[ebp]
  0011e	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@_W$0EAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<wchar_t,1024,ATL::CCRTAllocator>::FreeHeap
$LL27@RegisterFr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 539  : }

  00123	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00126	8b c6		 mov	 eax, esi
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	33 cd		 xor	 ecx, ebp
  0012c	5b		 pop	 ebx
  0012d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00132	c9		 leave
  00133	c2 10 00	 ret	 16			; 00000010H
?RegisterFromResource@CRegObject@ATL@@IAEJPB_W00H@Z ENDP ; ATL::CRegObject::RegisterFromResource
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?ResourceUnregisterSz@CRegObject@ATL@@QAGJPB_W00@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_szID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceUnregisterSz@CRegObject@ATL@@QAGJPB_W00@Z PROC	; ATL::CRegObject::ResourceUnregisterSz, COMDAT

; 600  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 601  : 	USES_CONVERSION_EX;
; 602  : 	if (szID == NULL || szType == NULL)

  00003	83 7d 10 00	 cmp	 DWORD PTR _szID$[ebp], 0
  00007	74 1b		 je	 SHORT $LN3@ResourceUn
  00009	83 7d 14 00	 cmp	 DWORD PTR _szType$[ebp], 0
  0000d	74 15		 je	 SHORT $LN3@ResourceUn

; 603  : 		return E_INVALIDARG;
; 604  : 
; 605  : 	LPCTSTR lpszID = OLE2CT_EX(szID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 606  : 	LPCTSTR lpszType = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 607  : #ifndef _UNICODE
; 608  : 	if (lpszID == NULL || lpszType == NULL)
; 609  : 	{
; 610  : 		return E_OUTOFMEMORY;
; 611  : 	}
; 612  : #endif // _UNICODE
; 613  : 
; 614  : 	return RegisterFromResource(szFileName, lpszID, lpszType, FALSE);

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	6a 00		 push	 0
  00014	ff 75 14	 push	 DWORD PTR _szType$[ebp]
  00017	ff 75 10	 push	 DWORD PTR _szID$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR _szFileName$[ebp]
  0001d	e8 00 00 00 00	 call	 ?RegisterFromResource@CRegObject@ATL@@IAEJPB_W00H@Z ; ATL::CRegObject::RegisterFromResource
  00022	eb 05		 jmp	 SHORT $LL15@ResourceUn
$LN3@ResourceUn:
  00024	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LL15@ResourceUn:

; 615  : }

  00029	5d		 pop	 ebp
  0002a	c2 10 00	 ret	 16			; 00000010H
?ResourceUnregisterSz@CRegObject@ATL@@QAGJPB_W00@Z ENDP	; ATL::CRegObject::ResourceUnregisterSz
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?ResourceRegisterSz@CRegObject@ATL@@QAGJPB_W00@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_szFileName$ = 12					; size = 4
_szID$ = 16						; size = 4
_szType$ = 20						; size = 4
?ResourceRegisterSz@CRegObject@ATL@@QAGJPB_W00@Z PROC	; ATL::CRegObject::ResourceRegisterSz, COMDAT

; 563  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 564  : 	USES_CONVERSION_EX;
; 565  : 	if (szID == NULL || szType == NULL)

  00003	83 7d 10 00	 cmp	 DWORD PTR _szID$[ebp], 0
  00007	74 1b		 je	 SHORT $LN3@ResourceRe
  00009	83 7d 14 00	 cmp	 DWORD PTR _szType$[ebp], 0
  0000d	74 15		 je	 SHORT $LN3@ResourceRe

; 566  : 		return E_INVALIDARG;
; 567  : 
; 568  : 	LPCTSTR lpszID = OLE2CT_EX(szID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 569  : 	LPCTSTR lpszType = OLE2CT_EX(szType, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 570  : #ifndef _UNICODE
; 571  : 	if (lpszID == NULL || lpszType==NULL)
; 572  : 	{
; 573  : 		return E_OUTOFMEMORY;
; 574  : 	}
; 575  : #endif // _UNICODE
; 576  : 	return RegisterFromResource(szFileName, lpszID, lpszType, TRUE);

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	6a 01		 push	 1
  00014	ff 75 14	 push	 DWORD PTR _szType$[ebp]
  00017	ff 75 10	 push	 DWORD PTR _szID$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR _szFileName$[ebp]
  0001d	e8 00 00 00 00	 call	 ?RegisterFromResource@CRegObject@ATL@@IAEJPB_W00H@Z ; ATL::CRegObject::RegisterFromResource
  00022	eb 05		 jmp	 SHORT $LL15@ResourceRe
$LN3@ResourceRe:
  00024	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LL15@ResourceRe:

; 577  : }

  00029	5d		 pop	 ebp
  0002a	c2 10 00	 ret	 16			; 00000010H
?ResourceRegisterSz@CRegObject@ATL@@QAGJPB_W00@Z ENDP	; ATL::CRegObject::ResourceRegisterSz
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?ClearReplacements@CRegObject@ATL@@UAGJXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?ClearReplacements@CRegObject@ATL@@UAGJXZ PROC		; ATL::CRegObject::ClearReplacements, COMDAT

; 638  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 639  : 	m_csMap.Lock();
; 640  : 	HRESULT hr = m_RepMap.ClearReplacements();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  00009	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements

; 641  : 	m_csMap.Unlock();
; 642  : 	return hr;
; 643  : }

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?ClearReplacements@CRegObject@ATL@@UAGJXZ ENDP		; ATL::CRegObject::ClearReplacements
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_lpszKey$ = 12						; size = 4
_lpszItem$ = 16						; size = 4
?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z PROC	; ATL::CRegObject::AddReplacement, COMDAT

; 419  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 420  : 	if (lpszKey == NULL || lpszItem == NULL)

  00003	83 7d 0c 00	 cmp	 DWORD PTR _lpszKey$[ebp], 0
  00007	74 27		 je	 SHORT $LN3@AddReplace
  00009	83 7d 10 00	 cmp	 DWORD PTR _lpszItem$[ebp], 0
  0000d	74 21		 je	 SHORT $LN3@AddReplace

; 422  : 	m_csMap.Lock();
; 423  : 	USES_CONVERSION_EX;
; 424  : 
; 425  : 	LPCTSTR lpszT = OLE2CT_EX(lpszKey, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 426  : 
; 427  : #ifndef _UNICODE
; 428  : 	if(lpszT == NULL)
; 429  : 		return E_OUTOFMEMORY;
; 430  : #endif
; 431  : 
; 432  : 	BOOL bRet = m_RepMap.Add(lpszT, lpszItem);

  0000f	ff 75 10	 push	 DWORD PTR _lpszItem$[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	ff 75 0c	 push	 DWORD PTR _lpszKey$[ebp]
  00018	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]
  0001b	e8 00 00 00 00	 call	 ?Add@CExpansionVector@ATL@@QAEHPB_W0@Z ; ATL::CExpansionVector::Add

; 433  : 	m_csMap.Unlock();
; 434  : 	return bRet ? S_OK : E_OUTOFMEMORY;

  00020	f7 d8		 neg	 eax
  00022	1b c0		 sbb	 eax, eax
  00024	25 f2 ff f8 7f	 and	 eax, 2147024882		; 7ff8fff2H
  00029	05 0e 00 07 80	 add	 eax, -2147024882	; 8007000eH
  0002e	eb 05		 jmp	 SHORT $LN1@AddReplace
$LN3@AddReplace:

; 421  : 		return E_INVALIDARG;

  00030	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN1@AddReplace:

; 435  : }

  00035	5d		 pop	 ebp
  00036	c2 0c 00	 ret	 12			; 0000000cH
?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ENDP	; ATL::CRegObject::AddReplacement
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ??1CRegObject@ATL@@UAE@XZ
_TEXT	SEGMENT
??1CRegObject@ATL@@UAE@XZ PROC				; ATL::CRegObject::~CRegObject, COMDAT
; _this$ = ecx

; 336  : 	{

  00000	56		 push	 esi

; 640  : 	HRESULT hr = m_RepMap.ClearReplacements();

  00001	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]

; 336  : 	{

  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CRegObject@ATL@@6B@

; 640  : 	HRESULT hr = m_RepMap.ClearReplacements();

  0000a	8b ce		 mov	 ecx, esi
  0000c	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements

; 104  : 		 ClearReplacements();

  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ; ATL::CExpansionVector::ClearReplacements
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 334  : 		RemoveAll();

  00018	8b ce		 mov	 ecx, esi
  0001a	5e		 pop	 esi
  0001b	e9 00 00 00 00	 jmp	 ?RemoveAll@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll
??1CRegObject@ATL@@UAE@XZ ENDP				; ATL::CRegObject::~CRegObject
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?Release@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CRegObject@ATL@@UAGKXZ PROC			; ATL::CRegObject::Release, COMDAT

; 331  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
; 332  : 		return 0;

  00000	33 c0		 xor	 eax, eax

; 333  : 	}

  00002	c2 04 00	 ret	 4
?Release@CRegObject@ATL@@UAGKXZ ENDP			; ATL::CRegObject::Release
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?AddRef@CRegObject@ATL@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CRegObject@ATL@@UAGKXZ PROC			; ATL::CRegObject::AddRef, COMDAT

; 326  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
; 327  : 		return 1;

  00000	33 c0		 xor	 eax, eax
  00002	40		 inc	 eax

; 328  : 	}

  00003	c2 04 00	 ret	 4
?AddRef@CRegObject@ATL@@UAGKXZ ENDP			; ATL::CRegObject::AddRef
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z PROC ; ATL::CRegObject::QueryInterface, COMDAT

; 320  : 		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
; 321  : 		return E_NOTIMPL;

  00000	b8 01 40 00 80	 mov	 eax, -2147467263	; 80004001H

; 322  : 	}

  00005	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CRegObject@ATL@@UAGJABU_GUID@@PAPAX@Z ENDP ; ATL::CRegObject::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z PROC	; ATL::CRegParser::CParseBuffer::AddString, COMDAT
; _this$ = ecx

; 288  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 289  : 			if (lpsz == NULL)

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpsz$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	75 04		 jne	 SHORT $LN2@AddString

; 290  : 			{
; 291  : 				return FALSE;

  0000d	33 c0		 xor	 eax, eax
  0000f	eb 1f		 jmp	 SHORT $LN1@AddString
$LN2@AddString:

; 292  : 			}
; 293  : 			USES_CONVERSION_EX;
; 294  : 			LPCTSTR lpszT = OLE2CT_EX(lpsz, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 295  : 			if (lpszT == NULL)
; 296  : 			{
; 297  : 				return FALSE;
; 298  : 			}
; 299  : 			return Append(lpszT, (int)_tcslen(lpszT));

  00011	8b ca		 mov	 ecx, edx
  00013	57		 push	 edi
  00014	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
$LL24@AddString:
  00017	66 8b 01	 mov	 ax, WORD PTR [ecx]
  0001a	83 c1 02	 add	 ecx, 2
  0001d	66 85 c0	 test	 ax, ax
  00020	75 f5		 jne	 SHORT $LL24@AddString
  00022	2b cf		 sub	 ecx, edi
  00024	d1 f9		 sar	 ecx, 1
  00026	51		 push	 ecx
  00027	52		 push	 edx
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPB_WH@Z ; ATL::CRegParser::CParseBuffer::Append
  0002f	5f		 pop	 edi
$LN1@AddString:
  00030	5e		 pop	 esi

; 300  : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ENDP	; ATL::CRegParser::CParseBuffer::AddString
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?Append@CParseBuffer@CRegParser@ATL@@QAEHPB_WH@Z
_TEXT	SEGMENT
_pch$ = 8						; size = 4
_nChars$ = 12						; size = 4
?Append@CParseBuffer@CRegParser@ATL@@QAEHPB_WH@Z PROC	; ATL::CRegParser::CParseBuffer::Append, COMDAT
; _this$ = ecx

; 245  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 246  : 			ATLASSERT(p != NULL);
; 247  : 			ATLASSUME(p != NULL);
; 248  : 			int newSize = nPos + nChars + 1;

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _nChars$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000c	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  0000f	03 d1		 add	 edx, ecx

; 249  : 			if ((newSize <= nPos) || (newSize <= nChars))

  00011	3b d1		 cmp	 edx, ecx
  00013	7e 71		 jle	 SHORT $LN8@Append
  00015	3b d7		 cmp	 edx, edi
  00017	7e 6d		 jle	 SHORT $LN8@Append

; 251  : 
; 252  : 			if (newSize >= nSize)

  00019	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001c	3b d0		 cmp	 edx, eax
  0001e	7c 27		 jl	 SHORT $LN21@Append
$LL5@Append:

; 253  : 			{
; 254  : 				while (newSize >= nSize) {
; 255  : 					if (nSize > INT_MAX / 2)

  00020	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00025	7f 5f		 jg	 SHORT $LN8@Append

; 256  : 					return FALSE;
; 257  : 					nSize *= 2;

  00027	03 c0		 add	 eax, eax
  00029	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0002c	3b d0		 cmp	 edx, eax
  0002e	7d f0		 jge	 SHORT $LL5@Append

; 258  : 				}
; 259  : 				LPTSTR pTemp = (LPTSTR)::ATL::AtlCoTaskMemRecalloc(p, nSize, sizeof(TCHAR));

  00030	6a 02		 push	 2
  00032	50		 push	 eax
  00033	ff 76 08	 push	 DWORD PTR [esi+8]
  00036	e8 00 00 00 00	 call	 ?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z ; ATL::AtlCoTaskMemRecalloc
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 260  : 				if (pTemp == NULL)

  0003e	85 c0		 test	 eax, eax
  00040	74 44		 je	 SHORT $LN8@Append

; 261  : 					return FALSE;
; 262  : 				p = pTemp;

  00042	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00044	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN21@Append:

; 263  : 			}
; 264  : 			if ((nPos < 0) || (nPos >= nSize) || nSize - nPos > nSize)

  00047	85 c9		 test	 ecx, ecx
  00049	78 3b		 js	 SHORT $LN8@Append
  0004b	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  0004e	7d 36		 jge	 SHORT $LN8@Append
  00050	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00053	2b d1		 sub	 edx, ecx
  00055	3b 56 04	 cmp	 edx, DWORD PTR [esi+4]
  00058	7f 2c		 jg	 SHORT $LN8@Append

; 265  : 				return FALSE;
; 266  : 
; 267  : #pragma warning(push)
; 268  : #pragma warning(disable: 22008)
; 269  : 			/* Prefast false warning is fired here despite the all above checks */
; 270  : 			Checked::memcpy_s(p + nPos, (nSize-nPos) * sizeof(TCHAR), pch, nChars * sizeof(TCHAR));

  0005a	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  0005d	50		 push	 eax
  0005e	ff 75 08	 push	 DWORD PTR _pch$[ebp]
  00061	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  00064	50		 push	 eax
  00065	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00068	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 271  : 			nPos += nChars;

  00071	01 3e		 add	 DWORD PTR [esi], edi

; 272  : 			*(p + nPos) = _T('\0');

  00073	33 d2		 xor	 edx, edx
  00075	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00078	83 c4 10	 add	 esp, 16			; 00000010H
  0007b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0007d	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 273  : #pragma warning(pop)
; 274  : 			return TRUE;

  00081	33 c0		 xor	 eax, eax
  00083	40		 inc	 eax
  00084	eb 02		 jmp	 SHORT $LN1@Append
$LN8@Append:

; 250  : 				return FALSE;

  00086	33 c0		 xor	 eax, eax
$LN1@Append:
  00088	5f		 pop	 edi

; 275  : 		}

  00089	5e		 pop	 esi
  0008a	5d		 pop	 ebp
  0008b	c2 08 00	 ret	 8
?Append@CParseBuffer@CRegParser@ATL@@QAEHPB_WH@Z ENDP	; ATL::CRegParser::CParseBuffer::Append
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ??0CParseBuffer@CRegParser@ATL@@QAE@H@Z
_TEXT	SEGMENT
_nInitial$ = 8						; size = 4
??0CParseBuffer@CRegParser@ATL@@QAE@H@Z PROC		; ATL::CRegParser::CParseBuffer::CParseBuffer, COMDAT
; _this$ = ecx

; 228  : 		CParseBuffer(_In_ int nInitial)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  : 		{
; 230  : 			if (nInitial < 100)
; 231  : 				nInitial = 1000;
; 232  : 			nPos = 0;

  00003	83 7d 08 64	 cmp	 DWORD PTR _nInitial$[ebp], 100 ; 00000064H
  00007	b8 e8 03 00 00	 mov	 eax, 1000		; 000003e8H
  0000c	56		 push	 esi
  0000d	0f 4d 45 08	 cmovge	 eax, DWORD PTR _nInitial$[ebp]
  00011	8b f1		 mov	 esi, ecx

; 233  : 			nSize = nInitial;
; 234  : 			p = (LPTSTR) ::ATL::AtlCoTaskMemCAlloc(nSize,static_cast<ULONG>(sizeof(TCHAR)));

  00013	6a 02		 push	 2
  00015	50		 push	 eax
  00016	83 26 00	 and	 DWORD PTR [esi], 0
  00019	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001c	e8 00 00 00 00	 call	 ?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z ; ATL::AtlCoTaskMemCAlloc
  00021	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx

; 235  : 			if (p != NULL)

  00026	85 c0		 test	 eax, eax
  00028	74 05		 je	 SHORT $LN3@CParseBuff

; 236  : 				*p = _T('\0');

  0002a	33 c9		 xor	 ecx, ecx
  0002c	66 89 08	 mov	 WORD PTR [eax], cx
$LN3@CParseBuff:

; 237  : 		}

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0CParseBuffer@CRegParser@ATL@@QAE@H@Z ENDP		; ATL::CRegParser::CParseBuffer::CParseBuffer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?VTFromRegType@CRegParser@ATL@@KAHPB_WAAG@Z
_TEXT	SEGMENT
_szValueType$ = 8					; size = 4
_vt$ = 12						; size = 4
?VTFromRegType@CRegParser@ATL@@KAHPB_WAAG@Z PROC	; ATL::CRegParser::VTFromRegType, COMDAT

; 756  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 757  : 	if (!lstrcmpi(szValueType, szStringVal))

  00004	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__lstrcmpiW@8
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_13HADIAKP@?$AAS@
  0000f	ff 75 08	 push	 DWORD PTR _szValueType$[ebp]
  00012	ff d7		 call	 edi
  00014	85 c0		 test	 eax, eax
  00016	75 0e		 jne	 SHORT $LN2@VTFromRegT

; 758  : 	{
; 759  : 		vt = VT_BSTR;

  00018	6a 08		 push	 8
$LN8@VTFromRegT:

; 783  : }

  0001a	59		 pop	 ecx
$LN7@VTFromRegT:
  0001b	8b 45 0c	 mov	 eax, DWORD PTR _vt$[ebp]
$LN9@VTFromRegT:
  0001e	66 89 08	 mov	 WORD PTR [eax], cx
  00021	33 c0		 xor	 eax, eax
  00023	40		 inc	 eax
  00024	eb 44		 jmp	 SHORT $LN1@VTFromRegT
$LN2@VTFromRegT:

; 760  : 		return TRUE;
; 761  : 	}
; 762  : 
; 763  : 	if (!lstrcmpi(szValueType, multiszStringVal))

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_13LHMFKAAD@?$AAM@
  0002b	ff 75 08	 push	 DWORD PTR _szValueType$[ebp]
  0002e	ff d7		 call	 edi
  00030	85 c0		 test	 eax, eax
  00032	75 07		 jne	 SHORT $LN3@VTFromRegT

; 764  : 	{
; 765  : 		vt = VT_BSTR | VT_BYREF;

  00034	b9 08 40 00 00	 mov	 ecx, 16392		; 00004008H

; 766  : 		return TRUE;

  00039	eb e0		 jmp	 SHORT $LN7@VTFromRegT
$LN3@VTFromRegT:

; 767  : 	}
; 768  : 
; 769  : 	if (!lstrcmpi(szValueType, szDwordVal))

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_13MKMNOPIJ@?$AAD@
  00040	ff 75 08	 push	 DWORD PTR _szValueType$[ebp]
  00043	ff d7		 call	 edi
  00045	85 c0		 test	 eax, eax
  00047	75 04		 jne	 SHORT $LN4@VTFromRegT

; 770  : 	{
; 771  : 		vt = VT_UI4;

  00049	6a 13		 push	 19			; 00000013H

; 772  : 		return TRUE;

  0004b	eb cd		 jmp	 SHORT $LN8@VTFromRegT
$LN4@VTFromRegT:

; 773  : 	}
; 774  : 
; 775  : 	if (!lstrcmpi(szValueType, szBinaryVal))

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_13OPKGLAFF@?$AAB@
  00052	ff 75 08	 push	 DWORD PTR _szValueType$[ebp]
  00055	ff d7		 call	 edi
  00057	85 c0		 test	 eax, eax
  00059	8b 45 0c	 mov	 eax, DWORD PTR _vt$[ebp]
  0005c	75 05		 jne	 SHORT $LN5@VTFromRegT

; 776  : 	{
; 777  : 		vt = VT_UI1;

  0005e	6a 11		 push	 17			; 00000011H
  00060	59		 pop	 ecx

; 778  : 		return TRUE;

  00061	eb bb		 jmp	 SHORT $LN9@VTFromRegT
$LN5@VTFromRegT:

; 779  : 	}
; 780  : 
; 781  : 	vt = VT_EMPTY;

  00063	33 c9		 xor	 ecx, ecx
  00065	66 89 08	 mov	 WORD PTR [eax], cx

; 782  : 	return FALSE;

  00068	33 c0		 xor	 eax, eax
$LN1@VTFromRegT:
  0006a	5f		 pop	 edi

; 783  : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?VTFromRegType@CRegParser@ATL@@KAHPB_WAAG@Z ENDP	; ATL::CRegParser::VTFromRegType
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?ChToByte@CRegParser@ATL@@KAE_W@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 2
?ChToByte@CRegParser@ATL@@KAE_W@Z PROC			; ATL::CRegParser::ChToByte, COMDAT

; 786  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 787  : 	switch (ch)

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _ch$[ebp]
  00007	83 f8 30	 cmp	 eax, 48			; 00000030H
  0000a	72 23		 jb	 SHORT $LN7@ChToByte
  0000c	83 f8 39	 cmp	 eax, 57			; 00000039H
  0000f	76 1a		 jbe	 SHORT $LN4@ChToByte
  00011	83 f8 40	 cmp	 eax, 64			; 00000040H
  00014	76 19		 jbe	 SHORT $LN7@ChToByte
  00016	83 f8 46	 cmp	 eax, 70			; 00000046H
  00019	76 0c		 jbe	 SHORT $LN5@ChToByte
  0001b	8d 48 9f	 lea	 ecx, DWORD PTR [eax-97]
  0001e	83 f9 05	 cmp	 ecx, 5
  00021	77 0c		 ja	 SHORT $LN7@ChToByte

; 807  : 		case 'a':
; 808  : 		case 'b':
; 809  : 		case 'c':
; 810  : 		case 'd':
; 811  : 		case 'e':
; 812  : 		case 'f':
; 813  : 				return (BYTE) (10 + (ch - 'a'));

  00023	2c 57		 sub	 al, 87			; 00000057H

; 818  : 	}
; 819  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
$LN5@ChToByte:

; 800  : 		case 'A':
; 801  : 		case 'B':
; 802  : 		case 'C':
; 803  : 		case 'D':
; 804  : 		case 'E':
; 805  : 		case 'F':
; 806  : 				return (BYTE) (10 + (ch - 'A'));

  00027	2c 37		 sub	 al, 55			; 00000037H

; 818  : 	}
; 819  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN4@ChToByte:

; 788  : 	{
; 789  : 		case '0':
; 790  : 		case '1':
; 791  : 		case '2':
; 792  : 		case '3':
; 793  : 		case '4':
; 794  : 		case '5':
; 795  : 		case '6':
; 796  : 		case '7':
; 797  : 		case '8':
; 798  : 		case '9':
; 799  : 				return (BYTE) (ch - '0');

  0002b	2c 30		 sub	 al, 48			; 00000030H

; 818  : 	}
; 819  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN7@ChToByte:

; 814  : 		default:
; 815  : 				ATLASSERT(FALSE);
; 816  : 				ATLTRACE(atlTraceRegistrar, 0, _T("Bogus value %Tc passed as binary Hex value\n"), ch);
; 817  : 				return 0;

  0002f	32 c0		 xor	 al, al

; 818  : 	}
; 819  : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?ChToByte@CRegParser@ATL@@KAE_W@Z ENDP			; ATL::CRegParser::ChToByte
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z
_TEXT	SEGMENT
_szToken$ = 8						; size = 4
?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z PROC ; ATL::CRegParser::HKeyFromString, COMDAT

; 822  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 823  : 	struct keymap
; 824  : 	{
; 825  : 		LPCTSTR lpsz;
; 826  : 		HKEY hkey;
; 827  : 	};
; 828  : 	static const keymap map[] = {
; 829  : 		{_T("HKCR"), HKEY_CLASSES_ROOT},
; 830  : 		{_T("HKCU"), HKEY_CURRENT_USER},
; 831  : 		{_T("HKLM"), HKEY_LOCAL_MACHINE},
; 832  : 		{_T("HKU"),  HKEY_USERS},
; 833  : 		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
; 834  : 		{_T("HKDD"), HKEY_DYN_DATA},
; 835  : 		{_T("HKCC"), HKEY_CURRENT_CONFIG},
; 836  : 		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
; 837  : 		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
; 838  : 		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
; 839  : 		{_T("HKEY_USERS"), HKEY_USERS},
; 840  : 		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
; 841  : 		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
; 842  : 		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
; 843  : 	};
; 844  : 
; 845  : 	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)

  00004	33 f6		 xor	 esi, esi
$LL4@HKeyFromSt:

; 846  : 	{
; 847  : 		if (!lstrcmpi(szToken, map[i].lpsz))

  00006	ff 34 f5 00 00
	00 00		 push	 DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[esi*8]
  0000d	ff 75 08	 push	 DWORD PTR _szToken$[ebp]
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiW@8
  00016	85 c0		 test	 eax, eax
  00018	74 0a		 je	 SHORT $LN8@HKeyFromSt

; 823  : 	struct keymap
; 824  : 	{
; 825  : 		LPCTSTR lpsz;
; 826  : 		HKEY hkey;
; 827  : 	};
; 828  : 	static const keymap map[] = {
; 829  : 		{_T("HKCR"), HKEY_CLASSES_ROOT},
; 830  : 		{_T("HKCU"), HKEY_CURRENT_USER},
; 831  : 		{_T("HKLM"), HKEY_LOCAL_MACHINE},
; 832  : 		{_T("HKU"),  HKEY_USERS},
; 833  : 		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
; 834  : 		{_T("HKDD"), HKEY_DYN_DATA},
; 835  : 		{_T("HKCC"), HKEY_CURRENT_CONFIG},
; 836  : 		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
; 837  : 		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
; 838  : 		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
; 839  : 		{_T("HKEY_USERS"), HKEY_USERS},
; 840  : 		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
; 841  : 		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
; 842  : 		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
; 843  : 	};
; 844  : 
; 845  : 	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)

  0001a	46		 inc	 esi
  0001b	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  0001e	72 e6		 jb	 SHORT $LL4@HKeyFromSt

; 849  : 	}
; 850  : 	return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 07		 jmp	 SHORT $LN1@HKeyFromSt
$LN8@HKeyFromSt:

; 848  : 			return map[i].hkey;

  00024	8b 04 f5 04 00
	00 00		 mov	 eax, DWORD PTR ?map@?1??HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z@4QBUkeymap@?1??123@KAPAU4@0@Z@B[esi*8+4]
$LN1@HKeyFromSt:
  0002b	5e		 pop	 esi

; 851  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z ENDP ; ATL::CRegParser::HKeyFromString
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?StrChrW@CRegParser@ATL@@KAPA_WPA_W_W@Z
_TEXT	SEGMENT
_lpsz$ = 8						; size = 4
_ch$ = 12						; size = 2
?StrChrW@CRegParser@ATL@@KAPA_WPA_W_W@Z PROC		; ATL::CRegParser::StrChrW, COMDAT

; 856  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 857  : 	LPTSTR p = NULL;
; 858  : 
; 859  : 	if (lpsz == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _lpsz$[ebp]
  00006	56		 push	 esi
  00007	33 f6		 xor	 esi, esi
  00009	85 c9		 test	 ecx, ecx
  0000b	75 04		 jne	 SHORT $LN7@StrChrW

; 860  : 		return NULL;

  0000d	33 c0		 xor	 eax, eax
  0000f	eb 29		 jmp	 SHORT $LN1@StrChrW
$LN7@StrChrW:

; 861  : 
; 862  : 	while (*lpsz)

  00011	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00014	66 85 c0	 test	 ax, ax
  00017	74 1f		 je	 SHORT $LN3@StrChrW
  00019	8b d0		 mov	 edx, eax
$LL2@StrChrW:

; 863  : 	{
; 864  : 		if (*lpsz == ch)

  0001b	66 3b 55 0c	 cmp	 dx, WORD PTR _ch$[ebp]
  0001f	74 15		 je	 SHORT $LN8@StrChrW

; 867  : 			break;
; 868  : 		}
; 869  : 		lpsz = CharNext(lpsz);

  00021	51		 push	 ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  00028	8b c8		 mov	 ecx, eax
  0002a	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  0002d	8b d0		 mov	 edx, eax
  0002f	66 85 c0	 test	 ax, ax
  00032	75 e7		 jne	 SHORT $LL2@StrChrW

; 863  : 	{
; 864  : 		if (*lpsz == ch)

  00034	eb 02		 jmp	 SHORT $LN3@StrChrW
$LN8@StrChrW:

; 865  : 		{
; 866  : 			p = lpsz;

  00036	8b f1		 mov	 esi, ecx
$LN3@StrChrW:

; 870  : 	}
; 871  : 	return p;

  00038	8b c6		 mov	 eax, esi
$LN1@StrChrW:
  0003a	5e		 pop	 esi

; 872  : }

  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?StrChrW@CRegParser@ATL@@KAPA_WPA_W_W@Z ENDP		; ATL::CRegParser::StrChrW
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?EndOfVar@CRegParser@ATL@@IAEHXZ
_TEXT	SEGMENT
?EndOfVar@CRegParser@ATL@@IAEHXZ PROC			; ATL::CRegParser::EndOfVar, COMDAT
; _this$ = ecx

; 210  : 		return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	6a 27		 push	 39			; 00000027H
  00005	5e		 pop	 esi
  00006	66 3b 30	 cmp	 si, WORD PTR [eax]
  00009	75 11		 jne	 SHORT $LN3@EndOfVar
  0000b	50		 push	 eax
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  00012	66 3b 30	 cmp	 si, WORD PTR [eax]
  00015	74 05		 je	 SHORT $LN3@EndOfVar
  00017	33 c0		 xor	 eax, eax
  00019	40		 inc	 eax
  0001a	5e		 pop	 esi

; 211  : 	}

  0001b	c3		 ret	 0
$LN3@EndOfVar:

; 210  : 		return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur);

  0001c	33 c0		 xor	 eax, eax
  0001e	5e		 pop	 esi

; 211  : 	}

  0001f	c3		 ret	 0
?EndOfVar@CRegParser@ATL@@IAEHXZ ENDP			; ATL::CRegParser::EndOfVar
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?SkipAssignment@CRegParser@ATL@@IAEJPA_W@Z
_TEXT	SEGMENT
_szValue$ = -8196					; size = 8192
__$ArrayPad$ = -4					; size = 4
_szToken$ = 8						; size = 4
?SkipAssignment@CRegParser@ATL@@IAEJPA_W@Z PROC		; ATL::CRegParser::SkipAssignment, COMDAT
; _this$ = ecx

; 1152 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 20 00 00	 mov	 eax, 8196		; 00002004H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _szToken$[ebp]
  0001c	8b f1		 mov	 esi, ecx

; 1153 : 	HRESULT hr;
; 1154 : 	TCHAR szValue[MAX_VALUE];
; 1155 : 
; 1156 : 	if (*szToken == chEquals)

  0001e	66 83 3f 3d	 cmp	 WORD PTR [edi], 61	; 0000003dH
  00022	75 2f		 jne	 SHORT $LN5@SkipAssign

; 1157 : 	{
; 1158 : 		if (FAILED(hr = NextToken(szToken)))

  00024	57		 push	 edi
  00025	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  0002a	85 c0		 test	 eax, eax
  0002c	78 27		 js	 SHORT $LN1@SkipAssign

; 1159 : 			return hr;
; 1160 : 		// Skip assignment
; 1161 : 		SkipWhiteSpace();

  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace

; 1162 : 		if (FAILED(hr = NextToken(szValue)))

  00035	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  0003b	8b ce		 mov	 ecx, esi
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  00043	85 c0		 test	 eax, eax
  00045	78 0e		 js	 SHORT $LN1@SkipAssign

; 1163 : 			return hr;
; 1164 : 		if (FAILED(hr = NextToken(szToken)))

  00047	57		 push	 edi
  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  0004f	85 c0		 test	 eax, eax
  00051	78 02		 js	 SHORT $LN1@SkipAssign
$LN5@SkipAssign:

; 1165 : 			return hr;
; 1166 : 	}
; 1167 : 
; 1168 : 	return S_OK;

  00053	33 c0		 xor	 eax, eax
$LN1@SkipAssign:

; 1169 : }

  00055	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00058	5f		 pop	 edi
  00059	33 cd		 xor	 ecx, ebp
  0005b	5e		 pop	 esi
  0005c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00061	c9		 leave
  00062	c2 04 00	 ret	 4
?SkipAssignment@CRegParser@ATL@@IAEJPA_W@Z ENDP		; ATL::CRegParser::SkipAssignment
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?IsSpace@CRegParser@ATL@@IAEH_W@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 2
?IsSpace@CRegParser@ATL@@IAEH_W@Z PROC			; ATL::CRegParser::IsSpace, COMDAT
; _this$ = ecx

; 881  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	66 8b 4d 08	 mov	 cx, WORD PTR _ch$[ebp]
  00007	0f b7 c1	 movzx	 eax, cx

; 882  : 	switch (ch)

  0000a	83 f8 09	 cmp	 eax, 9
  0000d	72 15		 jb	 SHORT $LN2@IsSpace
  0000f	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00012	76 0b		 jbe	 SHORT $LN4@IsSpace
  00014	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  00017	74 06		 je	 SHORT $LN4@IsSpace
  00019	66 83 f9 20	 cmp	 cx, 32			; 00000020H
  0001d	75 05		 jne	 SHORT $LN2@IsSpace
$LN4@IsSpace:

; 883  : 	{
; 884  : 		case _T(' '):
; 885  : 		case _T('\t'):
; 886  : 		case _T('\r'):
; 887  : 		case _T('\n'):
; 888  : 				return TRUE;

  0001f	33 c0		 xor	 eax, eax
  00021	40		 inc	 eax
  00022	eb 02		 jmp	 SHORT $LN1@IsSpace
$LN2@IsSpace:

; 889  : 	}
; 890  : 
; 891  : 	return FALSE;

  00024	33 c0		 xor	 eax, eax
$LN1@IsSpace:

; 892  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?IsSpace@CRegParser@ATL@@IAEH_W@Z ENDP			; ATL::CRegParser::IsSpace
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?RegisterSubkeys@CRegParser@ATL@@IAEJPA_WPAUHKEY__@@HH@Z
_TEXT	SEGMENT
_rkParent$1 = -8804					; size = 12
_dw$2 = -8792						; size = 4
_rk$3 = -8788						; size = 12
_rkParent$4 = -8776					; size = 12
_rkForceRemove$5 = -8764				; size = 12
tv700 = -8752						; size = 4
tv724 = -8748						; size = 4
tv709 = -8744						; size = 4
_bHasSubKeys$1$ = -8744					; size = 4
_lRes$2$ = -8744					; size = 4
_hkParent$GSCopy$1$ = -8740				; size = 4
_bDelete$1$ = -8736					; size = 4
_hKey$6 = -8736						; size = 4
_keyCur$ = -8732					; size = 12
_this$GSCopy$1$ = -8720					; size = 4
_szValueName$7 = -8716					; size = 8192
_szKey$ = -524						; size = 520
__$ArrayPad$ = -4					; size = 4
_szToken$ = 8						; size = 4
_hkParent$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_bRecover$ = 20						; size = 4
?RegisterSubkeys@CRegParser@ATL@@IAEJPA_WPAUHKEY__@@HH@Z PROC ; ATL::CRegParser::RegisterSubkeys, COMDAT
; _this$ = ecx

; 1412 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 64 22 00 00	 mov	 eax, 8804		; 00002264H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b c1		 mov	 eax, ecx
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _hkParent$[ebp]
  0001d	56		 push	 esi
  0001e	89 8d dc dd ff
	ff		 mov	 DWORD PTR _hkParent$GSCopy$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  00024	33 c9		 xor	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1412 : {

  00026	57		 push	 edi
  00027	8b 7d 08	 mov	 edi, DWORD PTR _szToken$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  0002a	8b d9		 mov	 ebx, ecx
  0002c	89 8d d4 dd ff
	ff		 mov	 DWORD PTR tv724[ebp], ecx
  00032	89 8d e8 dd ff
	ff		 mov	 DWORD PTR _keyCur$[ebp+4], ecx
  00038	89 8d ec dd ff
	ff		 mov	 DWORD PTR _keyCur$[ebp+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1421 : 	if (FAILED(hr = NextToken(szToken)))

  0003e	8b c8		 mov	 ecx, eax
  00040	57		 push	 edi
  00041	89 85 f0 dd ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  00047	89 9d e4 dd ff
	ff		 mov	 DWORD PTR _keyCur$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1421 : 	if (FAILED(hr = NextToken(szToken)))

  0004d	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  00052	8b f0		 mov	 esi, eax
  00054	85 f6		 test	 esi, esi
  00056	0f 88 3e 06 00
	00		 js	 $LN221@RegisterSu

; 1422 : 		return hr;
; 1423 : 
; 1424 : 	while (*szToken != chRightBracket) // Continue till we see a }

  0005c	6a 7d		 push	 125			; 0000007dH
  0005e	58		 pop	 eax
  0005f	66 39 07	 cmp	 WORD PTR [edi], ax
  00062	0f 84 21 06 00
	00		 je	 $LN276@RegisterSu
$LL2@RegisterSu:

; 1425 : 	{
; 1426 : 		bDelete = TRUE;
; 1427 : 		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_1O@JDLOHAN@?$AAD?$AAe?$AAl?$AAe?$AAt?$AAe@
  0006d	57		 push	 edi
  0006e	c7 85 e0 dd ff
	ff 01 00 00 00	 mov	 DWORD PTR _bDelete$1$[ebp], 1
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiW@8
  0007e	f7 d8		 neg	 eax

; 1429 : 		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)

  00080	68 00 00 00 00	 push	 OFFSET ??_C@_1BI@JFAIJMHL@?$AAF?$AAo?$AAr?$AAc?$AAe?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@
  00085	1b f6		 sbb	 esi, esi
  00087	46		 inc	 esi
  00088	57		 push	 edi
  00089	89 b5 d8 dd ff
	ff		 mov	 DWORD PTR tv709[ebp], esi
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiW@8
  00095	85 c0		 test	 eax, eax
  00097	74 08		 je	 SHORT $LN6@RegisterSu
  00099	85 f6		 test	 esi, esi
  0009b	0f 84 ca 00 00
	00		 je	 $LN284@RegisterSu
$LN6@RegisterSu:

; 1430 : 		{
; 1431 : 			if (FAILED(hr = NextToken(szToken)))

  000a1	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  000a7	57		 push	 edi
  000a8	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  000ad	8b f0		 mov	 esi, eax
  000af	85 f6		 test	 esi, esi
  000b1	0f 88 d2 05 00
	00		 js	 $LN276@RegisterSu

; 1432 : 				break;
; 1433 : 
; 1434 : 			if (bRegister)

  000b7	83 7d 10 00	 cmp	 DWORD PTR _bRegister$[ebp], 0
  000bb	0f 84 aa 00 00
	00		 je	 $LN284@RegisterSu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  000c1	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1438 : 				if (StrChr(szToken, chDirSep) != NULL)

  000c3	6a 5c		 push	 92			; 0000005cH
  000c5	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  000c6	89 85 c4 dd ff
	ff		 mov	 DWORD PTR _rkForceRemove$5[ebp], eax
  000cc	89 85 cc dd ff
	ff		 mov	 DWORD PTR _rkForceRemove$5[ebp+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1438 : 				if (StrChr(szToken, chDirSep) != NULL)

  000d2	e8 00 00 00 00	 call	 ?StrChrW@CRegParser@ATL@@KAPA_WPA_W_W@Z ; ATL::CRegParser::StrChrW
  000d7	59		 pop	 ecx
  000d8	59		 pop	 ecx
  000d9	85 c0		 test	 eax, eax
  000db	0f 85 a3 05 00
	00		 jne	 $LN239@RegisterSu

; 1441 : 				if (CanForceRemoveKey(szToken))

  000e1	8b b5 f0 dd ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  000e7	8b ce		 mov	 ecx, esi
  000e9	57		 push	 edi
  000ea	e8 00 00 00 00	 call	 ?CanForceRemoveKey@CRegParser@ATL@@IAEHPB_W@Z ; ATL::CRegParser::CanForceRemoveKey
  000ef	85 c0		 test	 eax, eax
  000f1	74 30		 je	 SHORT $LN285@RegisterSu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5749 : 	m_hKey = hKey;

  000f3	8b 85 dc dd ff
	ff		 mov	 eax, DWORD PTR _hkParent$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1445 : 					rkForceRemove.RecurseDeleteKey(szToken);

  000f9	8d 8d c4 dd ff
	ff		 lea	 ecx, DWORD PTR _rkForceRemove$5[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5749 : 	m_hKey = hKey;

  000ff	89 85 c4 dd ff
	ff		 mov	 DWORD PTR _rkForceRemove$5[ebp], eax

; 5750 : 	m_samWOW64 = 0;

  00105	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1445 : 					rkForceRemove.RecurseDeleteKey(szToken);

  00107	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5750 : 	m_samWOW64 = 0;

  00108	89 85 c8 dd ff
	ff		 mov	 DWORD PTR _rkForceRemove$5[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1445 : 					rkForceRemove.RecurseDeleteKey(szToken);

  0010e	e8 00 00 00 00	 call	 ?RecurseDeleteKey@CRegKey@ATL@@QAEJPB_W@Z ; ATL::CRegKey::RecurseDeleteKey
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5740 : 	m_hKey = NULL;

  00113	33 c0		 xor	 eax, eax
  00115	89 85 c4 dd ff
	ff		 mov	 DWORD PTR _rkForceRemove$5[ebp], eax

; 5741 : 	m_samWOW64 = 0;
; 5742 : 	m_pTM = NULL;

  0011b	89 85 cc dd ff
	ff		 mov	 DWORD PTR _rkForceRemove$5[ebp+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1441 : 				if (CanForceRemoveKey(szToken))

  00121	eb 02		 jmp	 SHORT $LN10@RegisterSu
$LN285@RegisterSu:
  00123	33 c0		 xor	 eax, eax
$LN10@RegisterSu:

; 1446 : 					rkForceRemove.Detach();
; 1447 : 				}
; 1448 : 				if (bTokenDelete)

  00125	83 bd d8 dd ff
	ff 00		 cmp	 DWORD PTR tv709[ebp], 0
  0012c	74 35		 je	 SHORT $LN112@RegisterSu

; 1449 : 				{
; 1450 : 					if (FAILED(hr = NextToken(szToken)))

  0012e	57		 push	 edi
  0012f	8b ce		 mov	 ecx, esi
  00131	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  00136	8b f0		 mov	 esi, eax
  00138	85 f6		 test	 esi, esi
  0013a	0f 88 49 05 00
	00		 js	 $LN276@RegisterSu

; 1451 : 						break;
; 1452 : 					if (FAILED(hr = SkipAssignment(szToken)))

  00140	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00146	57		 push	 edi
  00147	e8 00 00 00 00	 call	 ?SkipAssignment@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::SkipAssignment
  0014c	8b f0		 mov	 esi, eax
  0014e	85 f6		 test	 esi, esi
  00150	0f 88 33 05 00
	00		 js	 $LN276@RegisterSu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5809 : 	m_samWOW64 = 0;

  00156	33 c0		 xor	 eax, eax
  00158	89 85 c8 dd ff
	ff		 mov	 DWORD PTR _rkForceRemove$5[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1454 : 					goto EndCheck;

  0015e	e9 91 02 00 00	 jmp	 $LN253@RegisterSu
$LN112@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5809 : 	m_samWOW64 = 0;

  00163	89 85 c8 dd ff
	ff		 mov	 DWORD PTR _rkForceRemove$5[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1429 : 		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)

  00169	eb 06		 jmp	 SHORT $LN8@RegisterSu
$LN284@RegisterSu:

; 1455 : 				}
; 1456 : 			}
; 1457 : 		}
; 1458 : 
; 1459 : 		if (!lstrcmpi(szToken, szNoRemove))

  0016b	8b b5 f0 dd ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN8@RegisterSu:
  00171	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@GCKHIPE@?$AAN?$AAo?$AAR?$AAe?$AAm?$AAo?$AAv?$AAe@
  00176	57		 push	 edi
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiW@8
  0017d	85 c0		 test	 eax, eax
  0017f	75 18		 jne	 SHORT $LN16@RegisterSu

; 1460 : 		{
; 1461 : 			bDelete = FALSE;    // set even for register
; 1462 : 			if (FAILED(hr = NextToken(szToken)))

  00181	57		 push	 edi
  00182	8b ce		 mov	 ecx, esi
  00184	89 85 e0 dd ff
	ff		 mov	 DWORD PTR _bDelete$1$[ebp], eax
  0018a	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  0018f	8b f0		 mov	 esi, eax
  00191	85 f6		 test	 esi, esi
  00193	0f 88 f0 04 00
	00		 js	 $LN276@RegisterSu
$LN16@RegisterSu:

; 1463 : 				break;
; 1464 : 		}
; 1465 : 
; 1466 : 		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent

  00199	68 00 00 00 00	 push	 OFFSET ??_C@_17LLMMEOJD@?$AAV?$AAa?$AAl@
  0019e	57		 push	 edi
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiW@8
  001a5	85 c0		 test	 eax, eax
  001a7	0f 85 36 01 00
	00		 jne	 $LN22@RegisterSu

; 1467 : 		{
; 1468 : 			TCHAR  szValueName[MAX_VALUE];
; 1469 : 
; 1470 : 			if (FAILED(hr = NextToken(szValueName)))

  001ad	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001b3	8d 85 f4 dd ff
	ff		 lea	 eax, DWORD PTR _szValueName$7[ebp]
  001b9	50		 push	 eax
  001ba	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  001bf	8b f0		 mov	 esi, eax
  001c1	85 f6		 test	 esi, esi
  001c3	0f 88 c0 04 00
	00		 js	 $LN276@RegisterSu

; 1471 : 				break;
; 1472 : 			if (FAILED(hr = NextToken(szToken)))

  001c9	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001cf	57		 push	 edi
  001d0	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  001d5	8b f0		 mov	 esi, eax
  001d7	85 f6		 test	 esi, esi
  001d9	0f 88 aa 04 00
	00		 js	 $LN276@RegisterSu

; 1473 : 				break;
; 1474 : 
; 1475 : 			if (*szToken != chEquals)

  001df	6a 3d		 push	 61			; 0000003dH
  001e1	58		 pop	 eax
  001e2	66 39 07	 cmp	 WORD PTR [edi], ax
  001e5	0f 85 99 04 00
	00		 jne	 $LN239@RegisterSu

; 1476 : 				return GenerateError(E_ATL_EXPECTING_EQUAL);
; 1477 : 
; 1478 : 			if (bRegister)

  001eb	83 7d 10 00	 cmp	 DWORD PTR _bRegister$[ebp], 0
  001ef	74 57		 je	 SHORT $LN21@RegisterSu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5749 : 	m_hKey = hKey;

  001f1	8b 85 dc dd ff
	ff		 mov	 eax, DWORD PTR _hkParent$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1483 : 				hr = AddValue(rk, szValueName, szToken);

  001f7	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5749 : 	m_hKey = hKey;

  001fd	89 85 ac dd ff
	ff		 mov	 DWORD PTR _rk$3[ebp], eax

; 5750 : 	m_samWOW64 = 0;

  00203	33 c0		 xor	 eax, eax
  00205	89 85 b0 dd ff
	ff		 mov	 DWORD PTR _rk$3[ebp+4], eax

; 5751 : 	m_pTM = NULL;

  0020b	89 85 b4 dd ff
	ff		 mov	 DWORD PTR _rk$3[ebp+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1483 : 				hr = AddValue(rk, szValueName, szToken);

  00211	8d 85 f4 dd ff
	ff		 lea	 eax, DWORD PTR _szValueName$7[ebp]
  00217	57		 push	 edi
  00218	50		 push	 eax
  00219	8d 85 ac dd ff
	ff		 lea	 eax, DWORD PTR _rk$3[ebp]
  0021f	50		 push	 eax
  00220	e8 00 00 00 00	 call	 ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PB_WPA_W@Z ; ATL::CRegParser::AddValue
  00225	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5740 : 	m_hKey = NULL;

  00227	33 c0		 xor	 eax, eax
  00229	89 85 ac dd ff
	ff		 mov	 DWORD PTR _rk$3[ebp], eax

; 5741 : 	m_samWOW64 = 0;
; 5742 : 	m_pTM = NULL;

  0022f	89 85 b4 dd ff
	ff		 mov	 DWORD PTR _rk$3[ebp+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1486 : 				if (FAILED(hr))

  00235	85 f6		 test	 esi, esi
  00237	0f 88 4c 04 00
	00		 js	 $LN276@RegisterSu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5809 : 	m_samWOW64 = 0;

  0023d	89 85 b0 dd ff
	ff		 mov	 DWORD PTR _rk$3[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1489 : 				goto EndCheck;

  00243	e9 ac 01 00 00	 jmp	 $LN253@RegisterSu
$LN21@RegisterSu:

; 1490 : 			}
; 1491 : 			else
; 1492 : 			{
; 1493 : 				if (!bRecover && bDelete)

  00248	83 7d 14 00	 cmp	 DWORD PTR _bRecover$[ebp], 0
  0024c	75 74		 jne	 SHORT $LN25@RegisterSu
  0024e	83 bd e0 dd ff
	ff 00		 cmp	 DWORD PTR _bDelete$1$[ebp], 0
  00255	74 6b		 je	 SHORT $LN25@RegisterSu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  00257	33 f6		 xor	 esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1498 : 					lRes = rkParent.Open(hkParent, NULL, KEY_WRITE);

  00259	8d 8d b8 dd ff
	ff		 lea	 ecx, DWORD PTR _rkParent$4[ebp]
  0025f	68 06 00 02 00	 push	 131078			; 00020006H
  00264	56		 push	 esi
  00265	ff b5 dc dd ff
	ff		 push	 DWORD PTR _hkParent$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  0026b	89 b5 b8 dd ff
	ff		 mov	 DWORD PTR _rkParent$4[ebp], esi
  00271	89 b5 bc dd ff
	ff		 mov	 DWORD PTR _rkParent$4[ebp+4], esi
  00277	89 b5 c0 dd ff
	ff		 mov	 DWORD PTR _rkParent$4[ebp+8], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1498 : 					lRes = rkParent.Open(hkParent, NULL, KEY_WRITE);

  0027d	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z ; ATL::CRegKey::Open

; 1499 : 					if (lRes == ERROR_SUCCESS)

  00282	85 c0		 test	 eax, eax
  00284	0f 85 e0 03 00
	00		 jne	 $LN26@RegisterSu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5798 : 	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);

  0028a	8b 9d b8 dd ff
	ff		 mov	 ebx, DWORD PTR _rkParent$4[ebp]
  00290	8d 85 f4 dd ff
	ff		 lea	 eax, DWORD PTR _szValueName$7[ebp]
  00296	50		 push	 eax
  00297	53		 push	 ebx
  00298	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteValueW@8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1502 : 						if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)

  0029e	85 c0		 test	 eax, eax
  002a0	74 09		 je	 SHORT $LN28@RegisterSu
  002a2	83 f8 02	 cmp	 eax, 2
  002a5	0f 85 a9 03 00
	00		 jne	 $LN237@RegisterSu
$LN28@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5804 : 	if (m_hKey != NULL)

  002ab	85 db		 test	 ebx, ebx
  002ad	74 0d		 je	 SHORT $LN168@RegisterSu

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  002af	53		 push	 ebx
  002b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 5807 : 		m_hKey = NULL;

  002b6	89 b5 b8 dd ff
	ff		 mov	 DWORD PTR _rkParent$4[ebp], esi
$LN168@RegisterSu:

; 5809 : 	m_samWOW64 = 0;

  002bc	89 b5 bc dd ff
	ff		 mov	 DWORD PTR _rkParent$4[ebp+4], esi
$LN25@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1515 : 				if (FAILED(hr = SkipAssignment(szToken)))

  002c2	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  002c8	57		 push	 edi
  002c9	e8 00 00 00 00	 call	 ?SkipAssignment@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::SkipAssignment
$LN289@RegisterSu:

; 1422 : 		return hr;
; 1423 : 
; 1424 : 	while (*szToken != chRightBracket) // Continue till we see a }

  002ce	8b 9d e4 dd ff
	ff		 mov	 ebx, DWORD PTR _keyCur$[ebp]
  002d4	8b f0		 mov	 esi, eax
  002d6	85 f6		 test	 esi, esi
  002d8	0f 88 b1 03 00
	00		 js	 $LN211@RegisterSu
  002de	e9 73 02 00 00	 jmp	 $LN59@RegisterSu
$LN22@RegisterSu:

; 1516 : 					break;
; 1517 : 				continue;  // can never have a subkey
; 1518 : 			}
; 1519 : 		}
; 1520 : 
; 1521 : 		if (StrChr(szToken, chDirSep) != NULL)

  002e3	6a 5c		 push	 92			; 0000005cH
  002e5	57		 push	 edi
  002e6	e8 00 00 00 00	 call	 ?StrChrW@CRegParser@ATL@@KAPA_WPA_W_W@Z ; ATL::CRegParser::StrChrW
  002eb	59		 pop	 ecx
  002ec	59		 pop	 ecx
  002ed	85 c0		 test	 eax, eax
  002ef	0f 85 8f 03 00
	00		 jne	 $LN239@RegisterSu

; 1522 : 			return GenerateError(E_ATL_COMPOUND_KEY);
; 1523 : 
; 1524 : 		if (bRegister)

  002f5	39 45 10	 cmp	 DWORD PTR _bRegister$[ebp], eax
  002f8	0f 84 4f 01 00
	00		 je	 $LN31@RegisterSu

; 1525 : 		{
; 1526 : 			lRes = keyCur.Open(hkParent, szToken, KEY_READ | KEY_WRITE);

  002fe	8b 9d dc dd ff
	ff		 mov	 ebx, DWORD PTR _hkParent$GSCopy$1$[ebp]
  00304	8d 8d e4 dd ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  0030a	68 1f 00 02 00	 push	 131103			; 0002001fH
  0030f	57		 push	 edi
  00310	53		 push	 ebx
  00311	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z ; ATL::CRegKey::Open

; 1527 : 			if (ERROR_SUCCESS != lRes)

  00316	85 c0		 test	 eax, eax
  00318	0f 84 8c 00 00
	00		 je	 $LN257@RegisterSu

; 1528 : 			{
; 1529 : 				// Failed all access try read only
; 1530 : 				lRes = keyCur.Open(hkParent, szToken, KEY_READ);

  0031e	68 19 00 02 00	 push	 131097			; 00020019H
  00323	57		 push	 edi
  00324	53		 push	 ebx
  00325	8d 8d e4 dd ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  0032b	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z ; ATL::CRegKey::Open

; 1531 : 				if (ERROR_SUCCESS != lRes)

  00330	85 c0		 test	 eax, eax
  00332	74 76		 je	 SHORT $LN257@RegisterSu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5861 : 	LONG lRes = m_pTM != NULL ?

  00334	8b 8d ec dd ff
	ff		 mov	 ecx, DWORD PTR _keyCur$[ebp+8]
  0033a	8d 85 a8 dd ff
	ff		 lea	 eax, DWORD PTR _dw$2[ebp]
  00340	50		 push	 eax
  00341	33 f6		 xor	 esi, esi
  00343	8d 85 e0 dd ff
	ff		 lea	 eax, DWORD PTR _hKey$6[ebp]
  00349	89 b5 e0 dd ff
	ff		 mov	 DWORD PTR _hKey$6[ebp], esi
  0034f	50		 push	 eax
  00350	56		 push	 esi
  00351	68 1f 00 02 00	 push	 131103			; 0002001fH
  00356	56		 push	 esi
  00357	56		 push	 esi
  00358	56		 push	 esi
  00359	57		 push	 edi
  0035a	53		 push	 ebx
  0035b	85 c9		 test	 ecx, ecx
  0035d	74 07		 je	 SHORT $LN179@RegisterSu
  0035f	e8 00 00 00 00	 call	 ?RegCreateKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKPA_WKKQAU_SECURITY_ATTRIBUTES@@PAPAU3@PAK@Z ; ATL::CAtlTransactionManager::RegCreateKeyExW
  00364	eb 06		 jmp	 SHORT $LN180@RegisterSu
$LN179@RegisterSu:
  00366	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCreateKeyExW@36
$LN180@RegisterSu:

; 5862 : 		m_pTM->RegCreateKeyEx(hKeyParent, lpszKeyName, 0, lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw) :
; 5863 : 		RegCreateKeyEx(hKeyParent, lpszKeyName, 0, lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
; 5864 : 	if (lRes == ERROR_SUCCESS)

  0036c	85 c0		 test	 eax, eax
  0036e	75 2c		 jne	 SHORT $LN49@RegisterSu

; 5803 : 	LONG lRes = ERROR_SUCCESS;

  00370	8b c6		 mov	 eax, esi

; 5804 : 	if (m_hKey != NULL)

  00372	39 85 e4 dd ff
	ff		 cmp	 DWORD PTR _keyCur$[ebp], eax
  00378	74 0c		 je	 SHORT $LN182@RegisterSu

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  0037a	ff b5 e4 dd ff
	ff		 push	 DWORD PTR _keyCur$[ebp]
  00380	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN182@RegisterSu:

; 5870 : 		m_hKey = hKey;

  00386	8b 9d e0 dd ff
	ff		 mov	 ebx, DWORD PTR _hKey$6[ebp]
  0038c	89 9d e4 dd ff
	ff		 mov	 DWORD PTR _keyCur$[ebp], ebx

; 5871 : #if WINVER >= 0x0501
; 5872 : 		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);

  00392	89 b5 e8 dd ff
	ff		 mov	 DWORD PTR _keyCur$[ebp+4], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1536 : 					if (lRes != ERROR_SUCCESS)

  00398	85 c0		 test	 eax, eax
  0039a	74 14		 je	 SHORT $LN35@RegisterSu
$LN49@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5804 : 	if (m_hKey != NULL)

  0039c	50		 push	 eax
  0039d	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  003a2	59		 pop	 ecx
  003a3	8b f0		 mov	 esi, eax
  003a5	e9 df 02 00 00	 jmp	 $LN276@RegisterSu
$LN257@RegisterSu:
  003aa	8b 9d e4 dd ff
	ff		 mov	 ebx, DWORD PTR _keyCur$[ebp]
$LN35@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1541 : 			if (FAILED(hr = NextToken(szToken)))

  003b0	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  003b6	57		 push	 edi
  003b7	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  003bc	8b f0		 mov	 esi, eax
  003be	85 f6		 test	 esi, esi
  003c0	0f 88 c3 02 00
	00		 js	 $LN276@RegisterSu

; 1542 : 				break;
; 1543 : 
; 1544 : 
; 1545 : 			if (*szToken == chEquals)

  003c6	6a 3d		 push	 61			; 0000003dH
  003c8	58		 pop	 eax
  003c9	66 39 07	 cmp	 WORD PTR [edi], ax
  003cc	75 26		 jne	 SHORT $LN253@RegisterSu

; 1546 : 			{
; 1547 : 				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default

  003ce	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  003d4	33 c0		 xor	 eax, eax
  003d6	57		 push	 edi
  003d7	50		 push	 eax
  003d8	8d 85 e4 dd ff
	ff		 lea	 eax, DWORD PTR _keyCur$[ebp]
  003de	50		 push	 eax
  003df	e8 00 00 00 00	 call	 ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PB_WPA_W@Z ; ATL::CRegParser::AddValue
  003e4	8b 9d e4 dd ff
	ff		 mov	 ebx, DWORD PTR _keyCur$[ebp]
  003ea	8b f0		 mov	 esi, eax
  003ec	85 f6		 test	 esi, esi
  003ee	0f 88 9b 02 00
	00		 js	 $LN211@RegisterSu
$LN253@RegisterSu:
$EndCheck$291:

; 1641 : 				{
; 1642 : 
; 1643 : 					hr = AtlHresultFromWin32(lRes);
; 1644 : 					break;
; 1645 : 				}
; 1646 : 			}
; 1647 : 		}
; 1648 : 
; 1649 : EndCheck:
; 1650 : 
; 1651 : 		if (bRegister)
; 1652 : 		{
; 1653 : 			if (*szToken == chLeftBracket && _tcslen(szToken) == 1)

  003f4	6a 7b		 push	 123			; 0000007bH
  003f6	58		 pop	 eax
  003f7	66 39 07	 cmp	 WORD PTR [edi], ax
  003fa	0f 85 50 01 00
	00		 jne	 $LN281@RegisterSu
  00400	8b cf		 mov	 ecx, edi
  00402	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL255@RegisterSu:
  00405	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00408	83 c1 02	 add	 ecx, 2
  0040b	66 3b 85 d4 dd
	ff ff		 cmp	 ax, WORD PTR tv724[ebp]
  00412	75 f1		 jne	 SHORT $LL255@RegisterSu
  00414	2b ca		 sub	 ecx, edx
  00416	d1 f9		 sar	 ecx, 1
  00418	83 f9 01	 cmp	 ecx, 1
  0041b	0f 85 2f 01 00
	00		 jne	 $LN281@RegisterSu

; 1654 : 			{
; 1655 : 				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))

  00421	33 c0		 xor	 eax, eax
  00423	50		 push	 eax
  00424	ff 75 10	 push	 DWORD PTR _bRegister$[ebp]
  00427	53		 push	 ebx
  00428	8b 9d f0 dd ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  0042e	8b cb		 mov	 ecx, ebx
  00430	57		 push	 edi
  00431	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPA_WPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  00436	8b f0		 mov	 esi, eax
  00438	85 f6		 test	 esi, esi
  0043a	0f 88 49 02 00
	00		 js	 $LN276@RegisterSu

; 1656 : 					break;
; 1657 : 				if (FAILED(hr = NextToken(szToken)))

  00440	57		 push	 edi
  00441	8b cb		 mov	 ecx, ebx
  00443	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  00448	e9 81 fe ff ff	 jmp	 $LN289@RegisterSu
$LN31@RegisterSu:

; 1548 : 					break;
; 1549 : 			}
; 1550 : 		}
; 1551 : 		else //Unregister
; 1552 : 		{
; 1553 : 			if (!bRecover)

  0044d	83 7d 14 00	 cmp	 DWORD PTR _bRecover$[ebp], 0
  00451	75 1f		 jne	 SHORT $LN39@RegisterSu

; 1554 : 			{
; 1555 :  				lRes = keyCur.Open(hkParent, szToken, KEY_READ);

  00453	68 19 00 02 00	 push	 131097			; 00020019H
  00458	57		 push	 edi
  00459	ff b5 dc dd ff
	ff		 push	 DWORD PTR _hkParent$GSCopy$1$[ebp]
  0045f	8d 8d e4 dd ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  00465	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z ; ATL::CRegKey::Open

; 1556 : 
; 1557 : 			}

  0046a	8b 9d e4 dd ff
	ff		 mov	 ebx, DWORD PTR _keyCur$[ebp]
  00470	eb 03		 jmp	 SHORT $LN286@RegisterSu
$LN39@RegisterSu:

; 1558 : 			else
; 1559 : 				lRes = ERROR_FILE_NOT_FOUND;

  00472	6a 02		 push	 2
  00474	58		 pop	 eax
$LN286@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 138  : 	return ATLMFC_CRT_ERRORCHECK(::_tcsncpy_s(_Dest, _SizeInChars, _Source,_Count));

  00475	33 c9		 xor	 ecx, ecx
  00477	89 85 d8 dd ff
	ff		 mov	 DWORD PTR _lRes$2$[ebp], eax
  0047d	6a ff		 push	 -1
  0047f	41		 inc	 ecx
  00480	85 c0		 test	 eax, eax
  00482	57		 push	 edi
  00483	0f 44 4d 14	 cmove	 ecx, DWORD PTR _bRecover$[ebp]
  00487	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0048d	68 04 01 00 00	 push	 260			; 00000104H
  00492	50		 push	 eax
  00493	89 8d d0 dd ff
	ff		 mov	 DWORD PTR tv700[ebp], ecx
  00499	e8 00 00 00 00	 call	 _wcsncpy_s
  0049e	50		 push	 eax
  0049f	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1577 : 			if (FAILED(hr = NextToken(szToken)))

  004a4	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 138  : 	return ATLMFC_CRT_ERRORCHECK(::_tcsncpy_s(_Dest, _SizeInChars, _Source,_Count));

  004aa	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1577 : 			if (FAILED(hr = NextToken(szToken)))

  004ad	57		 push	 edi
  004ae	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  004b3	8b f0		 mov	 esi, eax
  004b5	85 f6		 test	 esi, esi
  004b7	0f 88 cc 01 00
	00		 js	 $LN276@RegisterSu

; 1578 : 				break;
; 1579 : 			if (FAILED(hr = SkipAssignment(szToken)))

  004bd	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  004c3	57		 push	 edi
  004c4	e8 00 00 00 00	 call	 ?SkipAssignment@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::SkipAssignment
  004c9	8b f0		 mov	 esi, eax
  004cb	85 f6		 test	 esi, esi
  004cd	0f 88 b6 01 00
	00		 js	 $LN276@RegisterSu

; 1580 : 				break;
; 1581 : 
; 1582 : 			if (*szToken == chLeftBracket && _tcslen(szToken) == 1)

  004d3	6a 7b		 push	 123			; 0000007bH
  004d5	58		 pop	 eax
  004d6	66 39 07	 cmp	 WORD PTR [edi], ax
  004d9	75 5c		 jne	 SHORT $LN46@RegisterSu
  004db	8b cf		 mov	 ecx, edi
  004dd	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL256@RegisterSu:
  004e0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  004e3	83 c1 02	 add	 ecx, 2
  004e6	66 3b 85 d4 dd
	ff ff		 cmp	 ax, WORD PTR tv724[ebp]
  004ed	75 f1		 jne	 SHORT $LL256@RegisterSu
  004ef	2b ca		 sub	 ecx, edx
  004f1	d1 f9		 sar	 ecx, 1
  004f3	83 f9 01	 cmp	 ecx, 1
  004f6	75 3f		 jne	 SHORT $LN46@RegisterSu

; 1583 : 			{
; 1584 : 				hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover);

  004f8	ff b5 d0 dd ff
	ff		 push	 DWORD PTR tv700[ebp]
  004fe	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00504	33 c0		 xor	 eax, eax
  00506	50		 push	 eax
  00507	53		 push	 ebx
  00508	57		 push	 edi
  00509	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPA_WPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  0050e	8b f0		 mov	 esi, eax

; 1585 : 				// In recover mode ignore error
; 1586 : 				if (FAILED(hr) && !bRecover)

  00510	85 f6		 test	 esi, esi
  00512	79 0d		 jns	 SHORT $LN45@RegisterSu
  00514	83 bd d0 dd ff
	ff 00		 cmp	 DWORD PTR tv700[ebp], 0
  0051b	0f 84 68 01 00
	00		 je	 $LN276@RegisterSu
$LN45@RegisterSu:

; 1587 : 					break;
; 1588 : 				// Skip the }
; 1589 : 				if (FAILED(hr = NextToken(szToken)))

  00521	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00527	57		 push	 edi
  00528	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  0052d	8b f0		 mov	 esi, eax
  0052f	85 f6		 test	 esi, esi
  00531	0f 88 52 01 00
	00		 js	 $LN276@RegisterSu
$LN46@RegisterSu:

; 1590 : 					break;
; 1591 : 			}
; 1592 : 
; 1593 : #ifdef _DEBUG
; 1594 : 			if (bRecover != bInRecovery)
; 1595 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));
; 1596 : #endif
; 1597 : 			bRecover = bInRecovery;
; 1598 : 
; 1599 : 			if (lRes == ERROR_FILE_NOT_FOUND)

  00537	8b 85 d8 dd ff
	ff		 mov	 eax, DWORD PTR _lRes$2$[ebp]
  0053d	83 f8 02	 cmp	 eax, 2
  00540	74 0e		 je	 SHORT $LN281@RegisterSu

; 1600 : 				// Key already not present so not an error.
; 1601 : 				continue;
; 1602 : 
; 1603 : 			if (lRes != ERROR_SUCCESS)

  00542	85 c0		 test	 eax, eax
  00544	74 27		 je	 SHORT $LN50@RegisterSu

; 1604 : 			{
; 1605 : 				// We are recovery mode continue on errors else break
; 1606 : 				if (bRecover)

  00546	83 7d 14 00	 cmp	 DWORD PTR _bRecover$[ebp], 0
  0054a	0f 84 4c fe ff
	ff		 je	 $LN49@RegisterSu
$LN281@RegisterSu:

; 1422 : 		return hr;
; 1423 : 
; 1424 : 	while (*szToken != chRightBracket) // Continue till we see a }

  00550	8b 9d e4 dd ff
	ff		 mov	 ebx, DWORD PTR _keyCur$[ebp]
$LN59@RegisterSu:
  00556	6a 7d		 push	 125			; 0000007dH
  00558	58		 pop	 eax
  00559	66 39 07	 cmp	 WORD PTR [edi], ax
  0055c	0f 84 2d 01 00
	00		 je	 $LN211@RegisterSu
  00562	8b 9d e4 dd ff
	ff		 mov	 ebx, DWORD PTR _keyCur$[ebp]
  00568	e9 fb fa ff ff	 jmp	 $LL2@RegisterSu
$LN50@RegisterSu:

; 1607 : 					continue;
; 1608 : 				else
; 1609 : 				{
; 1610 : 					hr = AtlHresultFromWin32(lRes);
; 1611 : 					break;
; 1612 : 				}
; 1613 : 			}
; 1614 : 
; 1615 : 			// If in recovery mode
; 1616 : 			if (bRecover && HasSubKeys(keyCur))

  0056d	83 7d 14 00	 cmp	 DWORD PTR _bRecover$[ebp], 0
  00571	74 43		 je	 SHORT $LN51@RegisterSu
  00573	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00579	53		 push	 ebx
  0057a	e8 00 00 00 00	 call	 ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ; ATL::CRegParser::HasSubKeys
  0057f	85 c0		 test	 eax, eax
  00581	74 33		 je	 SHORT $LN51@RegisterSu

; 1617 : 			{
; 1618 : 				// See if the KEY is in the NeverDelete list and if so, don't
; 1619 : 				if (CanForceRemoveKey(szKey) && bDelete)

  00583	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00589	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  0058f	50		 push	 eax
  00590	e8 00 00 00 00	 call	 ?CanForceRemoveKey@CRegParser@ATL@@IAEHPB_W@Z ; ATL::CRegParser::CanForceRemoveKey
  00595	85 c0		 test	 eax, eax
  00597	74 b7		 je	 SHORT $LN281@RegisterSu
  00599	83 bd e0 dd ff
	ff 00		 cmp	 DWORD PTR _bDelete$1$[ebp], 0
  005a0	74 ae		 je	 SHORT $LN281@RegisterSu

; 1620 : 				{
; 1621 : 					ATLTRACE(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %Ts by force\n"), szKey);
; 1622 : 					// Error not returned since we are in recovery mode. The error that caused recovery mode is returned
; 1623 : 					keyCur.RecurseDeleteKey(szKey);

  005a2	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  005a8	50		 push	 eax
  005a9	8d 8d e4 dd ff
	ff		 lea	 ecx, DWORD PTR _keyCur$[ebp]
  005af	e8 00 00 00 00	 call	 ?RecurseDeleteKey@CRegKey@ATL@@QAEJPB_W@Z ; ATL::CRegKey::RecurseDeleteKey

; 1624 : 				}
; 1625 : 				continue;

  005b4	eb 9a		 jmp	 SHORT $LN281@RegisterSu
$LN51@RegisterSu:

; 1628 : 			BOOL bHasSubKeys=HasSubKeys(keyCur);

  005b6	8b 8d f0 dd ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  005bc	53		 push	 ebx
  005bd	e8 00 00 00 00	 call	 ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ; ATL::CRegParser::HasSubKeys
  005c2	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5803 : 	LONG lRes = ERROR_SUCCESS;

  005c4	33 d2		 xor	 edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1628 : 			BOOL bHasSubKeys=HasSubKeys(keyCur);

  005c6	89 8d d8 dd ff
	ff		 mov	 DWORD PTR _bHasSubKeys$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5803 : 	LONG lRes = ERROR_SUCCESS;

  005cc	8b c2		 mov	 eax, edx

; 5804 : 	if (m_hKey != NULL)

  005ce	85 db		 test	 ebx, ebx
  005d0	74 19		 je	 SHORT $LN282@RegisterSu

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  005d2	53		 push	 ebx
  005d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  005d9	8b 8d d8 dd ff
	ff		 mov	 ecx, DWORD PTR _bHasSubKeys$1$[ebp]

; 5807 : 		m_hKey = NULL;

  005df	33 d2		 xor	 edx, edx
  005e1	8b da		 mov	 ebx, edx
  005e3	89 9d e4 dd ff
	ff		 mov	 DWORD PTR _keyCur$[ebp], ebx
  005e9	eb 06		 jmp	 SHORT $LN192@RegisterSu
$LN282@RegisterSu:

; 5804 : 	if (m_hKey != NULL)

  005eb	8b 9d e4 dd ff
	ff		 mov	 ebx, DWORD PTR _keyCur$[ebp]
$LN192@RegisterSu:

; 5809 : 	m_samWOW64 = 0;

  005f1	89 95 e8 dd ff
	ff		 mov	 DWORD PTR _keyCur$[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1630 : 			if (lRes != ERROR_SUCCESS)

  005f7	85 c0		 test	 eax, eax
  005f9	75 4e		 jne	 SHORT $LN248@RegisterSu

; 1631 : 			return AtlHresultFromWin32(lRes);
; 1632 : 
; 1633 : 			if (bDelete&& !bHasSubKeys)

  005fb	39 85 e0 dd ff
	ff		 cmp	 DWORD PTR _bDelete$1$[ebp], eax
  00601	0f 84 4f ff ff
	ff		 je	 $LN59@RegisterSu
  00607	85 c9		 test	 ecx, ecx
  00609	0f 85 47 ff ff
	ff		 jne	 $LN59@RegisterSu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5749 : 	m_hKey = hKey;

  0060f	8b 85 dc dd ff
	ff		 mov	 eax, DWORD PTR _hkParent$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1638 : 				lRes = rkParent.DeleteSubKey(szKey);

  00615	8d 8d 9c dd ff
	ff		 lea	 ecx, DWORD PTR _rkParent$1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5749 : 	m_hKey = hKey;

  0061b	89 85 9c dd ff
	ff		 mov	 DWORD PTR _rkParent$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1638 : 				lRes = rkParent.DeleteSubKey(szKey);

  00621	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szKey$[ebp]
  00627	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5750 : 	m_samWOW64 = 0;

  00628	89 95 a0 dd ff
	ff		 mov	 DWORD PTR _rkParent$1[ebp+4], edx

; 5751 : 	m_pTM = NULL;

  0062e	89 95 a4 dd ff
	ff		 mov	 DWORD PTR _rkParent$1[ebp+8], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1638 : 				lRes = rkParent.DeleteSubKey(szKey);

  00634	e8 00 00 00 00	 call	 ?DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z ; ATL::CRegKey::DeleteSubKey
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5740 : 	m_hKey = NULL;

  00639	33 c9		 xor	 ecx, ecx
  0063b	89 8d 9c dd ff
	ff		 mov	 DWORD PTR _rkParent$1[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1640 : 				if (lRes != ERROR_SUCCESS)

  00641	85 c0		 test	 eax, eax
  00643	0f 84 0d ff ff
	ff		 je	 $LN59@RegisterSu
$LN248@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5804 : 	if (m_hKey != NULL)

  00649	50		 push	 eax
  0064a	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  0064f	59		 pop	 ecx
  00650	8b f0		 mov	 esi, eax
  00652	eb 3b		 jmp	 SHORT $LN211@RegisterSu
$LN237@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1505 : 							hr = AtlHresultFromWin32(lRes);

  00654	50		 push	 eax
  00655	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  0065a	8b f0		 mov	 esi, eax
  0065c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5804 : 	if (m_hKey != NULL)

  0065d	85 db		 test	 ebx, ebx
  0065f	74 28		 je	 SHORT $LN276@RegisterSu

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  00661	53		 push	 ebx
$LN288@RegisterSu:

; 5804 : 	if (m_hKey != NULL)

  00662	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
  00668	eb 1f		 jmp	 SHORT $LN276@RegisterSu
$LN26@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1511 : 						hr = AtlHresultFromWin32(lRes);

  0066a	50		 push	 eax
  0066b	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5804 : 	if (m_hKey != NULL)

  00670	83 bd b8 dd ff
	ff 00		 cmp	 DWORD PTR _rkParent$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1511 : 						hr = AtlHresultFromWin32(lRes);

  00677	8b f0		 mov	 esi, eax
  00679	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5804 : 	if (m_hKey != NULL)

  0067a	74 0d		 je	 SHORT $LN276@RegisterSu

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  0067c	ff b5 b8 dd ff
	ff		 push	 DWORD PTR _rkParent$4[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1512 : 						break;

  00682	eb de		 jmp	 SHORT $LN288@RegisterSu
$LN239@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5804 : 	if (m_hKey != NULL)

  00684	be 09 00 02 80	 mov	 esi, -2147352567	; 80020009H
$LN276@RegisterSu:
  00689	8b 9d e4 dd ff
	ff		 mov	 ebx, DWORD PTR _keyCur$[ebp]
$LN211@RegisterSu:
  0068f	85 db		 test	 ebx, ebx
  00691	74 07		 je	 SHORT $LN221@RegisterSu

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  00693	53		 push	 ebx
  00694	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN221@RegisterSu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1664 : }

  0069a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0069d	8b c6		 mov	 eax, esi
  0069f	5f		 pop	 edi
  006a0	5e		 pop	 esi
  006a1	33 cd		 xor	 ecx, ebp
  006a3	5b		 pop	 ebx
  006a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006a9	c9		 leave
  006aa	c2 10 00	 ret	 16			; 00000010H
?RegisterSubkeys@CRegParser@ATL@@IAEJPA_WPAUHKEY__@@HH@Z ENDP ; ATL::CRegParser::RegisterSubkeys
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z
_TEXT	SEGMENT
_cSubKeys$ = -4						; size = 4
_hkey$ = 8						; size = 4
?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z PROC	; ATL::CRegParser::HasSubKeys, COMDAT
; _this$ = ecx

; 1112 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1113 : 	DWORD cSubKeys = 0;

  00004	33 c9		 xor	 ecx, ecx

; 1114 : 
; 1115 : 	if (RegQueryInfoKeyW(hkey, NULL, NULL, NULL,
; 1116 : 							   &cSubKeys, NULL, NULL,
; 1117 : 							   NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)

  00006	8d 45 fc	 lea	 eax, DWORD PTR _cSubKeys$[ebp]
  00009	51		 push	 ecx
  0000a	51		 push	 ecx
  0000b	51		 push	 ecx
  0000c	51		 push	 ecx
  0000d	51		 push	 ecx
  0000e	51		 push	 ecx
  0000f	51		 push	 ecx
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	51		 push	 ecx
  00014	ff 75 08	 push	 DWORD PTR _hkey$[ebp]
  00017	89 4d fc	 mov	 DWORD PTR _cSubKeys$[ebp], ecx
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryInfoKeyW@48
  00020	85 c0		 test	 eax, eax
  00022	74 04		 je	 SHORT $LN2@HasSubKeys

; 1118 : 	{
; 1119 : 		ATLTRACE(atlTraceRegistrar, 0, _T("Should not be here!!\n"));
; 1120 : 		ATLASSERT(FALSE);
; 1121 : 		return FALSE;

  00024	33 c0		 xor	 eax, eax
  00026	eb 09		 jmp	 SHORT $LN1@HasSubKeys
$LN2@HasSubKeys:

; 1122 : 	}
; 1123 : 
; 1124 : 	return cSubKeys > 0;

  00028	33 c0		 xor	 eax, eax
  0002a	3b 45 fc	 cmp	 eax, DWORD PTR _cSubKeys$[ebp]
  0002d	1b c0		 sbb	 eax, eax
  0002f	f7 d8		 neg	 eax
$LN1@HasSubKeys:

; 1125 : }

  00031	c9		 leave
  00032	c2 04 00	 ret	 4
?HasSubKeys@CRegParser@ATL@@IAEHPAUHKEY__@@@Z ENDP	; ATL::CRegParser::HasSubKeys
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?CanForceRemoveKey@CRegParser@ATL@@IAEHPB_W@Z
_TEXT	SEGMENT
_szKey$ = 8						; size = 4
?CanForceRemoveKey@CRegParser@ATL@@IAEHPB_W@Z PROC	; ATL::CRegParser::CanForceRemoveKey, COMDAT
; _this$ = ecx

; 1103 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1104 : 	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)

  00004	be 00 00 00 00	 mov	 esi, OFFSET ?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB ; ATL::CRegParser::rgszNeverDelete
$LL4@CanForceRe:

; 1105 : 		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	ff 75 08	 push	 DWORD PTR _szKey$[ebp]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiW@8
  00014	85 c0		 test	 eax, eax
  00016	74 10		 je	 SHORT $LN8@CanForceRe

; 1104 : 	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)

  00018	83 c6 04	 add	 esi, 4
  0001b	81 fe 30 00 00
	00		 cmp	 esi, OFFSET ?rgszNeverDelete@CRegParser@ATL@@1QBQB_WB+48
  00021	7c e6		 jl	 SHORT $LL4@CanForceRe

; 1107 : 
; 1108 : 	return TRUE;

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	eb 02		 jmp	 SHORT $LN1@CanForceRe
$LN8@CanForceRe:

; 1106 : 			 return FALSE;                       // We cannot delete it

  00028	33 c0		 xor	 eax, eax
$LN1@CanForceRe:
  0002a	5e		 pop	 esi

; 1109 : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?CanForceRemoveKey@CRegParser@ATL@@IAEHPB_W@Z ENDP	; ATL::CRegParser::CanForceRemoveKey
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PB_WPA_W@Z
_TEXT	SEGMENT
_szToken$GSCopy$1$ = -8480				; size = 4
_this$GSCopy$1$ = -8476					; size = 4
_cbValDiv2$1$ = -8472					; size = 4
_rkParent$GSCopy$1$ = -8468				; size = 4
_ulVal$1 = -8468					; size = 4
_szValueName$GSCopy$1$ = -8464				; size = 4
_dwValue$ = -8464					; size = 4
_irg$1$ = -8460						; size = 4
_vt$ = -8460						; size = 2
_rgBinary$2 = -8456					; size = 260
_pszDestValue$3 = -8456					; size = 260
_szValue$ = -8196					; size = 8192
__$ArrayPad$ = -4					; size = 4
_rkParent$ = 8						; size = 4
_szValueName$ = 12					; size = 4
_szToken$ = 16						; size = 4
?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PB_WPA_W@Z PROC ; ATL::CRegParser::AddValue, COMDAT
; _this$ = ecx

; 971  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 20 21 00 00	 mov	 eax, 8480		; 00002120H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 10	 mov	 eax, DWORD PTR _szToken$[ebp]
  0001a	53		 push	 ebx
  0001b	8b 5d 08	 mov	 ebx, DWORD PTR _rkParent$[ebp]
  0001e	89 85 e0 de ff
	ff		 mov	 DWORD PTR _szToken$GSCopy$1$[ebp], eax

; 972  : 	HRESULT hr;
; 973  : 
; 974  : 	TCHAR		szValue[MAX_VALUE];
; 975  : 	VARTYPE     vt = VT_EMPTY;

  00024	33 c0		 xor	 eax, eax
  00026	56		 push	 esi
  00027	8b 75 0c	 mov	 esi, DWORD PTR _szValueName$[ebp]
  0002a	57		 push	 edi
  0002b	89 85 f4 de ff
	ff		 mov	 DWORD PTR _vt$[ebp], eax
  00031	8b f9		 mov	 edi, ecx

; 976  : 	LONG        lRes = ERROR_SUCCESS;
; 977  : 	UINT        nIDRes = 0;
; 978  : 
; 979  : 	if (FAILED(hr = NextToken(szValue)))

  00033	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  00039	89 bd e4 de ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  0003f	50		 push	 eax
  00040	89 9d ec de ff
	ff		 mov	 DWORD PTR _rkParent$GSCopy$1$[ebp], ebx
  00046	89 b5 f0 de ff
	ff		 mov	 DWORD PTR _szValueName$GSCopy$1$[ebp], esi
  0004c	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  00051	85 c0		 test	 eax, eax
  00053	0f 88 b0 02 00
	00		 js	 $LN24@AddValue

; 980  : 		return hr;
; 981  : 	if (!VTFromRegType(szValue, vt))

  00059	8d 85 f4 de ff
	ff		 lea	 eax, DWORD PTR _vt$[ebp]
  0005f	50		 push	 eax
  00060	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?VTFromRegType@CRegParser@ATL@@KAHPB_WAAG@Z ; ATL::CRegParser::VTFromRegType
  0006c	59		 pop	 ecx
  0006d	59		 pop	 ecx
  0006e	85 c0		 test	 eax, eax
  00070	75 0a		 jne	 SHORT $LN10@AddValue

; 982  : 	{
; 983  : 		ATLTRACE(atlTraceRegistrar, 0, _T("%Ts Type not supported\n"), szValue);
; 984  : 		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);

  00072	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
  00077	e9 8d 02 00 00	 jmp	 $LN24@AddValue
$LN10@AddValue:

; 985  : 	}
; 986  : 
; 987  : 	SkipWhiteSpace();

  0007c	8b cf		 mov	 ecx, edi
  0007e	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace

; 988  : 	if (FAILED(hr = NextToken(szValue)))

  00083	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  00089	8b cf		 mov	 ecx, edi
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  00091	85 c0		 test	 eax, eax
  00093	0f 88 70 02 00
	00		 js	 $LN24@AddValue

; 989  : 		return hr;
; 990  : 
; 991  : 	switch (vt)

  00099	0f b7 85 f4 de
	ff ff		 movzx	 eax, WORD PTR _vt$[ebp]
  000a0	83 e8 08	 sub	 eax, 8
  000a3	0f 84 24 02 00
	00		 je	 $LN12@AddValue
  000a9	83 e8 09	 sub	 eax, 9
  000ac	0f 84 1f 01 00
	00		 je	 $LN52@AddValue
  000b2	48		 dec	 eax
  000b3	83 e8 01	 sub	 eax, 1
  000b6	0f 84 cf 00 00
	00		 je	 $LN18@AddValue
  000bc	2d f5 3f 00 00	 sub	 eax, 16373		; 00003ff5H
  000c1	0f 85 2c 02 00
	00		 jne	 $LN23@AddValue

; 1002 : 			int nLen = static_cast<int>(_tcslen(szValue) + 2); //Allocate space for double null termination.

  000c7	8d 8d fc df ff
	ff		 lea	 ecx, DWORD PTR _szValue$[ebp]
  000cd	33 f6		 xor	 esi, esi
  000cf	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL83@AddValue:
  000d2	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000d5	83 c1 02	 add	 ecx, 2
  000d8	66 3b c6	 cmp	 ax, si
  000db	75 f5		 jne	 SHORT $LL83@AddValue
  000dd	2b ca		 sub	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h

; 481  : 		m_p( NULL )

  000df	89 b5 f8 de ff
	ff		 mov	 DWORD PTR _pszDestValue$3[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1002 : 			int nLen = static_cast<int>(_tcslen(szValue) + 2); //Allocate space for double null termination.

  000e5	d1 f9		 sar	 ecx, 1
  000e7	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]

; 1003 : 			CTempBuffer<TCHAR, 256> pszDestValue;
; 1004 : 			//nLen should be >= the max size of the target buffer.
; 1005 : 			ATLTRY(pszDestValue.Allocate(nLen));

  000ea	50		 push	 eax
  000eb	8d 8d f8 de ff
	ff		 lea	 ecx, DWORD PTR _pszDestValue$3[ebp]
  000f1	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPA_WI@Z ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::Allocate

; 1006 : 			if (pszDestValue != NULL)

  000f6	8b b5 f8 de ff
	ff		 mov	 esi, DWORD PTR _pszDestValue$3[ebp]
  000fc	85 f6		 test	 esi, esi
  000fe	74 6a		 je	 SHORT $LN14@AddValue

; 1007 : 			{
; 1008 : 				TCHAR* p = pszDestValue;
; 1009 : 				TCHAR* q = szValue;
; 1010 : 				nLen = 0;
; 1011 : 				while (*q != _T('\0'))

  00100	66 83 bd fc df
	ff ff 00	 cmp	 WORD PTR _szValue$[ebp], 0
  00108	8d bd fc df ff
	ff		 lea	 edi, DWORD PTR _szValue$[ebp]
  0010e	74 39		 je	 SHORT $LN5@AddValue
  00110	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__CharNextW@4
$LL4@AddValue:

; 1012 : 				{
; 1013 : 					TCHAR* r = CharNext(q);

  00116	57		 push	 edi
  00117	ff d3		 call	 ebx

; 1014 : 					if (*q == _T('\\') && *r == _T('0'))

  00119	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  0011c	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  0011f	75 12		 jne	 SHORT $LN16@AddValue
  00121	66 83 38 30	 cmp	 WORD PTR [eax], 48	; 00000030H
  00125	75 0c		 jne	 SHORT $LN16@AddValue

; 1015 : 					{
; 1016 : 						*p++ = _T('\0');

  00127	33 c9		 xor	 ecx, ecx

; 1017 : 						q = CharNext(r);

  00129	50		 push	 eax
  0012a	66 89 0e	 mov	 WORD PTR [esi], cx
  0012d	ff d3		 call	 ebx
  0012f	8b f8		 mov	 edi, eax

; 1018 : 					}

  00131	eb 06		 jmp	 SHORT $LN17@AddValue
$LN16@AddValue:

; 1019 : 					else
; 1020 : 					{
; 1021 : 						*p = *q;

  00133	66 89 0e	 mov	 WORD PTR [esi], cx

; 1022 : #ifndef _UNICODE
; 1023 : 						if (IsDBCSLeadByte(*q))
; 1024 : 						{
; 1025 : 							p++;
; 1026 : 							q++;
; 1027 : 							//Protect from Lead byte followed by the zero terminator.May skip beyond the end of the string.
; 1028 : 							if (*q == _T('\0')) { break; }
; 1029 : 							*p = *q;
; 1030 : 						}
; 1031 : #endif
; 1032 : 						p++;
; 1033 : 						q++;

  00136	83 c7 02	 add	 edi, 2
$LN17@AddValue:

; 1007 : 			{
; 1008 : 				TCHAR* p = pszDestValue;
; 1009 : 				TCHAR* q = szValue;
; 1010 : 				nLen = 0;
; 1011 : 				while (*q != _T('\0'))

  00139	33 c0		 xor	 eax, eax
  0013b	83 c6 02	 add	 esi, 2
  0013e	66 39 07	 cmp	 WORD PTR [edi], ax
  00141	75 d3		 jne	 SHORT $LL4@AddValue
  00143	8b 9d ec de ff
	ff		 mov	 ebx, DWORD PTR _rkParent$GSCopy$1$[ebp]
$LN5@AddValue:

; 1034 : 					}
; 1035 : 					nLen ++;
; 1036 : 				}
; 1037 : 			   //Always terminate with 2 null characters.
; 1038 : 				*p = _T('\0');

  00149	33 c0		 xor	 eax, eax

; 1039 : 				p++;
; 1040 : 			    *p = _T('\0');
; 1041 : 				lRes = rkParent.SetMultiStringValue(szValueName, pszDestValue);

  0014b	8b cb		 mov	 ecx, ebx
  0014d	89 06		 mov	 DWORD PTR [esi], eax
  0014f	ff b5 f8 de ff
	ff		 push	 DWORD PTR _pszDestValue$3[ebp]
  00155	ff b5 f0 de ff
	ff		 push	 DWORD PTR _szValueName$GSCopy$1$[ebp]
  0015b	e8 00 00 00 00	 call	 ?SetMultiStringValue@CRegKey@ATL@@QAEJPB_W0@Z ; ATL::CRegKey::SetMultiStringValue

; 1042 : 			}

  00160	8b b5 f8 de ff
	ff		 mov	 esi, DWORD PTR _pszDestValue$3[ebp]
  00166	8b f8		 mov	 edi, eax
  00168	eb 03		 jmp	 SHORT $LN15@AddValue
$LN14@AddValue:

; 1043 : 			else
; 1044 : 			{
; 1045 : 				lRes = ERROR_OUTOFMEMORY;

  0016a	6a 0e		 push	 14			; 0000000eH
  0016c	5f		 pop	 edi
$LN15@AddValue:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h

; 493  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  0016d	8d 85 fc de ff
	ff		 lea	 eax, DWORD PTR _pszDestValue$3[ebp+4]
  00173	3b f0		 cmp	 esi, eax
  00175	0f 84 65 01 00
	00		 je	 $LN65@AddValue

; 495  : 			FreeHeap();

  0017b	8d 8d f8 de ff
	ff		 lea	 ecx, DWORD PTR _pszDestValue$3[ebp]
  00181	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@_W$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<wchar_t,256,ATL::CCRTAllocator>::FreeHeap
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1048 : 		break;

  00186	e9 55 01 00 00	 jmp	 $LN65@AddValue
$LN18@AddValue:

; 1049 : 	case VT_UI4:
; 1050 : 		{
; 1051 : 			ULONG ulVal;
; 1052 : 			USES_CONVERSION_EX;
; 1053 : 
; 1054 : 			LPOLESTR lpszV = T2OLE_EX(szValue, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 1055 : 	#ifndef _UNICODE
; 1056 : 			if(lpszV == NULL)
; 1057 : 				return E_OUTOFMEMORY;
; 1058 : 	#endif
; 1059 : 
; 1060 : 			hr = VarUI4FromStr(lpszV, 0, 0, &ulVal);

  0018b	8d 85 ec de ff
	ff		 lea	 eax, DWORD PTR _ulVal$1[ebp]
  00191	33 ff		 xor	 edi, edi
  00193	50		 push	 eax
  00194	57		 push	 edi
  00195	57		 push	 edi
  00196	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  0019c	50		 push	 eax
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VarUI4FromStr@16

; 1061 :             if (FAILED(hr))

  001a3	85 c0		 test	 eax, eax
  001a5	0f 88 5e 01 00
	00		 js	 $LN24@AddValue

; 1064 : 			lRes = rkParent.SetDWORDValue(szValueName, ulVal);

  001ab	8b 85 ec de ff
	ff		 mov	 eax, DWORD PTR _ulVal$1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 6247 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_DWORD, reinterpret_cast<const BYTE*>(&dwValue), sizeof(DWORD));

  001b1	6a 04		 push	 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1064 : 			lRes = rkParent.SetDWORDValue(szValueName, ulVal);

  001b3	89 85 f0 de ff
	ff		 mov	 DWORD PTR _dwValue$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 6247 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_DWORD, reinterpret_cast<const BYTE*>(&dwValue), sizeof(DWORD));

  001b9	8d 85 f0 de ff
	ff		 lea	 eax, DWORD PTR _dwValue$[ebp]
  001bf	50		 push	 eax
  001c0	6a 04		 push	 4
  001c2	57		 push	 edi
  001c3	56		 push	 esi
  001c4	ff 33		 push	 DWORD PTR [ebx]
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExW@24
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1066 : 			break;

  001cc	e9 0d 01 00 00	 jmp	 $LN86@AddValue
$LN52@AddValue:

; 1067 : 		}
; 1068 : 	case VT_UI1:
; 1069 : 		{
; 1070 : 			int cbValue = static_cast<int>(_tcslen(szValue));

  001d1	8d 9d fc df ff
	ff		 lea	 ebx, DWORD PTR _szValue$[ebp]
  001d7	33 ff		 xor	 edi, edi
  001d9	8d 4b 02	 lea	 ecx, DWORD PTR [ebx+2]
$LL84@AddValue:
  001dc	66 8b 03	 mov	 ax, WORD PTR [ebx]
  001df	83 c3 02	 add	 ebx, 2
  001e2	66 3b c7	 cmp	 ax, di
  001e5	75 f5		 jne	 SHORT $LL84@AddValue
  001e7	2b d9		 sub	 ebx, ecx
  001e9	d1 fb		 sar	 ebx, 1

; 1071 : 			if (cbValue & 0x00000001)

  001eb	f6 c3 01	 test	 bl, 1
  001ee	75 34		 jne	 SHORT $LN59@AddValue

; 1076 : 			int cbValDiv2 = cbValue/2;

  001f0	8b c3		 mov	 eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h

; 481  : 		m_p( NULL )

  001f2	89 bd f8 de ff
	ff		 mov	 DWORD PTR _rgBinary$2[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1076 : 			int cbValDiv2 = cbValue/2;

  001f8	99		 cdq

; 1077 : 			CTempBuffer<BYTE, 256> rgBinary;
; 1078 : 			ATLTRY(rgBinary.Allocate(cbValDiv2));

  001f9	8d 8d f8 de ff
	ff		 lea	 ecx, DWORD PTR _rgBinary$2[ebp]
  001ff	2b c2		 sub	 eax, edx
  00201	8b f0		 mov	 esi, eax
  00203	d1 fe		 sar	 esi, 1
  00205	56		 push	 esi
  00206	89 b5 e8 de ff
	ff		 mov	 DWORD PTR _cbValDiv2$1$[ebp], esi
  0020c	e8 00 00 00 00	 call	 ?Allocate@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@QAEPAEI@Z ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::Allocate

; 1079 : 			if (rgBinary == NULL)

  00211	39 bd f8 de ff
	ff		 cmp	 DWORD PTR _rgBinary$2[ebp], edi
  00217	75 15		 jne	 SHORT $LN22@AddValue
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h

; 495  : 			FreeHeap();

  00219	8d 8d f8 de ff
	ff		 lea	 ecx, DWORD PTR _rgBinary$2[ebp]
  0021f	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
$LN59@AddValue:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1080 : 				return E_FAIL;

  00224	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  00229	e9 db 00 00 00	 jmp	 $LN24@AddValue
$LN22@AddValue:

; 1081 : 			memset(rgBinary, 0, cbValDiv2);

  0022e	56		 push	 esi
  0022f	57		 push	 edi
  00230	ff b5 f8 de ff
	ff		 push	 DWORD PTR _rgBinary$2[ebp]
  00236	e8 00 00 00 00	 call	 _memset
  0023b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0023e	8b c7		 mov	 eax, edi
  00240	89 85 f4 de ff
	ff		 mov	 DWORD PTR _irg$1$[ebp], eax

; 1082 : 			for (int irg = 0; irg < cbValue; irg++)

  00246	85 db		 test	 ebx, ebx
  00248	7e 48		 jle	 SHORT $LN7@AddValue
$LL8@AddValue:

; 1083 : 				rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));

  0024a	8b b5 f8 de ff
	ff		 mov	 esi, DWORD PTR _rgBinary$2[ebp]
  00250	8b f8		 mov	 edi, eax
  00252	0f b7 84 45 fc
	df ff ff	 movzx	 eax, WORD PTR _szValue$[ebp+eax*2]
  0025a	50		 push	 eax
  0025b	d1 ef		 shr	 edi, 1
  0025d	e8 00 00 00 00	 call	 ?ChToByte@CRegParser@ATL@@KAE_W@Z ; ATL::CRegParser::ChToByte
  00262	8b 95 f4 de ff
	ff		 mov	 edx, DWORD PTR _irg$1$[ebp]
  00268	59		 pop	 ecx
  00269	83 e2 01	 and	 edx, 1
  0026c	c1 e2 02	 shl	 edx, 2
  0026f	6a 04		 push	 4
  00271	59		 pop	 ecx
  00272	2b ca		 sub	 ecx, edx
  00274	d2 e0		 shl	 al, cl
  00276	08 04 37	 or	 BYTE PTR [edi+esi], al
  00279	8b 85 f4 de ff
	ff		 mov	 eax, DWORD PTR _irg$1$[ebp]
  0027f	40		 inc	 eax
  00280	89 85 f4 de ff
	ff		 mov	 DWORD PTR _irg$1$[ebp], eax
  00286	3b c3		 cmp	 eax, ebx
  00288	7c c0		 jl	 SHORT $LL8@AddValue
  0028a	8b b5 e8 de ff
	ff		 mov	 esi, DWORD PTR _cbValDiv2$1$[ebp]
  00290	33 ff		 xor	 edi, edi
$LN7@AddValue:

; 1084 : 			lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);

  00292	8b 85 ec de ff
	ff		 mov	 eax, DWORD PTR _rkParent$GSCopy$1$[ebp]
  00298	56		 push	 esi
  00299	ff b5 f8 de ff
	ff		 push	 DWORD PTR _rgBinary$2[ebp]
  0029f	6a 03		 push	 3
  002a1	57		 push	 edi
  002a2	ff b5 f0 de ff
	ff		 push	 DWORD PTR _szValueName$GSCopy$1$[ebp]
  002a8	ff 30		 push	 DWORD PTR [eax]
  002aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExW@24
  002b0	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h

; 493  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  002b2	8d 85 fc de ff
	ff		 lea	 eax, DWORD PTR _rgBinary$2[ebp+4]
  002b8	39 85 f8 de ff
	ff		 cmp	 DWORD PTR _rgBinary$2[ebp], eax
  002be	74 20		 je	 SHORT $LN65@AddValue

; 495  : 			FreeHeap();

  002c0	8d 8d f8 de ff
	ff		 lea	 ecx, DWORD PTR _rgBinary$2[ebp]
  002c6	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@E$0BAA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<unsigned char,256,ATL::CCRTAllocator>::FreeHeap
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1085 : 			break;

  002cb	eb 13		 jmp	 SHORT $LN65@AddValue
$LN12@AddValue:

; 992  : 	{
; 993  : 	case VT_BSTR:
; 994  : 		{
; 995  : 			lRes = rkParent.SetStringValue(szValueName, szValue);

  002cd	6a 01		 push	 1
  002cf	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szValue$[ebp]
  002d5	8b cb		 mov	 ecx, ebx
  002d7	50		 push	 eax
  002d8	56		 push	 esi
  002d9	e8 00 00 00 00	 call	 ?SetStringValue@CRegKey@ATL@@QAEJPB_W0K@Z ; ATL::CRegKey::SetStringValue
$LN86@AddValue:

; 1086 : 		}
; 1087 : 	}
; 1088 : 
; 1089 : 	if (ERROR_SUCCESS != lRes)

  002de	8b f8		 mov	 edi, eax
$LN65@AddValue:
  002e0	85 ff		 test	 edi, edi
  002e2	74 09		 je	 SHORT $LN85@AddValue

; 1090 : 	{
; 1091 : 		nIDRes = E_ATL_VALUE_SET_FAILED;
; 1092 : 		return AtlHresultFromWin32(lRes);

  002e4	57		 push	 edi
  002e5	e8 00 00 00 00	 call	 ?AtlHresultFromWin32@ATL@@YAJK@Z ; ATL::AtlHresultFromWin32
  002ea	59		 pop	 ecx
  002eb	eb 1c		 jmp	 SHORT $LN24@AddValue
$LN85@AddValue:

; 1086 : 		}
; 1087 : 	}
; 1088 : 
; 1089 : 	if (ERROR_SUCCESS != lRes)

  002ed	8b bd e4 de ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN23@AddValue:

; 1093 : 	}
; 1094 : 
; 1095 : 	if (FAILED(hr = NextToken(szToken)))

  002f3	ff b5 e0 de ff
	ff		 push	 DWORD PTR _szToken$GSCopy$1$[ebp]
  002f9	8b cf		 mov	 ecx, edi
  002fb	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  00300	33 c9		 xor	 ecx, ecx
  00302	85 c0		 test	 eax, eax
  00304	0f 48 c8	 cmovs	 ecx, eax
  00307	8b c1		 mov	 eax, ecx
$LN24@AddValue:

; 1096 : 		return hr;
; 1097 : 
; 1098 : 	return S_OK;
; 1099 : }

  00309	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0030c	5f		 pop	 edi
  0030d	5e		 pop	 esi
  0030e	33 cd		 xor	 ecx, ebp
  00310	5b		 pop	 ebx
  00311	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00316	c9		 leave
  00317	c2 0c 00	 ret	 12			; 0000000cH
?AddValue@CRegParser@ATL@@IAEJAAVCRegKey@2@PB_WPA_W@Z ENDP ; ATL::CRegParser::AddValue
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?NextToken@CRegParser@ATL@@IAEJPA_W@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_nChars$1$ = -8						; size = 4
$T2 = -4						; size = 4
_nChars$1$ = -4						; size = 4
_szOrig$1$ = 8						; size = 4
_szToken$ = 8						; size = 4
?NextToken@CRegParser@ATL@@IAEJPA_W@Z PROC		; ATL::CRegParser::NextToken, COMDAT
; _this$ = ecx

; 902  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx

; 903  : 	SkipWhiteSpace();

  0000a	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace

; 904  : 
; 905  : 	// NextToken cannot be called at EOS
; 906  : 	if (_T('\0') == *m_pchCur)

  0000f	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00011	33 d2		 xor	 edx, edx
  00013	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  00016	8b c8		 mov	 ecx, eax
  00018	66 3b d0	 cmp	 dx, ax
  0001b	0f 84 0b 01 00
	00		 je	 $LN25@NextToken

; 907  : 		return GenerateError(E_ATL_UNEXPECTED_EOS);
; 908  : 
; 909  : 	LPCTSTR szOrig = szToken;

  00021	8b 7d 08	 mov	 edi, DWORD PTR _szToken$[ebp]

; 910  : 	// handle quoted value / key
; 911  : 	if (chQuote == *m_pchCur)

  00024	6a 27		 push	 39			; 00000027H
  00026	5a		 pop	 edx
  00027	89 7d 08	 mov	 DWORD PTR _szOrig$1$[ebp], edi
  0002a	66 3b d0	 cmp	 dx, ax
  0002d	0f 85 94 00 00
	00		 jne	 $LL7@NextToken

; 912  : 	{
; 913  : 		m_pchCur = CharNext(m_pchCur);

  00033	53		 push	 ebx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  0003a	89 06		 mov	 DWORD PTR [esi], eax

; 914  : 
; 915  : 		while (_T('\0') != *m_pchCur && !EndOfVar())

  0003c	eb 68		 jmp	 SHORT $LN40@NextToken
$LL2@NextToken:
  0003e	8b ce		 mov	 ecx, esi
  00040	e8 00 00 00 00	 call	 ?EndOfVar@CRegParser@ATL@@IAEHXZ ; ATL::CRegParser::EndOfVar
  00045	85 c0		 test	 eax, eax
  00047	75 64		 jne	 SHORT $LN3@NextToken

; 916  : 		{
; 917  : 			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it

  00049	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0004b	6a 27		 push	 39			; 00000027H
  0004d	58		 pop	 eax
  0004e	66 3b 03	 cmp	 ax, WORD PTR [ebx]
  00051	75 0b		 jne	 SHORT $LN15@NextToken

; 918  : 				m_pchCur = CharNext(m_pchCur);

  00053	53		 push	 ebx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  0005a	8b d8		 mov	 ebx, eax
  0005c	89 1e		 mov	 DWORD PTR [esi], ebx
$LN15@NextToken:

; 919  : 
; 920  : 			LPTSTR pchPrev = m_pchCur;
; 921  : 			m_pchCur = CharNext(m_pchCur);

  0005e	53		 push	 ebx
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4

; 922  : 
; 923  : 			INT_PTR nChars = m_pchCur - pchPrev;
; 924  : 
; 925  : 			// Make sure we have room for nChars plus terminating NULL
; 926  : 			if ((szToken + nChars + 1) >= szOrig + MAX_VALUE)

  00065	8b 4d 08	 mov	 ecx, DWORD PTR _szOrig$1$[ebp]
  00068	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0006b	81 c1 00 20 00
	00		 add	 ecx, 8192		; 00002000H
  00071	89 06		 mov	 DWORD PTR [esi], eax
  00073	2b c3		 sub	 eax, ebx
  00075	d1 f8		 sar	 eax, 1
  00077	89 45 fc	 mov	 DWORD PTR _nChars$1$[ebp], eax
  0007a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0007d	8d 14 57	 lea	 edx, DWORD PTR [edi+edx*2]
  00080	3b d1		 cmp	 edx, ecx
  00082	0f 83 a4 00 00
	00		 jae	 $LN25@NextToken

; 927  : 				return GenerateError(E_ATL_VALUE_TOO_LARGE);
; 928  : 
; 929  : 			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)

  00088	85 c0		 test	 eax, eax
  0008a	7e 17		 jle	 SHORT $LN42@NextToken
  0008c	2b df		 sub	 ebx, edi
  0008e	8b c8		 mov	 ecx, eax
$LL28@NextToken:

; 930  : 				*szToken = *pchPrev;

  00090	66 8b 04 3b	 mov	 ax, WORD PTR [ebx+edi]
  00094	66 89 07	 mov	 WORD PTR [edi], ax
  00097	83 c7 02	 add	 edi, 2
  0009a	83 e9 01	 sub	 ecx, 1
  0009d	75 f1		 jne	 SHORT $LL28@NextToken

; 927  : 				return GenerateError(E_ATL_VALUE_TOO_LARGE);
; 928  : 
; 929  : 			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)

  0009f	8b 06		 mov	 eax, DWORD PTR [esi]
  000a1	eb 03		 jmp	 SHORT $LN40@NextToken
$LN42@NextToken:
  000a3	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
$LN40@NextToken:

; 914  : 
; 915  : 		while (_T('\0') != *m_pchCur && !EndOfVar())

  000a6	33 c9		 xor	 ecx, ecx
  000a8	66 3b 08	 cmp	 cx, WORD PTR [eax]
  000ab	75 91		 jne	 SHORT $LL2@NextToken
$LN3@NextToken:

; 931  : 		}
; 932  : 
; 933  : 		if (_T('\0') == *m_pchCur)

  000ad	8b 06		 mov	 eax, DWORD PTR [esi]
  000af	33 c9		 xor	 ecx, ecx
  000b1	66 3b 08	 cmp	 cx, WORD PTR [eax]
  000b4	74 76		 je	 SHORT $LN25@NextToken

; 934  : 		{
; 935  : 			ATLTRACE(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));
; 936  : 			return GenerateError(E_ATL_UNEXPECTED_EOS);
; 937  : 		}
; 938  : 
; 939  : 		*szToken = _T('\0');

  000b6	33 c0		 xor	 eax, eax
  000b8	66 89 07	 mov	 WORD PTR [edi], ax

; 940  : 		m_pchCur = CharNext(m_pchCur);

  000bb	ff 36		 push	 DWORD PTR [esi]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  000c3	89 06		 mov	 DWORD PTR [esi], eax

; 941  : 	}

  000c5	eb 61		 jmp	 SHORT $LN14@NextToken
$LL7@NextToken:

; 942  : 
; 943  : 	else
; 944  : 	{
; 945  : 		// Handle non-quoted ie parse up till first "White Space"
; 946  : 		while (_T('\0') != *m_pchCur && !IsSpace(*m_pchCur))

  000c7	51		 push	 ecx
  000c8	8b ce		 mov	 ecx, esi
  000ca	e8 00 00 00 00	 call	 ?IsSpace@CRegParser@ATL@@IAEH_W@Z ; ATL::CRegParser::IsSpace
  000cf	85 c0		 test	 eax, eax
  000d1	75 50		 jne	 SHORT $LN8@NextToken

; 947  : 		{
; 948  : 			LPTSTR pchPrev = m_pchCur;
; 949  : 			m_pchCur = CharNext(m_pchCur);

  000d3	53		 push	 ebx
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4

; 950  : 
; 951  : 			INT_PTR nChars = m_pchCur - pchPrev;
; 952  : 
; 953  : 			// Make sure we have room for nChars plus terminating NULL
; 954  : 			if ((szToken + nChars + 1) >= szOrig + MAX_VALUE)

  000da	8b 4d 08	 mov	 ecx, DWORD PTR _szOrig$1$[ebp]
  000dd	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  000e0	81 c1 00 20 00
	00		 add	 ecx, 8192		; 00002000H
  000e6	89 06		 mov	 DWORD PTR [esi], eax
  000e8	2b c3		 sub	 eax, ebx
  000ea	d1 f8		 sar	 eax, 1
  000ec	89 45 f8	 mov	 DWORD PTR _nChars$1$[ebp], eax
  000ef	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  000f2	8d 14 57	 lea	 edx, DWORD PTR [edi+edx*2]
  000f5	3b d1		 cmp	 edx, ecx
  000f7	73 33		 jae	 SHORT $LN25@NextToken

; 956  : 
; 957  : 			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)

  000f9	85 c0		 test	 eax, eax
  000fb	7e 17		 jle	 SHORT $LN41@NextToken
  000fd	2b df		 sub	 ebx, edi
  000ff	8b c8		 mov	 ecx, eax
$LL30@NextToken:

; 958  : 				*szToken = *pchPrev;

  00101	66 8b 04 3b	 mov	 ax, WORD PTR [ebx+edi]
  00105	66 89 07	 mov	 WORD PTR [edi], ax
  00108	83 c7 02	 add	 edi, 2
  0010b	83 e9 01	 sub	 ecx, 1
  0010e	75 f1		 jne	 SHORT $LL30@NextToken

; 956  : 
; 957  : 			for (int i = 0; i < (int)nChars; i++, szToken++, pchPrev++)

  00110	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00112	eb 03		 jmp	 SHORT $LN10@NextToken
$LN41@NextToken:
  00114	8b 5d fc	 mov	 ebx, DWORD PTR $T2[ebp]
$LN10@NextToken:

; 942  : 
; 943  : 	else
; 944  : 	{
; 945  : 		// Handle non-quoted ie parse up till first "White Space"
; 946  : 		while (_T('\0') != *m_pchCur && !IsSpace(*m_pchCur))

  00117	0f b7 03	 movzx	 eax, WORD PTR [ebx]
  0011a	33 d2		 xor	 edx, edx
  0011c	8b c8		 mov	 ecx, eax
  0011e	66 3b d0	 cmp	 dx, ax
  00121	75 a4		 jne	 SHORT $LL7@NextToken
$LN8@NextToken:

; 959  : 		}
; 960  : 
; 961  : 		*szToken = _T('\0');

  00123	33 c0		 xor	 eax, eax
  00125	66 89 07	 mov	 WORD PTR [edi], ax
$LN14@NextToken:

; 962  : 	}
; 963  : 	return S_OK;

  00128	33 c0		 xor	 eax, eax
  0012a	eb 05		 jmp	 SHORT $LN1@NextToken
$LN25@NextToken:

; 955  : 				return GenerateError(E_ATL_VALUE_TOO_LARGE);

  0012c	b8 09 00 02 80	 mov	 eax, -2147352567	; 80020009H
$LN1@NextToken:
  00131	5f		 pop	 edi

; 964  : }

  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx
  00134	c9		 leave
  00135	c2 04 00	 ret	 4
?NextToken@CRegParser@ATL@@IAEJPA_W@Z ENDP		; ATL::CRegParser::NextToken
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ
_TEXT	SEGMENT
?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ PROC		; ATL::CRegParser::SkipWhiteSpace, COMDAT
; _this$ = ecx

; 895  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 896  : 	while(IsSpace(*m_pchCur))

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	eb 0c		 jmp	 SHORT $LN10@SkipWhiteS
$LL2@SkipWhiteS:

; 897  : 		m_pchCur = CharNext(m_pchCur);

  00007	ff 36		 push	 DWORD PTR [esi]
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  0000f	89 06		 mov	 DWORD PTR [esi], eax
  00011	8b ce		 mov	 ecx, esi
$LN10@SkipWhiteS:

; 896  : 	while(IsSpace(*m_pchCur))

  00013	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ?IsSpace@CRegParser@ATL@@IAEH_W@Z ; ATL::CRegParser::IsSpace
  0001c	85 c0		 test	 eax, eax
  0001e	75 e7		 jne	 SHORT $LL2@SkipWhiteS

; 898  : }

  00020	5e		 pop	 esi
  00021	c3		 ret	 0
?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ENDP		; ATL::CRegParser::SkipWhiteSpace
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?RegisterBuffer@CRegParser@ATL@@QAEJPA_WH@Z
_TEXT	SEGMENT
_szRegAtRegister$1$ = -8204				; size = 4
_hkBase$1$ = -8200					; size = 4
_szReg$ = -8200						; size = 4
_szToken$ = -8196					; size = 8192
__$ArrayPad$ = -4					; size = 4
_szBuffer$ = 8						; size = 4
_bRegister$ = 12					; size = 4
?RegisterBuffer@CRegParser@ATL@@QAEJPA_WH@Z PROC	; ATL::CRegParser::RegisterBuffer, COMDAT
; _this$ = ecx

; 1346 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 0c 20 00 00	 mov	 eax, 8204		; 0000200cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR _szBuffer$[ebp]

; 1347 : 	TCHAR   szToken[MAX_VALUE];
; 1348 : 	HRESULT hr = S_OK;
; 1349 : 
; 1350 : 	LPTSTR szReg = NULL;

  0001a	83 a5 f8 df ff
	ff 00		 and	 DWORD PTR _szReg$[ebp], 0
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	8b f9		 mov	 edi, ecx

; 1351 : 	hr = PreProcessBuffer(szBuffer, &szReg);

  00025	8d 8d f8 df ff
	ff		 lea	 ecx, DWORD PTR _szReg$[ebp]
  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	8b cf		 mov	 ecx, edi
  0002f	e8 00 00 00 00	 call	 ?PreProcessBuffer@CRegParser@ATL@@QAEJPA_WPAPA_W@Z ; ATL::CRegParser::PreProcessBuffer
  00034	8b f0		 mov	 esi, eax

; 1352 : 	if (FAILED(hr))

  00036	85 f6		 test	 esi, esi
  00038	0f 88 f9 00 00
	00		 js	 $LN1@RegisterBu

; 1353 : 		return hr;
; 1354 : 
; 1355 : 	ATLTRACE(atlTraceRegistrar, 0, _T("%Ts\n"), szReg);
; 1356 : 
; 1357 : 	m_pchCur = szReg;

  0003e	53		 push	 ebx
  0003f	8b 9d f8 df ff
	ff		 mov	 ebx, DWORD PTR _szReg$[ebp]

; 1358 : 
; 1359 : 	// Preprocess szReg
; 1360 : 
; 1361 : 	while (_T('\0') != *m_pchCur)

  00045	33 c0		 xor	 eax, eax
  00047	89 1f		 mov	 DWORD PTR [edi], ebx
  00049	66 3b 03	 cmp	 ax, WORD PTR [ebx]
  0004c	0f 84 db 00 00
	00		 je	 $LN20@RegisterBu
$LL2@RegisterBu:

; 1362 : 	{
; 1363 : 		if (FAILED(hr = NextToken(szToken)))

  00052	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  00058	8b cf		 mov	 ecx, edi
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  00060	8b f0		 mov	 esi, eax
  00062	85 f6		 test	 esi, esi
  00064	0f 88 c3 00 00
	00		 js	 $LN20@RegisterBu

; 1364 : 			break;
; 1365 : 		HKEY hkBase;
; 1366 : 		if ((hkBase = HKeyFromString(szToken)) == NULL)

  0006a	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ?HKeyFromString@CRegParser@ATL@@KAPAUHKEY__@@PA_W@Z ; ATL::CRegParser::HKeyFromString
  00076	89 85 f8 df ff
	ff		 mov	 DWORD PTR _hkBase$1$[ebp], eax
  0007c	59		 pop	 ecx
  0007d	85 c0		 test	 eax, eax
  0007f	0f 84 a3 00 00
	00		 je	 $LN16@RegisterBu

; 1367 : 		{
; 1368 : 			ATLTRACE(atlTraceRegistrar, 0, _T("HKeyFromString failed on %Ts\n"), szToken);
; 1369 : 			hr = GenerateError(E_ATL_BAD_HKEY);
; 1370 : 			break;
; 1371 : 		}
; 1372 : 
; 1373 : 		if (FAILED(hr = NextToken(szToken)))

  00085	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  0008b	8b cf		 mov	 ecx, edi
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ?NextToken@CRegParser@ATL@@IAEJPA_W@Z ; ATL::CRegParser::NextToken
  00093	8b f0		 mov	 esi, eax
  00095	85 f6		 test	 esi, esi
  00097	0f 88 90 00 00
	00		 js	 $LN20@RegisterBu

; 1374 : 			break;
; 1375 : 
; 1376 : 		if (chLeftBracket != *szToken)

  0009d	6a 7b		 push	 123			; 0000007bH
  0009f	58		 pop	 eax
  000a0	66 3b 85 fc df
	ff ff		 cmp	 ax, WORD PTR _szToken$[ebp]
  000a7	75 7f		 jne	 SHORT $LN16@RegisterBu

; 1377 : 		{
; 1378 : 			ATLTRACE(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %Ts\n"), szToken);
; 1379 : 			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
; 1380 : 			break;
; 1381 : 		}
; 1382 : 		if (bRegister)

  000a9	83 7d 0c 00	 cmp	 DWORD PTR _bRegister$[ebp], 0
  000ad	8b cf		 mov	 ecx, edi
  000af	6a 00		 push	 0
  000b1	74 45		 je	 SHORT $LN9@RegisterBu

; 1383 : 		{
; 1384 : 			LPTSTR szRegAtRegister = m_pchCur;
; 1385 : 			hr = RegisterSubkeys(szToken, hkBase, bRegister);

  000b3	ff 75 0c	 push	 DWORD PTR _bRegister$[ebp]
  000b6	8b 07		 mov	 eax, DWORD PTR [edi]
  000b8	ff b5 f8 df ff
	ff		 push	 DWORD PTR _hkBase$1$[ebp]
  000be	89 85 f4 df ff
	ff		 mov	 DWORD PTR _szRegAtRegister$1$[ebp], eax
  000c4	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPA_WPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  000d0	8b f0		 mov	 esi, eax

; 1386 : 			if (FAILED(hr))

  000d2	85 f6		 test	 esi, esi
  000d4	79 3c		 jns	 SHORT $LN12@RegisterBu

; 1387 : 			{
; 1388 : 				ATLTRACE(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));
; 1389 : 				m_pchCur = szRegAtRegister;

  000d6	8b 85 f4 df ff
	ff		 mov	 eax, DWORD PTR _szRegAtRegister$1$[ebp]

; 1390 : 				RegisterSubkeys(szToken, hkBase, FALSE);

  000dc	8b cf		 mov	 ecx, edi
  000de	6a 00		 push	 0
  000e0	6a 00		 push	 0
  000e2	ff b5 f8 df ff
	ff		 push	 DWORD PTR _hkBase$1$[ebp]
  000e8	89 07		 mov	 DWORD PTR [edi], eax
  000ea	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPA_WPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  000f6	eb 35		 jmp	 SHORT $LN20@RegisterBu
$LN9@RegisterBu:

; 1391 : 				break;
; 1392 : 			}
; 1393 : 		}
; 1394 : 		else
; 1395 : 		{
; 1396 : 			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))

  000f8	6a 00		 push	 0
  000fa	ff b5 f8 df ff
	ff		 push	 DWORD PTR _hkBase$1$[ebp]
  00100	8d 85 fc df ff
	ff		 lea	 eax, DWORD PTR _szToken$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ?RegisterSubkeys@CRegParser@ATL@@IAEJPA_WPAUHKEY__@@HH@Z ; ATL::CRegParser::RegisterSubkeys
  0010c	8b f0		 mov	 esi, eax
  0010e	85 f6		 test	 esi, esi
  00110	78 1b		 js	 SHORT $LN20@RegisterBu
$LN12@RegisterBu:

; 1397 : 				break;
; 1398 : 		}
; 1399 : 
; 1400 : 		SkipWhiteSpace();

  00112	8b cf		 mov	 ecx, edi
  00114	e8 00 00 00 00	 call	 ?SkipWhiteSpace@CRegParser@ATL@@IAEXXZ ; ATL::CRegParser::SkipWhiteSpace
  00119	8b 07		 mov	 eax, DWORD PTR [edi]
  0011b	33 c9		 xor	 ecx, ecx
  0011d	66 3b 08	 cmp	 cx, WORD PTR [eax]
  00120	0f 85 2c ff ff
	ff		 jne	 $LL2@RegisterBu

; 1358 : 
; 1359 : 	// Preprocess szReg
; 1360 : 
; 1361 : 	while (_T('\0') != *m_pchCur)

  00126	eb 05		 jmp	 SHORT $LN20@RegisterBu
$LN16@RegisterBu:

; 1401 : 	}
; 1402 : 	CoTaskMemFree(szReg);

  00128	be 09 00 02 80	 mov	 esi, -2147352567	; 80020009H
$LN20@RegisterBu:
  0012d	53		 push	 ebx
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4

; 1403 : 	return hr;

  00134	8b c6		 mov	 eax, esi
  00136	5b		 pop	 ebx
$LN1@RegisterBu:

; 1404 : }

  00137	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013a	5f		 pop	 edi
  0013b	33 cd		 xor	 ecx, ebp
  0013d	5e		 pop	 esi
  0013e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00143	c9		 leave
  00144	c2 08 00	 ret	 8
?RegisterBuffer@CRegParser@ATL@@QAEJPA_WH@Z ENDP	; ATL::CRegParser::RegisterBuffer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_wstring.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?PreProcessBuffer@CRegParser@ATL@@QAEJPA_WPAPA_W@Z
_TEXT	SEGMENT
_ppszReg$GSCopy$1$ = -100				; size = 4
tv499 = -96						; size = 4
_pb$ = -92						; size = 12
tv492 = -80						; size = 4
_lpszKey$ = -80						; size = 4
_nNestingLevel$1$ = -76					; size = 4
_bRedirectionEnabled$1$ = -71				; size = 1
_bRedirectionPresent$1$ = -70				; size = 1
_bInsideQuotes$1$ = -69					; size = 1
_buf$1 = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_lpszReg$ = 8						; size = 4
_ppszReg$ = 12						; size = 4
?PreProcessBuffer@CRegParser@ATL@@QAEJPA_WPAPA_W@Z PROC	; ATL::CRegParser::PreProcessBuffer, COMDAT
; _this$ = ecx

; 1175 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 0c	 mov	 eax, DWORD PTR _ppszReg$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi

; 1176 : 	ATLASSERT(lpszReg != NULL);
; 1177 : 	ATLASSERT(ppszReg != NULL);
; 1178 : 
; 1179 : 	if (lpszReg == NULL || ppszReg == NULL)

  00015	8b 7d 08	 mov	 edi, DWORD PTR _lpszReg$[ebp]
  00018	8b f1		 mov	 esi, ecx
  0001a	89 45 9c	 mov	 DWORD PTR _ppszReg$GSCopy$1$[ebp], eax
  0001d	85 ff		 test	 edi, edi
  0001f	0f 84 35 02 00
	00		 je	 $LN7@PreProcess
  00025	85 c0		 test	 eax, eax
  00027	0f 84 2d 02 00
	00		 je	 $LN7@PreProcess

; 1181 : 
; 1182 : 	*ppszReg = NULL;
; 1183 : 	int nSize = static_cast<int>(_tcslen(lpszReg))*2;

  0002d	8b cf		 mov	 ecx, edi
  0002f	53		 push	 ebx
  00030	33 db		 xor	 ebx, ebx
  00032	89 18		 mov	 DWORD PTR [eax], ebx
  00034	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL83@PreProcess:
  00037	66 8b 01	 mov	 ax, WORD PTR [ecx]
  0003a	83 c1 02	 add	 ecx, 2
  0003d	66 3b c3	 cmp	 ax, bx
  00040	75 f5		 jne	 SHORT $LL83@PreProcess
  00042	2b ca		 sub	 ecx, edx
  00044	d1 f9		 sar	 ecx, 1
  00046	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 1184 : 	CParseBuffer pb(nSize);

  00049	50		 push	 eax
  0004a	8d 4d a4	 lea	 ecx, DWORD PTR _pb$[ebp]
  0004d	e8 00 00 00 00	 call	 ??0CParseBuffer@CRegParser@ATL@@QAE@H@Z ; ATL::CRegParser::CParseBuffer::CParseBuffer

; 1185 : 	if (pb.p == NULL)

  00052	39 5d ac	 cmp	 DWORD PTR _pb$[ebp+8], ebx
  00055	0f 84 c7 00 00
	00		 je	 $LN72@PreProcess

; 1186 : 		return E_OUTOFMEMORY;
; 1187 : 	m_pchCur = lpszReg;

  0005b	89 3e		 mov	 DWORD PTR [esi], edi

; 1199 : 	int nNestingLevel = 0;

  0005d	8b c3		 mov	 eax, ebx

; 1201 : 	bool bInsideQuotes = false;

  0005f	8a cb		 mov	 cl, bl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7100 : 	*pbEnabled = _AtlRegisterPerUser;

  00061	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR ?_AtlRegisterPerUser@ATL@@3_NA ; ATL::_AtlRegisterPerUser
  00067	88 55 b9	 mov	 BYTE PTR _bRedirectionEnabled$1$[ebp], dl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1199 : 	int nNestingLevel = 0;

  0006a	89 45 b4	 mov	 DWORD PTR _nNestingLevel$1$[ebp], eax

; 1200 : 	bool bRedirectionPresent = false;

  0006d	88 5d ba	 mov	 BYTE PTR _bRedirectionPresent$1$[ebp], bl

; 1201 : 	bool bInsideQuotes = false;

  00070	88 4d bb	 mov	 BYTE PTR _bInsideQuotes$1$[ebp], cl

; 1202 : 
; 1203 : 	while (*m_pchCur != _T('\0')) // look for end

  00073	66 39 1f	 cmp	 WORD PTR [edi], bx
  00076	0f 84 c5 01 00
	00		 je	 $LN79@PreProcess
  0007c	c7 45 a0 25 00
	00 00		 mov	 DWORD PTR tv499[ebp], 37 ; 00000025H
$LL2@PreProcess:

; 1204 : 	{
; 1205 : 		if ( true == bRedirectionEnabled )

  00083	89 45 b0	 mov	 DWORD PTR tv492[ebp], eax
  00086	80 fa 01	 cmp	 dl, 1
  00089	0f 85 df 00 00
	00		 jne	 $LN22@PreProcess

; 1206 : 		{
; 1207 : 			LPCOLESTR szStartHKCU = L"HKCU\r\n{\tSoftware\r\n\t{\r\n\t\tClasses";
; 1208 : 			LPCOLESTR szEndHKCU = L"\r\n\t}\r\n}\r\n";
; 1209 : 
; 1210 : 			if ( 0 == nNestingLevel )

  0008f	85 c0		 test	 eax, eax
  00091	75 52		 jne	 SHORT $LN12@PreProcess
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_wstring.h

; 550  :         return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));

  00093	68 00 00 00 00	 push	 OFFSET ??_C@_19NCHLBIN@?$AAH?$AAK?$AAC?$AAR@
  00098	57		 push	 edi
  00099	e8 00 00 00 00	 call	 _wcsstr
  0009e	59		 pop	 ecx
  0009f	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1214 : 				if( NULL != ( szRootKey = _tcsstr(m_pchCur, _T("HKCR")) ) &&	// if HKCR is found.

  000a0	85 c0		 test	 eax, eax
  000a2	74 3e		 je	 SHORT $LN86@PreProcess
  000a4	3b 06		 cmp	 eax, DWORD PTR [esi]
  000a6	75 3a		 jne	 SHORT $LN86@PreProcess

; 1215 : 					(szRootKey == m_pchCur) )	// if HKCR is the first token.
; 1216 : 				{
; 1217 : 					// Skip HKCR
; 1218 : 					m_pchCur = CharNext(m_pchCur);

  000a8	ff 36		 push	 DWORD PTR [esi]
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4

; 1219 : 					m_pchCur = CharNext(m_pchCur);

  000b0	50		 push	 eax
  000b1	89 06		 mov	 DWORD PTR [esi], eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4

; 1220 : 					m_pchCur = CharNext(m_pchCur);

  000b9	50		 push	 eax
  000ba	89 06		 mov	 DWORD PTR [esi], eax
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4

; 1221 : 					m_pchCur = CharNext(m_pchCur);

  000c2	50		 push	 eax
  000c3	89 06		 mov	 DWORD PTR [esi], eax
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4

; 1222 : 
; 1223 : 					// Add HKCU
; 1224 : 					if (!pb.AddString(szStartHKCU))

  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@NHKLICFA@?$AAH?$AAK?$AAC?$AAU?$AA?$AN?$AA?6?$AA?$HL?$AA?7?$AAS?$AAo?$AAf?$AAt?$AAw?$AAa?$AAr@
  000d0	8d 4d a4	 lea	 ecx, DWORD PTR _pb$[ebp]
  000d3	89 06		 mov	 DWORD PTR [esi], eax
  000d5	e8 00 00 00 00	 call	 ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
  000da	85 c0		 test	 eax, eax
  000dc	74 44		 je	 SHORT $LN72@PreProcess

; 1225 : 					{
; 1226 : 						hr = E_OUTOFMEMORY;
; 1227 : 						break;
; 1228 : 					}
; 1229 : 
; 1230 : 					bRedirectionPresent = true;

  000de	c6 45 ba 01	 mov	 BYTE PTR _bRedirectionPresent$1$[ebp], 1
$LN86@PreProcess:

; 1231 : 				}
; 1232 : 			}
; 1233 : 
; 1234 : 			if ( chQuote == *m_pchCur )

  000e2	8a 4d bb	 mov	 cl, BYTE PTR _bInsideQuotes$1$[ebp]
$LN12@PreProcess:
  000e5	8b 06		 mov	 eax, DWORD PTR [esi]
  000e7	6a 27		 push	 39			; 00000027H
  000e9	5a		 pop	 edx
  000ea	66 3b 10	 cmp	 dx, WORD PTR [eax]
  000ed	75 3d		 jne	 SHORT $LN19@PreProcess

; 1235 : 			{
; 1236 : 				if( false == bInsideQuotes )

  000ef	84 c9		 test	 cl, cl
  000f1	75 06		 jne	 SHORT $LN15@PreProcess

; 1237 : 				{
; 1238 : 					bInsideQuotes = true;

  000f3	c6 45 bb 01	 mov	 BYTE PTR _bInsideQuotes$1$[ebp], 1

; 1239 : 				}

  000f7	eb 75		 jmp	 SHORT $LN22@PreProcess
$LN15@PreProcess:

; 1240 : 				else
; 1241 : 				{
; 1242 : 					// Make sure it is not an escaped sequence.
; 1243 : 					if( EndOfVar() )

  000f9	8b ce		 mov	 ecx, esi
  000fb	e8 00 00 00 00	 call	 ?EndOfVar@CRegParser@ATL@@IAEHXZ ; ATL::CRegParser::EndOfVar
  00100	85 c0		 test	 eax, eax
  00102	74 05		 je	 SHORT $LN17@PreProcess

; 1244 : 					{
; 1245 : 						bInsideQuotes = false;

  00104	88 5d bb	 mov	 BYTE PTR _bInsideQuotes$1$[ebp], bl

; 1246 : 					}

  00107	eb 27		 jmp	 SHORT $LN80@PreProcess
$LN17@PreProcess:

; 1247 : 					else
; 1248 : 					{
; 1249 : 						// An escaped single quote...
; 1250 : 						m_pchCur = CharNext(m_pchCur);

  00109	ff 36		 push	 DWORD PTR [esi]
  0010b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4

; 284  : 			return Append(pch, nChars);

  00111	6a 01		 push	 1
  00113	50		 push	 eax
  00114	8d 4d a4	 lea	 ecx, DWORD PTR _pb$[ebp]

; 1247 : 					else
; 1248 : 					{
; 1249 : 						// An escaped single quote...
; 1250 : 						m_pchCur = CharNext(m_pchCur);

  00117	89 06		 mov	 DWORD PTR [esi], eax

; 284  : 			return Append(pch, nChars);

  00119	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPB_WH@Z ; ATL::CRegParser::CParseBuffer::Append

; 1251 : 						if (!pb.AddChar(m_pchCur))

  0011e	85 c0		 test	 eax, eax
  00120	75 4c		 jne	 SHORT $LN22@PreProcess
$LN72@PreProcess:

; 240  : 			CoTaskMemFree(p);

  00122	bb 0e 00 07 80	 mov	 ebx, -2147024882	; 8007000eH
  00127	e9 20 01 00 00	 jmp	 $LN34@PreProcess
$LN19@PreProcess:

; 1252 : 						{
; 1253 : 							hr = E_OUTOFMEMORY;
; 1254 : 							break;
; 1255 : 						}
; 1256 : 					}
; 1257 : 				}
; 1258 : 			}
; 1259 : 
; 1260 : 			if ( (false == bInsideQuotes) && (*m_pchCur == _T('{')) )

  0012c	84 c9		 test	 cl, cl
  0012e	75 3e		 jne	 SHORT $LN22@PreProcess
$LN80@PreProcess:
  00130	8b 06		 mov	 eax, DWORD PTR [esi]
  00132	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00135	83 f9 7b	 cmp	 ecx, 123		; 0000007bH
  00138	75 05		 jne	 SHORT $LN20@PreProcess

; 1261 : 			{
; 1262 : 				++nNestingLevel;

  0013a	ff 45 b4	 inc	 DWORD PTR _nNestingLevel$1$[ebp]
  0013d	eb 2f		 jmp	 SHORT $LN22@PreProcess
$LN20@PreProcess:

; 1263 : 			}
; 1264 : 
; 1265 : 			if ( (false == bInsideQuotes) && (*m_pchCur == _T('}')) )

  0013f	8b 55 b0	 mov	 edx, DWORD PTR tv492[ebp]
  00142	89 55 b4	 mov	 DWORD PTR _nNestingLevel$1$[ebp], edx
  00145	83 f9 7d	 cmp	 ecx, 125		; 0000007dH
  00148	75 24		 jne	 SHORT $LN22@PreProcess

; 1266 : 			{
; 1267 : 				--nNestingLevel;

  0014a	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  0014d	89 45 b4	 mov	 DWORD PTR _nNestingLevel$1$[ebp], eax

; 1268 : 				if ( (0 == nNestingLevel) && (true == bRedirectionPresent) )

  00150	85 c0		 test	 eax, eax
  00152	75 1a		 jne	 SHORT $LN22@PreProcess
  00154	80 7d ba 01	 cmp	 BYTE PTR _bRedirectionPresent$1$[ebp], 1
  00158	75 14		 jne	 SHORT $LN22@PreProcess

; 1269 : 				{
; 1270 : 					if (!pb.AddString(szEndHKCU))

  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_1BE@LJOLIMEM@?$AA?$AN?$AA?6?$AA?7?$AA?$HN?$AA?$AN?$AA?6?$AA?$HN?$AA?$AN?$AA?6@
  0015f	8d 4d a4	 lea	 ecx, DWORD PTR _pb$[ebp]
  00162	e8 00 00 00 00	 call	 ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
  00167	85 c0		 test	 eax, eax
  00169	74 b7		 je	 SHORT $LN72@PreProcess

; 1271 : 					{
; 1272 : 						hr = E_OUTOFMEMORY;
; 1273 : 						break;
; 1274 : 					}
; 1275 : 
; 1276 : 					bRedirectionPresent = false;

  0016b	88 5d ba	 mov	 BYTE PTR _bRedirectionPresent$1$[ebp], bl
$LN22@PreProcess:

; 1277 : 				}
; 1278 : 			}
; 1279 : 		}
; 1280 : 
; 1281 : 		if (*m_pchCur == _T('%'))

  0016e	8b 06		 mov	 eax, DWORD PTR [esi]
  00170	8b 7d a0	 mov	 edi, DWORD PTR tv499[ebp]
  00173	66 39 38	 cmp	 WORD PTR [eax], di
  00176	0f 85 85 00 00
	00		 jne	 $LN24@PreProcess

; 1282 : 		{
; 1283 : 			m_pchCur = CharNext(m_pchCur);

  0017c	50		 push	 eax
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  00183	89 06		 mov	 DWORD PTR [esi], eax

; 1284 : 			if (*m_pchCur == _T('%'))

  00185	66 39 38	 cmp	 WORD PTR [eax], di
  00188	74 77		 je	 SHORT $LN24@PreProcess

; 1285 : 			{
; 1286 : 				if (!pb.AddChar(m_pchCur))
; 1287 : 				{
; 1288 : 					hr = E_OUTOFMEMORY;
; 1289 : 					break;
; 1290 : 				}
; 1291 : 			}
; 1292 : 			else
; 1293 : 			{
; 1294 : 				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));

  0018a	57		 push	 edi
  0018b	50		 push	 eax
  0018c	e8 00 00 00 00	 call	 ?StrChrW@CRegParser@ATL@@KAPA_WPA_W_W@Z ; ATL::CRegParser::StrChrW
  00191	8b f8		 mov	 edi, eax
  00193	59		 pop	 ecx
  00194	59		 pop	 ecx

; 1295 : 				if (lpszNext == NULL)

  00195	85 ff		 test	 edi, edi
  00197	0f 84 9d 00 00
	00		 je	 $LN68@PreProcess

; 1296 : 				{
; 1297 : 					ATLTRACE(atlTraceRegistrar, 0, _T("Error no closing %% found\n"));
; 1298 : 					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
; 1299 : 					break;
; 1300 : 				}
; 1301 : 				if ((lpszNext-m_pchCur) > 31)

  0019d	8b cf		 mov	 ecx, edi
  0019f	2b 0e		 sub	 ecx, DWORD PTR [esi]
  001a1	d1 f9		 sar	 ecx, 1
  001a3	83 f9 1f	 cmp	 ecx, 31			; 0000001fH
  001a6	0f 8f 87 00 00
	00		 jg	 $LN69@PreProcess
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 138  : 	return ATLMFC_CRT_ERRORCHECK(::_tcsncpy_s(_Dest, _SizeInChars, _Source,_Count));

  001ac	51		 push	 ecx
  001ad	ff 36		 push	 DWORD PTR [esi]
  001af	8d 45 bc	 lea	 eax, DWORD PTR _buf$1[ebp]
  001b2	6a 20		 push	 32			; 00000020H
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 _wcsncpy_s
  001ba	50		 push	 eax
  001bb	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1309 : 				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);

  001c0	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  001c3	8d 45 bc	 lea	 eax, DWORD PTR _buf$1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 138  : 	return ATLMFC_CRT_ERRORCHECK(::_tcsncpy_s(_Dest, _SizeInChars, _Source,_Count));

  001c6	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 1309 : 				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);

  001c9	89 45 b0	 mov	 DWORD PTR _lpszKey$[ebp], eax

; 649  : 	LPCOLESTR lpsz = m_RepMap.Lookup(lpszKey);

  001cc	8d 45 b0	 lea	 eax, DWORD PTR _lpszKey$[ebp]
  001cf	83 c1 04	 add	 ecx, 4
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ?Lookup@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQA_W@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup

; 1310 : 				if (lpszVar == NULL)

  001d8	85 c0		 test	 eax, eax
  001da	74 5e		 je	 SHORT $LN68@PreProcess

; 1311 : 				{
; 1312 : 					hr = GenerateError(E_ATL_NOT_IN_MAP);
; 1313 : 					break;
; 1314 : 				}
; 1315 : 				if (!pb.AddString(lpszVar))

  001dc	50		 push	 eax
  001dd	8d 4d a4	 lea	 ecx, DWORD PTR _pb$[ebp]
  001e0	e8 00 00 00 00	 call	 ?AddString@CParseBuffer@CRegParser@ATL@@QAEHPB_W@Z ; ATL::CRegParser::CParseBuffer::AddString
  001e5	85 c0		 test	 eax, eax
  001e7	0f 84 35 ff ff
	ff		 je	 $LN72@PreProcess

; 1316 : 				{
; 1317 : 					hr = E_OUTOFMEMORY;
; 1318 : 					break;
; 1319 : 				}
; 1320 : 
; 1321 : 				while (m_pchCur != lpszNext)

  001ed	39 3e		 cmp	 DWORD PTR [esi], edi
  001ef	74 23		 je	 SHORT $LN33@PreProcess
$LL4@PreProcess:

; 1322 : 					m_pchCur = CharNext(m_pchCur);

  001f1	ff 36		 push	 DWORD PTR [esi]
  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  001f9	89 06		 mov	 DWORD PTR [esi], eax
  001fb	3b c7		 cmp	 eax, edi
  001fd	75 f2		 jne	 SHORT $LL4@PreProcess

; 1323 : 			}
; 1324 : 		}

  001ff	eb 13		 jmp	 SHORT $LN33@PreProcess
$LN24@PreProcess:

; 1325 : 		else
; 1326 : 		{
; 1327 : 			if (!pb.AddChar(m_pchCur))
; 1328 : 			{
; 1329 : 				hr = E_OUTOFMEMORY;
; 1330 : 				break;
; 1331 : 			}
; 1332 : 		}
; 1333 : 
; 1334 : 		m_pchCur = CharNext(m_pchCur);

  00201	6a 01		 push	 1
  00203	50		 push	 eax
  00204	8d 4d a4	 lea	 ecx, DWORD PTR _pb$[ebp]
  00207	e8 00 00 00 00	 call	 ?Append@CParseBuffer@CRegParser@ATL@@QAEHPB_WH@Z ; ATL::CRegParser::CParseBuffer::Append
  0020c	85 c0		 test	 eax, eax
  0020e	0f 84 0e ff ff
	ff		 je	 $LN72@PreProcess
$LN33@PreProcess:
  00214	ff 36		 push	 DWORD PTR [esi]
  00216	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  0021c	8b f8		 mov	 edi, eax
  0021e	89 3e		 mov	 DWORD PTR [esi], edi
  00220	66 39 1f	 cmp	 WORD PTR [edi], bx
  00223	74 1c		 je	 SHORT $LN79@PreProcess

; 1202 : 
; 1203 : 	while (*m_pchCur != _T('\0')) // look for end

  00225	8b 45 b4	 mov	 eax, DWORD PTR _nNestingLevel$1$[ebp]
  00228	8a 4d bb	 mov	 cl, BYTE PTR _bInsideQuotes$1$[ebp]
  0022b	8a 55 b9	 mov	 dl, BYTE PTR _bRedirectionEnabled$1$[ebp]
  0022e	e9 50 fe ff ff	 jmp	 $LL2@PreProcess
$LN69@PreProcess:

; 1302 : 				{
; 1303 : 					hr = E_FAIL;

  00233	bb 05 40 00 80	 mov	 ebx, -2147467259	; 80004005H

; 1304 : 					break;

  00238	eb 12		 jmp	 SHORT $LN34@PreProcess
$LN68@PreProcess:

; 240  : 			CoTaskMemFree(p);

  0023a	bb 09 00 02 80	 mov	 ebx, -2147352567	; 80020009H
  0023f	eb 0b		 jmp	 SHORT $LN34@PreProcess
$LN79@PreProcess:

; 1335 : 	}
; 1336 : 	if (SUCCEEDED(hr))
; 1337 : 		*ppszReg = pb.Detach();

  00241	8b 45 9c	 mov	 eax, DWORD PTR _ppszReg$GSCopy$1$[ebp]

; 303  : 			LPTSTR lp = p;

  00244	8b 4d ac	 mov	 ecx, DWORD PTR _pb$[ebp+8]

; 304  : 			p = NULL;

  00247	89 5d ac	 mov	 DWORD PTR _pb$[ebp+8], ebx

; 1335 : 	}
; 1336 : 	if (SUCCEEDED(hr))
; 1337 : 		*ppszReg = pb.Detach();

  0024a	89 08		 mov	 DWORD PTR [eax], ecx
$LN34@PreProcess:

; 240  : 			CoTaskMemFree(p);

  0024c	ff 75 ac	 push	 DWORD PTR _pb$[ebp+8]
  0024f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemFree@4

; 1338 : 	return hr;

  00255	8b c3		 mov	 eax, ebx
  00257	5b		 pop	 ebx
  00258	eb 05		 jmp	 SHORT $LN1@PreProcess
$LN7@PreProcess:

; 1180 : 		return E_POINTER;

  0025a	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@PreProcess:

; 1339 : }

  0025f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00262	5f		 pop	 edi
  00263	33 cd		 xor	 ecx, ebp
  00265	5e		 pop	 esi
  00266	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026b	c9		 leave
  0026c	c2 08 00	 ret	 8
?PreProcessBuffer@CRegParser@ATL@@QAEJPA_WPAPA_W@Z ENDP	; ATL::CRegParser::PreProcessBuffer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?ClearReplacements@CExpansionVector@ATL@@QAEJXZ
_TEXT	SEGMENT
?ClearReplacements@CExpansionVector@ATL@@QAEJXZ PROC	; ATL::CExpansionVector::ClearReplacements, COMDAT
; _this$ = ecx

; 152  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 153  : 		for (int i = 0; i < GetSize(); i++)

  00004	33 ff		 xor	 edi, edi
  00006	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  00009	7e 26		 jle	 SHORT $LN3@ClearRepla
$LL4@ClearRepla:

; 154  : 		{
; 155  : 			delete []GetKeyAt(i);

  0000b	57		 push	 edi
  0000c	8b ce		 mov	 ecx, esi
  0000e	e8 00 00 00 00	 call	 ?GetKeyAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetKeyAt
  00013	ff 30		 push	 DWORD PTR [eax]
  00015	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0001a	59		 pop	 ecx

; 156  : 			delete []GetValueAt(i);

  0001b	57		 push	 edi
  0001c	8b ce		 mov	 ecx, esi
  0001e	e8 00 00 00 00	 call	 ?GetValueAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt
  00023	ff 30		 push	 DWORD PTR [eax]
  00025	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002a	47		 inc	 edi
  0002b	59		 pop	 ecx
  0002c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0002f	7c da		 jl	 SHORT $LL4@ClearRepla
$LN3@ClearRepla:

; 157  : 		}
; 158  : 		RemoveAll();

  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll

; 159  : 		return S_OK;

  00038	5f		 pop	 edi
  00039	33 c0		 xor	 eax, eax
  0003b	5e		 pop	 esi

; 160  : 	}

  0003c	c3		 ret	 0
?ClearReplacements@CExpansionVector@ATL@@QAEJXZ ENDP	; ATL::CExpansionVector::ClearReplacements
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
;	COMDAT ?Add@CExpansionVector@ATL@@QAEHPB_W0@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
_szValue$ = -16						; size = 4
_cbValue$1$ = -12					; size = 4
_cbKey$1$ = -8						; size = 4
_szKey$ = -4						; size = 4
_lpszKey$ = 8						; size = 4
_lpszValue$ = 12					; size = 4
?Add@CExpansionVector@ATL@@QAEHPB_W0@Z PROC		; ATL::CExpansionVector::Add, COMDAT
; _this$ = ecx

; 111  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 112  : 		ATLASSERT(lpszKey != NULL && lpszValue != NULL);
; 113  : 		if (lpszKey == NULL || lpszValue == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _lpszKey$[ebp], 0
  0000a	89 4d ec	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000d	0f 84 f0 00 00
	00		 je	 $LN9@Add
  00013	83 7d 0c 00	 cmp	 DWORD PTR _lpszValue$[ebp], 0
  00017	0f 84 e6 00 00
	00		 je	 $LN9@Add

; 115  : 
; 116  : 		HRESULT hRes = S_OK;
; 117  : 
; 118  : 		size_t cbKey = (_tcslen(lpszKey)+1)*sizeof(TCHAR);

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _lpszKey$[ebp]
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	6a 02		 push	 2
  00024	33 f6		 xor	 esi, esi
  00026	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
  00029	5b		 pop	 ebx
$LL35@Add:
  0002a	66 8b 01	 mov	 ax, WORD PTR [ecx]
  0002d	03 cb		 add	 ecx, ebx
  0002f	66 3b c6	 cmp	 ax, si
  00032	75 f6		 jne	 SHORT $LL35@Add
  00034	2b ca		 sub	 ecx, edx
  00036	d1 f9		 sar	 ecx, 1

; 121  : 		szKey = _ATL_NEW TCHAR[cbKey];

  00038	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0003d	8d 04 4d 02 00
	00 00		 lea	 eax, DWORD PTR [ecx*2+2]
  00044	33 c9		 xor	 ecx, ecx
  00046	89 45 f8	 mov	 DWORD PTR _cbKey$1$[ebp], eax
  00049	f7 e3		 mul	 ebx
  0004b	0f 90 c1	 seto	 cl
  0004e	f7 d9		 neg	 ecx
  00050	0b c8		 or	 ecx, eax
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  00058	59		 pop	 ecx
  00059	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h

; 737  : 	return static_cast<int>(wcslen(x));

  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _lpszValue$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 121  : 		szKey = _ATL_NEW TCHAR[cbKey];

  0005d	89 45 fc	 mov	 DWORD PTR _szKey$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h

; 737  : 	return static_cast<int>(wcslen(x));

  00060	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL36@Add:
  00063	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00066	03 cb		 add	 ecx, ebx
  00068	66 3b c6	 cmp	 ax, si
  0006b	75 f6		 jne	 SHORT $LL36@Add
  0006d	2b ca		 sub	 ecx, edx
  0006f	d1 f9		 sar	 ecx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 128  : 		szValue = _ATL_NEW OLECHAR[cbValue];

  00071	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  00076	8d 04 4d 02 00
	00 00		 lea	 eax, DWORD PTR [ecx*2+2]
  0007d	33 c9		 xor	 ecx, ecx
  0007f	89 45 f4	 mov	 DWORD PTR _cbValue$1$[ebp], eax
  00082	f7 e3		 mul	 ebx
  00084	0f 90 c1	 seto	 cl
  00087	f7 d9		 neg	 ecx
  00089	0b c8		 or	 ecx, eax
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 ??_U@YAPAXIABUnothrow_t@std@@@Z ; operator new[]
  00091	8b d8		 mov	 ebx, eax

; 129  : 		CAutoVectorPtr<OLECHAR> spValue;
; 130  : 		ATLASSUME(szValue != NULL);
; 131  : 		spValue.Attach(szValue);

  00093	8b 45 fc	 mov	 eax, DWORD PTR _szKey$[ebp]
  00096	89 5d f0	 mov	 DWORD PTR _szValue$[ebp], ebx
  00099	59		 pop	 ecx
  0009a	59		 pop	 ecx
  0009b	85 c0		 test	 eax, eax

; 132  : 
; 133  : 		if (szKey == NULL || szValue == NULL)

  0009d	74 37		 je	 SHORT $LN12@Add
  0009f	85 db		 test	 ebx, ebx
  000a1	74 33		 je	 SHORT $LN12@Add

; 134  : 			hRes = E_OUTOFMEMORY;
; 135  : 		else
; 136  : 		{
; 137  : 			Checked::memcpy_s(szKey, cbKey, lpszKey, cbKey);

  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _cbKey$1$[ebp]
  000a6	51		 push	 ecx
  000a7	ff 75 08	 push	 DWORD PTR _lpszKey$[ebp]
  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 138  : 			Checked::memcpy_s(szValue, cbValue, lpszValue, cbValue);

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _cbValue$1$[ebp]
  000b4	50		 push	 eax
  000b5	ff 75 0c	 push	 DWORD PTR _lpszValue$[ebp]
  000b8	50		 push	 eax
  000b9	53		 push	 ebx
  000ba	e8 00 00 00 00	 call	 ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ; ATL::Checked::memcpy_s

; 139  : 			if (!CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper>::Add(szKey, szValue))

  000bf	8b 4d ec	 mov	 ecx, DWORD PTR _this$1$[ebp]
  000c2	8d 45 f0	 lea	 eax, DWORD PTR _szValue$[ebp]
  000c5	83 c4 20	 add	 esp, 32			; 00000020H
  000c8	50		 push	 eax
  000c9	8d 45 fc	 lea	 eax, DWORD PTR _szKey$[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ?Add@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQA_W0@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add
  000d2	85 c0		 test	 eax, eax
  000d4	75 05		 jne	 SHORT $LN13@Add
$LN12@Add:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 827  : 		delete[] m_p;

  000d6	be 0e 00 07 80	 mov	 esi, -2147024882	; 8007000eH
$LN13@Add:
  000db	33 c0		 xor	 eax, eax
  000dd	85 f6		 test	 esi, esi
  000df	0f 48 c3	 cmovs	 eax, ebx
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000e8	33 c9		 xor	 ecx, ecx
  000ea	85 f6		 test	 esi, esi
  000ec	0f 48 4d fc	 cmovs	 ecx, DWORD PTR _szKey$[ebp]
  000f0	51		 push	 ecx
  000f1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000f6	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 147  : 		return SUCCEEDED(hRes);

  000f7	f7 d6		 not	 esi
  000f9	c1 ee 1f	 shr	 esi, 31			; 0000001fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 827  : 		delete[] m_p;

  000fc	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 147  : 		return SUCCEEDED(hRes);

  000fd	8b c6		 mov	 eax, esi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	eb 02		 jmp	 SHORT $LN1@Add
$LN9@Add:

; 114  : 			return FALSE;

  00103	33 c0		 xor	 eax, eax
$LN1@Add:

; 148  : 	}

  00105	c9		 leave
  00106	c2 08 00	 ret	 8
?Add@CExpansionVector@ATL@@QAEHPB_W0@Z ENDP		; ATL::CExpansionVector::Add
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?InternalSetAtIndex@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQA_W0@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_key$ = 12						; size = 4
_val$ = 16						; size = 4
?InternalSetAtIndex@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQA_W0@Z PROC ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex, COMDAT
; _this$ = ecx

; 513  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 514  : 		new(m_aKey + nIndex) Wrapper<TKey>(key);

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR _nIndex$[ebp]
  00009	c1 e6 02	 shl	 esi, 2
  0000c	03 d6		 add	 edx, esi
  0000e	74 07		 je	 SHORT $LN3@InternalSe

; 491  : 		Wrapper(_In_ const T& _t) : t(_t)

  00010	8b 45 0c	 mov	 eax, DWORD PTR _key$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 02		 mov	 DWORD PTR [edx], eax
$LN3@InternalSe:

; 515  : 		new(m_aVal + nIndex) Wrapper<TVal>(val);

  00017	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001a	03 ce		 add	 ecx, esi
  0001c	5e		 pop	 esi
  0001d	74 07		 je	 SHORT $LN5@InternalSe

; 491  : 		Wrapper(_In_ const T& _t) : t(_t)

  0001f	8b 45 10	 mov	 eax, DWORD PTR _val$[ebp]
  00022	8b 00		 mov	 eax, DWORD PTR [eax]
  00024	89 01		 mov	 DWORD PTR [ecx], eax
$LN5@InternalSe:

; 516  : 	}

  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
?InternalSetAtIndex@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQA_W0@Z ENDP ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?FindKey@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQA_W@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?FindKey@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQA_W@Z PROC ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey, COMDAT
; _this$ = ecx

; 455  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 456  : 		for(int i = 0; i < m_nSize; i++)

  00008	33 f6		 xor	 esi, esi
  0000a	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  0000d	7e 1a		 jle	 SHORT $LN3@FindKey
  0000f	8b 5d 08	 mov	 ebx, DWORD PTR _key$[ebp]
$LL4@FindKey:

; 457  : 		{
; 458  : 			if(TEqual::IsEqualKey(m_aKey[i], key))

  00012	8b 07		 mov	 eax, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\statreg.h

; 83   : 		if (lstrcmpi(k1, k2) == 0)

  00014	ff 33		 push	 DWORD PTR [ebx]
  00016	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiW@8
  0001f	85 c0		 test	 eax, eax
  00021	74 10		 je	 SHORT $LN11@FindKey
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 456  : 		for(int i = 0; i < m_nSize; i++)

  00023	46		 inc	 esi
  00024	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00027	7c e9		 jl	 SHORT $LL4@FindKey
$LN3@FindKey:

; 460  : 		}
; 461  : 		return -1;  // not found

  00029	83 c8 ff	 or	 eax, -1
$LN1@FindKey:
  0002c	5f		 pop	 edi

; 462  : 	}

  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN11@FindKey:

; 459  : 				return i;

  00033	8b c6		 mov	 eax, esi
  00035	eb f5		 jmp	 SHORT $LN1@FindKey
?FindKey@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQA_W@Z ENDP ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetValueAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetValueAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z PROC ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt, COMDAT
; _this$ = ecx

; 446  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 447  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 448  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0f		 js	 SHORT $LN3@GetValueAt
  0000a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0000d	7d 0a		 jge	 SHORT $LN3@GetValueAt

; 450  : 
; 451  : 		return m_aVal[nIndex];

  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00012	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 452  : 	}

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN3@GetValueAt:

; 449  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00019	6a 01		 push	 1
  0001b	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  00020	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN5@GetValueAt:
  00025	cc		 int	 3
?GetValueAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ENDP ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?GetKeyAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetKeyAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z PROC ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetKeyAt, COMDAT
; _this$ = ecx

; 438  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 440  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0e		 js	 SHORT $LN3@GetKeyAt
  0000a	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0000d	7d 09		 jge	 SHORT $LN3@GetKeyAt

; 442  : 
; 443  : 		return m_aKey[nIndex];

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]

; 444  : 	}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@GetKeyAt:

; 441  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00018	6a 01		 push	 1
  0001a	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0001f	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN5@GetKeyAt:
  00024	cc		 int	 3
?GetKeyAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ENDP ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetKeyAt
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?Lookup@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQA_W@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
?Lookup@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQA_W@Z PROC ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup, COMDAT
; _this$ = ecx

; 424  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 425  : 		int nIndex = FindKey(key);

  00004	ff 75 08	 push	 DWORD PTR _key$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	e8 00 00 00 00	 call	 ?FindKey@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEHABQA_W@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::FindKey

; 426  : 		if(nIndex == -1)

  0000e	83 f8 ff	 cmp	 eax, -1
  00011	75 04		 jne	 SHORT $LN2@Lookup

; 427  : 			return NULL;    // must be able to convert

  00013	33 c0		 xor	 eax, eax
  00015	eb 0a		 jmp	 SHORT $LN1@Lookup
$LN2@Lookup:

; 428  : 		return GetValueAt(nIndex);

  00017	50		 push	 eax
  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?GetValueAt@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEAAPA_WH@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::GetValueAt
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Lookup:
  00021	5e		 pop	 esi

; 429  : 	}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?Lookup@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QBEPA_WABQA_W@Z ENDP ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Lookup
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll, COMDAT
; _this$ = ecx

; 391  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 392  : 		if(m_aKey != NULL)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0b		 je	 SHORT $LN5@RemoveAll

; 393  : 		{
; 394  : 			for(int i = 0; i < m_nSize; i++)
; 395  : 			{
; 396  : 				m_aKey[i].~TKey();
; 397  : 				m_aVal[i].~TVal();
; 398  : 			}
; 399  : 			free(m_aKey);

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 _free

; 400  : 			m_aKey = NULL;

  0000f	83 26 00	 and	 DWORD PTR [esi], 0
  00012	59		 pop	 ecx
$LN5@RemoveAll:

; 401  : 		}
; 402  : 		if(m_aVal != NULL)

  00013	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00017	74 0d		 je	 SHORT $LN6@RemoveAll

; 403  : 		{
; 404  : 			free(m_aVal);

  00019	ff 76 04	 push	 DWORD PTR [esi+4]
  0001c	e8 00 00 00 00	 call	 _free

; 405  : 			m_aVal = NULL;

  00021	83 66 04 00	 and	 DWORD PTR [esi+4], 0
  00025	59		 pop	 ecx
$LN6@RemoveAll:

; 406  : 		}
; 407  : 
; 408  : 		m_nSize = 0;

  00026	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  0002a	5e		 pop	 esi

; 409  : 	}

  0002b	c3		 ret	 0
?RemoveAll@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?Add@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQA_W0@Z
_TEXT	SEGMENT
_key$ = 8						; size = 4
_val$ = 12						; size = 4
?Add@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQA_W0@Z PROC ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add, COMDAT
; _this$ = ecx

; 345  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 346  : 		TKey* pKey;
; 347  : 		pKey = (TKey*)_recalloc(m_aKey, (m_nSize + 1), sizeof(TKey));

  00006	6a 04		 push	 4
  00008	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000b	40		 inc	 eax
  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 __recalloc
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 348  : 		if(pKey == NULL)

  00017	85 c0		 test	 eax, eax
  00019	74 33		 je	 SHORT $LN5@Add

; 349  : 			return FALSE;
; 350  : 		m_aKey = pKey;

  0001b	89 06		 mov	 DWORD PTR [esi], eax

; 351  : 		TVal* pVal;
; 352  : 		pVal = (TVal*)_recalloc(m_aVal, (m_nSize + 1), sizeof(TVal));

  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	6a 04		 push	 4
  00022	40		 inc	 eax
  00023	50		 push	 eax
  00024	ff 76 04	 push	 DWORD PTR [esi+4]
  00027	e8 00 00 00 00	 call	 __recalloc
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 353  : 		if(pVal == NULL)

  0002f	85 c0		 test	 eax, eax
  00031	74 1b		 je	 SHORT $LN5@Add

; 355  : 		m_aVal = pVal;
; 356  : 		InternalSetAtIndex(m_nSize, key, val);

  00033	ff 75 0c	 push	 DWORD PTR _val$[ebp]
  00036	8b ce		 mov	 ecx, esi
  00038	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0003b	ff 75 08	 push	 DWORD PTR _key$[ebp]
  0003e	ff 76 08	 push	 DWORD PTR [esi+8]
  00041	e8 00 00 00 00	 call	 ?InternalSetAtIndex@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEXHABQA_W0@Z ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::InternalSetAtIndex

; 357  : 		m_nSize++;

  00046	ff 46 08	 inc	 DWORD PTR [esi+8]

; 358  : 		return TRUE;

  00049	33 c0		 xor	 eax, eax
  0004b	40		 inc	 eax
  0004c	eb 02		 jmp	 SHORT $LN1@Add
$LN5@Add:

; 354  : 			return FALSE;

  0004e	33 c0		 xor	 eax, eax
$LN1@Add:
  00050	5e		 pop	 esi

; 359  : 	}

  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
?Add@?$CSimpleMap@PA_WPA_WVCExpansionVectorEqualHelper@ATL@@@ATL@@QAEHABQA_W0@Z ENDP ; ATL::CSimpleMap<wchar_t *,wchar_t *,ATL::CExpansionVectorEqualHelper>::Add
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??_GCComModule@ATL@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCComModule@ATL@@UAEPAXI@Z PROC			; ATL::CComModule::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4716 : 	{

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CComModule@ATL@@6B@

; 3082 : 		Term();

  0000c	e8 00 00 00 00	 call	 ?Term@CAtlModule@ATL@@QAEXXZ ; ATL::CAtlModule::Term
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 0a		 je	 SHORT $LN2@scalar
  00017	6a 30		 push	 48			; 00000030H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001f	59		 pop	 ecx
  00020	59		 pop	 ecx
$LN2@scalar:
  00021	8b c6		 mov	 eax, esi
  00023	5e		 pop	 esi
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
??_GCComModule@ATL@@UAEPAXI@Z ENDP			; ATL::CComModule::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?UpdateRegistryFromResource@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_nResID$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResource@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z PROC ; ATL::CComModule::UpdateRegistryFromResource, COMDAT

; 4912 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4914 : 	}

  00003	5d		 pop	 ebp

; 4913 : 		return CAtlModuleT<CComModule>::UpdateRegistryFromResource(nResID, bRegister, pMapEntries);

  00004	e9 00 00 00 00	 jmp	 ?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CAtlModule::UpdateRegistryFromResource
?UpdateRegistryFromResource@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CComModule::UpdateRegistryFromResource
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?UpdateRegistryFromResource@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_lpszRes$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResource@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z PROC ; ATL::CComModule::UpdateRegistryFromResource, COMDAT

; 4905 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4907 : 	}

  00003	5d		 pop	 ebp

; 4906 : 		return CAtlModuleT<CComModule>::UpdateRegistryFromResource(lpszRes, bRegister, pMapEntries);

  00004	e9 00 00 00 00	 jmp	 ?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z ; ATL::CAtlModule::UpdateRegistryFromResource
?UpdateRegistryFromResource@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CComModule::UpdateRegistryFromResource
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_nResID$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z PROC ; ATL::CComModule::UpdateRegistryFromResourceD, COMDAT

; 4895 : 		(nResID);
; 4896 : 		(bRegister);
; 4897 : 		(pMapEntries);
; 4898 : 		return E_FAIL;

  00000	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H

; 4899 : 	}

  00005	c2 10 00	 ret	 16			; 00000010H
?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CComModule::UpdateRegistryFromResourceD
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_lpszRes$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z PROC ; ATL::CComModule::UpdateRegistryFromResourceD, COMDAT

; 4884 : 		(lpszRes);
; 4885 : 		(bRegister);
; 4886 : 		(pMapEntries);
; 4887 : 		return E_FAIL;

  00000	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H

; 4888 : 	}

  00005	c2 10 00	 ret	 16			; 00000010H
?UpdateRegistryFromResourceD@CComModule@ATL@@UAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CComModule::UpdateRegistryFromResourceD
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_bUnRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z PROC ; ATL::CComModule::UnregisterServer, COMDAT
; _this$ = ecx

; 7952 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c1		 mov	 eax, ecx

; 7953 : 	HRESULT hr = S_OK;

  00006	33 d2		 xor	 edx, edx
  00008	53		 push	 ebx

; 7954 : 	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
; 7955 : 	if (pEntry != NULL)

  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _pCLSID$[ebp]
  0000c	56		 push	 esi
  0000d	8b 70 2c	 mov	 esi, DWORD PTR [eax+44]
  00010	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  00013	57		 push	 edi
  00014	85 f6		 test	 esi, esi
  00016	74 48		 je	 SHORT $LN21@Unregister

; 7956 : 	{
; 7957 : 		for (;pEntry->pclsid != NULL; pEntry++)

  00018	8b 3e		 mov	 edi, DWORD PTR [esi]
  0001a	85 ff		 test	 edi, edi
  0001c	74 42		 je	 SHORT $LN21@Unregister
$LL4@Unregister:

; 7958 : 		{
; 7959 : 			if (pCLSID != NULL)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN19@Unregister
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00022	33 c9		 xor	 ecx, ecx
$LL22@Unregister:
  00024	8b 04 8b	 mov	 eax, DWORD PTR [ebx+ecx*4]
  00027	3b 04 8f	 cmp	 eax, DWORD PTR [edi+ecx*4]
  0002a	75 24		 jne	 SHORT $LN2@Unregister
  0002c	41		 inc	 ecx
  0002d	83 f9 04	 cmp	 ecx, 4
  00030	75 f2		 jne	 SHORT $LL22@Unregister
$LN19@Unregister:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7964 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,

  00032	6a 00		 push	 0
  00034	ff 56 1c	 call	 DWORD PTR [esi+28]
  00037	50		 push	 eax
  00038	ff 36		 push	 DWORD PTR [esi]
  0003a	e8 00 00 00 00	 call	 ?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
  0003f	8b d0		 mov	 edx, eax

; 7965 : 				pEntry->pfnGetCategoryMap(), FALSE );
; 7966 : 			if (FAILED(hr))

  00041	85 d2		 test	 edx, edx
  00043	78 28		 js	 SHORT $LN10@Unregister

; 7967 : 				break;
; 7968 : 			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister

  00045	6a 00		 push	 0
  00047	ff 56 04	 call	 DWORD PTR [esi+4]
  0004a	8b d0		 mov	 edx, eax

; 7969 : 			if (FAILED(hr))

  0004c	85 d2		 test	 edx, edx
  0004e	78 1d		 js	 SHORT $LN10@Unregister
$LN2@Unregister:

; 7956 : 	{
; 7957 : 		for (;pEntry->pclsid != NULL; pEntry++)

  00050	83 c6 24	 add	 esi, 36			; 00000024H
  00053	8b 3e		 mov	 edi, DWORD PTR [esi]
  00055	85 ff		 test	 edi, edi
  00057	75 c5		 jne	 SHORT $LL4@Unregister

; 7970 : 				break;
; 7971 : 		}
; 7972 : 	}
; 7973 : 	if (SUCCEEDED(hr))

  00059	85 d2		 test	 edx, edx
  0005b	78 10		 js	 SHORT $LN10@Unregister
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
$LN21@Unregister:

; 7974 : 		hr = CAtlModuleT<CComModule>::UnregisterServer(bUnRegTypeLib, pCLSID);

  00060	53		 push	 ebx
  00061	ff 75 08	 push	 DWORD PTR _bUnRegTypeLib$[ebp]
  00064	8b c8		 mov	 ecx, eax
  00066	e8 00 00 00 00	 call	 ?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::UnregisterServer
  0006b	8b d0		 mov	 edx, eax
$LN10@Unregister:

; 7975 : 	return hr;

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	8b c2		 mov	 eax, edx
  00071	5b		 pop	 ebx

; 7976 : }

  00072	c9		 leave
  00073	c2 08 00	 ret	 8
?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ENDP ; ATL::CComModule::UnregisterServer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_bRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z PROC	; ATL::CComModule::RegisterServer, COMDAT
; _this$ = ecx

; 7923 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c1		 mov	 eax, ecx

; 7924 : 	HRESULT hr = S_OK;

  00006	33 d2		 xor	 edx, edx
  00008	53		 push	 ebx

; 7925 : 	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
; 7926 : 	if (pEntry != NULL)

  00009	8b 5d 0c	 mov	 ebx, DWORD PTR _pCLSID$[ebp]
  0000c	56		 push	 esi
  0000d	8b 70 2c	 mov	 esi, DWORD PTR [eax+44]
  00010	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  00013	57		 push	 edi
  00014	85 f6		 test	 esi, esi
  00016	74 48		 je	 SHORT $LN21@RegisterSe

; 7927 : 	{
; 7928 : 		for (;pEntry->pclsid != NULL; pEntry++)

  00018	8b 3e		 mov	 edi, DWORD PTR [esi]
  0001a	85 ff		 test	 edi, edi
  0001c	74 42		 je	 SHORT $LN21@RegisterSe
$LL4@RegisterSe:

; 7929 : 		{
; 7930 : 			if (pCLSID != NULL)

  0001e	85 db		 test	 ebx, ebx
  00020	74 10		 je	 SHORT $LN19@RegisterSe
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00022	33 c9		 xor	 ecx, ecx
$LL22@RegisterSe:
  00024	8b 04 8b	 mov	 eax, DWORD PTR [ebx+ecx*4]
  00027	3b 04 8f	 cmp	 eax, DWORD PTR [edi+ecx*4]
  0002a	75 24		 jne	 SHORT $LN2@RegisterSe
  0002c	41		 inc	 ecx
  0002d	83 f9 04	 cmp	 ecx, 4
  00030	75 f2		 jne	 SHORT $LL22@RegisterSe
$LN19@RegisterSe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7935 : 			hr = pEntry->pfnUpdateRegistry(TRUE);

  00032	6a 01		 push	 1
  00034	ff 56 04	 call	 DWORD PTR [esi+4]
  00037	8b d0		 mov	 edx, eax

; 7936 : 			if (FAILED(hr))

  00039	85 d2		 test	 edx, edx
  0003b	78 30		 js	 SHORT $LN10@RegisterSe

; 7937 : 				break;
; 7938 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,

  0003d	6a 01		 push	 1
  0003f	ff 56 1c	 call	 DWORD PTR [esi+28]
  00042	50		 push	 eax
  00043	ff 36		 push	 DWORD PTR [esi]
  00045	e8 00 00 00 00	 call	 ?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
  0004a	8b d0		 mov	 edx, eax

; 7939 : 				pEntry->pfnGetCategoryMap(), TRUE );
; 7940 : 			if (FAILED(hr))

  0004c	85 d2		 test	 edx, edx
  0004e	78 1d		 js	 SHORT $LN10@RegisterSe
$LN2@RegisterSe:

; 7927 : 	{
; 7928 : 		for (;pEntry->pclsid != NULL; pEntry++)

  00050	83 c6 24	 add	 esi, 36			; 00000024H
  00053	8b 3e		 mov	 edi, DWORD PTR [esi]
  00055	85 ff		 test	 edi, edi
  00057	75 c5		 jne	 SHORT $LL4@RegisterSe

; 7941 : 				break;
; 7942 : 		}
; 7943 : 	}
; 7944 : 	if (SUCCEEDED(hr))

  00059	85 d2		 test	 edx, edx
  0005b	78 10		 js	 SHORT $LN10@RegisterSe
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
$LN21@RegisterSe:

; 7945 : 		hr = CAtlModuleT<CComModule>::RegisterServer(bRegTypeLib, pCLSID);

  00060	53		 push	 ebx
  00061	ff 75 08	 push	 DWORD PTR _bRegTypeLib$[ebp]
  00064	8b c8		 mov	 ecx, eax
  00066	e8 00 00 00 00	 call	 ?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CAtlModuleT<ATL::CComModule>::RegisterServer
  0006b	8b d0		 mov	 edx, eax
$LN10@RegisterSe:

; 7946 : 	return hr;

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	8b c2		 mov	 eax, edx
  00071	5b		 pop	 ebx

; 7947 : }

  00072	c9		 leave
  00073	c2 08 00	 ret	 8
?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ENDP	; ATL::CComModule::RegisterServer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z
_TEXT	SEGMENT
_rclsid$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z PROC ; ATL::CComModule::GetClassObject, COMDAT
; _this$ = ecx

; 7816 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7817 : 	*ppv = NULL;

  00003	8b 45 10	 mov	 eax, DWORD PTR _ppv$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi

; 7818 : 	HRESULT hr = S_OK;

  00008	33 ff		 xor	 edi, edi
  0000a	83 20 00	 and	 DWORD PTR [eax], 0

; 7819 : 
; 7820 : 	if (m_pObjMap != NULL)

  0000d	8b 71 2c	 mov	 esi, DWORD PTR [ecx+44]
  00010	85 f6		 test	 esi, esi
  00012	74 67		 je	 SHORT $LN62@GetClassOb

; 7821 : 	{
; 7822 : 		const _ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
; 7823 : 
; 7824 : 		while (pEntry->pclsid != NULL)

  00014	eb 17		 jmp	 SHORT $LN64@GetClassOb
$LL2@GetClassOb:

; 7825 : 		{
; 7826 : 			if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))

  00016	39 7e 08	 cmp	 DWORD PTR [esi+8], edi
  00019	74 0f		 je	 SHORT $LN5@GetClassOb
  0001b	50		 push	 eax
  0001c	ff 75 08	 push	 DWORD PTR _rclsid$[ebp]
  0001f	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
  00026	85 c0		 test	 eax, eax
  00028	75 0b		 jne	 SHORT $LN54@GetClassOb
$LN5@GetClassOb:

; 7848 : 				}
; 7849 : 				break;
; 7850 : 			}
; 7851 : 			pEntry++;

  0002a	83 c6 24	 add	 esi, 36			; 00000024H
$LN64@GetClassOb:

; 7821 : 	{
; 7822 : 		const _ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
; 7823 : 
; 7824 : 		while (pEntry->pclsid != NULL)

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	85 c0		 test	 eax, eax
  00031	75 e3		 jne	 SHORT $LL2@GetClassOb
  00033	eb 46		 jmp	 SHORT $LN62@GetClassOb
$LN54@GetClassOb:
  00035	53		 push	 ebx

; 7827 : 			{
; 7828 : 				if (pEntry->pCF == NULL)

  00036	8d 5e 10	 lea	 ebx, DWORD PTR [esi+16]
  00039	39 3b		 cmp	 DWORD PTR [ebx], edi
  0003b	75 2a		 jne	 SHORT $LN44@GetClassOb
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  0003d	68 10 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7839 : 					if (pEntry->pCF == NULL)

  00048	33 ff		 xor	 edi, edi
  0004a	39 3b		 cmp	 DWORD PTR [ebx], edi
  0004c	75 0e		 jne	 SHORT $LN8@GetClassOb

; 7840 : 					{
; 7841 : 						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), (LPVOID*)&pEntry->pCF);

  0004e	53		 push	 ebx
  0004f	68 00 00 00 00	 push	 OFFSET __GUID_00000000_0000_0000_c000_000000000046
  00054	ff 76 0c	 push	 DWORD PTR [esi+12]
  00057	ff 56 08	 call	 DWORD PTR [esi+8]
  0005a	8b f8		 mov	 edi, eax
$LN8@GetClassOb:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  0005c	68 10 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A+16
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
$LN44@GetClassOb:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7845 : 				if (pEntry->pCF != NULL)

  00067	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00069	5b		 pop	 ebx
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 0d		 je	 SHORT $LN62@GetClassOb

; 7846 : 				{
; 7847 : 					hr = pEntry->pCF->QueryInterface(riid, ppv);

  0006e	ff 75 10	 push	 DWORD PTR _ppv$[ebp]
  00071	8b 01		 mov	 eax, DWORD PTR [ecx]
  00073	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  00076	51		 push	 ecx
  00077	ff 10		 call	 DWORD PTR [eax]
  00079	8b f8		 mov	 edi, eax
$LN62@GetClassOb:

; 7852 : 		}
; 7853 : 	}
; 7854 : 
; 7855 : 	if (*ppv == NULL && hr == S_OK)

  0007b	8b 4d 10	 mov	 ecx, DWORD PTR _ppv$[ebp]
  0007e	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00081	75 17		 jne	 SHORT $LN10@GetClassOb
  00083	85 ff		 test	 edi, edi
  00085	75 13		 jne	 SHORT $LN10@GetClassOb

; 7856 : 	{
; 7857 : 		hr = AtlComModuleGetClassObject(&_AtlComModule, rclsid, riid, ppv);

  00087	51		 push	 ecx
  00088	ff 75 0c	 push	 DWORD PTR _riid$[ebp]
  0008b	ff 75 08	 push	 DWORD PTR _rclsid$[ebp]
  0008e	68 00 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00093	e8 00 00 00 00	 call	 ?AtlComModuleGetClassObject@ATL@@YGJPAU_ATL_COM_MODULE70@1@ABU_GUID@@1PAPAX@Z ; ATL::AtlComModuleGetClassObject
  00098	8b f8		 mov	 edi, eax
$LN10@GetClassOb:

; 7858 : 	}
; 7859 : 
; 7860 : 	return hr;

  0009a	8b c7		 mov	 eax, edi
  0009c	5f		 pop	 edi
  0009d	5e		 pop	 esi

; 7861 : }

  0009e	5d		 pop	 ebp
  0009f	c2 0c 00	 ret	 12			; 0000000cH
?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z ENDP ; ATL::CComModule::GetClassObject
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?Term@CComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CComModule@ATL@@QAEXXZ PROC			; ATL::CComModule::Term, COMDAT
; _this$ = ecx

; 7784 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 7785 : 	_ATL_OBJMAP_ENTRY* pEntry;
; 7786 : 	if (m_pObjMap != NULL)

  00005	33 db		 xor	 ebx, ebx
  00007	8b 77 2c	 mov	 esi, DWORD PTR [edi+44]
  0000a	85 f6		 test	 esi, esi
  0000c	74 1d		 je	 SHORT $LN3@Term
  0000e	eb 17		 jmp	 SHORT $LN21@Term
$LL2@Term:

; 7790 : 		{
; 7791 : 			if (pEntry->pCF != NULL)

  00010	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00013	85 c9		 test	 ecx, ecx
  00015	74 06		 je	 SHORT $LN8@Term

; 7792 : 				pEntry->pCF->Release();

  00017	8b 01		 mov	 eax, DWORD PTR [ecx]
  00019	51		 push	 ecx
  0001a	ff 50 08	 call	 DWORD PTR [eax+8]
$LN8@Term:

; 7793 : 			pEntry->pCF = NULL;
; 7794 : 			pEntry->pfnObjectMain(false); //cleanup class resources

  0001d	53		 push	 ebx
  0001e	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00021	ff 56 20	 call	 DWORD PTR [esi+32]

; 7795 : 			pEntry++;

  00024	83 c6 24	 add	 esi, 36			; 00000024H
$LN21@Term:

; 7787 : 	{
; 7788 : 		pEntry = m_pObjMap;
; 7789 : 		while (pEntry->pclsid != NULL)

  00027	39 1e		 cmp	 DWORD PTR [esi], ebx
  00029	75 e5		 jne	 SHORT $LL2@Term
$LN3@Term:

; 7796 : 		}
; 7797 : 	}
; 7798 : 
; 7799 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)

  0002b	8b 35 08 00 00
	00		 mov	 esi, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+8
  00031	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
  00036	eb 12		 jmp	 SHORT $LN22@Term
$LL6@Term:

; 7800 : 	{
; 7801 : 		if (*ppEntry != NULL)

  00038	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 09		 je	 SHORT $LN4@Term

; 7802 : 			(*ppEntry)->pfnObjectMain(false); //cleanup class resources

  0003e	53		 push	 ebx
  0003f	ff 51 1c	 call	 DWORD PTR [ecx+28]
  00042	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
$LN4@Term:

; 7796 : 		}
; 7797 : 	}
; 7798 : 
; 7799 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)

  00047	83 c6 04	 add	 esi, 4
$LN22@Term:
  0004a	3b f0		 cmp	 esi, eax
  0004c	72 ea		 jb	 SHORT $LL6@Term

; 7803 : 	}
; 7804 : #if defined(_DEBUG) && !defined(_ATL_NO_WIN_SUPPORT)
; 7805 : 	// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
; 7806 : 	_AtlWinModule.Term();
; 7807 : #endif	// _DEBUG
; 7808 : 
; 7809 : 	CAtlModuleT<CComModule>::Term();

  0004e	8b cf		 mov	 ecx, edi
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	e9 00 00 00 00	 jmp	 ?Term@CAtlModule@ATL@@QAEXXZ ; ATL::CAtlModule::Term
?Term@CComModule@ATL@@QAEXXZ ENDP			; ATL::CComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
___formal$ = 12						; size = 4
_plibid$ = 16						; size = 4
?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z PROC ; ATL::CComModule::Init, COMDAT
; _this$ = ecx

; 7757 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7758 : 	if (plibid != NULL)

  00004	8b 75 10	 mov	 esi, DWORD PTR _plibid$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 0b		 je	 SHORT $LN7@Init

; 7759 : 		m_libid = *plibid;

  0000b	57		 push	 edi
  0000c	bf 00 00 00 00	 mov	 edi, OFFSET ?m_libid@CAtlModule@ATL@@2U_GUID@@A ; ATL::CAtlModule::m_libid
  00011	a5		 movsd
  00012	a5		 movsd
  00013	a5		 movsd
  00014	a5		 movsd
  00015	5f		 pop	 edi
$LN7@Init:

; 7760 : 
; 7761 : 	_ATL_OBJMAP_ENTRY* pEntry;
; 7762 : 	if (p != (_ATL_OBJMAP_ENTRY*)-1)

  00016	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00019	83 fe ff	 cmp	 esi, -1
  0001c	74 16		 je	 SHORT $LN3@Init

; 7763 : 	{
; 7764 : 		m_pObjMap = p;

  0001e	89 71 2c	 mov	 DWORD PTR [ecx+44], esi

; 7765 : 		if (m_pObjMap != NULL)

  00021	85 f6		 test	 esi, esi
  00023	74 0f		 je	 SHORT $LN3@Init
  00025	eb 08		 jmp	 SHORT $LN20@Init
$LL2@Init:

; 7769 : 			{
; 7770 : 				pEntry->pfnObjectMain(true); //initialize class resources

  00027	6a 01		 push	 1
  00029	ff 56 20	 call	 DWORD PTR [esi+32]

; 7771 : 				pEntry++;

  0002c	8d 76 24	 lea	 esi, DWORD PTR [esi+36]
$LN20@Init:

; 7766 : 		{
; 7767 : 			pEntry = m_pObjMap;
; 7768 : 			while (pEntry->pclsid != NULL)

  0002f	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00032	75 f3		 jne	 SHORT $LL2@Init
$LN3@Init:

; 7772 : 			}
; 7773 : 		}
; 7774 : 	}
; 7775 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)

  00034	8b 35 08 00 00
	00		 mov	 esi, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+8
  0003a	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
  0003f	eb 13		 jmp	 SHORT $LN21@Init
$LL6@Init:

; 7776 : 	{
; 7777 : 		if (*ppEntry != NULL)

  00041	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00043	85 c9		 test	 ecx, ecx
  00045	74 0a		 je	 SHORT $LN4@Init

; 7778 : 			(*ppEntry)->pfnObjectMain(true); //initialize class resources

  00047	6a 01		 push	 1
  00049	ff 51 1c	 call	 DWORD PTR [ecx+28]
  0004c	a1 0c 00 00 00	 mov	 eax, DWORD PTR ?_AtlComModule@ATL@@3VCAtlComModule@1@A+12
$LN4@Init:

; 7772 : 			}
; 7773 : 		}
; 7774 : 	}
; 7775 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)

  00051	83 c6 04	 add	 esi, 4
$LN21@Init:
  00054	3b f0		 cmp	 esi, eax
  00056	72 e9		 jb	 SHORT $LL6@Init

; 7779 : 	}
; 7780 : 	return S_OK;

  00058	33 c0		 xor	 eax, eax
  0005a	5e		 pop	 esi

; 7781 : }

  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
?Init@CComModule@ATL@@QAEJPAU_ATL_OBJMAP_ENTRY30@2@PAUHINSTANCE__@@PBU_GUID@@@Z ENDP ; ATL::CComModule::Init
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z
_TEXT	SEGMENT
_pRegistrar$ = 8					; size = 4
?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z PROC ; ATL::CAtlModuleT<ATL::CComModule>::AddCommonRGSReplacements, COMDAT
; _this$ = ecx

; 3357 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3358 : 		return pRegistrar->AddReplacement(L"APPID", T::GetAppId());

  00003	8b 45 08	 mov	 eax, DWORD PTR _pRegistrar$[ebp]
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_1M@PPPPCDEP@?$AAA?$AAP?$AAP?$AAI?$AAD@
  00010	50		 push	 eax
  00011	8b 08		 mov	 ecx, DWORD PTR [eax]
  00013	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 3359 : 	}

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?AddCommonRGSReplacements@?$CAtlModuleT@VCComModule@ATL@@@ATL@@UAEJPAUIRegistrarBase@@@Z ENDP ; ATL::CAtlModuleT<ATL::CComModule>::AddCommonRGSReplacements
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_bUnRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z PROC ; ATL::CAtlModuleT<ATL::CComModule>::UnregisterServer, COMDAT
; _this$ = ecx

; 3318 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3319 : 		(bUnRegTypeLib);
; 3320 : 		(pCLSID);
; 3321 : 
; 3322 : 		HRESULT hr = S_OK;
; 3323 : 
; 3324 : #ifndef _ATL_NO_PERF_SUPPORT
; 3325 : 
; 3326 : 		if (_pPerfUnRegFunc != NULL)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_pPerfUnRegFunc@ATL@@3P6AJXZA ; ATL::_pPerfUnRegFunc
  00008	85 c0		 test	 eax, eax
  0000a	74 06		 je	 SHORT $LN7@Unregister

; 3327 : 			hr = (*_pPerfUnRegFunc)();

  0000c	ff d0		 call	 eax

; 3328 : 
; 3329 : #endif
; 3330 : 
; 3331 : #ifndef _ATL_NO_COM_SUPPORT
; 3332 : 
; 3333 : 		if (SUCCEEDED(hr))

  0000e	85 c0		 test	 eax, eax
  00010	78 10		 js	 SHORT $LN3@Unregister
$LN7@Unregister:

; 2697 : 		return AtlComModuleUnregisterServer(this, bRegTypeLib, pCLSID);

  00012	ff 75 0c	 push	 DWORD PTR _pCLSID$[ebp]
  00015	ff 75 08	 push	 DWORD PTR _bUnRegTypeLib$[ebp]
  00018	68 00 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  0001d	e8 00 00 00 00	 call	 ?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ; ATL::AtlComModuleUnregisterServer
$LN3@Unregister:

; 3334 : 			hr = _AtlComModule.UnregisterServer(bUnRegTypeLib, pCLSID);
; 3335 : 
; 3336 : #endif	// _ATL_NO_COM_SUPPORT
; 3337 : 
; 3338 : 		return hr;
; 3339 : 
; 3340 : 	}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?UnregisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ENDP ; ATL::CAtlModuleT<ATL::CComModule>::UnregisterServer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z
_TEXT	SEGMENT
_bRegTypeLib$ = 8					; size = 4
_pCLSID$ = 12						; size = 4
?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z PROC ; ATL::CAtlModuleT<ATL::CComModule>::RegisterServer, COMDAT
; _this$ = ecx

; 3292 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2687 : 		return AtlComModuleRegisterServer(this, bRegTypeLib, pCLSID);

  00003	ff 75 0c	 push	 DWORD PTR _pCLSID$[ebp]
  00006	ff 75 08	 push	 DWORD PTR _bRegTypeLib$[ebp]
  00009	68 00 00 00 00	 push	 OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  0000e	e8 00 00 00 00	 call	 ?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ; ATL::AtlComModuleRegisterServer

; 3293 : 		(pCLSID);
; 3294 : 		(bRegTypeLib);
; 3295 : 
; 3296 : 		HRESULT hr = S_OK;
; 3297 : 
; 3298 : #ifndef _ATL_NO_COM_SUPPORT
; 3299 : 
; 3300 : 		hr = _AtlComModule.RegisterServer(bRegTypeLib, pCLSID);
; 3301 : 
; 3302 : #endif	// _ATL_NO_COM_SUPPORT
; 3303 : 
; 3304 : 
; 3305 : #ifndef _ATL_NO_PERF_SUPPORT
; 3306 : 
; 3307 : 		if (SUCCEEDED(hr) && _pPerfRegFunc != NULL)

  00013	85 c0		 test	 eax, eax
  00015	78 13		 js	 SHORT $LN2@RegisterSe
  00017	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_pPerfRegFunc@ATL@@3P6AJPAUHINSTANCE__@@@ZA ; ATL::_pPerfRegFunc
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 09		 je	 SHORT $LN2@RegisterSe

; 3308 : 			hr = (*_pPerfRegFunc)(_AtlBaseModule.m_hInst);

  00021	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00027	ff d1		 call	 ecx
  00029	59		 pop	 ecx
$LN2@RegisterSe:

; 3309 : 
; 3310 : #endif
; 3311 : 
; 3312 : 		return hr;
; 3313 : 	}

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
?RegisterServer@?$CAtlModuleT@VCComModule@ATL@@@ATL@@QAEJHPBU_GUID@@@Z ENDP ; ATL::CAtlModuleT<ATL::CComModule>::RegisterServer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?EscapeSingleQuote@CAtlModule@ATL@@SAXPA_WIPB_W@Z
_TEXT	SEGMENT
_lpDest$ = 8						; size = 4
_destSizeInChars$ = 12					; size = 4
_lp$ = 16						; size = 4
?EscapeSingleQuote@CAtlModule@ATL@@SAXPA_WIPB_W@Z PROC	; ATL::CAtlModule::EscapeSingleQuote, COMDAT

; 3148 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3149 : 		if (destSizeInChars == 0)

  00003	8b 45 0c	 mov	 eax, DWORD PTR _destSizeInChars$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 43		 je	 SHORT $LN1@EscapeSing

; 3150 : 		{
; 3151 : 			return;
; 3152 : 		}
; 3153 : 		UINT i = 0;
; 3154 : 		// copy characters to the destination buffer but leave the last char to be NULL.
; 3155 : 		for (i=0; i < destSizeInChars-1 && *lp; i++)

  0000a	53		 push	 ebx
  0000b	8d 50 ff	 lea	 edx, DWORD PTR [eax-1]
  0000e	33 c9		 xor	 ecx, ecx
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpDest$[ebp]
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	85 d2		 test	 edx, edx
  00017	74 2c		 je	 SHORT $LN3@EscapeSing
  00019	8b 75 10	 mov	 esi, DWORD PTR _lp$[ebp]
  0001c	6a 27		 push	 39			; 00000027H
  0001e	5b		 pop	 ebx
$LL4@EscapeSing:
  0001f	0f b7 3e	 movzx	 edi, WORD PTR [esi]
  00022	66 85 ff	 test	 di, di
  00025	74 1e		 je	 SHORT $LN3@EscapeSing

; 3156 : 		{
; 3157 : 			*lpDest++ = *lp;

  00027	66 89 38	 mov	 WORD PTR [eax], di
  0002a	83 c0 02	 add	 eax, 2

; 3158 : 			// make sure we won't promote lpDest behind the buffer limit.
; 3159 : 			if (*lp == '\'' && ++i < destSizeInChars-1)

  0002d	66 39 1e	 cmp	 WORD PTR [esi], bx
  00030	75 0b		 jne	 SHORT $LN6@EscapeSing
  00032	41		 inc	 ecx
  00033	3b ca		 cmp	 ecx, edx
  00035	73 06		 jae	 SHORT $LN6@EscapeSing

; 3160 : 				*lpDest++ = *lp;

  00037	66 89 18	 mov	 WORD PTR [eax], bx
  0003a	83 c0 02	 add	 eax, 2
$LN6@EscapeSing:

; 3161 : 			lp++;

  0003d	83 c6 02	 add	 esi, 2
  00040	41		 inc	 ecx
  00041	3b ca		 cmp	 ecx, edx
  00043	72 da		 jb	 SHORT $LL4@EscapeSing
$LN3@EscapeSing:

; 3162 : 		}
; 3163 : 		*lpDest = '\0';

  00045	5f		 pop	 edi
  00046	33 c9		 xor	 ecx, ecx
  00048	5e		 pop	 esi
  00049	66 89 08	 mov	 WORD PTR [eax], cx
  0004c	5b		 pop	 ebx
$LN1@EscapeSing:

; 3164 : 	}

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?EscapeSingleQuote@CAtlModule@ATL@@SAXPA_WIPB_W@Z ENDP	; ATL::CAtlModule::EscapeSingleQuote
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_ro$ = -2632						; size = 20
_pszModuleUnquoted$ = -2612				; size = 1040
_pszModuleQuote$1 = -1572				; size = 1048
_szModule$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_nResID$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z PROC ; ATL::CAtlModule::UpdateRegistryFromResource, COMDAT

; 6641 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 0a 00
	00		 sub	 esp, 2632		; 00000a48H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 328  : 		m_aKey(NULL), m_aVal(NULL), m_nSize(0)

  00014	33 db		 xor	 ebx, ebx
  00016	c7 85 b8 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ro$[ebp], OFFSET ??_7CRegObject@ATL@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 6641 : {

  00020	56		 push	 esi
  00021	8b 75 14	 mov	 esi, DWORD PTR _pMapEntries$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 328  : 		m_aKey(NULL), m_aVal(NULL), m_nSize(0)

  00024	89 9d bc f5 ff
	ff		 mov	 DWORD PTR _ro$[ebp+4], ebx
  0002a	89 9d c0 f5 ff
	ff		 mov	 DWORD PTR _ro$[ebp+8], ebx
  00030	89 9d c4 f5 ff
	ff		 mov	 DWORD PTR _ro$[ebp+12], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 6641 : {

  00036	57		 push	 edi
  00037	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 6642 : 	CRegObject ro;
; 6643 : 	HRESULT hr = ro.FinalConstruct();
; 6644 : 	if (FAILED(hr))
; 6645 : 	{
; 6646 : 		return hr;
; 6647 : 	}
; 6648 : 
; 6649 : 	if (pMapEntries != NULL)

  0003a	85 f6		 test	 esi, esi
  0003c	74 1b		 je	 SHORT $LN3@UpdateRegi

; 6650 : 	{
; 6651 : 		while (pMapEntries->szKey != NULL)

  0003e	eb 13		 jmp	 SHORT $LN137@UpdateRegi
$LL2@UpdateRegi:

; 6652 : 		{
; 6653 : 			ATLASSUME(NULL != pMapEntries->szData);
; 6654 : 			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);

  00040	ff 76 04	 push	 DWORD PTR [esi+4]
  00043	50		 push	 eax
  00044	8d 85 b8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement

; 6655 : 			pMapEntries++;

  00050	8d 76 08	 lea	 esi, DWORD PTR [esi+8]
$LN137@UpdateRegi:

; 6650 : 	{
; 6651 : 		while (pMapEntries->szKey != NULL)

  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	85 c0		 test	 eax, eax
  00057	75 e7		 jne	 SHORT $LL2@UpdateRegi
$LN3@UpdateRegi:

; 6656 : 		}
; 6657 : 	}
; 6658 : 
; 6659 : 	hr = AddCommonRGSReplacements(&ro);

  00059	8b 07		 mov	 eax, DWORD PTR [edi]
  0005b	8d 8d b8 f5 ff
	ff		 lea	 ecx, DWORD PTR _ro$[ebp]
  00061	51		 push	 ecx
  00062	8b cf		 mov	 ecx, edi
  00064	ff 50 14	 call	 DWORD PTR [eax+20]
  00067	8b f0		 mov	 esi, eax

; 6660 : 	if (FAILED(hr))

  00069	85 f6		 test	 esi, esi
  0006b	0f 88 0f 01 00
	00		 js	 $LN129@UpdateRegi

; 6661 : 		return hr;
; 6662 : 
; 6663 : 	USES_CONVERSION_EX;
; 6664 : 	TCHAR szModule[MAX_PATH];
; 6665 : 	HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();

  00071	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4

; 6666 : 	DWORD dwFLen = GetModuleFileName(hInst, szModule, MAX_PATH);

  00077	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  0007d	bf 04 01 00 00	 mov	 edi, 260		; 00000104H
  00082	57		 push	 edi
  00083	50		 push	 eax
  00084	56		 push	 esi
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameW@12

; 6667 : 	if( dwFLen == 0 )

  0008b	85 c0		 test	 eax, eax
  0008d	75 0a		 jne	 SHORT $LN10@UpdateRegi

; 6668 : 		return AtlHresultFromLastError();

  0008f	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError
  00094	e9 e5 00 00 00	 jmp	 $LN138@UpdateRegi
$LN10@UpdateRegi:

; 6669 : 	else if( dwFLen == MAX_PATH )

  00099	3b c7		 cmp	 eax, edi
  0009b	75 0a		 jne	 SHORT $LN12@UpdateRegi
  0009d	be 7a 00 07 80	 mov	 esi, -2147024774	; 8007007aH
  000a2	e9 d9 00 00 00	 jmp	 $LN129@UpdateRegi
$LN12@UpdateRegi:

; 6670 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
; 6671 : 
; 6672 : 	LPOLESTR pszModule = NULL;
; 6673 : 	pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6674 : #ifndef _UNICODE
; 6675 : 	if(pszModule == NULL)
; 6676 : 		return E_OUTOFMEMORY;
; 6677 : #endif
; 6678 : 
; 6679 : 	OLECHAR pszModuleUnquoted[_MAX_PATH * 2];
; 6680 : 	EscapeSingleQuote(pszModuleUnquoted, _countof(pszModuleUnquoted), pszModule);

  000a7	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  000ad	50		 push	 eax
  000ae	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR _pszModuleUnquoted$[ebp]
  000b4	68 08 02 00 00	 push	 520			; 00000208H
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ?EscapeSingleQuote@CAtlModule@ATL@@SAXPA_WIPB_W@Z ; ATL::CAtlModule::EscapeSingleQuote
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6681 : 
; 6682 : 	HRESULT hRes;
; 6683 : 	if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE

  000c2	85 f6		 test	 esi, esi
  000c4	74 13		 je	 SHORT $LN15@UpdateRegi
  000c6	53		 push	 ebx
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4
  000cd	3b f0		 cmp	 esi, eax
  000cf	74 08		 je	 SHORT $LN15@UpdateRegi

; 6699 : 	}
; 6700 : 	else
; 6701 : 	{
; 6702 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleUnquoted);

  000d1	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR _pszModuleUnquoted$[ebp]
  000d7	eb 73		 jmp	 SHORT $LN139@UpdateRegi
$LN15@UpdateRegi:

; 6684 : 	{
; 6685 : 		// If Registering as an EXE, then we quote the resultant path.
; 6686 : 		// We don't do it for a DLL, because LoadLibrary fails if the path is
; 6687 : 		// quoted
; 6688 : 		OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2];
; 6689 : 		pszModuleQuote[0] = OLESTR('\"');

  000d9	6a 22		 push	 34			; 00000022H
  000db	5e		 pop	 esi

; 6690 : 		if(!ocscpy_s(pszModuleQuote + 1, (_MAX_PATH + _ATL_QUOTES_SPACE)*2 - 1, pszModuleUnquoted))

  000dc	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR _pszModuleUnquoted$[ebp]
  000e2	66 89 b5 dc f9
	ff ff		 mov	 WORD PTR _pszModuleQuote$1[ebp], si
  000e9	50		 push	 eax
  000ea	8d 85 de f9 ff
	ff		 lea	 eax, DWORD PTR _pszModuleQuote$1[ebp+2]
  000f0	68 0b 02 00 00	 push	 523			; 0000020bH
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ?ocscpy_s@@YA_NPA_WIPB_W@Z ; ocscpy_s
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fe	84 c0		 test	 al, al
  00100	75 07		 jne	 SHORT $LN16@UpdateRegi
  00102	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
  00107	eb 77		 jmp	 SHORT $LN129@UpdateRegi
$LN16@UpdateRegi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h

; 737  : 	return static_cast<int>(wcslen(x));

  00109	8d 8d dc f9 ff
	ff		 lea	 ecx, DWORD PTR _pszModuleQuote$1[ebp]
  0010f	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL134@UpdateRegi:
  00112	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00115	83 c1 02	 add	 ecx, 2
  00118	66 3b c3	 cmp	 ax, bx
  0011b	75 f5		 jne	 SHORT $LL134@UpdateRegi
  0011d	2b ca		 sub	 ecx, edx
  0011f	d1 f9		 sar	 ecx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 6695 : 		pszModuleQuote[nLen] = OLESTR('\"');

  00121	66 89 b4 4d dc
	f9 ff ff	 mov	 WORD PTR _pszModuleQuote$1[ebp+ecx*2], si

; 6696 : 		pszModuleQuote[nLen + 1] = 0;

  00129	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00130	81 f9 18 04 00
	00		 cmp	 ecx, 1048		; 00000418H
  00136	0f 83 89 00 00
	00		 jae	 $LN20@UpdateRegi
  0013c	33 c0		 xor	 eax, eax
  0013e	66 89 84 0d dc
	f9 ff ff	 mov	 WORD PTR _pszModuleQuote$1[ebp+ecx], ax

; 6697 : 
; 6698 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);

  00146	8d 85 dc f9 ff
	ff		 lea	 eax, DWORD PTR _pszModuleQuote$1[ebp]
$LN139@UpdateRegi:

; 6703 : 	}
; 6704 : 
; 6705 : 	if(FAILED(hRes))

  0014c	50		 push	 eax
  0014d	68 00 00 00 00	 push	 OFFSET ??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe@
  00152	8d 85 b8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  00158	50		 push	 eax
  00159	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement
  0015e	85 c0		 test	 eax, eax
  00160	78 1c		 js	 SHORT $LN138@UpdateRegi

; 6706 : 		return hRes;
; 6707 : 
; 6708 : 	hRes = ro.AddReplacement(OLESTR("Module_Raw"), pszModuleUnquoted);

  00162	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR _pszModuleUnquoted$[ebp]
  00168	50		 push	 eax
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw@
  0016e	8d 85 b8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement

; 6709 : 	if(FAILED(hRes))

  0017a	85 c0		 test	 eax, eax
  0017c	79 20		 jns	 SHORT $LN18@UpdateRegi
$LN138@UpdateRegi:

; 6716 : }

  0017e	8b f0		 mov	 esi, eax
$LN129@UpdateRegi:
  00180	8d 8d b8 f5 ff
	ff		 lea	 ecx, DWORD PTR _ro$[ebp]
  00186	e8 00 00 00 00	 call	 ??1CRegObject@ATL@@UAE@XZ ; ATL::CRegObject::~CRegObject
  0018b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018e	8b c6		 mov	 eax, esi
  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	33 cd		 xor	 ecx, ebp
  00194	5b		 pop	 ebx
  00195	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019a	c9		 leave
  0019b	c2 10 00	 ret	 16			; 00000010H
$LN18@UpdateRegi:

; 6710 : 		return hRes;
; 6711 : 
; 6712 : 	LPCOLESTR szType = OLESTR("REGISTRY");
; 6713 : 	hr = (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
; 6714 : 		ro.ResourceUnregister(pszModule, nResID, szType);
; 6715 : 	return hr;

  0019e	33 c0		 xor	 eax, eax
  001a0	8d 8d b8 f5 ff
	ff		 lea	 ecx, DWORD PTR _ro$[ebp]
  001a6	39 45 10	 cmp	 DWORD PTR _bRegister$[ebp], eax
  001a9	0f 95 c0	 setne	 al
  001ac	50		 push	 eax
  001ad	0f b7 45 0c	 movzx	 eax, WORD PTR _nResID$[ebp]
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY@
  001b6	50		 push	 eax
  001b7	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  001bd	50		 push	 eax
  001be	e8 00 00 00 00	 call	 ?RegisterFromResource@CRegObject@ATL@@IAEJPB_W00H@Z ; ATL::CRegObject::RegisterFromResource
  001c3	eb b9		 jmp	 SHORT $LN138@UpdateRegi
$LN20@UpdateRegi:

; 6696 : 		pszModuleQuote[nLen + 1] = 0;

  001c5	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN135@UpdateRegi:
  001ca	cc		 int	 3
?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJIHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CAtlModule::UpdateRegistryFromResource
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z
_TEXT	SEGMENT
_ro$ = -2632						; size = 20
_pszModuleUnquoted$ = -2612				; size = 1040
_pszModuleQuote$1 = -1572				; size = 1048
_szModule$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_this$ = 8						; size = 4
_lpszRes$ = 12						; size = 4
_bRegister$ = 16					; size = 4
_pMapEntries$ = 20					; size = 4
?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z PROC ; ATL::CAtlModule::UpdateRegistryFromResource, COMDAT

; 6555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 0a 00
	00		 sub	 esp, 2632		; 00000a48H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _lpszRes$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 328  : 		m_aKey(NULL), m_aVal(NULL), m_nSize(0)

  00017	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 6555 : {

  00019	56		 push	 esi
  0001a	8b 75 14	 mov	 esi, DWORD PTR _pMapEntries$[ebp]
  0001d	c7 85 b8 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _ro$[ebp], OFFSET ??_7CRegObject@ATL@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 328  : 		m_aKey(NULL), m_aVal(NULL), m_nSize(0)

  00027	89 85 bc f5 ff
	ff		 mov	 DWORD PTR _ro$[ebp+4], eax
  0002d	89 85 c0 f5 ff
	ff		 mov	 DWORD PTR _ro$[ebp+8], eax
  00033	89 85 c4 f5 ff
	ff		 mov	 DWORD PTR _ro$[ebp+12], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 6555 : {

  00039	57		 push	 edi
  0003a	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 6556 : 	CRegObject ro;
; 6557 : 	HRESULT hr = ro.FinalConstruct();
; 6558 : 	if (FAILED(hr))
; 6559 : 	{
; 6560 : 		return hr;
; 6561 : 	}
; 6562 : 
; 6563 : 	if (pMapEntries != NULL)

  0003d	85 f6		 test	 esi, esi
  0003f	74 1b		 je	 SHORT $LN3@UpdateRegi

; 6564 : 	{
; 6565 : 		while (pMapEntries->szKey != NULL)

  00041	eb 13		 jmp	 SHORT $LN110@UpdateRegi
$LL2@UpdateRegi:

; 6566 : 		{
; 6567 : 			ATLASSUME(NULL != pMapEntries->szData);
; 6568 : 			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);

  00043	ff 76 04	 push	 DWORD PTR [esi+4]
  00046	50		 push	 eax
  00047	8d 85 b8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement

; 6569 : 			pMapEntries++;

  00053	8d 76 08	 lea	 esi, DWORD PTR [esi+8]
$LN110@UpdateRegi:

; 6564 : 	{
; 6565 : 		while (pMapEntries->szKey != NULL)

  00056	8b 06		 mov	 eax, DWORD PTR [esi]
  00058	85 c0		 test	 eax, eax
  0005a	75 e7		 jne	 SHORT $LL2@UpdateRegi
$LN3@UpdateRegi:

; 6570 : 		}
; 6571 : 	}
; 6572 : 
; 6573 : 	hr = AddCommonRGSReplacements(&ro);

  0005c	8b 07		 mov	 eax, DWORD PTR [edi]
  0005e	8d 8d b8 f5 ff
	ff		 lea	 ecx, DWORD PTR _ro$[ebp]
  00064	51		 push	 ecx
  00065	8b cf		 mov	 ecx, edi
  00067	ff 50 14	 call	 DWORD PTR [eax+20]
  0006a	8b f0		 mov	 esi, eax

; 6574 : 	if (FAILED(hr))

  0006c	85 f6		 test	 esi, esi
  0006e	0f 88 11 01 00
	00		 js	 $LN101@UpdateRegi

; 6575 : 		return hr;
; 6576 : 
; 6577 : 	USES_CONVERSION_EX;
; 6578 : 	TCHAR szModule[MAX_PATH];
; 6579 : 	HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();

  00074	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4

; 6580 : 	DWORD dwFLen = GetModuleFileName(hInst, szModule, MAX_PATH);

  0007a	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  00080	bf 04 01 00 00	 mov	 edi, 260		; 00000104H
  00085	57		 push	 edi
  00086	50		 push	 eax
  00087	56		 push	 esi
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameW@12

; 6581 : 	if( dwFLen == 0 )

  0008e	85 c0		 test	 eax, eax
  00090	75 0a		 jne	 SHORT $LN10@UpdateRegi

; 6582 : 		return AtlHresultFromLastError();

  00092	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError
  00097	e9 e7 00 00 00	 jmp	 $LN111@UpdateRegi
$LN10@UpdateRegi:

; 6583 : 	else if( dwFLen == MAX_PATH )

  0009c	3b c7		 cmp	 eax, edi
  0009e	75 0a		 jne	 SHORT $LN12@UpdateRegi
  000a0	be 7a 00 07 80	 mov	 esi, -2147024774	; 8007007aH
  000a5	e9 db 00 00 00	 jmp	 $LN101@UpdateRegi
$LN12@UpdateRegi:

; 6584 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
; 6585 : 
; 6586 : 	LPOLESTR pszModule = NULL;
; 6587 : 	pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6588 : #ifndef _UNICODE
; 6589 : 	if(pszModule == NULL)
; 6590 : 		return E_OUTOFMEMORY;
; 6591 : #endif
; 6592 : 
; 6593 : 	OLECHAR pszModuleUnquoted[_MAX_PATH * 2];
; 6594 : 	EscapeSingleQuote(pszModuleUnquoted, _countof(pszModuleUnquoted), pszModule);

  000aa	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  000b0	50		 push	 eax
  000b1	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR _pszModuleUnquoted$[ebp]
  000b7	68 08 02 00 00	 push	 520			; 00000208H
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 ?EscapeSingleQuote@CAtlModule@ATL@@SAXPA_WIPB_W@Z ; ATL::CAtlModule::EscapeSingleQuote
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6595 : 
; 6596 : 	HRESULT hRes;
; 6597 : 	if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE

  000c5	33 ff		 xor	 edi, edi
  000c7	85 f6		 test	 esi, esi
  000c9	74 13		 je	 SHORT $LN15@UpdateRegi
  000cb	57		 push	 edi
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4
  000d2	3b f0		 cmp	 esi, eax
  000d4	74 08		 je	 SHORT $LN15@UpdateRegi

; 6613 : 	}
; 6614 : 	else
; 6615 : 	{
; 6616 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleUnquoted);

  000d6	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR _pszModuleUnquoted$[ebp]
  000dc	eb 73		 jmp	 SHORT $LN112@UpdateRegi
$LN15@UpdateRegi:

; 6598 : 	{
; 6599 : 		// If Registering as an EXE, then we quote the resultant path.
; 6600 : 		// We don't do it for a DLL, because LoadLibrary fails if the path is
; 6601 : 		// quoted
; 6602 : 		OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2];
; 6603 : 		pszModuleQuote[0] = OLESTR('\"');

  000de	6a 22		 push	 34			; 00000022H
  000e0	5e		 pop	 esi

; 6604 : 		if(!ocscpy_s(pszModuleQuote + 1, (_MAX_PATH + _ATL_QUOTES_SPACE)*2 - 1, pszModuleUnquoted))

  000e1	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR _pszModuleUnquoted$[ebp]
  000e7	66 89 b5 dc f9
	ff ff		 mov	 WORD PTR _pszModuleQuote$1[ebp], si
  000ee	50		 push	 eax
  000ef	8d 85 de f9 ff
	ff		 lea	 eax, DWORD PTR _pszModuleQuote$1[ebp+2]
  000f5	68 0b 02 00 00	 push	 523			; 0000020bH
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?ocscpy_s@@YA_NPA_WIPB_W@Z ; ocscpy_s
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
  00103	84 c0		 test	 al, al
  00105	75 07		 jne	 SHORT $LN16@UpdateRegi
  00107	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
  0010c	eb 77		 jmp	 SHORT $LN101@UpdateRegi
$LN16@UpdateRegi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h

; 737  : 	return static_cast<int>(wcslen(x));

  0010e	8d 8d dc f9 ff
	ff		 lea	 ecx, DWORD PTR _pszModuleQuote$1[ebp]
  00114	8d 51 02	 lea	 edx, DWORD PTR [ecx+2]
$LL106@UpdateRegi:
  00117	66 8b 01	 mov	 ax, WORD PTR [ecx]
  0011a	83 c1 02	 add	 ecx, 2
  0011d	66 3b c7	 cmp	 ax, di
  00120	75 f5		 jne	 SHORT $LL106@UpdateRegi
  00122	2b ca		 sub	 ecx, edx
  00124	d1 f9		 sar	 ecx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 6609 : 		pszModuleQuote[nLen] = OLESTR('\"');

  00126	66 89 b4 4d dc
	f9 ff ff	 mov	 WORD PTR _pszModuleQuote$1[ebp+ecx*2], si

; 6610 : 		pszModuleQuote[nLen + 1] = 0;

  0012e	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00135	81 f9 18 04 00
	00		 cmp	 ecx, 1048		; 00000418H
  0013b	0f 83 8a 00 00
	00		 jae	 $LN20@UpdateRegi
  00141	33 c0		 xor	 eax, eax
  00143	66 89 84 0d dc
	f9 ff ff	 mov	 WORD PTR _pszModuleQuote$1[ebp+ecx], ax

; 6611 : 
; 6612 : 		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);

  0014b	8d 85 dc f9 ff
	ff		 lea	 eax, DWORD PTR _pszModuleQuote$1[ebp]
$LN112@UpdateRegi:

; 6617 : 	}
; 6618 : 
; 6619 : 	if(FAILED(hRes))

  00151	50		 push	 eax
  00152	68 00 00 00 00	 push	 OFFSET ??_C@_1O@MNLDABAF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe@
  00157	8d 85 b8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement
  00163	85 c0		 test	 eax, eax
  00165	78 1c		 js	 SHORT $LN111@UpdateRegi

; 6620 : 		return hRes;
; 6621 : 
; 6622 : 	hRes = ro.AddReplacement(OLESTR("Module_Raw"), pszModuleUnquoted);

  00167	8d 85 cc f5 ff
	ff		 lea	 eax, DWORD PTR _pszModuleUnquoted$[ebp]
  0016d	50		 push	 eax
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_1BG@JBACFMF@?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AA_?$AAR?$AAa?$AAw@
  00173	8d 85 b8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  00179	50		 push	 eax
  0017a	e8 00 00 00 00	 call	 ?AddReplacement@CRegObject@ATL@@UAGJPB_W0@Z ; ATL::CRegObject::AddReplacement

; 6623 : 	if(FAILED(hRes))

  0017f	85 c0		 test	 eax, eax
  00181	79 20		 jns	 SHORT $LN18@UpdateRegi
$LN111@UpdateRegi:

; 6635 : }

  00183	8b f0		 mov	 esi, eax
$LN101@UpdateRegi:
  00185	8d 8d b8 f5 ff
	ff		 lea	 ecx, DWORD PTR _ro$[ebp]
  0018b	e8 00 00 00 00	 call	 ??1CRegObject@ATL@@UAE@XZ ; ATL::CRegObject::~CRegObject
  00190	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00193	8b c6		 mov	 eax, esi
  00195	5f		 pop	 edi
  00196	5e		 pop	 esi
  00197	33 cd		 xor	 ecx, ebp
  00199	5b		 pop	 ebx
  0019a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019f	c9		 leave
  001a0	c2 10 00	 ret	 16			; 00000010H
$LN18@UpdateRegi:

; 6624 : 		return hRes;
; 6625 : 
; 6626 : 	LPCOLESTR szType = OLESTR("REGISTRY");
; 6627 : 	LPCOLESTR pszRes = T2COLE_EX(lpszRes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 6628 : #ifndef _UNICODE
; 6629 : 	if(pszRes == NULL)
; 6630 : 		return E_OUTOFMEMORY;
; 6631 : #endif
; 6632 : 	hr = (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :

  001a3	83 7d 10 00	 cmp	 DWORD PTR _bRegister$[ebp], 0
  001a7	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  001ad	68 00 00 00 00	 push	 OFFSET ??_C@_1BC@KAILKFFG@?$AAR?$AAE?$AAG?$AAI?$AAS?$AAT?$AAR?$AAY@
  001b2	53		 push	 ebx
  001b3	50		 push	 eax
  001b4	8d 85 b8 f5 ff
	ff		 lea	 eax, DWORD PTR _ro$[ebp]
  001ba	50		 push	 eax
  001bb	74 07		 je	 SHORT $LN22@UpdateRegi
  001bd	e8 00 00 00 00	 call	 ?ResourceRegisterSz@CRegObject@ATL@@QAGJPB_W00@Z ; ATL::CRegObject::ResourceRegisterSz
  001c2	eb bf		 jmp	 SHORT $LN111@UpdateRegi
$LN22@UpdateRegi:
  001c4	e8 00 00 00 00	 call	 ?ResourceUnregisterSz@CRegObject@ATL@@QAGJPB_W00@Z ; ATL::CRegObject::ResourceUnregisterSz

; 6633 : 		ro.ResourceUnregisterSz(pszModule, pszRes, szType);
; 6634 : 	return hr;

  001c9	eb b8		 jmp	 SHORT $LN111@UpdateRegi
$LN20@UpdateRegi:

; 6610 : 		pszModuleQuote[nLen + 1] = 0;

  001cb	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN108@UpdateRegi:
  001d0	cc		 int	 3
?UpdateRegistryFromResource@CAtlModule@ATL@@QAGJPB_WHPAU_ATL_REGMAP_ENTRY@2@@Z ENDP ; ATL::CAtlModule::UpdateRegistryFromResource
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z
_TEXT	SEGMENT
_ppGIT$ = 8						; size = 4
?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z PROC ; ATL::CAtlModule::GetGITPtr, COMDAT
; _this$ = ecx

; 3108 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 3109 : 		ATLASSERT(ppGIT != NULL);
; 3110 : 
; 3111 : 		if (ppGIT == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _ppGIT$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	75 07		 jne	 SHORT $LN5@GetGITPtr

; 3112 : 			return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	eb 35		 jmp	 SHORT $LN1@GetGITPtr
$LN5@GetGITPtr:
  00012	56		 push	 esi
  00013	57		 push	 edi

; 3113 : 
; 3114 : 		HRESULT hr = S_OK;

  00014	33 f6		 xor	 esi, esi

; 3115 : 		if (m_pGIT == NULL)

  00016	8d 79 28	 lea	 edi, DWORD PTR [ecx+40]
  00019	39 37		 cmp	 DWORD PTR [edi], esi
  0001b	75 1a		 jne	 SHORT $LN9@GetGITPtr

; 3116 : 		{
; 3117 : 			hr = ::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,

  0001d	57		 push	 edi
  0001e	68 00 00 00 00	 push	 OFFSET __GUID_00000146_0000_0000_c000_000000000046
  00023	6a 01		 push	 1
  00025	56		 push	 esi
  00026	68 00 00 00 00	 push	 OFFSET _CLSID_StdGlobalInterfaceTable
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
  00031	8b f0		 mov	 esi, eax

; 3118 : 				__uuidof(IGlobalInterfaceTable), (void**)&m_pGIT);
; 3119 : 		}
; 3120 : 
; 3121 : 		if (SUCCEEDED(hr))

  00033	85 f6		 test	 esi, esi
  00035	78 0c		 js	 SHORT $LN7@GetGITPtr
$LN9@GetGITPtr:

; 3122 : 		{
; 3123 : 			ATLASSUME(m_pGIT != NULL);
; 3124 : 			*ppGIT = m_pGIT;

  00037	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00039	89 0b		 mov	 DWORD PTR [ebx], ecx

; 3125 : 			m_pGIT->AddRef();

  0003b	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0003d	51		 push	 ecx
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	ff 52 04	 call	 DWORD PTR [edx+4]
$LN7@GetGITPtr:

; 3126 : 		}
; 3127 : 		return hr;

  00043	5f		 pop	 edi
  00044	8b c6		 mov	 eax, esi
  00046	5e		 pop	 esi
$LN1@GetGITPtr:
  00047	5b		 pop	 ebx

; 3128 : 	}

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
?GetGITPtr@CAtlModule@ATL@@UAEJPAPAUIGlobalInterfaceTable@@@Z ENDP ; ATL::CAtlModule::GetGITPtr
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z
_TEXT	SEGMENT
_pFunc$ = 8						; size = 4
_dw$ = 12						; size = 4
?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z PROC	; ATL::CAtlModule::AddTermFunc, COMDAT
; _this$ = ecx

; 3103 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 8423 : 	if (pModule == NULL)

  00006	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00009	f7 df		 neg	 edi
  0000b	1b ff		 sbb	 edi, edi
  0000d	23 f8		 and	 edi, eax
  0000f	75 07		 jne	 SHORT $LN6@AddTermFun

; 8424 : 		return E_INVALIDARG;

  00011	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00016	eb 46		 jmp	 SHORT $LN34@AddTermFun
$LN6@AddTermFun:
  00018	53		 push	 ebx

; 8425 : 
; 8426 : 	HRESULT hr = S_OK;
; 8427 : 	_ATL_TERMFUNC_ELEM* pNew = _ATL_NEW _ATL_TERMFUNC_ELEM;

  00019	68 00 00 00 00	 push	 OFFSET ?nothrow@std@@3Unothrow_t@1@B ; std::nothrow
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	e8 00 00 00 00	 call	 ??2@YAPAXIABUnothrow_t@std@@@Z ; operator new
  00025	8b d8		 mov	 ebx, eax
  00027	59		 pop	 ecx
  00028	59		 pop	 ecx

; 8428 : 	if (pNew == NULL)

  00029	85 db		 test	 ebx, ebx
  0002b	75 07		 jne	 SHORT $LN7@AddTermFun

; 8429 : 		hr = E_OUTOFMEMORY;

  0002d	b8 0e 00 07 80	 mov	 eax, -2147024882	; 8007000eH
  00032	eb 29		 jmp	 SHORT $LN46@AddTermFun
$LN7@AddTermFun:

; 8430 : 	else
; 8431 : 	{
; 8432 : 		pNew->pFunc = pFunc;

  00034	8b 45 08	 mov	 eax, DWORD PTR _pFunc$[ebp]
  00037	56		 push	 esi
  00038	89 03		 mov	 DWORD PTR [ebx], eax

; 8434 : 		CComCritSecLock<CComCriticalSection> lock(pModule->m_csStaticDataInitAndTypeInfo, false);

  0003a	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _dw$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  00040	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8433 : 		pNew->dw = dw;

  00041	89 43 04	 mov	 DWORD PTR [ebx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8438 : 			pNew->pNext = pModule->m_pTermFuncs;

  0004a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0004d	89 43 08	 mov	 DWORD PTR [ebx+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  00050	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8439 : 			pModule->m_pTermFuncs = pNew;

  00051	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0005a	33 c0		 xor	 eax, eax
  0005c	5e		 pop	 esi
$LN46@AddTermFun:
  0005d	5b		 pop	 ebx
$LN34@AddTermFun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 3104 : 		return AtlModuleAddTermFunc(this, pFunc, dw);

  0005e	5f		 pop	 edi

; 3105 : 	}

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?AddTermFunc@CAtlModule@ATL@@QAEJP6GXK@ZK@Z ENDP	; ATL::CAtlModule::AddTermFunc
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?GetLockCount@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT
?GetLockCount@CAtlModule@ATL@@UAEJXZ PROC		; ATL::CAtlModule::GetLockCount, COMDAT
; _this$ = ecx

; 3097 : 		return m_nLockCnt;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 3098 : 	}

  00003	c3		 ret	 0
?GetLockCount@CAtlModule@ATL@@UAEJXZ ENDP		; ATL::CAtlModule::GetLockCount
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?Unlock@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT
?Unlock@CAtlModule@ATL@@UAEJXZ PROC			; ATL::CAtlModule::Unlock, COMDAT
; _this$ = ecx

; 427  : 		return ::InterlockedDecrement(p);

  00000	83 c8 ff	 or	 eax, -1
  00003	f0 0f c1 41 08	 lock	  xadd	 DWORD PTR [ecx+8], eax
  00008	48		 dec	 eax

; 3092 : 		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
; 3093 : 	}

  00009	c3		 ret	 0
?Unlock@CAtlModule@ATL@@UAEJXZ ENDP			; ATL::CAtlModule::Unlock
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?Lock@CAtlModule@ATL@@UAEJXZ
_TEXT	SEGMENT
?Lock@CAtlModule@ATL@@UAEJXZ PROC			; ATL::CAtlModule::Lock, COMDAT
; _this$ = ecx

; 423  : 		return ::InterlockedIncrement(p);

  00000	33 c0		 xor	 eax, eax
  00002	40		 inc	 eax
  00003	f0 0f c1 41 08	 lock	  xadd	 DWORD PTR [ecx+8], eax
  00008	40		 inc	 eax

; 3087 : 		return CComGlobalsThreadModel::Increment(&m_nLockCnt);
; 3088 : 	}

  00009	c3		 ret	 0
?Lock@CAtlModule@ATL@@UAEJXZ ENDP			; ATL::CAtlModule::Lock
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??1CAtlModule@ATL@@UAE@XZ
_TEXT	SEGMENT
??1CAtlModule@ATL@@UAE@XZ PROC				; ATL::CAtlModule::~CAtlModule, COMDAT
; _this$ = ecx

; 3082 : 		Term();

  00000	e9 00 00 00 00	 jmp	 ?Term@CAtlModule@ATL@@QAEXXZ ; ATL::CAtlModule::Term
??1CAtlModule@ATL@@UAE@XZ ENDP				; ATL::CAtlModule::~CAtlModule
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlModule@ATL@@QAEXXZ PROC			; ATL::CAtlModule::Term, COMDAT
; _this$ = ecx

; 3060 : 	{

  00000	53		 push	 ebx
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 3061 : 		// cbSize == 0 indicates that Term has already been called
; 3062 : 		if (cbSize == 0)

  00004	33 db		 xor	 ebx, ebx
  00006	39 5f 04	 cmp	 DWORD PTR [edi+4], ebx
  00009	74 45		 je	 SHORT $LN1@Term

; 3063 : 			return;
; 3064 : 
; 3065 : 		// Call term functions
; 3066 : 		if (m_pTermFuncs != NULL)

  0000b	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  0000e	74 26		 je	 SHORT $LN3@Term

; 8456 : 	_ATL_TERMFUNC_ELEM* pElem = pModule->m_pTermFuncs;

  00010	8b 5f 0c	 mov	 ebx, DWORD PTR [edi+12]

; 8457 : 	_ATL_TERMFUNC_ELEM* pNext = NULL;
; 8458 : 	while (pElem != NULL)

  00013	85 db		 test	 ebx, ebx
  00015	74 1a		 je	 SHORT $LN10@Term
  00017	56		 push	 esi
$LL9@Term:

; 8459 : 	{
; 8460 : 		pElem->pFunc(pElem->dw);

  00018	ff 73 04	 push	 DWORD PTR [ebx+4]
  0001b	ff 13		 call	 DWORD PTR [ebx]

; 8461 : 		pNext = pElem->pNext;

  0001d	8b 73 08	 mov	 esi, DWORD PTR [ebx+8]

; 8462 : 		delete pElem;

  00020	6a 0c		 push	 12			; 0000000cH
  00022	53		 push	 ebx
  00023	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete

; 8463 : 		pElem = pNext;

  00028	8b de		 mov	 ebx, esi
  0002a	59		 pop	 ecx
  0002b	59		 pop	 ecx
  0002c	85 f6		 test	 esi, esi
  0002e	75 e8		 jne	 SHORT $LL9@Term
  00030	5e		 pop	 esi
$LN10@Term:

; 8464 : 	}
; 8465 : 	pModule->m_pTermFuncs = NULL;

  00031	33 db		 xor	 ebx, ebx

; 3067 : 		{
; 3068 : 			AtlCallTermFunc(this);
; 3069 : 			m_pTermFuncs = NULL;

  00033	89 5f 0c	 mov	 DWORD PTR [edi+12], ebx
$LN3@Term:

; 3070 : 		}
; 3071 : 
; 3072 : 		if (m_pGIT != NULL)

  00036	8b 4f 28	 mov	 ecx, DWORD PTR [edi+40]
  00039	85 c9		 test	 ecx, ecx
  0003b	74 06		 je	 SHORT $LN4@Term

; 3073 : 			m_pGIT->Release();

  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	51		 push	 ecx
  00040	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@Term:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  00043	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 3077 : 		cbSize = 0;

  0004d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
$LN1@Term:

; 3078 : 	}

  00050	5f		 pop	 edi
  00051	5b		 pop	 ebx
  00052	c3		 ret	 0
?Term@CAtlModule@ATL@@QAEXXZ ENDP			; ATL::CAtlModule::Term
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlModule@ATL@@QAE@XZ PROC				; ATL::CAtlModule::CAtlModule, COMDAT
; _this$ = ecx

; 3035 : 	CAtlModule() throw()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00003	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 3035 : 	CAtlModule() throw()

  00005	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00006	6a 06		 push	 6
  00008	59		 pop	 ecx
  00009	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  0000c	f3 ab		 rep stosd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 3040 : 		cbSize = 0;

  0000e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 3041 : 		m_pTermFuncs = NULL;
; 3042 : 
; 3043 : 		m_nLockCnt = 0;
; 3044 : 		_pAtlModule = this;
; 3045 : 		m_pGIT = NULL;
; 3046 : 
; 3047 : 		if (FAILED(m_csStaticDataInitAndTypeInfo.Init()))

  00011	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00014	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00017	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001a	89 35 00 00 00
	00		 mov	 DWORD PTR ?_pAtlModule@ATL@@3PAVCAtlModule@1@A, esi ; ATL::_pAtlModule
  00020	89 46 28	 mov	 DWORD PTR [esi+40], eax
  00023	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  00028	85 c0		 test	 eax, eax
  0002a	79 09		 jns	 SHORT $LN2@CAtlModule

; 3048 : 		{
; 3049 : 			ATLTRACE(atlTraceGeneral, 0, _T("ERROR : Unable to initialize critical section in CAtlModule\n"));
; 3050 : 			ATLASSERT(0);
; 3051 : 			CAtlBaseModule::m_bInitFailed = true;

  0002c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 3052 : 			return;

  00033	eb 07		 jmp	 SHORT $LN1@CAtlModule
$LN2@CAtlModule:

; 3053 : 		}
; 3054 : 
; 3055 : 		// Set cbSize on success.
; 3056 : 		cbSize = sizeof(_ATL_MODULE);

  00035	c7 46 04 24 00
	00 00		 mov	 DWORD PTR [esi+4], 36	; 00000024H
$LN1@CAtlModule:

; 3057 : 	}

  0003c	5f		 pop	 edi
  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	c3		 ret	 0
??0CAtlModule@ATL@@QAE@XZ ENDP				; ATL::CAtlModule::CAtlModule
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ??__F_AtlWinModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlWinModule'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2957 : 		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());

  00000	ff 35 04 00 00
	00		 push	 DWORD PTR ?_AtlBaseModule@ATL@@3VCAtlBaseModule@1@A+4
  00006	68 00 00 00 00	 push	 OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  0000b	e8 00 00 00 00	 call	 ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ; ATL::AtlWinModuleTerm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 311  : 	RemoveAll();

  00010	b9 20 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A+32
  00015	e9 00 00 00 00	 jmp	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
??__F_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlWinModule''
text$yd	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlWinModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlWinModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlWinModule'', COMDAT

; 2972 : __declspec(selectany) CAtlWinModule _AtlWinModule;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlWinModule@ATL@@3VCAtlWinModule@1@A ; ATL::_AtlWinModule
  00005	e8 00 00 00 00	 call	 ??0CAtlWinModule@ATL@@QAE@XZ ; ATL::CAtlWinModule::CAtlWinModule
  0000a	68 00 00 00 00	 push	 OFFSET ??__F_AtlWinModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlWinModule''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E_AtlWinModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlWinModule''
text$di	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlWinModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlWinModule@ATL@@QAE@XZ PROC			; ATL::CAtlWinModule::CAtlWinModule, COMDAT
; _this$ = ecx

; 2937 : 	CAtlWinModule()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00003	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2937 : 	CAtlWinModule()

  00005	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00006	6a 06		 push	 6
  00008	59		 pop	 ecx
  00009	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0000c	f3 ab		 rep stosd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h

; 119  : 		m_aT(NULL), m_nSize(0), m_nAllocSize(0)

  0000e	33 ff		 xor	 edi, edi
  00010	89 7e 20	 mov	 DWORD PTR [esi+32], edi
  00013	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  00016	89 7e 28	 mov	 DWORD PTR [esi+40], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2940 : 		HRESULT hr = AtlWinModuleInit(this);

  00019	56		 push	 esi
  0001a	c7 06 2c 00 00
	00		 mov	 DWORD PTR [esi], 44	; 0000002cH
  00020	e8 00 00 00 00	 call	 ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ; ATL::AtlWinModuleInit

; 2941 : 		if (FAILED(hr))

  00025	85 c0		 test	 eax, eax
  00027	79 09		 jns	 SHORT $LN2@CAtlWinMod

; 2942 : 		{
; 2943 : 			ATLASSERT(0);
; 2944 : 			CAtlBaseModule::m_bInitFailed = true;

  00029	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2945 : 			cbSize = 0;

  00030	89 3e		 mov	 DWORD PTR [esi], edi
$LN2@CAtlWinMod:

; 2946 : 			return;
; 2947 : 		}
; 2948 : 	}

  00032	5f		 pop	 edi
  00033	8b c6		 mov	 eax, esi
  00035	5e		 pop	 esi
  00036	c3		 ret	 0
??0CAtlWinModule@ATL@@QAE@XZ ENDP			; ATL::CAtlWinModule::CAtlWinModule
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??__F_AtlComModule@ATL@@YAXXZ
text$yd	SEGMENT
??__F_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic atexit destructor for '_AtlComModule'', COMDAT

; 2608 : 		Term();

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00005	e9 00 00 00 00	 jmp	 ?Term@CAtlComModule@ATL@@QAEXXZ ; ATL::CAtlComModule::Term
??__F_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic atexit destructor for '_AtlComModule''
text$yd	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??__E_AtlComModule@ATL@@YAXXZ
text$di	SEGMENT
??__E_AtlComModule@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for '_AtlComModule'', COMDAT

; 2716 : __declspec(selectany) CAtlComModule _AtlComModule;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?_AtlComModule@ATL@@3VCAtlComModule@1@A ; ATL::_AtlComModule
  00005	e8 00 00 00 00	 call	 ??0CAtlComModule@ATL@@QAE@XZ ; ATL::CAtlComModule::CAtlComModule
  0000a	68 00 00 00 00	 push	 OFFSET ??__F_AtlComModule@ATL@@YAXXZ ; ATL::`dynamic atexit destructor for '_AtlComModule''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__E_AtlComModule@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for '_AtlComModule''
text$di	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?Term@CAtlComModule@ATL@@QAEXXZ
_TEXT	SEGMENT
?Term@CAtlComModule@ATL@@QAEXXZ PROC			; ATL::CAtlComModule::Term, COMDAT
; _this$ = ecx

; 2613 : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2614 : 		if (cbSize == 0)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 40		 je	 SHORT $LN1@Term

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00008	57		 push	 edi
  00009	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0000c	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  0000f	73 29		 jae	 SHORT $LN3@Term
  00011	53		 push	 ebx
$LL4@Term:

; 2618 : 		{
; 2619 : 			if (*ppEntry != NULL)

  00012	8b 07		 mov	 eax, DWORD PTR [edi]
  00014	85 c0		 test	 eax, eax
  00016	74 19		 je	 SHORT $LN2@Term

; 2620 : 			{
; 2621 : 				_ATL_OBJMAP_CACHE* pCache = (**ppEntry).pCache;

  00018	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 2622 : 
; 2623 : 				if (pCache->pCF != NULL)

  0001b	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  0001e	74 11		 je	 SHORT $LN2@Term

; 2624 : 				{
; 2625 : 					// Decode factory pointer if it's not null
; 2626 : 					IUnknown *factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  00020	ff 33		 push	 DWORD PTR [ebx]
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4

; 2627 : 					_Analysis_assume_(factory != nullptr);
; 2628 : 					factory->Release();

  00028	50		 push	 eax
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2629 : 					pCache->pCF = NULL;

  0002e	83 23 00	 and	 DWORD PTR [ebx], 0
$LN2@Term:

; 2615 : 			return;
; 2616 : 
; 2617 : 		for (_ATL_OBJMAP_ENTRY_EX** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)

  00031	83 c7 04	 add	 edi, 4
  00034	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  00037	72 d9		 jb	 SHORT $LL4@Term
  00039	5b		 pop	 ebx
$LN3@Term:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  0003a	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2637 : 		cbSize = 0;

  00044	83 26 00	 and	 DWORD PTR [esi], 0
  00047	5f		 pop	 edi
$LN1@Term:

; 2638 : 	}

  00048	5e		 pop	 esi
  00049	c3		 ret	 0
?Term@CAtlComModule@ATL@@QAEXXZ ENDP			; ATL::CAtlComModule::Term
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ??0CAtlComModule@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CAtlComModule@ATL@@QAE@XZ PROC			; ATL::CAtlComModule::CAtlComModule, COMDAT
; _this$ = ecx

; 2586 : 	CAtlComModule() throw()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00003	33 c0		 xor	 eax, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2586 : 	CAtlComModule() throw()

  00005	57		 push	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 125  : 		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));

  00006	6a 06		 push	 6
  00008	59		 pop	 ecx
  00009	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  0000c	f3 ab		 rep stosd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 2588 : 		cbSize = 0;

  0000e	21 06		 and	 DWORD PTR [esi], eax

; 2589 : 
; 2590 : 		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);
; 2591 : 
; 2592 : 		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;
; 2593 : 		m_ppAutoObjMapLast = &__pobjMapEntryLast;
; 2594 : 
; 2595 : 		if (FAILED(m_csObjMap.Init()))

  00010	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00013	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], OFFSET ___ImageBase
  0001a	c7 46 08 04 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET ___pobjMapEntryFirst+4
  00021	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], OFFSET ___pobjMapEntryLast
  00028	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init
  0002d	85 c0		 test	 eax, eax
  0002f	79 09		 jns	 SHORT $LN2@CAtlComMod

; 2596 : 		{
; 2597 : 			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
; 2598 : 			ATLASSERT(0);
; 2599 : 			CAtlBaseModule::m_bInitFailed = true;

  00031	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA, 1 ; ATL::CAtlBaseModule::m_bInitFailed

; 2600 : 			return;

  00038	eb 06		 jmp	 SHORT $LN1@CAtlComMod
$LN2@CAtlComMod:

; 2601 : 		}
; 2602 : 		// Set cbSize on success.
; 2603 : 		cbSize = sizeof(_ATL_COM_MODULE);

  0003a	c7 06 28 00 00
	00		 mov	 DWORD PTR [esi], 40	; 00000028H
$LN1@CAtlComMod:

; 2604 : 	}

  00040	5f		 pop	 edi
  00041	8b c6		 mov	 eax, esi
  00043	5e		 pop	 esi
  00044	c3		 ret	 0
??0CAtlComModule@ATL@@QAE@XZ ENDP			; ATL::CAtlComModule::CAtlComModule
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?RecurseDeleteKey@CRegKey@ATL@@QAEJPB_W@Z
_TEXT	SEGMENT
_time$ = -544						; size = 8
_lpszKey$GSCopy$1$ = -536				; size = 4
_dwSize$ = -532						; size = 4
_key$ = -528						; size = 12
_szBuffer$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_lpszKey$ = 8						; size = 4
?RecurseDeleteKey@CRegKey@ATL@@QAEJPB_W@Z PROC		; ATL::CRegKey::RecurseDeleteKey, COMDAT
; _this$ = ecx

; 6338 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b d9		 mov	 ebx, ecx

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  00016	33 c0		 xor	 eax, eax

; 6338 : {

  00018	8b 4d 08	 mov	 ecx, DWORD PTR _lpszKey$[ebp]

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  0001b	89 85 f0 fd ff
	ff		 mov	 DWORD PTR _key$[ebp], eax
  00021	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _key$[ebp+4], eax
  00027	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _key$[ebp+8], eax

; 6339 : 	CRegKey key;
; 6340 : 	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE | m_samWOW64);

  0002d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00030	56		 push	 esi
  00031	0d 1f 00 02 00	 or	 eax, 131103		; 0002001fH
  00036	89 8d e8 fd ff
	ff		 mov	 DWORD PTR _lpszKey$GSCopy$1$[ebp], ecx
  0003c	50		 push	 eax
  0003d	51		 push	 ecx
  0003e	ff 33		 push	 DWORD PTR [ebx]
  00040	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  00046	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z ; ATL::CRegKey::Open

; 6341 : 	if (lRes != ERROR_SUCCESS)
; 6342 : 	{
; 6343 : 		if (lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
; 6344 : 		{
; 6345 : 			ATLTRACE(atlTraceCOM, 0, _T("CRegKey::RecurseDeleteKey : Failed to Open Key %Ts(Error = %d)\n"), lpszKey, lRes);
; 6346 : 		}
; 6347 : 		return lRes;
; 6348 : 	}
; 6349 : 	FILETIME time;
; 6350 : 	DWORD dwSize = 256;
; 6351 : 	TCHAR szBuffer[256];
; 6352 : 	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
; 6353 : 		&time)==ERROR_SUCCESS)

  0004b	eb 12		 jmp	 SHORT $LN36@RecurseDel
$LL2@RecurseDel:

; 6354 : 	{
; 6355 : 		lRes = key.RecurseDeleteKey(szBuffer);

  0004d	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  00053	50		 push	 eax
  00054	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _key$[ebp]
  0005a	e8 00 00 00 00	 call	 ?RecurseDeleteKey@CRegKey@ATL@@QAEJPB_W@Z ; ATL::CRegKey::RecurseDeleteKey
$LN36@RecurseDel:

; 6341 : 	if (lRes != ERROR_SUCCESS)
; 6342 : 	{
; 6343 : 		if (lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
; 6344 : 		{
; 6345 : 			ATLTRACE(atlTraceCOM, 0, _T("CRegKey::RecurseDeleteKey : Failed to Open Key %Ts(Error = %d)\n"), lpszKey, lRes);
; 6346 : 		}
; 6347 : 		return lRes;
; 6348 : 	}
; 6349 : 	FILETIME time;
; 6350 : 	DWORD dwSize = 256;
; 6351 : 	TCHAR szBuffer[256];
; 6352 : 	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
; 6353 : 		&time)==ERROR_SUCCESS)

  0005f	8b f0		 mov	 esi, eax
  00061	85 f6		 test	 esi, esi
  00063	75 62		 jne	 SHORT $LN31@RecurseDel
  00065	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR _time$[ebp]
  0006b	c7 85 ec fd ff
	ff 00 01 00 00	 mov	 DWORD PTR _dwSize$[ebp], 256 ; 00000100H
  00075	50		 push	 eax
  00076	56		 push	 esi
  00077	56		 push	 esi
  00078	56		 push	 esi
  00079	8d 85 ec fd ff
	ff		 lea	 eax, DWORD PTR _dwSize$[ebp]
  0007f	50		 push	 eax
  00080	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  00086	50		 push	 eax
  00087	56		 push	 esi
  00088	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _key$[ebp]
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegEnumKeyExW@32
  00094	85 c0		 test	 eax, eax
  00096	74 b5		 je	 SHORT $LL2@RecurseDel

; 5804 : 	if (m_hKey != NULL)

  00098	39 b5 f0 fd ff
	ff		 cmp	 DWORD PTR _key$[ebp], esi
  0009e	74 12		 je	 SHORT $LN23@RecurseDel

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  000a0	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _key$[ebp]
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 5807 : 		m_hKey = NULL;

  000ac	89 b5 f0 fd ff
	ff		 mov	 DWORD PTR _key$[ebp], esi
$LN23@RecurseDel:

; 6356 : 		if (lRes != ERROR_SUCCESS)
; 6357 : 			return lRes;
; 6358 : 		dwSize = 256;
; 6359 : 	}
; 6360 : 	key.Close();
; 6361 : 	return DeleteSubKey(lpszKey);

  000b2	ff b5 e8 fd ff
	ff		 push	 DWORD PTR _lpszKey$GSCopy$1$[ebp]
  000b8	8b cb		 mov	 ecx, ebx

; 5809 : 	m_samWOW64 = 0;

  000ba	89 b5 f4 fd ff
	ff		 mov	 DWORD PTR _key$[ebp+4], esi

; 6356 : 		if (lRes != ERROR_SUCCESS)
; 6357 : 			return lRes;
; 6358 : 		dwSize = 256;
; 6359 : 	}
; 6360 : 	key.Close();
; 6361 : 	return DeleteSubKey(lpszKey);

  000c0	e8 00 00 00 00	 call	 ?DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z ; ATL::CRegKey::DeleteSubKey
  000c5	8b f0		 mov	 esi, eax
$LN31@RecurseDel:

; 5804 : 	if (m_hKey != NULL)

  000c7	83 bd f0 fd ff
	ff 00		 cmp	 DWORD PTR _key$[ebp], 0
  000ce	74 0c		 je	 SHORT $LN28@RecurseDel

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  000d0	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _key$[ebp]
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4
$LN28@RecurseDel:

; 6362 : }

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	8b c6		 mov	 eax, esi
  000e1	5e		 pop	 esi
  000e2	33 cd		 xor	 ecx, ebp
  000e4	5b		 pop	 ebx
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	c9		 leave
  000eb	c2 04 00	 ret	 4
?RecurseDeleteKey@CRegKey@ATL@@QAEJPB_W@Z ENDP		; ATL::CRegKey::RecurseDeleteKey
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z
_TEXT	SEGMENT
_lpszSubKey$ = 8					; size = 4
?DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z PROC		; ATL::CRegKey::DeleteSubKey, COMDAT
; _this$ = ecx

; 5755 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 5756 : 	ATLASSUME(m_hKey != NULL);
; 5757 : 
; 5758 : 	if (m_pTM != NULL)

  00006	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00009	85 c9		 test	 ecx, ecx
  0000b	74 0c		 je	 SHORT $LN5@DeleteSubK

; 5759 : 	{
; 5760 : 		return m_pTM->RegDeleteKey(m_hKey, lpszSubKey);

  0000d	ff 75 08	 push	 DWORD PTR _lpszSubKey$[ebp]
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ?RegDeleteKeyW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_W@Z ; ATL::CAtlTransactionManager::RegDeleteKeyW
  00017	eb 5b		 jmp	 SHORT $LN1@DeleteSubK
$LN5@DeleteSubK:

; 5761 : 	}
; 5762 : 
; 5763 : #if WINVER >= 0x0501
; 5764 : #ifdef _UNICODE
; 5765 : 	static decltype(RegDeleteKeyExW) *pfnRegDeleteKeyEx = NULL;
; 5766 : #else
; 5767 : 	static decltype(RegDeleteKeyExA) *pfnRegDeleteKeyEx = NULL;
; 5768 : #endif	// _UNICODE
; 5769 : 	static bool bInitialized = false;
; 5770 : 
; 5771 : 	if (!bInitialized)

  00019	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4_NA, 0 ; `ATL::CRegKey::DeleteSubKey'::`2'::bInitialized
  00020	75 30		 jne	 SHORT $LN11@DeleteSubK

; 5772 : 	{
; 5773 : 		HMODULE hAdvapi32 = GetModuleHandle(_T("Advapi32.dll"));

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@BIGILECK@?$AAA?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4

; 5774 : 		if (hAdvapi32 != NULL)

  0002d	85 c0		 test	 eax, eax
  0002f	74 13		 je	 SHORT $LN10@DeleteSubK

; 5775 : 		{
; 5776 : #ifdef _UNICODE
; 5777 : 			pfnRegDeleteKeyEx = (decltype(RegDeleteKeyExW) *)GetProcAddress(hAdvapi32, "RegDeleteKeyExW");

  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LILAPHGE@RegDeleteKeyExW@
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0003d	a3 00 00 00 00	 mov	 DWORD PTR ?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4P6GJPAUHKEY__@@0KK@ZA, eax ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx
  00042	eb 05		 jmp	 SHORT $LN7@DeleteSubK
$LN10@DeleteSubK:

; 5774 : 		if (hAdvapi32 != NULL)

  00044	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4P6GJPAUHKEY__@@0KK@ZA ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx
$LN7@DeleteSubK:

; 5778 : #else
; 5779 : 			pfnRegDeleteKeyEx = (decltype(RegDeleteKeyExA) *)GetProcAddress(hAdvapi32, "RegDeleteKeyExA");
; 5780 : #endif	// _UNICODE
; 5781 : 		}
; 5782 : 		bInitialized = true;

  00049	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?bInitialized@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4_NA, 1 ; `ATL::CRegKey::DeleteSubKey'::`2'::bInitialized
  00050	eb 05		 jmp	 SHORT $LN6@DeleteSubK
$LN11@DeleteSubK:

; 5761 : 	}
; 5762 : 
; 5763 : #if WINVER >= 0x0501
; 5764 : #ifdef _UNICODE
; 5765 : 	static decltype(RegDeleteKeyExW) *pfnRegDeleteKeyEx = NULL;
; 5766 : #else
; 5767 : 	static decltype(RegDeleteKeyExA) *pfnRegDeleteKeyEx = NULL;
; 5768 : #endif	// _UNICODE
; 5769 : 	static bool bInitialized = false;
; 5770 : 
; 5771 : 	if (!bInitialized)

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pfnRegDeleteKeyEx@?1??DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z@4P6GJPAUHKEY__@@0KK@ZA ; `ATL::CRegKey::DeleteSubKey'::`2'::pfnRegDeleteKeyEx
$LN6@DeleteSubK:

; 5783 : 	}
; 5784 : 
; 5785 : 	if (pfnRegDeleteKeyEx != NULL)

  00057	85 c0		 test	 eax, eax
  00059	74 0e		 je	 SHORT $LN8@DeleteSubK

; 5786 : 	{
; 5787 : 		return pfnRegDeleteKeyEx(m_hKey, lpszSubKey, m_samWOW64, 0);

  0005b	6a 00		 push	 0
  0005d	ff 76 04	 push	 DWORD PTR [esi+4]
  00060	ff 75 08	 push	 DWORD PTR _lpszSubKey$[ebp]
  00063	ff 36		 push	 DWORD PTR [esi]
  00065	ff d0		 call	 eax
  00067	eb 0b		 jmp	 SHORT $LN1@DeleteSubK
$LN8@DeleteSubK:

; 5788 : 	}
; 5789 : 
; 5790 : #endif	// WINVER
; 5791 : 
; 5792 : 	return RegDeleteKey(m_hKey, lpszSubKey);

  00069	ff 75 08	 push	 DWORD PTR _lpszSubKey$[ebp]
  0006c	ff 36		 push	 DWORD PTR [esi]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegDeleteKeyW@8
$LN1@DeleteSubK:
  00074	5e		 pop	 esi

; 5793 : }

  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
?DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z ENDP		; ATL::CRegKey::DeleteSubKey
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?Close@CRegKey@ATL@@QAEJXZ
_TEXT	SEGMENT
?Close@CRegKey@ATL@@QAEJXZ PROC				; ATL::CRegKey::Close, COMDAT
; _this$ = ecx

; 5802 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 5803 : 	LONG lRes = ERROR_SUCCESS;

  00003	33 c0		 xor	 eax, eax

; 5804 : 	if (m_hKey != NULL)

  00005	39 06		 cmp	 DWORD PTR [esi], eax
  00007	74 0b		 je	 SHORT $LN2@Close

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 5807 : 		m_hKey = NULL;

  00011	83 26 00	 and	 DWORD PTR [esi], 0
$LN2@Close:

; 5808 : 	}
; 5809 : 	m_samWOW64 = 0;

  00014	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 5810 : 	return lRes;

  00018	5e		 pop	 esi

; 5811 : }

  00019	c3		 ret	 0
?Close@CRegKey@ATL@@QAEJXZ ENDP				; ATL::CRegKey::Close
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z
_TEXT	SEGMENT
_hKey$ = -4						; size = 4
_hKeyParent$ = 8					; size = 4
_lpszKeyName$ = 12					; size = 4
_samDesired$ = 16					; size = 4
?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z PROC		; ATL::CRegKey::Open, COMDAT
; _this$ = ecx

; 5882 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 5883 : 	ATLASSUME(hKeyParent != NULL);
; 5884 : 	HKEY hKey = NULL;
; 5885 : 	LONG lRes = m_pTM != NULL ?

  00005	8b 75 10	 mov	 esi, DWORD PTR _samDesired$[ebp]
  00008	8d 45 fc	 lea	 eax, DWORD PTR _hKey$[ebp]
  0000b	57		 push	 edi
  0000c	50		 push	 eax
  0000d	33 d2		 xor	 edx, edx
  0000f	8b f9		 mov	 edi, ecx
  00011	56		 push	 esi
  00012	52		 push	 edx
  00013	ff 75 0c	 push	 DWORD PTR _lpszKeyName$[ebp]
  00016	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00019	89 55 fc	 mov	 DWORD PTR _hKey$[ebp], edx
  0001c	ff 75 08	 push	 DWORD PTR _hKeyParent$[ebp]
  0001f	85 c9		 test	 ecx, ecx
  00021	74 07		 je	 SHORT $LN7@Open
  00023	e8 00 00 00 00	 call	 ?RegOpenKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKKPAPAU3@@Z ; ATL::CAtlTransactionManager::RegOpenKeyExW
  00028	eb 06		 jmp	 SHORT $LN9@Open
$LN7@Open:
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExW@20
$LN9@Open:

; 5886 : 		m_pTM->RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey) :
; 5887 : 		RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
; 5888 : 	if (lRes == ERROR_SUCCESS)

  00030	8b c8		 mov	 ecx, eax
  00032	85 c9		 test	 ecx, ecx
  00034	75 17		 jne	 SHORT $LN5@Open

; 5889 : 	{
; 5890 : 		lRes = Close();

  00036	8b cf		 mov	 ecx, edi
  00038	e8 00 00 00 00	 call	 ?Close@CRegKey@ATL@@QAEJXZ ; ATL::CRegKey::Close
  0003d	8b c8		 mov	 ecx, eax

; 5891 : 		ATLASSERT(lRes == ERROR_SUCCESS);
; 5892 : 		m_hKey = hKey;
; 5893 : #if WINVER >= 0x0501
; 5894 : 		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);

  0003f	81 e6 00 03 00
	00		 and	 esi, 768		; 00000300H
  00045	8b 45 fc	 mov	 eax, DWORD PTR _hKey$[ebp]
  00048	89 07		 mov	 DWORD PTR [edi], eax
  0004a	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN5@Open:

; 5895 : #endif
; 5896 : 	}
; 5897 : 	return lRes;

  0004d	5f		 pop	 edi
  0004e	8b c1		 mov	 eax, ecx
  00050	5e		 pop	 esi

; 5898 : }

  00051	c9		 leave
  00052	c2 0c 00	 ret	 12			; 0000000cH
?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z ENDP		; ATL::CRegKey::Open
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?SetMultiStringValue@CRegKey@ATL@@QAEJPB_W0@Z
_TEXT	SEGMENT
tv87 = -4						; size = 4
_pszValueName$ = 8					; size = 4
tv128 = 12						; size = 4
_pszValue$ = 12						; size = 4
?SetMultiStringValue@CRegKey@ATL@@QAEJPB_W0@Z PROC	; ATL::CRegKey::SetMultiStringValue, COMDAT
; _this$ = ecx

; 6273 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 6274 : 	LPCTSTR pszTemp;
; 6275 : 	ULONG nBytes;
; 6276 : 	ULONG nLength;
; 6277 : 
; 6278 : 	ATLASSUME(m_hKey != NULL);
; 6279 : 	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);

  00004	8b 55 0c	 mov	 edx, DWORD PTR _pszValue$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	85 d2		 test	 edx, edx
  0000c	75 05		 jne	 SHORT $LN5@SetMultiSt
  0000e	6a 0d		 push	 13			; 0000000dH
  00010	58		 pop	 eax
  00011	eb 44		 jmp	 SHORT $LN1@SetMultiSt
$LN5@SetMultiSt:
  00013	56		 push	 esi

; 6280 : 
; 6281 : 	// Find the total length (in bytes) of all of the strings, including the
; 6282 : 	// terminating '\0' of each string, and the second '\0' that terminates
; 6283 : 	// the list.
; 6284 : 	nBytes = 0;

  00014	33 c0		 xor	 eax, eax
  00016	57		 push	 edi
  00017	89 45 0c	 mov	 DWORD PTR tv128[ebp], eax
  0001a	8b f0		 mov	 esi, eax

; 6285 : 	pszTemp = pszValue;

  0001c	8b fa		 mov	 edi, edx
$LL10@SetMultiSt:

; 6286 : 	do
; 6287 : 	{
; 6288 : 		nLength = static_cast<ULONG>(_tcslen(pszTemp))+1;

  0001e	8b cf		 mov	 ecx, edi
  00020	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  00023	89 45 fc	 mov	 DWORD PTR tv87[ebp], eax
$LL16@SetMultiSt:
  00026	66 8b 01	 mov	 ax, WORD PTR [ecx]
  00029	83 c1 02	 add	 ecx, 2
  0002c	66 3b 45 0c	 cmp	 ax, WORD PTR tv128[ebp]
  00030	75 f4		 jne	 SHORT $LL16@SetMultiSt
  00032	2b 4d fc	 sub	 ecx, DWORD PTR tv87[ebp]
  00035	d1 f9		 sar	 ecx, 1
  00037	41		 inc	 ecx

; 6289 : 		pszTemp += nLength;

  00038	8d 3c 4f	 lea	 edi, DWORD PTR [edi+ecx*2]
  0003b	8d 34 4e	 lea	 esi, DWORD PTR [esi+ecx*2]

; 6290 : 		nBytes += nLength*sizeof(TCHAR);
; 6291 : 	} while (nLength != 1);

  0003e	83 f9 01	 cmp	 ecx, 1
  00041	75 db		 jne	 SHORT $LL10@SetMultiSt

; 6292 : 
; 6293 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_MULTI_SZ, reinterpret_cast<const BYTE*>(pszValue),

  00043	56		 push	 esi
  00044	52		 push	 edx
  00045	6a 07		 push	 7
  00047	33 c0		 xor	 eax, eax
  00049	50		 push	 eax
  0004a	ff 75 08	 push	 DWORD PTR _pszValueName$[ebp]
  0004d	ff 33		 push	 DWORD PTR [ebx]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExW@24
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
$LN1@SetMultiSt:
  00057	5b		 pop	 ebx

; 6294 : 		nBytes);
; 6295 : }

  00058	c9		 leave
  00059	c2 08 00	 ret	 8
?SetMultiStringValue@CRegKey@ATL@@QAEJPB_W0@Z ENDP	; ATL::CRegKey::SetMultiStringValue
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?SetStringValue@CRegKey@ATL@@QAEJPB_W0K@Z
_TEXT	SEGMENT
_pszValueName$ = 8					; size = 4
_pszValue$ = 12						; size = 4
_dwType$ = 16						; size = 4
?SetStringValue@CRegKey@ATL@@QAEJPB_W0K@Z PROC		; ATL::CRegKey::SetStringValue, COMDAT
; _this$ = ecx

; 6262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6263 : 	ATLASSUME(m_hKey != NULL);
; 6264 : 	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);

  00003	8b 55 0c	 mov	 edx, DWORD PTR _pszValue$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	85 d2		 test	 edx, edx
  0000b	75 05		 jne	 SHORT $LN5@SetStringV
  0000d	6a 0d		 push	 13			; 0000000dH
  0000f	58		 pop	 eax
  00010	eb 32		 jmp	 SHORT $LN1@SetStringV
$LN5@SetStringV:

; 6265 : 	ATLASSERT((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ));
; 6266 : 
; 6267 : 	return ::RegSetValueEx(m_hKey, pszValueName, 0, dwType, reinterpret_cast<const BYTE*>(pszValue), (static_cast<DWORD>(_tcslen(pszValue))+1)*sizeof(TCHAR));

  00012	8b ca		 mov	 ecx, edx
  00014	53		 push	 ebx
  00015	57		 push	 edi
  00016	33 db		 xor	 ebx, ebx
  00018	8d 79 02	 lea	 edi, DWORD PTR [ecx+2]
$LL10@SetStringV:
  0001b	66 8b 01	 mov	 ax, WORD PTR [ecx]
  0001e	83 c1 02	 add	 ecx, 2
  00021	66 3b c3	 cmp	 ax, bx
  00024	75 f5		 jne	 SHORT $LL10@SetStringV
  00026	2b cf		 sub	 ecx, edi
  00028	d1 f9		 sar	 ecx, 1
  0002a	8d 04 4d 02 00
	00 00		 lea	 eax, DWORD PTR [ecx*2+2]
  00031	50		 push	 eax
  00032	52		 push	 edx
  00033	ff 75 10	 push	 DWORD PTR _dwType$[ebp]
  00036	53		 push	 ebx
  00037	ff 75 08	 push	 DWORD PTR _pszValueName$[ebp]
  0003a	ff 36		 push	 DWORD PTR [esi]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegSetValueExW@24
  00042	5f		 pop	 edi
  00043	5b		 pop	 ebx
$LN1@SetStringV:
  00044	5e		 pop	 esi

; 6268 : }

  00045	5d		 pop	 ebp
  00046	c2 0c 00	 ret	 12			; 0000000cH
?SetStringValue@CRegKey@ATL@@QAEJPB_W0K@Z ENDP		; ATL::CRegKey::SetStringValue
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z PROC		; ATL::InlineIsEqualUnknown, COMDAT

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 667  :    return (

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	39 01		 cmp	 DWORD PTR [ecx], eax
  0000a	75 18		 jne	 SHORT $LN4@InlineIsEq
  0000c	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  0000f	75 13		 jne	 SHORT $LN4@InlineIsEq
  00011	81 79 08 c0 00
	00 00		 cmp	 DWORD PTR [ecx+8], 192	; 000000c0H
  00018	75 0a		 jne	 SHORT $LN4@InlineIsEq
  0001a	81 79 0c 00 00
	00 46		 cmp	 DWORD PTR [ecx+12], 1174405120 ; 46000000H
  00021	75 01		 jne	 SHORT $LN4@InlineIsEq
  00023	40		 inc	 eax
$LN4@InlineIsEq:

; 668  : 	  ((PLONG) &rguid1)[0] == 0 &&
; 669  : 	  ((PLONG) &rguid1)[1] == 0 &&
; 670  : #ifdef _ATL_BYTESWAP
; 671  : 	  ((PLONG) &rguid1)[2] == 0xC0000000 &&
; 672  : 	  ((PLONG) &rguid1)[3] == 0x00000046);
; 673  : #else
; 674  : 	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
; 675  : 	  ((PLONG) &rguid1)[3] == 0x46000000);
; 676  : #endif
; 677  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z ENDP		; ATL::InlineIsEqualUnknown
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleExtractCreateWndData@ATL@@YGPAXPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_lock$$sroa$66$1$ = 8					; size = 4
_pWinModule$ = 8					; size = 4
?AtlWinModuleExtractCreateWndData@ATL@@YGPAXPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleExtractCreateWndData, COMDAT

; 8359 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 8360 : 	if (pWinModule == NULL)

  00004	8b 7d 08	 mov	 edi, DWORD PTR _pWinModule$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	75 04		 jne	 SHORT $LN4@AtlWinModu

; 8361 : 		return NULL;

  0000b	33 c0		 xor	 eax, eax
  0000d	eb 4f		 jmp	 SHORT $LN1@AtlWinModu
$LN4@AtlWinModu:
  0000f	53		 push	 ebx

; 8364 : 	CComCritSecLock<CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);

  00010	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00013	33 db		 xor	 ebx, ebx
  00015	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  00016	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8364 : 	CComCritSecLock<CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);

  00017	89 45 08	 mov	 DWORD PTR _lock$$sroa$66$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8371 : 	_AtlCreateWndData* pEntry = pWinModule->m_pCreateWndList;

  00020	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]

; 8372 : 	if(pEntry != NULL)

  00023	85 f6		 test	 esi, esi
  00025	74 2a		 je	 SHORT $LN3@AtlWinModu

; 8373 : 	{
; 8374 : 		DWORD dwThreadID = ::GetCurrentThreadId();

  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0
  0002d	8b d0		 mov	 edx, eax

; 8375 : 		_AtlCreateWndData* pPrev = NULL;

  0002f	8b cb		 mov	 ecx, ebx
$LL2@AtlWinModu:

; 8376 : 		while(pEntry != NULL)
; 8377 : 		{
; 8378 : 			if(pEntry->m_dwThreadID == dwThreadID)

  00031	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00034	39 56 04	 cmp	 DWORD PTR [esi+4], edx
  00037	74 0a		 je	 SHORT $LN54@AtlWinModu

; 8385 : 				break;
; 8386 : 			}
; 8387 : 			pPrev = pEntry;

  00039	8b ce		 mov	 ecx, esi

; 8388 : 			pEntry = pEntry->m_pNext;

  0003b	8b f0		 mov	 esi, eax
  0003d	85 f6		 test	 esi, esi
  0003f	75 f0		 jne	 SHORT $LL2@AtlWinModu

; 8376 : 		while(pEntry != NULL)
; 8377 : 		{
; 8378 : 			if(pEntry->m_dwThreadID == dwThreadID)

  00041	eb 0e		 jmp	 SHORT $LN3@AtlWinModu
$LN54@AtlWinModu:

; 8379 : 			{
; 8380 : 				if(pPrev == NULL)

  00043	85 c9		 test	 ecx, ecx
  00045	75 05		 jne	 SHORT $LN8@AtlWinModu

; 8381 : 					pWinModule->m_pCreateWndList = pEntry->m_pNext;

  00047	89 47 1c	 mov	 DWORD PTR [edi+28], eax
  0004a	eb 03		 jmp	 SHORT $LN9@AtlWinModu
$LN8@AtlWinModu:

; 8382 : 				else
; 8383 : 					pPrev->m_pNext = pEntry->m_pNext;

  0004c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN9@AtlWinModu:

; 8384 : 				pv = pEntry->m_pThis;

  0004f	8b 1e		 mov	 ebx, DWORD PTR [esi]
$LN3@AtlWinModu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  00051	ff 75 08	 push	 DWORD PTR _lock$$sroa$66$1$[ebp]
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8391 : 	return pv;

  0005a	5e		 pop	 esi
  0005b	8b c3		 mov	 eax, ebx
  0005d	5b		 pop	 ebx
$LN1@AtlWinModu:
  0005e	5f		 pop	 edi

; 8392 : }

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?AtlWinModuleExtractCreateWndData@ATL@@YGPAXPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleExtractCreateWndData
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleAddCreateWndData@ATL@@YGXPAU_ATL_WIN_MODULE70@1@PAU_AtlCreateWndData@1@PAX@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_pData$ = 12						; size = 4
_pObject$ = 16						; size = 4
?AtlWinModuleAddCreateWndData@ATL@@YGXPAU_ATL_WIN_MODULE70@1@PAU_AtlCreateWndData@1@PAX@Z PROC ; ATL::AtlWinModuleAddCreateWndData, COMDAT

; 8336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 8337 : 	if (pWinModule == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _pWinModule$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	85 db		 test	 ebx, ebx
  0000b	74 3a		 je	 SHORT $LN4@AtlWinModu

; 8338 : 		_AtlRaiseException((DWORD)EXCEPTION_ACCESS_VIOLATION);
; 8339 : 
; 8340 : 	ATLASSERT(pData != NULL && pObject != NULL);
; 8341 : 	if(pData == NULL || pObject == NULL)

  0000d	8b 7d 0c	 mov	 edi, DWORD PTR _pData$[ebp]
  00010	85 ff		 test	 edi, edi
  00012	74 33		 je	 SHORT $LN4@AtlWinModu
  00014	8b 45 10	 mov	 eax, DWORD PTR _pObject$[ebp]
  00017	85 c0		 test	 eax, eax
  00019	74 2c		 je	 SHORT $LN4@AtlWinModu

; 8343 : 
; 8344 : 	pData->m_pThis = pObject;

  0001b	89 07		 mov	 DWORD PTR [edi], eax

; 8345 : 	pData->m_dwThreadID = ::GetCurrentThreadId();

  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentThreadId@0

; 8346 : 	CComCritSecLock<CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);

  00023	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  00026	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  00029	56		 push	 esi
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8353 : 	pData->m_pNext = pWinModule->m_pCreateWndList;

  00030	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  00033	89 47 08	 mov	 DWORD PTR [edi+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  00036	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8354 : 	pWinModule->m_pCreateWndList = pData;

  00037	89 7b 1c	 mov	 DWORD PTR [ebx+28], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8355 : }

  00043	5d		 pop	 ebp
  00044	c2 0c 00	 ret	 12			; 0000000cH
$LN4@AtlWinModu:

; 8342 : 		_AtlRaiseException((DWORD)EXCEPTION_ACCESS_VIOLATION);

  00047	6a 01		 push	 1
  00049	68 05 00 00 c0	 push	 -1073741819		; c0000005H
  0004e	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN50@AtlWinModu:
  00053	cc		 int	 3
?AtlWinModuleAddCreateWndData@ATL@@YGXPAU_ATL_WIN_MODULE70@1@PAU_AtlCreateWndData@1@PAX@Z ENDP ; ATL::AtlWinModuleAddCreateWndData
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
_hInst$ = 12						; size = 4
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z PROC ; ATL::AtlWinModuleTerm, COMDAT

; 7652 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _pWinModule$[ebp]

; 7653 : 	if (pWinModule == NULL)

  00007	85 f6		 test	 esi, esi
  00009	74 4e		 je	 SHORT $LN16@AtlWinModu

; 7654 : 		return E_INVALIDARG;
; 7655 : 	if (pWinModule->cbSize == 0)

  0000b	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0000e	75 04		 jne	 SHORT $LN6@AtlWinModu

; 7656 : 		return S_OK;

  00010	33 c0		 xor	 eax, eax
  00012	eb 4a		 jmp	 SHORT $LN1@AtlWinModu
$LN6@AtlWinModu:

; 7657 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  00014	83 3e 2c	 cmp	 DWORD PTR [esi], 44	; 0000002cH
  00017	75 40		 jne	 SHORT $LN16@AtlWinModu

; 7659 : 
; 7660 : 	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)

  00019	53		 push	 ebx
  0001a	57		 push	 edi
  0001b	33 ff		 xor	 edi, edi
  0001d	39 7e 24	 cmp	 DWORD PTR [esi+36], edi
  00020	7e 1c		 jle	 SHORT $LN14@AtlWinModu
$LL4@AtlWinModu:

; 7661 : 		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);

  00022	57		 push	 edi
  00023	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00026	e8 00 00 00 00	 call	 ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
  0002b	ff 75 0c	 push	 DWORD PTR _hInst$[ebp]
  0002e	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnregisterClassW@8
  00038	47		 inc	 edi
  00039	3b 7e 24	 cmp	 edi, DWORD PTR [esi+36]
  0003c	7c e4		 jl	 SHORT $LL4@AtlWinModu
$LN14@AtlWinModu:

; 7662 : 	pWinModule->m_rgWindowClassAtoms.RemoveAll();

  0003e	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00041	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 155  : 		DeleteCriticalSection(&m_sec);

  00046	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00049	50		 push	 eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7664 : 	pWinModule->cbSize = 0;

  00050	83 26 00	 and	 DWORD PTR [esi], 0

; 7665 : 	return S_OK;

  00053	33 c0		 xor	 eax, eax
  00055	5f		 pop	 edi
  00056	5b		 pop	 ebx
  00057	eb 05		 jmp	 SHORT $LN1@AtlWinModu
$LN16@AtlWinModu:

; 7658 : 		return E_INVALIDARG;

  00059	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN1@AtlWinModu:
  0005e	5e		 pop	 esi

; 7666 : }

  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?AtlWinModuleTerm@ATL@@YGJPAU_ATL_WIN_MODULE70@1@PAUHINSTANCE__@@@Z ENDP ; ATL::AtlWinModuleTerm
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z
_TEXT	SEGMENT
_pWinModule$ = 8					; size = 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z PROC ; ATL::AtlWinModuleInit, COMDAT

; 8396 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 8397 : 	if (pWinModule == NULL)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _pWinModule$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 13		 je	 SHORT $LN6@AtlWinModu

; 8398 : 		return E_INVALIDARG;
; 8399 : 
; 8400 : 	// check only in the DLL
; 8401 : 	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))

  0000a	83 39 2c	 cmp	 DWORD PTR [ecx], 44	; 0000002cH
  0000d	75 0e		 jne	 SHORT $LN6@AtlWinModu

; 8403 : 
; 8404 : 	pWinModule->m_pCreateWndList = NULL;

  0000f	83 61 1c 00	 and	 DWORD PTR [ecx+28], 0

; 8405 : 
; 8406 : 	HRESULT hr = pWinModule->m_csWindowCreate.Init();

  00013	83 c1 04	 add	 ecx, 4
  00016	e8 00 00 00 00	 call	 ?Init@CComCriticalSection@ATL@@QAEJXZ ; ATL::CComCriticalSection::Init

; 8407 : 	if (FAILED(hr))
; 8408 : 	{
; 8409 : 		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));
; 8410 : 		ATLASSERT(0);
; 8411 : 	}
; 8412 : 	return hr;

  0001b	eb 05		 jmp	 SHORT $LN1@AtlWinModu
$LN6@AtlWinModu:

; 8402 : 		return E_INVALIDARG;

  0001d	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN1@AtlWinModu:

; 8413 : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?AtlWinModuleInit@ATL@@YGJPAU_ATL_WIN_MODULE70@1@@Z ENDP ; ATL::AtlWinModuleInit
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z
_TEXT	SEGMENT
_pComModule$ = 8					; size = 4
_bUnRegTypeLib$ = 12					; size = 4
_pCLSID$ = 16						; size = 4
?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z PROC ; ATL::AtlComModuleUnregisterServer, COMDAT

; 7617 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7618 : 	ATLASSERT(pComModule != NULL);
; 7619 : 	if (pComModule == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _pComModule$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN5@AtlComModu

; 7620 : 		return E_INVALIDARG;

  0000b	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00010	eb 71		 jmp	 SHORT $LN1@AtlComModu
$LN5@AtlComModu:
  00012	53		 push	 ebx
  00013	57		 push	 edi

; 7621 : 
; 7622 : 	HRESULT hr = S_OK;
; 7623 : 
; 7624 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)

  00014	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00017	33 c9		 xor	 ecx, ecx
  00019	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  0001c	73 4f		 jae	 SHORT $LN22@AtlComModu
$LL4@AtlComModu:

; 7625 : 	{
; 7626 : 		if (*ppEntry != NULL)

  0001e	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00020	85 db		 test	 ebx, ebx
  00022	74 3d		 je	 SHORT $LN2@AtlComModu

; 7627 : 		{
; 7628 : 			_ATL_OBJMAP_ENTRY_EX* pEntry = *ppEntry;
; 7629 : 			if (pCLSID != NULL)

  00024	8b 45 10	 mov	 eax, DWORD PTR _pCLSID$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	74 18		 je	 SHORT $LN23@AtlComModu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0002b	33 d2		 xor	 edx, edx
$LL24@AtlComModu:
  0002d	8b 33		 mov	 esi, DWORD PTR [ebx]
  0002f	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00032	3b 04 96	 cmp	 eax, DWORD PTR [esi+edx*4]
  00035	8b 75 08	 mov	 esi, DWORD PTR _pComModule$[ebp]
  00038	75 27		 jne	 SHORT $LN2@AtlComModu
  0003a	8b 45 10	 mov	 eax, DWORD PTR _pCLSID$[ebp]
  0003d	42		 inc	 edx
  0003e	83 fa 04	 cmp	 edx, 4
  00041	75 ea		 jne	 SHORT $LL24@AtlComModu
$LN23@AtlComModu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7634 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid, pEntry->pfnGetCategoryMap(), FALSE );

  00043	6a 00		 push	 0
  00045	ff 53 18	 call	 DWORD PTR [ebx+24]
  00048	50		 push	 eax
  00049	ff 33		 push	 DWORD PTR [ebx]
  0004b	e8 00 00 00 00	 call	 ?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
  00050	8b c8		 mov	 ecx, eax

; 7635 : 			if (FAILED(hr))

  00052	85 c9		 test	 ecx, ecx
  00054	78 29		 js	 SHORT $LN11@AtlComModu

; 7636 : 				break;
; 7637 : 			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister

  00056	6a 00		 push	 0
  00058	ff 53 04	 call	 DWORD PTR [ebx+4]
  0005b	8b c8		 mov	 ecx, eax

; 7638 : 			if (FAILED(hr))

  0005d	85 c9		 test	 ecx, ecx
  0005f	78 1e		 js	 SHORT $LN11@AtlComModu
$LN2@AtlComModu:

; 7621 : 
; 7622 : 	HRESULT hr = S_OK;
; 7623 : 
; 7624 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)

  00061	83 c7 04	 add	 edi, 4
  00064	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  00067	72 b5		 jb	 SHORT $LL4@AtlComModu

; 7639 : 				break;
; 7640 : 		}
; 7641 : 	}
; 7642 : 	if (SUCCEEDED(hr) && bUnRegTypeLib)

  00069	85 c9		 test	 ecx, ecx
  0006b	78 12		 js	 SHORT $LN11@AtlComModu
$LN22@AtlComModu:
  0006d	83 7d 0c 00	 cmp	 DWORD PTR _bUnRegTypeLib$[ebp], 0
  00071	74 0c		 je	 SHORT $LN11@AtlComModu

; 7643 : 		hr = AtlUnRegisterTypeLib(pComModule->m_hInstTypeLib, 0);

  00073	6a 00		 push	 0
  00075	ff 76 04	 push	 DWORD PTR [esi+4]
  00078	e8 00 00 00 00	 call	 ?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z ; ATL::AtlUnRegisterTypeLib
  0007d	8b c8		 mov	 ecx, eax
$LN11@AtlComModu:

; 7644 : 
; 7645 : 	return hr;

  0007f	5f		 pop	 edi
  00080	8b c1		 mov	 eax, ecx
  00082	5b		 pop	 ebx
$LN1@AtlComModu:
  00083	5e		 pop	 esi

; 7646 : }

  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH
?AtlComModuleUnregisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ENDP ; ATL::AtlComModuleUnregisterServer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z
_TEXT	SEGMENT
_pComModule$ = 8					; size = 4
_bRegTypeLib$ = 12					; size = 4
_pCLSID$ = 16						; size = 4
?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z PROC ; ATL::AtlComModuleRegisterServer, COMDAT

; 7573 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7574 : 	ATLASSERT(pComModule != NULL);
; 7575 : 	if (pComModule == NULL)

  00004	8b 75 08	 mov	 esi, DWORD PTR _pComModule$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 07		 jne	 SHORT $LN8@AtlComModu

; 7576 : 		return E_INVALIDARG;

  0000b	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00010	eb 71		 jmp	 SHORT $LN1@AtlComModu
$LN8@AtlComModu:
  00012	53		 push	 ebx
  00013	57		 push	 edi

; 7577 : 	ATLASSERT(pComModule->m_hInstTypeLib != NULL);
; 7578 : 
; 7579 : 	HRESULT hr = S_OK;
; 7580 : 
; 7581 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)

  00014	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00017	33 c9		 xor	 ecx, ecx
  00019	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  0001c	73 4f		 jae	 SHORT $LN25@AtlComModu
$LL4@AtlComModu:

; 7582 : 	{
; 7583 : 		if (*ppEntry != NULL)

  0001e	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00020	85 db		 test	 ebx, ebx
  00022	74 3d		 je	 SHORT $LN2@AtlComModu

; 7584 : 		{
; 7585 : 			_ATL_OBJMAP_ENTRY_EX* pEntry = *ppEntry;
; 7586 : 			if (pCLSID != NULL)

  00024	8b 45 10	 mov	 eax, DWORD PTR _pCLSID$[ebp]
  00027	85 c0		 test	 eax, eax
  00029	74 18		 je	 SHORT $LN26@AtlComModu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0002b	33 d2		 xor	 edx, edx
$LL27@AtlComModu:
  0002d	8b 33		 mov	 esi, DWORD PTR [ebx]
  0002f	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00032	3b 04 96	 cmp	 eax, DWORD PTR [esi+edx*4]
  00035	8b 75 08	 mov	 esi, DWORD PTR _pComModule$[ebp]
  00038	75 27		 jne	 SHORT $LN2@AtlComModu
  0003a	8b 45 10	 mov	 eax, DWORD PTR _pCLSID$[ebp]
  0003d	42		 inc	 edx
  0003e	83 fa 04	 cmp	 edx, 4
  00041	75 ea		 jne	 SHORT $LL27@AtlComModu
$LN26@AtlComModu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7591 : 			hr = pEntry->pfnUpdateRegistry(TRUE);

  00043	6a 01		 push	 1
  00045	ff 53 04	 call	 DWORD PTR [ebx+4]
  00048	8b c8		 mov	 ecx, eax

; 7592 : 			if (FAILED(hr))

  0004a	85 c9		 test	 ecx, ecx
  0004c	78 31		 js	 SHORT $LN14@AtlComModu

; 7593 : 				break;
; 7594 : 			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,

  0004e	6a 01		 push	 1
  00050	ff 53 18	 call	 DWORD PTR [ebx+24]
  00053	50		 push	 eax
  00054	ff 33		 push	 DWORD PTR [ebx]
  00056	e8 00 00 00 00	 call	 ?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ; ATL::AtlRegisterClassCategoriesHelper
  0005b	8b c8		 mov	 ecx, eax

; 7595 : 				pEntry->pfnGetCategoryMap(), TRUE );
; 7596 : 			if (FAILED(hr))

  0005d	85 c9		 test	 ecx, ecx
  0005f	78 1e		 js	 SHORT $LN14@AtlComModu
$LN2@AtlComModu:

; 7577 : 	ATLASSERT(pComModule->m_hInstTypeLib != NULL);
; 7578 : 
; 7579 : 	HRESULT hr = S_OK;
; 7580 : 
; 7581 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)

  00061	83 c7 04	 add	 edi, 4
  00064	3b 7e 0c	 cmp	 edi, DWORD PTR [esi+12]
  00067	72 b5		 jb	 SHORT $LL4@AtlComModu

; 7597 : 				break;
; 7598 : 		}
; 7599 : 	}
; 7600 : 
; 7601 : 	if (SUCCEEDED(hr) && bRegTypeLib)

  00069	85 c9		 test	 ecx, ecx
  0006b	78 12		 js	 SHORT $LN14@AtlComModu
$LN25@AtlComModu:
  0006d	83 7d 0c 00	 cmp	 DWORD PTR _bRegTypeLib$[ebp], 0
  00071	74 0c		 je	 SHORT $LN14@AtlComModu

; 7602 : 	{
; 7603 : 		ATLASSUME(pComModule->m_hInstTypeLib != NULL);
; 7604 : 		hr = AtlRegisterTypeLib(pComModule->m_hInstTypeLib, 0);

  00073	6a 00		 push	 0
  00075	ff 76 04	 push	 DWORD PTR [esi+4]
  00078	e8 00 00 00 00	 call	 ?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z ; ATL::AtlRegisterTypeLib
  0007d	8b c8		 mov	 ecx, eax
$LN14@AtlComModu:

; 7605 : 	}
; 7606 : 
; 7607 : 	return hr;

  0007f	5f		 pop	 edi
  00080	8b c1		 mov	 eax, ecx
  00082	5b		 pop	 ebx
$LN1@AtlComModu:
  00083	5e		 pop	 esi

; 7608 : }

  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH
?AtlComModuleRegisterServer@ATL@@YGJPAU_ATL_COM_MODULE70@1@HPBU_GUID@@@Z ENDP ; ATL::AtlComModuleRegisterServer
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z
_TEXT	SEGMENT
_bstrPath$ = -8						; size = 4
_pTypeLib$ = -4						; size = 4
_hInstTypeLib$ = 8					; size = 4
_ptla$1 = 12						; size = 4
_lpszIndex$ = 12					; size = 4
?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z PROC ; ATL::AtlUnRegisterTypeLib, COMDAT

; 7353 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  00005	83 65 f8 00	 and	 DWORD PTR _bstrPath$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7356 : 	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);

  00009	8d 45 fc	 lea	 eax, DWORD PTR _pTypeLib$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0000c	83 65 fc 00	 and	 DWORD PTR _pTypeLib$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7353 : {

  00010	56		 push	 esi

; 7356 : 	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);

  00011	50		 push	 eax
  00012	8d 45 f8	 lea	 eax, DWORD PTR _bstrPath$[ebp]
  00015	50		 push	 eax
  00016	ff 75 0c	 push	 DWORD PTR _lpszIndex$[ebp]
  00019	ff 75 08	 push	 DWORD PTR _hInstTypeLib$[ebp]
  0001c	e8 00 00 00 00	 call	 ?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_WPAPA_WPAPAUITypeLib@@@Z ; ATL::AtlLoadTypeLib
  00021	8b f0		 mov	 esi, eax

; 7357 : 	if (SUCCEEDED(hr))

  00023	85 f6		 test	 esi, esi
  00025	78 67		 js	 SHORT $LN3@AtlUnRegis

; 7358 : 	{
; 7359 : 		TLIBATTR* ptla;
; 7360 : 		hr = pTypeLib->GetLibAttr(&ptla);

  00027	8b 45 fc	 mov	 eax, DWORD PTR _pTypeLib$[ebp]
  0002a	8d 55 0c	 lea	 edx, DWORD PTR _ptla$1[ebp]
  0002d	52		 push	 edx
  0002e	50		 push	 eax
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	ff 51 1c	 call	 DWORD PTR [ecx+28]
  00034	8b f0		 mov	 esi, eax

; 7361 : 		if (SUCCEEDED(hr))

  00036	85 f6		 test	 esi, esi
  00038	78 54		 js	 SHORT $LN3@AtlUnRegis

; 7362 : 		{
; 7363 : 			typedef HRESULT (STDAPICALLTYPE *PFNUNREGISTERTYPELIB)(REFGUID, WORD /* wVerMajor */, WORD /* wVerMinor */, LCID, SYSKIND);
; 7364 : 			PFNUNREGISTERTYPELIB pfnUnRegisterTypeLib = NULL;
; 7365 : 
; 7366 : 			bool bRedirectionEnabled = false;
; 7367 : 			hr = AtlGetPerUserRegistration(&bRedirectionEnabled);
; 7368 : 			if( FAILED(hr) )
; 7369 : 			{
; 7370 : 				return hr;
; 7371 : 			}
; 7372 : 
; 7373 : 			if( true == bRedirectionEnabled )

  0003a	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?_AtlRegisterPerUser@ATL@@3_NA, 1 ; ATL::_AtlRegisterPerUser
  00041	75 21		 jne	 SHORT $LN33@AtlUnRegis

; 7374 : 			{
; 7375 : 				HMODULE hmodOleAut=::GetModuleHandleW(L"OLEAUT32.DLL");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@EDKOLFBJ@?$AAO?$AAL?$AAE?$AAA?$AAU?$AAT?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL@
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4

; 7376 : 				if(hmodOleAut)

  0004e	85 c0		 test	 eax, eax
  00050	74 12		 je	 SHORT $LN33@AtlUnRegis

; 7377 : 				{
; 7378 : 					pfnUnRegisterTypeLib=reinterpret_cast<PFNUNREGISTERTYPELIB>(::GetProcAddress(hmodOleAut, "UnRegisterTypeLibForUser"));

  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CNLFOMHB@UnRegisterTypeLibForUser@
  00057	50		 push	 eax
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8
  0005e	8b d0		 mov	 edx, eax

; 7379 : 				}
; 7380 : 			}
; 7381 : 
; 7382 : 			if( NULL == pfnUnRegisterTypeLib )

  00060	85 d2		 test	 edx, edx
  00062	75 06		 jne	 SHORT $LN7@AtlUnRegis
$LN33@AtlUnRegis:

; 7383 : 			{
; 7384 : 				pfnUnRegisterTypeLib = (PFNUNREGISTERTYPELIB)&UnRegisterTypeLib;

  00064	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp__UnRegisterTypeLib@20
$LN7@AtlUnRegis:

; 7385 : 			}
; 7386 : 
; 7387 : 			hr = pfnUnRegisterTypeLib(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);

  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _ptla$1[ebp]
  0006d	ff 71 14	 push	 DWORD PTR [ecx+20]
  00070	0f b7 41 1a	 movzx	 eax, WORD PTR [ecx+26]
  00074	ff 71 10	 push	 DWORD PTR [ecx+16]
  00077	50		 push	 eax
  00078	0f b7 41 18	 movzx	 eax, WORD PTR [ecx+24]
  0007c	50		 push	 eax
  0007d	51		 push	 ecx
  0007e	ff d2		 call	 edx

; 7388 : 
; 7389 : 			pTypeLib->ReleaseTLibAttr(ptla);

  00080	ff 75 0c	 push	 DWORD PTR _ptla$1[ebp]
  00083	8b f0		 mov	 esi, eax
  00085	8b 45 fc	 mov	 eax, DWORD PTR _pTypeLib$[ebp]
  00088	50		 push	 eax
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	ff 51 30	 call	 DWORD PTR [ecx+48]
$LN3@AtlUnRegis:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0008e	8b 45 fc	 mov	 eax, DWORD PTR _pTypeLib$[ebp]
  00091	85 c0		 test	 eax, eax
  00093	74 06		 je	 SHORT $LN29@AtlUnRegis

; 184  :             p->Release();

  00095	8b 08		 mov	 ecx, DWORD PTR [eax]
  00097	50		 push	 eax
  00098	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN29@AtlUnRegis:

; 1674 :     ::SysFreeString(m_str);

  0009b	ff 75 f8	 push	 DWORD PTR _bstrPath$[ebp]
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7392 : 	return hr;

  000a4	8b c6		 mov	 eax, esi
  000a6	5e		 pop	 esi

; 7393 : }

  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
?AtlUnRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z ENDP ; ATL::AtlUnRegisterTypeLib
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z
_TEXT	SEGMENT
_bstrPath$ = -536					; size = 4
_pTypeLib$ = -532					; size = 4
_bstrHelpFile$1 = -528					; size = 4
_szDirBuffer$2 = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_hInstTypeLib$ = 8					; size = 4
_lpszIndex$ = 12					; size = 4
?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z PROC	; ATL::AtlRegisterTypeLib, COMDAT

; 7398 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpszIndex$[ebp]

; 7401 : 	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);

  00016	8d 95 ec fd ff
	ff		 lea	 edx, DWORD PTR _pTypeLib$[ebp]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _hInstTypeLib$[ebp]
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	52		 push	 edx
  00022	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR _bstrPath$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  00028	33 f6		 xor	 esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7401 : 	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);

  0002a	52		 push	 edx
  0002b	50		 push	 eax
  0002c	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  0002d	89 b5 e8 fd ff
	ff		 mov	 DWORD PTR _bstrPath$[ebp], esi

; 165  :         p = NULL;

  00033	89 b5 ec fd ff
	ff		 mov	 DWORD PTR _pTypeLib$[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7401 : 	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);

  00039	e8 00 00 00 00	 call	 ?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_WPAPA_WPAPAUITypeLib@@@Z ; ATL::AtlLoadTypeLib
  0003e	8b f8		 mov	 edi, eax

; 7402 : 	if (SUCCEEDED(hr))

  00040	85 ff		 test	 edi, edi
  00042	0f 88 0c 01 00
	00		 js	 $LN2@AtlRegiste

; 7407 : 		hr = pTypeLib->GetDocumentation(-1, NULL, NULL, NULL, &bstrHelpFile);

  00048	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _pTypeLib$[ebp]
  0004e	8d 95 f0 fd ff
	ff		 lea	 edx, DWORD PTR _bstrHelpFile$1[ebp]
  00054	52		 push	 edx
  00055	56		 push	 esi
  00056	56		 push	 esi
  00057	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 728  :         m_str = NULL;

  00058	89 b5 f0 fd ff
	ff		 mov	 DWORD PTR _bstrHelpFile$1[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7407 : 		hr = pTypeLib->GetDocumentation(-1, NULL, NULL, NULL, &bstrHelpFile);

  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	6a ff		 push	 -1
  00062	50		 push	 eax
  00063	ff 51 24	 call	 DWORD PTR [ecx+36]

; 7408 : 		if (SUCCEEDED(hr) && bstrHelpFile != NULL)

  00066	85 c0		 test	 eax, eax
  00068	0f 88 9c 00 00
	00		 js	 $LN3@AtlRegiste
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 986  :         return (m_str == NULL);

  0006e	39 b5 f0 fd ff
	ff		 cmp	 DWORD PTR _bstrHelpFile$1[ebp], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7408 : 		if (SUCCEEDED(hr) && bstrHelpFile != NULL)

  00074	0f 84 90 00 00
	00		 je	 $LN3@AtlRegiste
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 880  :         return ::SysStringLen(m_str);

  0007a	53		 push	 ebx
  0007b	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _bstrHelpFile$1[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysStringLen@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 129  : 	return ATLMFC_CRT_ERRORCHECK(::wcsncpy_s(_Dest, _SizeInChars, _Source,_Count));

  00087	50		 push	 eax
  00088	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _bstrHelpFile$1[ebp]
  0008e	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szDirBuffer$2[ebp]
  00094	68 04 01 00 00	 push	 260			; 00000104H
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _wcsncpy_s
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7411 : 			szDirBuffer[MAX_PATH - 1] = 0;

  000a5	33 c0		 xor	 eax, eax

; 7335 : 	LPCOLESTR lpszTemp = lpszPathName;

  000a7	8d bd f4 fd ff
	ff		 lea	 edi, DWORD PTR _szDirBuffer$2[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 129  : 	return ATLMFC_CRT_ERRORCHECK(::wcsncpy_s(_Dest, _SizeInChars, _Source,_Count));

  000ad	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7411 : 			szDirBuffer[MAX_PATH - 1] = 0;

  000b0	66 89 45 fa	 mov	 WORD PTR _szDirBuffer$2[ebp+518], ax

; 7336 : 	for (LPCOLESTR lpsz = lpszPathName; *lpsz != '\0'; )

  000b4	8b df		 mov	 ebx, edi
  000b6	66 39 85 f4 fd
	ff ff		 cmp	 WORD PTR _szDirBuffer$2[ebp], ax
  000bd	74 22		 je	 SHORT $LN33@AtlRegiste
$LL32@AtlRegiste:

; 7337 : 	{
; 7338 : 
; 7339 : 		LPCOLESTR lp = CharNextW(lpsz);

  000bf	53		 push	 ebx
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4

; 7340 : 
; 7341 : 		// remember last directory/drive separator
; 7342 : 		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))

  000c6	0f b7 0b	 movzx	 ecx, WORD PTR [ebx]
  000c9	83 f9 5c	 cmp	 ecx, 92			; 0000005cH
  000cc	74 0a		 je	 SHORT $LN37@AtlRegiste
  000ce	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  000d1	74 05		 je	 SHORT $LN37@AtlRegiste
  000d3	83 f9 3a	 cmp	 ecx, 58			; 0000003aH
  000d6	75 02		 jne	 SHORT $LN36@AtlRegiste
$LN37@AtlRegiste:

; 7343 : 			lpszTemp = lp;

  000d8	8b f8		 mov	 edi, eax
$LN36@AtlRegiste:

; 7344 : 		lpsz = lp;

  000da	8b d8		 mov	 ebx, eax
  000dc	66 39 30	 cmp	 WORD PTR [eax], si
  000df	75 de		 jne	 SHORT $LL32@AtlRegiste
$LN33@AtlRegiste:

; 7345 : 	}
; 7346 : 
; 7347 : 	return UINT( lpszTemp-lpszPathName );

  000e1	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _szDirBuffer$2[ebp]
  000e7	2b f8		 sub	 edi, eax
  000e9	d1 ff		 sar	 edi, 1

; 7412 : 
; 7413 : 			// truncate at the directory level
; 7414 : 			szDirBuffer[AtlGetDirLen(szDirBuffer)] = 0;

  000eb	03 ff		 add	 edi, edi
  000ed	5b		 pop	 ebx
  000ee	81 ff 08 02 00
	00		 cmp	 edi, 520		; 00000208H
  000f4	0f 83 88 00 00
	00		 jae	 $LN11@AtlRegiste
  000fa	33 c0		 xor	 eax, eax

; 7415 : 
; 7416 : 			szDir=&szDirBuffer[0];

  000fc	8d b5 f4 fd ff
	ff		 lea	 esi, DWORD PTR _szDirBuffer$2[ebp]
  00102	66 89 84 3d f4
	fd ff ff	 mov	 WORD PTR _szDirBuffer$2[ebp+edi], ax
$LN3@AtlRegiste:

; 7417 : 		}
; 7418 : 
; 7419 : 		typedef HRESULT (STDAPICALLTYPE *PFNREGISTERTYPELIB)(ITypeLib *, LPCOLESTR /* const szFullPath */, LPCOLESTR /* const szHelpDir */);
; 7420 : 		PFNREGISTERTYPELIB pfnRegisterTypeLib = NULL;
; 7421 : 
; 7422 : 		bool bRedirectionEnabled = false;
; 7423 : 		hr = AtlGetPerUserRegistration(&bRedirectionEnabled);
; 7424 : 		if( FAILED(hr) )
; 7425 : 		{
; 7426 : 			return hr;
; 7427 : 		}
; 7428 : 
; 7429 : 		if( true == bRedirectionEnabled )

  0010a	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?_AtlRegisterPerUser@ATL@@3_NA, 1 ; ATL::_AtlRegisterPerUser
  00111	75 1f		 jne	 SHORT $LN64@AtlRegiste

; 7430 : 		{
; 7431 : 			HMODULE hmodOleAut=::GetModuleHandleW(L"OLEAUT32.DLL");

  00113	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@EDKOLFBJ@?$AAO?$AAL?$AAE?$AAA?$AAU?$AAT?$AA3?$AA2?$AA?4?$AAD?$AAL?$AAL@
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4

; 7432 : 			if(hmodOleAut)

  0011e	85 c0		 test	 eax, eax
  00120	74 10		 je	 SHORT $LN64@AtlRegiste

; 7433 : 			{
; 7434 : 				pfnRegisterTypeLib=reinterpret_cast<PFNREGISTERTYPELIB>(::GetProcAddress(hmodOleAut, "RegisterTypeLibForUser"));

  00122	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@LBOMMKPJ@RegisterTypeLibForUser@
  00127	50		 push	 eax
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 7435 : 			}
; 7436 : 		}
; 7437 : 
; 7438 : 		if( NULL == pfnRegisterTypeLib )

  0012e	85 c0		 test	 eax, eax
  00130	75 05		 jne	 SHORT $LN7@AtlRegiste
$LN64@AtlRegiste:

; 7439 : 		{
; 7440 : 			pfnRegisterTypeLib = (PFNREGISTERTYPELIB)&RegisterTypeLib;

  00132	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__RegisterTypeLib@12
$LN7@AtlRegiste:

; 7443 : 		hr = pfnRegisterTypeLib(pTypeLib, bstrPath, szDir);

  00137	56		 push	 esi
  00138	ff b5 e8 fd ff
	ff		 push	 DWORD PTR _bstrPath$[ebp]
  0013e	ff b5 ec fd ff
	ff		 push	 DWORD PTR _pTypeLib$[ebp]
  00144	ff d0		 call	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 1674 :     ::SysFreeString(m_str);

  00146	ff b5 f0 fd ff
	ff		 push	 DWORD PTR _bstrHelpFile$1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7443 : 		hr = pfnRegisterTypeLib(pTypeLib, bstrPath, szDir);

  0014c	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 1674 :     ::SysFreeString(m_str);

  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN2@AtlRegiste:

; 183  :         if (p)

  00154	8b 85 ec fd ff
	ff		 mov	 eax, DWORD PTR _pTypeLib$[ebp]
  0015a	85 c0		 test	 eax, eax
  0015c	74 06		 je	 SHORT $LN56@AtlRegiste

; 184  :             p->Release();

  0015e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00160	50		 push	 eax
  00161	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN56@AtlRegiste:

; 1674 :     ::SysFreeString(m_str);

  00164	ff b5 e8 fd ff
	ff		 push	 DWORD PTR _bstrPath$[ebp]
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7447 : }

  00170	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	8b c7		 mov	 eax, edi
  00175	5f		 pop	 edi
  00176	33 cd		 xor	 ecx, ebp
  00178	5e		 pop	 esi
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	c9		 leave
  0017f	c2 08 00	 ret	 8
$LN11@AtlRegiste:

; 7412 : 
; 7413 : 			// truncate at the directory level
; 7414 : 			szDirBuffer[AtlGetDirLen(szDirBuffer)] = 0;

  00182	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN65@AtlRegiste:
  00187	cc		 int	 3
?AtlRegisterTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_W@Z ENDP	; ATL::AtlRegisterTypeLib
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_WPAPA_WPAPAUITypeLib@@@Z
_TEXT	SEGMENT
_pbstrPath$GSCopy$1$ = -572				; size = 4
tv403 = -568						; size = 4
tv394 = -564						; size = 4
_lpszIndex$GSCopy$1$ = -564				; size = 4
_ppTypeLib$GSCopy$1$ = -560				; size = 4
_lpszExt$1$ = -560					; size = 4
_szModule$ = -556					; size = 540
_szExt$1 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_hInstTypeLib$ = 8					; size = 4
_lpszIndex$ = 12					; size = 4
_pbstrPath$ = 16					; size = 4
_ppTypeLib$ = 20					; size = 4
?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_WPAPA_WPAPAUITypeLib@@@Z PROC ; ATL::AtlLoadTypeLib, COMDAT

; 7114 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 02 00
	00		 sub	 esp, 572		; 0000023cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 0c	 mov	 eax, DWORD PTR _lpszIndex$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _hInstTypeLib$[ebp]
  00019	89 85 cc fd ff
	ff		 mov	 DWORD PTR _lpszIndex$GSCopy$1$[ebp], eax
  0001f	8b 45 10	 mov	 eax, DWORD PTR _pbstrPath$[ebp]
  00022	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _pbstrPath$GSCopy$1$[ebp], eax
  00028	53		 push	 ebx
  00029	8b 5d 14	 mov	 ebx, DWORD PTR _ppTypeLib$[ebp]
  0002c	89 9d d0 fd ff
	ff		 mov	 DWORD PTR _ppTypeLib$GSCopy$1$[ebp], ebx

; 7115 : 	ATLASSERT(pbstrPath != NULL && ppTypeLib != NULL);
; 7116 : 	if (pbstrPath == NULL || ppTypeLib == NULL)

  00032	85 c0		 test	 eax, eax
  00034	0f 84 90 01 00
	00		 je	 $LN3@AtlLoadTyp
  0003a	85 db		 test	 ebx, ebx
  0003c	0f 84 88 01 00
	00		 je	 $LN3@AtlLoadTyp

; 7118 : 
; 7119 : 	*pbstrPath = NULL;

  00042	56		 push	 esi
  00043	57		 push	 edi
  00044	33 f6		 xor	 esi, esi
  00046	89 30		 mov	 DWORD PTR [eax], esi

; 7120 : 	*ppTypeLib = NULL;
; 7121 : 
; 7122 : 	USES_CONVERSION_EX;
; 7123 : 	ATLASSERT(hInstTypeLib != NULL);
; 7124 : 	TCHAR szModule[_ATL_MAX_PATH_PLUS_INDEX];
; 7125 : 
; 7126 : 	DWORD dwFLen = GetModuleFileName(hInstTypeLib, szModule, MAX_PATH);

  00048	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  0004e	68 04 01 00 00	 push	 260			; 00000104H
  00053	50		 push	 eax
  00054	51		 push	 ecx
  00055	89 b5 c8 fd ff
	ff		 mov	 DWORD PTR tv403[ebp], esi
  0005b	89 33		 mov	 DWORD PTR [ebx], esi
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameW@12
  00063	8b f8		 mov	 edi, eax

; 7127 : 	if( dwFLen == 0 )

  00065	85 ff		 test	 edi, edi
  00067	75 0c		 jne	 SHORT $LN4@AtlLoadTyp

; 7128 : 	{
; 7129 : 		HRESULT hRes = AtlHresultFromLastError();

  00069	e8 00 00 00 00	 call	 ?AtlHresultFromLastError@ATL@@YAJXZ ; ATL::AtlHresultFromLastError
  0006e	8b f0		 mov	 esi, eax
  00070	e9 4f 01 00 00	 jmp	 $LL68@AtlLoadTyp
$LN4@AtlLoadTyp:

; 7130 : 		_Analysis_assume_(FAILED(hRes));
; 7131 : 		return hRes;
; 7132 : 	}
; 7133 : 	else if( dwFLen == MAX_PATH )

  00075	81 ff 04 01 00
	00		 cmp	 edi, 260		; 00000104H
  0007b	75 0a		 jne	 SHORT $LN6@AtlLoadTyp

; 7134 : 		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

  0007d	be 7a 00 07 80	 mov	 esi, -2147024774	; 8007007aH
  00082	e9 3d 01 00 00	 jmp	 $LL68@AtlLoadTyp
$LN6@AtlLoadTyp:

; 7068 : 		while (*psz != _T('\0'))

  00087	66 8b 8d d4 fd
	ff ff		 mov	 cx, WORD PTR _szModule$[ebp]

; 7135 : 
; 7136 : 	// get the extension pointer in case of fail
; 7137 : 	LPTSTR lpszExt = NULL;
; 7138 : 
; 7139 : 	lpszExt = AtlFindExtension(szModule);

  0008e	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]

; 7068 : 		while (*psz != _T('\0'))

  00094	66 85 c9	 test	 cx, cx
  00097	74 2e		 je	 SHORT $LN39@AtlLoadTyp
  00099	0f b7 d1	 movzx	 edx, cx
  0009c	33 db		 xor	 ebx, ebx
$LL38@AtlLoadTyp:

; 7069 : 		{
; 7070 : 			switch (*psz)

  0009e	66 83 fa 2e	 cmp	 dx, 46			; 0000002eH
  000a2	74 0a		 je	 SHORT $LN44@AtlLoadTyp
  000a4	66 83 fa 5c	 cmp	 dx, 92			; 0000005cH
  000a8	75 06		 jne	 SHORT $LN45@AtlLoadTyp

; 7071 : 			{
; 7072 : 			case _T('\\'):
; 7073 : 				pszRemember = NULL;

  000aa	8b f3		 mov	 esi, ebx

; 7074 : 				break;

  000ac	eb 02		 jmp	 SHORT $LN45@AtlLoadTyp
$LN44@AtlLoadTyp:

; 7075 : 			case _T('.'):
; 7076 : 				pszRemember = psz;

  000ae	8b f0		 mov	 esi, eax
$LN45@AtlLoadTyp:

; 7077 : 				break;
; 7078 : 			default:
; 7079 : 				break;
; 7080 : 			}
; 7081 : 			psz = CharNext(psz);

  000b0	50		 push	 eax
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  000b7	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  000ba	8b d1		 mov	 edx, ecx
  000bc	66 85 c9	 test	 cx, cx
  000bf	75 dd		 jne	 SHORT $LL38@AtlLoadTyp
  000c1	8b 9d d0 fd ff
	ff		 mov	 ebx, DWORD PTR _ppTypeLib$GSCopy$1$[ebp]
$LN39@AtlLoadTyp:

; 7082 : 		}
; 7083 : 		return (LPTSTR) ((pszRemember == NULL) ? psz : pszRemember);

  000c7	85 f6		 test	 esi, esi

; 7140 : 
; 7141 : 	if (lpszIndex != NULL)

  000c9	ba 0e 01 00 00	 mov	 edx, 270		; 0000010eH

; 7083 : 		return (LPTSTR) ((pszRemember == NULL) ? psz : pszRemember);

  000ce	0f 44 f0	 cmove	 esi, eax
  000d1	89 b5 d0 fd ff
	ff		 mov	 DWORD PTR _lpszExt$1$[ebp], esi

; 7140 : 
; 7141 : 	if (lpszIndex != NULL)

  000d7	8b b5 cc fd ff
	ff		 mov	 esi, DWORD PTR _lpszIndex$GSCopy$1$[ebp]
  000dd	85 f6		 test	 esi, esi
  000df	74 47		 je	 SHORT $LN7@AtlLoadTyp

; 7142 : 	{
; 7143 : 		LPCTSTR lpcszIndex = OLE2CT_EX(lpszIndex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 7144 : 		if(lpcszIndex == NULL)
; 7145 : 		{
; 7146 : 			return E_OUTOFMEMORY;
; 7147 : 		}
; 7148 : 		DWORD nIndexLen = static_cast<DWORD>(_tcslen(lpcszIndex));

  000e1	8b ce		 mov	 ecx, esi
  000e3	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]
  000e6	89 85 cc fd ff
	ff		 mov	 DWORD PTR tv394[ebp], eax
$LL82@AtlLoadTyp:
  000ec	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000ef	83 c1 02	 add	 ecx, 2
  000f2	66 3b 85 c8 fd
	ff ff		 cmp	 ax, WORD PTR tv403[ebp]
  000f9	75 f1		 jne	 SHORT $LL82@AtlLoadTyp
  000fb	2b 8d cc fd ff
	ff		 sub	 ecx, DWORD PTR tv394[ebp]
  00101	d1 f9		 sar	 ecx, 1

; 7149 : 
; 7150 : 		DWORD newLen = dwFLen + nIndexLen;

  00103	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]

; 7151 : 		if ((newLen < dwFLen) || (newLen < nIndexLen) || (newLen >= _ATL_MAX_PATH_PLUS_INDEX))

  00106	3b c7		 cmp	 eax, edi
  00108	72 5a		 jb	 SHORT $LN10@AtlLoadTyp
  0010a	3b c1		 cmp	 eax, ecx
  0010c	72 56		 jb	 SHORT $LN10@AtlLoadTyp
  0010e	3b c2		 cmp	 eax, edx
  00110	73 52		 jae	 SHORT $LN10@AtlLoadTyp

; 7152 : 			return E_FAIL;
; 7153 : #ifdef UNICODE
; 7154 : 		Checked::wcscpy_s(szModule + dwFLen, _countof(szModule) - dwFLen, lpcszIndex);

  00112	56		 push	 esi
  00113	2b d7		 sub	 edx, edi
  00115	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  0011b	52		 push	 edx
  0011c	8d 04 78	 lea	 eax, DWORD PTR [eax+edi*2]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ?wcscpy_s@Checked@ATL@@YAXPA_WIPB_W@Z ; ATL::Checked::wcscpy_s
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@AtlLoadTyp:

; 7155 : #else
; 7156 : 		Checked::strcpy_s(szModule + dwFLen, _countof(szModule) - dwFLen, lpcszIndex);
; 7157 : #endif
; 7158 : 	}
; 7159 : 	LPOLESTR lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 7160 : #ifndef _UNICODE
; 7161 : 	if(lpszModule == NULL)
; 7162 : 		return E_OUTOFMEMORY;
; 7163 : #endif
; 7164 : 	HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);

  00128	53		 push	 ebx
  00129	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  0012f	50		 push	 eax
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadTypeLib@8
  00136	8b f0		 mov	 esi, eax

; 7165 : 	if (FAILED(hr))

  00138	85 f6		 test	 esi, esi
  0013a	79 5e		 jns	 SHORT $LN81@AtlLoadTyp

; 7166 : 	{
; 7167 : 		// typelib not in module, try <module>.tlb instead
; 7168 : 		const TCHAR szExt[] = _T(".tlb");
; 7169 : 		if ((lpszExt - szModule + _countof(szExt)) > _MAX_PATH)

  0013c	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _lpszExt$1$[ebp]
  00142	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  00148	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_19ILOCMLCJ@?$AA?4?$AAt?$AAl?$AAb@
  0014d	8d 7d f0	 lea	 edi, DWORD PTR _szExt$1[ebp]
  00150	8b d1		 mov	 edx, ecx
  00152	2b d0		 sub	 edx, eax
  00154	d1 fa		 sar	 edx, 1
  00156	a5		 movsd
  00157	8d 42 05	 lea	 eax, DWORD PTR [edx+5]
  0015a	a5		 movsd
  0015b	66 a5		 movsw
  0015d	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  00162	76 07		 jbe	 SHORT $LN12@AtlLoadTyp
$LN10@AtlLoadTyp:

; 7192 : 		}
; 7193 : 	}
; 7194 : 	return hr;

  00164	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
  00169	eb 59		 jmp	 SHORT $LL68@AtlLoadTyp
$LN12@AtlLoadTyp:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 103  : 	ATLMFC_CRT_ERRORCHECK(::wcscpy_s(_S1, _S1max, _S2));

  0016b	8d 45 f0	 lea	 eax, DWORD PTR _szExt$1[ebp]
  0016e	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7173 : 		Checked::wcscpy_s(lpszExt, _countof(szModule) - (lpszExt - szModule), szExt);

  0016f	b8 0e 01 00 00	 mov	 eax, 270		; 0000010eH
  00174	2b c2		 sub	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 103  : 	ATLMFC_CRT_ERRORCHECK(::wcscpy_s(_S1, _S1max, _S2));

  00176	50		 push	 eax
  00177	51		 push	 ecx
  00178	e8 00 00 00 00	 call	 _wcscpy_s
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  00183	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7182 : 		hr = LoadTypeLib(lpszModule, ppTypeLib);

  00186	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  0018c	53		 push	 ebx
  0018d	50		 push	 eax
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadTypeLib@8
  00194	8b f0		 mov	 esi, eax

; 7183 : 	}
; 7184 : 	if (SUCCEEDED(hr))

  00196	85 f6		 test	 esi, esi
  00198	78 2a		 js	 SHORT $LL68@AtlLoadTyp
$LN81@AtlLoadTyp:

; 7185 : 	{
; 7186 : 		*pbstrPath = ::SysAllocString(lpszModule);

  0019a	8d 85 d4 fd ff
	ff		 lea	 eax, DWORD PTR _szModule$[ebp]
  001a0	50		 push	 eax
  001a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocString@4
  001a7	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _pbstrPath$GSCopy$1$[ebp]
  001ad	89 01		 mov	 DWORD PTR [ecx], eax

; 7187 : 		if (*pbstrPath == NULL)

  001af	85 c0		 test	 eax, eax
  001b1	75 11		 jne	 SHORT $LL68@AtlLoadTyp

; 7188 : 		{
; 7189 : 			hr = E_OUTOFMEMORY;
; 7190 : 			(*ppTypeLib)->Release();

  001b3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001b5	be 0e 00 07 80	 mov	 esi, -2147024882	; 8007000eH
  001ba	51		 push	 ecx
  001bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001bd	ff 52 08	 call	 DWORD PTR [edx+8]

; 7191 : 			*ppTypeLib = NULL;

  001c0	33 c0		 xor	 eax, eax
  001c2	89 03		 mov	 DWORD PTR [ebx], eax
$LL68@AtlLoadTyp:

; 7192 : 		}
; 7193 : 	}
; 7194 : 	return hr;

  001c4	5f		 pop	 edi
  001c5	8b c6		 mov	 eax, esi
  001c7	5e		 pop	 esi
  001c8	eb 05		 jmp	 SHORT $LN1@AtlLoadTyp
$LN3@AtlLoadTyp:

; 7117 : 		return E_POINTER;

  001ca	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
$LN1@AtlLoadTyp:

; 7195 : }

  001cf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d2	33 cd		 xor	 ecx, ebp
  001d4	5b		 pop	 ebx
  001d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001da	c9		 leave
  001db	c2 10 00	 ret	 16			; 00000010H
?AtlLoadTypeLib@ATL@@YGJPAUHINSTANCE__@@PB_WPAPA_WPAPAUITypeLib@@@Z ENDP ; ATL::AtlLoadTypeLib
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z
_TEXT	SEGMENT
_root$1 = -440						; size = 12
_key$2 = -428						; size = 12
_lRes$2$ = -416						; size = 4
_lRes$1$ = -416						; size = 4
_pEntry$1$ = -416					; size = 4
_pCatRegister$ = -412					; size = 4
_clsid$GSCopy$1$ = -408					; size = 4
_cbSubKeys$3 = -408					; size = 4
_catid$ = -404						; size = 16
_szGUID$4 = -388					; size = 128
_szKey$5 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_clsid$ = 8						; size = 4
_pCatMap$ = 12						; size = 4
_bRegister$ = 16					; size = 4
?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z PROC ; ATL::AtlRegisterClassCategoriesHelper, COMDAT

; 7201 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 01 00
	00		 sub	 esp, 440		; 000001b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _clsid$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  00018	33 db		 xor	 ebx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7201 : {

  0001a	57		 push	 edi
  0001b	8b 7d 0c	 mov	 edi, DWORD PTR _pCatMap$[ebp]
  0001e	89 b5 68 fe ff
	ff		 mov	 DWORD PTR _clsid$GSCopy$1$[ebp], esi
  00024	89 bd 60 fe ff
	ff		 mov	 DWORD PTR _pEntry$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  0002a	89 9d 64 fe ff
	ff		 mov	 DWORD PTR _pCatRegister$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7207 :    if( pCatMap == NULL )

  00030	85 ff		 test	 edi, edi
  00032	74 33		 je	 SHORT $LN116@AtlRegiste

; 7208 :    {
; 7209 : 	  return( S_OK );
; 7210 :    }
; 7211 : 
; 7212 :    if (InlineIsEqualGUID(clsid, GUID_NULL))

  00034	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  00039	56		 push	 esi
  0003a	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  0003f	59		 pop	 ecx
  00040	59		 pop	 ecx
  00041	85 c0		 test	 eax, eax
  00043	75 22		 jne	 SHORT $LN116@AtlRegiste

; 7213 :    {
; 7214 : 	  ATLASSERT(0 && _T("Use OBJECT_ENTRY_NON_CREATEABLE_EX macro if you want to register class categories for non creatable objects."));
; 7215 : 	  return S_OK;
; 7216 :    }
; 7217 : 
; 7218 :    hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,

  00045	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _pCatRegister$[ebp]
  0004b	50		 push	 eax
  0004c	68 00 00 00 00	 push	 OFFSET __GUID_0002e012_0000_0000_c000_000000000046
  00051	6a 01		 push	 1
  00053	53		 push	 ebx
  00054	68 00 00 00 00	 push	 OFFSET _CLSID_StdComponentCategoriesMgr
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 7219 : 	  CLSCTX_INPROC_SERVER, __uuidof(ICatRegister), (void**)&pCatRegister );
; 7220 :    if( FAILED( hResult ) )

  0005f	85 c0		 test	 eax, eax
  00061	0f 89 96 00 00
	00		 jns	 $LN120@AtlRegiste
$LN116@AtlRegiste:
  00067	8b c3		 mov	 eax, ebx
$LN27@AtlRegiste:
  00069	8b d8		 mov	 ebx, eax
$LN29@AtlRegiste:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 183  :         if (p)

  0006b	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR _pCatRegister$[ebp]
  00071	85 c9		 test	 ecx, ecx
  00073	74 06		 je	 SHORT $LN102@AtlRegiste

; 184  :             p->Release();

  00075	8b 11		 mov	 edx, DWORD PTR [ecx]
  00077	51		 push	 ecx
  00078	ff 52 08	 call	 DWORD PTR [edx+8]
$LN102@AtlRegiste:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7326 : }

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	8b c3		 mov	 eax, ebx
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	33 cd		 xor	 ecx, ebp
  00084	5b		 pop	 ebx
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	c9		 leave
  0008b	c2 0c 00	 ret	 12			; 0000000cH
$LL2@AtlRegiste:

; 7234 :    {
; 7235 : 	  catid = *pEntry->pcatid;
; 7236 : 	  if( bRegister )

  0008e	8d 95 6c fe ff
	ff		 lea	 edx, DWORD PTR _catid$[ebp]
  00094	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00097	8d bd 6c fe ff
	ff		 lea	 edi, DWORD PTR _catid$[ebp]
  0009d	52		 push	 edx
  0009e	6a 01		 push	 1
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	a5		 movsd
  000a3	a5		 movsd
  000a4	39 5d 10	 cmp	 DWORD PTR _bRegister$[ebp], ebx
  000a7	74 28		 je	 SHORT $LN10@AtlRegiste

; 7237 : 	  {
; 7238 : 		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )

  000a9	ff b5 68 fe ff
	ff		 push	 DWORD PTR _clsid$GSCopy$1$[ebp]
  000af	83 f8 01	 cmp	 eax, 1
  000b2	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _pCatRegister$[ebp]
  000b8	50		 push	 eax
  000b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000bb	75 05		 jne	 SHORT $LN12@AtlRegiste

; 7239 : 		 {
; 7240 : 			hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,

  000bd	ff 51 14	 call	 DWORD PTR [ecx+20]

; 7241 : 			   &catid );
; 7242 : 		 }

  000c0	eb 03		 jmp	 SHORT $LN13@AtlRegiste
$LN12@AtlRegiste:

; 7243 : 		 else
; 7244 : 		 {
; 7245 : 			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
; 7246 : 			hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,

  000c2	ff 51 1c	 call	 DWORD PTR [ecx+28]
$LN13@AtlRegiste:

; 7247 : 			   &catid );
; 7248 : 		 }
; 7249 : 		 if( FAILED( hResult ) )

  000c5	85 c0		 test	 eax, eax
  000c7	78 a0		 js	 SHORT $LN27@AtlRegiste

; 7250 : 		 {
; 7251 : 			return( hResult );
; 7252 : 		 }
; 7253 : 	  }

  000c9	8b b5 68 fe ff
	ff		 mov	 esi, DWORD PTR _clsid$GSCopy$1$[ebp]
  000cf	eb 1d		 jmp	 SHORT $LN16@AtlRegiste
$LN10@AtlRegiste:

; 7254 : 	  else
; 7255 : 	  {
; 7256 : 		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )

  000d1	8b b5 68 fe ff
	ff		 mov	 esi, DWORD PTR _clsid$GSCopy$1$[ebp]
  000d7	83 f8 01	 cmp	 eax, 1
  000da	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR _pCatRegister$[ebp]
  000e0	56		 push	 esi
  000e1	50		 push	 eax
  000e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e4	75 05		 jne	 SHORT $LN15@AtlRegiste

; 7257 : 		 {
; 7258 : 			pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );

  000e6	ff 51 18	 call	 DWORD PTR [ecx+24]

; 7259 : 		 }

  000e9	eb 03		 jmp	 SHORT $LN16@AtlRegiste
$LN15@AtlRegiste:

; 7260 : 		 else
; 7261 : 		 {
; 7262 : 			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
; 7263 : 			pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );

  000eb	ff 51 20	 call	 DWORD PTR [ecx+32]
$LN16@AtlRegiste:

; 7264 : 		 }
; 7265 : 	  }
; 7266 : 	  pEntry++;

  000ee	8b bd 60 fe ff
	ff		 mov	 edi, DWORD PTR _pEntry$1$[ebp]
  000f4	83 c7 08	 add	 edi, 8
  000f7	89 bd 60 fe ff
	ff		 mov	 DWORD PTR _pEntry$1$[ebp], edi
$LN120@AtlRegiste:

; 7221 :    {
; 7222 : 	  // Since not all systems have the category manager installed, we'll allow
; 7223 : 	  // the registration to succeed even though we didn't register our
; 7224 : 	  // categories.  If you really want to register categories on a system
; 7225 : 	  // without the category manager, you can either manually add the
; 7226 : 	  // appropriate entries to your registry script (.rgs), or you can
; 7227 : 	  // redistribute comcat.dll.
; 7228 : 	  return( S_OK );
; 7229 :    }
; 7230 : 
; 7231 :    hResult = S_OK;
; 7232 :    pEntry = pCatMap;
; 7233 :    while( pEntry->iType != _ATL_CATMAP_ENTRY_END )

  000fd	8b 07		 mov	 eax, DWORD PTR [edi]
  000ff	85 c0		 test	 eax, eax
  00101	75 8b		 jne	 SHORT $LL2@AtlRegiste

; 7267 :    }
; 7268 : 
; 7269 :    // When unregistering remove "Implemented Categories" and "Required Categories" subkeys if they are empty.
; 7270 :    if (!bRegister)

  00103	39 5d 10	 cmp	 DWORD PTR _bRegister$[ebp], ebx
  00106	0f 85 5f ff ff
	ff		 jne	 $LN29@AtlRegiste

; 7271 :    {
; 7272 : 		OLECHAR szGUID[64];
; 7273 : 		ATLENSURE_RETURN_VAL(::StringFromGUID2(clsid, szGUID, 64), ERROR_INVALID_DATA);

  0010c	6a 40		 push	 64			; 00000040H
  0010e	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _szGUID$4[ebp]
  00114	50		 push	 eax
  00115	56		 push	 esi
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StringFromGUID2@12
  0011c	85 c0		 test	 eax, eax
  0011e	75 08		 jne	 SHORT $LN4@AtlRegiste
  00120	6a 0d		 push	 13			; 0000000dH
  00122	58		 pop	 eax
  00123	e9 41 ff ff ff	 jmp	 $LN27@AtlRegiste
$LN4@AtlRegiste:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 103  : 	ATLMFC_CRT_ERRORCHECK(::wcscpy_s(_S1, _S1max, _S2));

  00128	68 00 00 00 00	 push	 OFFSET ??_C@_1O@FHBGLCIO@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?2@
  0012d	be 80 00 00 00	 mov	 esi, 128		; 00000080H
  00132	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]
  00138	56		 push	 esi
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 _wcscpy_s
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck

; 154  : 	ATLMFC_CRT_ERRORCHECK(::wcscat_s(_Dst, _SizeInChars, _Src));

  00145	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _szGUID$4[ebp]
  0014b	50		 push	 eax
  0014c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]
  00152	56		 push	 esi
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _wcscat_s
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@IFBKBFAA@?$AA?2?$AAR?$AAe?$AAq?$AAu?$AAi?$AAr?$AAe?$AAd?$AA?5?$AAC?$AAa?$AAt?$AAe?$AAg@
  00164	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]
  0016a	56		 push	 esi
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _wcscat_s
  00171	50		 push	 eax
  00172	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  00177	83 c4 30	 add	 esp, 48			; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 5711 : 	m_hKey(hKey), m_samWOW64(0), m_pTM(NULL)

  0017a	89 9d 4c fe ff
	ff		 mov	 DWORD PTR _root$1[ebp+4], ebx

; 7292 : 
; 7293 : 			LRESULT lRes = key.Open(root, szKey, KEY_READ);

  00180	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]

; 5711 : 	m_hKey(hKey), m_samWOW64(0), m_pTM(NULL)

  00186	89 9d 50 fe ff
	ff		 mov	 DWORD PTR _root$1[ebp+8], ebx
  0018c	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  00191	89 9d 54 fe ff
	ff		 mov	 DWORD PTR _key$2[ebp], ebx

; 5711 : 	m_hKey(hKey), m_samWOW64(0), m_pTM(NULL)

  00197	89 8d 48 fe ff
	ff		 mov	 DWORD PTR _root$1[ebp], ecx

; 7292 : 
; 7293 : 			LRESULT lRes = key.Open(root, szKey, KEY_READ);

  0019d	68 19 00 02 00	 push	 131097			; 00020019H
  001a2	50		 push	 eax
  001a3	51		 push	 ecx
  001a4	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _key$2[ebp]

; 5696 : 	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)

  001aa	89 9d 58 fe ff
	ff		 mov	 DWORD PTR _key$2[ebp+4], ebx
  001b0	89 9d 5c fe ff
	ff		 mov	 DWORD PTR _key$2[ebp+8], ebx

; 7274 : 		USES_CONVERSION_EX;
; 7275 : 		TCHAR* pszGUID = OLE2T_EX(szGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
; 7276 : 		if (pszGUID != NULL)
; 7277 : 		{
; 7278 : 			TCHAR szKey[128];
; 7279 : #ifdef UNICODE
; 7280 : 			Checked::wcscpy_s(szKey, _countof(szKey), _T("CLSID\\"));
; 7281 : 			Checked::wcscat_s(szKey, _countof(szKey), pszGUID);
; 7282 : 			Checked::wcscat_s(szKey, _countof(szKey), _T("\\Required Categories"));
; 7283 : #else
; 7284 : 			Checked::strcpy_s(szKey, _countof(szKey), _T("CLSID\\"));
; 7285 : 			Checked::strcat_s(szKey, _countof(szKey), pszGUID);
; 7286 : 			Checked::strcat_s(szKey, _countof(szKey), _T("\\Required Categories"));
; 7287 : #endif
; 7288 : 
; 7289 : 			CRegKey root(HKEY_CLASSES_ROOT);
; 7290 : 			CRegKey key;
; 7291 : 			DWORD cbSubKeys = 0;

  001b6	89 9d 68 fe ff
	ff		 mov	 DWORD PTR _cbSubKeys$3[ebp], ebx

; 7292 : 
; 7293 : 			LRESULT lRes = key.Open(root, szKey, KEY_READ);

  001bc	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z ; ATL::CRegKey::Open

; 7294 : 			if (lRes == ERROR_SUCCESS)

  001c1	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__RegCloseKey@4
  001c7	85 c0		 test	 eax, eax
  001c9	75 60		 jne	 SHORT $LN21@AtlRegiste

; 7295 : 			{
; 7296 : 				lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  001cb	53		 push	 ebx
  001cc	8b b5 54 fe ff
	ff		 mov	 esi, DWORD PTR _key$2[ebp]
  001d2	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _cbSubKeys$3[ebp]
  001d8	53		 push	 ebx
  001d9	53		 push	 ebx
  001da	53		 push	 ebx
  001db	53		 push	 ebx
  001dc	53		 push	 ebx
  001dd	53		 push	 ebx
  001de	50		 push	 eax
  001df	53		 push	 ebx
  001e0	53		 push	 ebx
  001e1	53		 push	 ebx
  001e2	56		 push	 esi
  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryInfoKeyW@48
  001e9	89 85 60 fe ff
	ff		 mov	 DWORD PTR _lRes$1$[ebp], eax

; 5804 : 	if (m_hKey != NULL)

  001ef	85 f6		 test	 esi, esi
  001f1	74 0f		 je	 SHORT $LN72@AtlRegiste

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  001f3	56		 push	 esi
  001f4	ff d7		 call	 edi
  001f6	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _lRes$1$[ebp]

; 5807 : 		m_hKey = NULL;

  001fc	89 9d 54 fe ff
	ff		 mov	 DWORD PTR _key$2[ebp], ebx
$LN72@AtlRegiste:

; 5808 : 	}
; 5809 : 	m_samWOW64 = 0;

  00202	89 9d 58 fe ff
	ff		 mov	 DWORD PTR _key$2[ebp+4], ebx

; 7297 : 				key.Close();
; 7298 : 				if (lRes == ERROR_SUCCESS && cbSubKeys == 0)

  00208	85 c0		 test	 eax, eax
  0020a	75 1a		 jne	 SHORT $LN118@AtlRegiste
  0020c	39 9d 68 fe ff
	ff		 cmp	 DWORD PTR _cbSubKeys$3[ebp], ebx
  00212	75 12		 jne	 SHORT $LN118@AtlRegiste

; 7299 : 				{
; 7300 : 					root.DeleteSubKey(szKey);

  00214	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]
  0021a	50		 push	 eax
  0021b	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR _root$1[ebp]
  00221	e8 00 00 00 00	 call	 ?DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z ; ATL::CRegKey::DeleteSubKey
$LN118@AtlRegiste:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h

; 103  : 	ATLMFC_CRT_ERRORCHECK(::wcscpy_s(_S1, _S1max, _S2));

  00226	be 80 00 00 00	 mov	 esi, 128		; 00000080H
$LN21@AtlRegiste:
  0022b	68 00 00 00 00	 push	 OFFSET ??_C@_1O@FHBGLCIO@?$AAC?$AAL?$AAS?$AAI?$AAD?$AA?2@
  00230	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]
  00236	56		 push	 esi
  00237	50		 push	 eax
  00238	e8 00 00 00 00	 call	 _wcscpy_s
  0023d	50		 push	 eax
  0023e	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck

; 154  : 	ATLMFC_CRT_ERRORCHECK(::wcscat_s(_Dst, _SizeInChars, _Src));

  00243	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR _szGUID$4[ebp]
  00249	50		 push	 eax
  0024a	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]
  00250	56		 push	 esi
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 _wcscat_s
  00257	50		 push	 eax
  00258	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  0025d	68 00 00 00 00	 push	 OFFSET ??_C@_1DA@BIHALFED@?$AA?2?$AAI?$AAm?$AAp?$AAl?$AAe?$AAm?$AAe?$AAn?$AAt?$AAe?$AAd?$AA?5?$AAC?$AAa@
  00262	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]
  00268	56		 push	 esi
  00269	50		 push	 eax
  0026a	e8 00 00 00 00	 call	 _wcscat_s
  0026f	50		 push	 eax
  00270	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  00275	83 c4 30	 add	 esp, 48			; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 7313 : 			lRes = key.Open(root, szKey, KEY_READ);

  00278	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]
  0027e	8d 8d 54 fe ff
	ff		 lea	 ecx, DWORD PTR _key$2[ebp]
  00284	68 19 00 02 00	 push	 131097			; 00020019H
  00289	50		 push	 eax
  0028a	68 00 00 00 80	 push	 -2147483648		; 80000000H
  0028f	e8 00 00 00 00	 call	 ?Open@CRegKey@ATL@@QAEJPAUHKEY__@@PB_WK@Z ; ATL::CRegKey::Open

; 7314 : 			if (lRes == ERROR_SUCCESS)

  00294	8b b5 54 fe ff
	ff		 mov	 esi, DWORD PTR _key$2[ebp]
  0029a	85 c0		 test	 eax, eax
  0029c	75 4b		 jne	 SHORT $LN23@AtlRegiste

; 7315 : 			{
; 7316 : 				lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  0029e	53		 push	 ebx
  0029f	53		 push	 ebx
  002a0	53		 push	 ebx
  002a1	53		 push	 ebx
  002a2	53		 push	 ebx
  002a3	53		 push	 ebx
  002a4	53		 push	 ebx
  002a5	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR _cbSubKeys$3[ebp]
  002ab	50		 push	 eax
  002ac	53		 push	 ebx
  002ad	53		 push	 ebx
  002ae	53		 push	 ebx
  002af	56		 push	 esi
  002b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryInfoKeyW@48
  002b6	89 85 60 fe ff
	ff		 mov	 DWORD PTR _lRes$2$[ebp], eax

; 5804 : 	if (m_hKey != NULL)

  002bc	85 f6		 test	 esi, esi
  002be	74 0b		 je	 SHORT $LN81@AtlRegiste

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  002c0	56		 push	 esi
  002c1	ff d7		 call	 edi
  002c3	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR _lRes$2$[ebp]

; 5807 : 		m_hKey = NULL;

  002c9	8b f3		 mov	 esi, ebx
$LN81@AtlRegiste:

; 7317 : 				key.Close();
; 7318 : 				if (lRes == ERROR_SUCCESS && cbSubKeys == 0)

  002cb	85 c0		 test	 eax, eax
  002cd	75 1a		 jne	 SHORT $LN23@AtlRegiste
  002cf	39 9d 68 fe ff
	ff		 cmp	 DWORD PTR _cbSubKeys$3[ebp], ebx
  002d5	75 12		 jne	 SHORT $LN23@AtlRegiste

; 7319 : 				{
; 7320 : 					root.DeleteSubKey(szKey);

  002d7	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szKey$5[ebp]
  002dd	50		 push	 eax
  002de	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR _root$1[ebp]
  002e4	e8 00 00 00 00	 call	 ?DeleteSubKey@CRegKey@ATL@@QAEJPB_W@Z ; ATL::CRegKey::DeleteSubKey
$LN23@AtlRegiste:

; 5804 : 	if (m_hKey != NULL)

  002e9	85 f6		 test	 esi, esi
  002eb	74 03		 je	 SHORT $LN86@AtlRegiste

; 5805 : 	{
; 5806 : 		lRes = RegCloseKey(m_hKey);

  002ed	56		 push	 esi
  002ee	ff d7		 call	 edi
$LN86@AtlRegiste:
  002f0	68 00 00 00 80	 push	 -2147483648		; 80000000H
  002f5	ff d7		 call	 edi

; 7321 : 				}
; 7322 : 			}
; 7323 : 		}
; 7324 : 	}
; 7325 : 	return(S_OK);

  002f7	e9 6f fd ff ff	 jmp	 $LN29@AtlRegiste
?AtlRegisterClassCategoriesHelper@ATL@@YGJABU_GUID@@PBU_ATL_CATMAP_ENTRY@1@H@Z ENDP ; ATL::AtlRegisterClassCategoriesHelper
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlComModuleGetClassObject@ATL@@YGJPAU_ATL_COM_MODULE70@1@ABU_GUID@@1PAPAX@Z
_TEXT	SEGMENT
_pEntry$1$ = 8						; size = 4
_pComModule$ = 8					; size = 4
_lock$1$sroa$186$1$ = 12				; size = 4
_rclsid$ = 12						; size = 4
_riid$ = 16						; size = 4
_pCache$1$ = 20						; size = 4
_ppEntry$1$ = 20					; size = 4
_factory$2 = 20						; size = 4
_ppv$ = 20						; size = 4
?AtlComModuleGetClassObject@ATL@@YGJPAU_ATL_COM_MODULE70@1@ABU_GUID@@1PAPAX@Z PROC ; ATL::AtlComModuleGetClassObject, COMDAT

; 8102 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 8103 : 	if (ppv == NULL)

  00004	8b 5d 14	 mov	 ebx, DWORD PTR _ppv$[ebp]
  00007	85 db		 test	 ebx, ebx
  00009	75 0a		 jne	 SHORT $LN5@AtlComModu

; 8104 : 	{
; 8105 : 		return E_POINTER;

  0000b	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00010	e9 d9 00 00 00	 jmp	 $LN1@AtlComModu
$LN5@AtlComModu:

; 8106 : 	}
; 8107 : 
; 8108 : 	*ppv = NULL;

  00015	83 23 00	 and	 DWORD PTR [ebx], 0
  00018	57		 push	 edi

; 8109 : 
; 8110 : 	ATLASSERT(pComModule != NULL);
; 8111 : 	if (pComModule == NULL)

  00019	8b 7d 08	 mov	 edi, DWORD PTR _pComModule$[ebp]
  0001c	85 ff		 test	 edi, edi
  0001e	75 0a		 jne	 SHORT $LN6@AtlComModu

; 8112 : 	{
; 8113 : 		return E_INVALIDARG;

  00020	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00025	e9 c3 00 00 00	 jmp	 $LN69@AtlComModu
$LN6@AtlComModu:

; 8114 : 	}
; 8115 : 
; 8116 : 	if (pComModule->cbSize == 0)  // Module hasn't been initialized

  0002a	83 3f 00	 cmp	 DWORD PTR [edi], 0
  0002d	75 0a		 jne	 SHORT $LN7@AtlComModu

; 8117 : 	{
; 8118 : 		return E_UNEXPECTED;

  0002f	b8 ff ff 00 80	 mov	 eax, -2147418113	; 8000ffffH
  00034	e9 b4 00 00 00	 jmp	 $LN69@AtlComModu
$LN7@AtlComModu:

; 8119 : 	}
; 8120 : 
; 8121 : 	HRESULT hr = S_OK;
; 8122 : 
; 8123 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)

  00039	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0003c	56		 push	 esi
  0003d	33 f6		 xor	 esi, esi
  0003f	eb 24		 jmp	 SHORT $LN70@AtlComModu
$LL4@AtlComModu:

; 8124 : 	{
; 8125 : 		if (*ppEntry != NULL)

  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 45 08	 mov	 DWORD PTR _pEntry$1$[ebp], eax
  00046	85 c0		 test	 eax, eax
  00048	74 15		 je	 SHORT $LN2@AtlComModu

; 8126 : 		{
; 8127 : 			const _ATL_OBJMAP_ENTRY_EX* pEntry = *ppEntry;
; 8128 : 
; 8129 : 			if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))

  0004a	39 70 08	 cmp	 DWORD PTR [eax+8], esi
  0004d	74 10		 je	 SHORT $LN2@AtlComModu
  0004f	ff 30		 push	 DWORD PTR [eax]
  00051	ff 75 0c	 push	 DWORD PTR _rclsid$[ebp]
  00054	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx
  0005b	85 c0		 test	 eax, eax
  0005d	75 10		 jne	 SHORT $LN59@AtlComModu
$LN2@AtlComModu:

; 8119 : 	}
; 8120 : 
; 8121 : 	HRESULT hr = S_OK;
; 8122 : 
; 8123 : 	for (_ATL_OBJMAP_ENTRY_EX** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)

  0005f	8b 45 14	 mov	 eax, DWORD PTR _ppEntry$1$[ebp]
  00062	83 c0 04	 add	 eax, 4
$LN70@AtlComModu:
  00065	89 45 14	 mov	 DWORD PTR _ppEntry$1$[ebp], eax
  00068	3b 47 0c	 cmp	 eax, DWORD PTR [edi+12]
  0006b	72 d4		 jb	 SHORT $LL4@AtlComModu
  0006d	eb 6c		 jmp	 SHORT $LN68@AtlComModu
$LN59@AtlComModu:

; 8130 : 			{
; 8131 : 				_ATL_OBJMAP_CACHE* pCache = pEntry->pCache;

  0006f	8b 45 08	 mov	 eax, DWORD PTR _pEntry$1$[ebp]
  00072	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00075	89 45 14	 mov	 DWORD PTR _pCache$1$[ebp], eax

; 8132 : 
; 8133 : 				if (pCache->pCF == NULL)

  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	85 c0		 test	 eax, eax
  0007c	75 4b		 jne	 SHORT $LN67@AtlComModu

; 8135 : 					CComCritSecLock<CComCriticalSection> lock(pComModule->m_csObjMap, false);

  0007e	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  00081	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8135 : 					CComCritSecLock<CComCriticalSection> lock(pComModule->m_csObjMap, false);

  00082	89 45 0c	 mov	 DWORD PTR _lock$1$sroa$186$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 134  : 		EnterCriticalSection(&m_sec);

  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8144 : 					if (pCache->pCF == NULL)

  0008b	8b 7d 14	 mov	 edi, DWORD PTR _pCache$1$[ebp]
  0008e	33 f6		 xor	 esi, esi
  00090	39 37		 cmp	 DWORD PTR [edi], esi
  00092	75 26		 jne	 SHORT $LN13@AtlComModu

; 8145 : 					{
; 8146 : 						IUnknown *factory = NULL;

  00094	21 75 14	 and	 DWORD PTR _factory$2[ebp], esi

; 8147 : 						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), reinterpret_cast<void**>(&factory));

  00097	8d 45 14	 lea	 eax, DWORD PTR _factory$2[ebp]
  0009a	50		 push	 eax
  0009b	8b 45 08	 mov	 eax, DWORD PTR _pEntry$1$[ebp]
  0009e	68 00 00 00 00	 push	 OFFSET __GUID_00000000_0000_0000_c000_000000000046
  000a3	ff 70 0c	 push	 DWORD PTR [eax+12]
  000a6	ff 50 08	 call	 DWORD PTR [eax+8]
  000a9	8b f0		 mov	 esi, eax

; 8148 : 						if (SUCCEEDED(hr))

  000ab	85 f6		 test	 esi, esi
  000ad	78 0b		 js	 SHORT $LN13@AtlComModu

; 8149 : 						{
; 8150 : 							pCache->pCF = reinterpret_cast<IUnknown*>(::EncodePointer(factory));

  000af	ff 75 14	 push	 DWORD PTR _factory$2[ebp]
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EncodePointer@4
  000b8	89 07		 mov	 DWORD PTR [edi], eax
$LN13@AtlComModu:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 139  : 		LeaveCriticalSection(&m_sec);

  000ba	ff 75 0c	 push	 DWORD PTR _lock$1$sroa$186$1$[ebp]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h

; 8155 : 				if (pCache->pCF != NULL)

  000c3	8b 07		 mov	 eax, DWORD PTR [edi]
  000c5	85 c0		 test	 eax, eax
  000c7	74 12		 je	 SHORT $LN68@AtlComModu
$LN67@AtlComModu:

; 8156 : 				{
; 8157 : 					// Decode factory pointer
; 8158 : 					IUnknown* factory = reinterpret_cast<IUnknown*>(::DecodePointer(pCache->pCF));

  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DecodePointer@4

; 8159 : 					_Analysis_assume_(factory != nullptr);
; 8160 : 					hr = factory->QueryInterface(riid, ppv);

  000d0	53		 push	 ebx
  000d1	ff 75 10	 push	 DWORD PTR _riid$[ebp]
  000d4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d6	50		 push	 eax
  000d7	ff 11		 call	 DWORD PTR [ecx]
  000d9	8b f0		 mov	 esi, eax
$LN68@AtlComModu:

; 8161 : 				}
; 8162 : 				break;
; 8163 : 			}
; 8164 : 		}
; 8165 : 	}
; 8166 : 
; 8167 : 	if (*ppv == NULL && hr == S_OK)

  000db	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  000de	75 0a		 jne	 SHORT $LN15@AtlComModu
  000e0	85 f6		 test	 esi, esi
  000e2	b8 11 01 04 80	 mov	 eax, -2147221231	; 80040111H
  000e7	0f 44 f0	 cmove	 esi, eax
$LN15@AtlComModu:

; 8168 : 	{
; 8169 : 		hr = CLASS_E_CLASSNOTAVAILABLE;
; 8170 : 	}
; 8171 : 
; 8172 : 	return hr;

  000ea	8b c6		 mov	 eax, esi
  000ec	5e		 pop	 esi
$LN69@AtlComModu:
  000ed	5f		 pop	 edi
$LN1@AtlComModu:
  000ee	5b		 pop	 ebx

; 8173 : }

  000ef	5d		 pop	 ebp
  000f0	c2 10 00	 ret	 16			; 00000010H
?AtlComModuleGetClassObject@ATL@@YGJPAU_ATL_COM_MODULE70@1@ABU_GUID@@1PAPAX@Z ENDP ; ATL::AtlComModuleGetClassObject
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlbase.h
;	COMDAT ?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
tv284 = 8						; size = 4
_pThis$ = 8						; size = 4
_pEntries$ = 12						; size = 4
_iid$ = 16						; size = 4
_ppvObject$ = 20					; size = 4
?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z PROC ; ATL::AtlInternalQueryInterface, COMDAT

; 8265 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 8266 : 	ATLASSERT(pThis != NULL);
; 8267 : 	ATLASSERT(pEntries!= NULL);
; 8268 : 
; 8269 : 	if(pThis == NULL || pEntries == NULL)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _pThis$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	85 db		 test	 ebx, ebx
  0000b	0f 84 86 00 00
	00		 je	 $LN6@AtlInterna
  00011	8b 75 0c	 mov	 esi, DWORD PTR _pEntries$[ebp]
  00014	85 f6		 test	 esi, esi
  00016	74 7f		 je	 SHORT $LN6@AtlInterna

; 8271 : 
; 8272 : 	// First entry in the com map should be a simple map entry
; 8273 : 	ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
; 8274 : 
; 8275 : 	if (ppvObject == NULL)

  00018	8b 7d 14	 mov	 edi, DWORD PTR _ppvObject$[ebp]
  0001b	85 ff		 test	 edi, edi
  0001d	75 07		 jne	 SHORT $LN7@AtlInterna

; 8276 : 		return E_POINTER;

  0001f	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H
  00024	eb 76		 jmp	 SHORT $LN1@AtlInterna
$LN7@AtlInterna:

; 8277 : 
; 8278 : 	if (InlineIsEqualUnknown(iid)) // use first interface

  00026	ff 75 10	 push	 DWORD PTR _iid$[ebp]
  00029	e8 00 00 00 00	 call	 ?InlineIsEqualUnknown@ATL@@YGHABU_GUID@@@Z ; ATL::InlineIsEqualUnknown
  0002e	85 c0		 test	 eax, eax
  00030	74 11		 je	 SHORT $LN8@AtlInterna

; 8279 : 	{
; 8280 : 		IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);

  00032	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
$LN26@AtlInterna:

; 8322 : }

  00035	03 f3		 add	 esi, ebx
  00037	56		 push	 esi
  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	ff 50 04	 call	 DWORD PTR [eax+4]
  0003d	89 37		 mov	 DWORD PTR [edi], esi
$LN19@AtlInterna:
  0003f	33 c0		 xor	 eax, eax
  00041	eb 59		 jmp	 SHORT $LN1@AtlInterna
$LN8@AtlInterna:

; 8289 : 	{
; 8290 : 		if (pEntries->pFunc == NULL)

  00043	83 c6 08	 add	 esi, 8
  00046	eb 3b		 jmp	 SHORT $LN25@AtlInterna
$LL4@AtlInterna:

; 8293 : 			break;
; 8294 : 		}
; 8295 : 
; 8296 : 		BOOL bBlind = (pEntries->piid == NULL);

  00048	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  0004b	89 45 08	 mov	 DWORD PTR tv284[ebp], eax

; 8297 : 		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))

  0004e	85 c0		 test	 eax, eax
  00050	74 0f		 je	 SHORT $LN23@AtlInterna
  00052	ff 75 10	 push	 DWORD PTR _iid$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 _InlineIsEqualGUID
  0005b	59		 pop	 ecx
  0005c	59		 pop	 ecx
  0005d	85 c0		 test	 eax, eax
  0005f	74 1f		 je	 SHORT $LN2@AtlInterna
$LN23@AtlInterna:

; 8298 : 		{
; 8299 : 			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset

  00061	8b 06		 mov	 eax, DWORD PTR [esi]
  00063	83 f8 01	 cmp	 eax, 1
  00066	74 2a		 je	 SHORT $LN18@AtlInterna

; 8306 : 			}
; 8307 : 
; 8308 : 			// Actual function call
; 8309 : 
; 8310 : 			hRes = pEntries->pFunc(pThis,

  00068	ff 76 fc	 push	 DWORD PTR [esi-4]
  0006b	57		 push	 edi
  0006c	ff 75 10	 push	 DWORD PTR _iid$[ebp]
  0006f	53		 push	 ebx
  00070	ff d0		 call	 eax

; 8311 : 				iid, ppvObject, pEntries->dw);
; 8312 : 			if (hRes == S_OK)

  00072	85 c0		 test	 eax, eax
  00074	74 c9		 je	 SHORT $LN19@AtlInterna

; 8313 : 				return S_OK;
; 8314 : 			if (!bBlind && FAILED(hRes))

  00076	83 7d 08 00	 cmp	 DWORD PTR tv284[ebp], 0
  0007a	74 04		 je	 SHORT $LN2@AtlInterna
  0007c	85 c0		 test	 eax, eax
  0007e	78 0d		 js	 SHORT $LN20@AtlInterna
$LN2@AtlInterna:

; 8281 : 		pUnk->AddRef();
; 8282 : 		*ppvObject = pUnk;
; 8283 : 		return S_OK;
; 8284 : 	}
; 8285 : 
; 8286 : 	HRESULT hRes;
; 8287 : 
; 8288 : 	for (;; pEntries++)

  00080	83 c6 0c	 add	 esi, 12			; 0000000cH
$LN25@AtlInterna:

; 8289 : 	{
; 8290 : 		if (pEntries->pFunc == NULL)

  00083	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00086	75 c0		 jne	 SHORT $LL4@AtlInterna

; 8291 : 		{
; 8292 : 			hRes = E_NOINTERFACE;

  00088	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
$LN20@AtlInterna:

; 8315 : 				break;
; 8316 : 		}
; 8317 : 	}
; 8318 : 
; 8319 : 	*ppvObject = NULL;

  0008d	83 27 00	 and	 DWORD PTR [edi], 0

; 8320 : 
; 8321 : 	return hRes;

  00090	eb 0a		 jmp	 SHORT $LN1@AtlInterna
$LN18@AtlInterna:

; 8300 : 			{
; 8301 : 				ATLASSERT(!bBlind);
; 8302 : 				IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);

  00092	8b 76 fc	 mov	 esi, DWORD PTR [esi-4]

; 8303 : 				pUnk->AddRef();
; 8304 : 				*ppvObject = pUnk;
; 8305 : 				return S_OK;

  00095	eb 9e		 jmp	 SHORT $LN26@AtlInterna
$LN6@AtlInterna:

; 8270 : 		return E_INVALIDARG;

  00097	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
$LN1@AtlInterna:
  0009c	5f		 pop	 edi

; 8322 : }

  0009d	5e		 pop	 esi
  0009e	5b		 pop	 ebx
  0009f	5d		 pop	 ebp
  000a0	c2 10 00	 ret	 16			; 00000010H
?AtlInternalQueryInterface@ATL@@YGJPAXPBU_ATL_INTMAP_ENTRY@1@ABU_GUID@@PAPAX@Z ENDP ; ATL::AtlInternalQueryInterface
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[], COMDAT
; _this$ = ecx

; 236  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 237  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
; 238  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	78 0e		 js	 SHORT $LN3@operator
  0000a	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  0000d	7d 09		 jge	 SHORT $LN3@operator

; 241  : 		}
; 242  : 		return m_aT[nIndex];

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00011	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]

; 243  : 	}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@operator:

; 239  : 		{
; 240  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00018	6a 01		 push	 1
  0001a	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0001f	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN5@operator:
  00024	cc		 int	 3
??A?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEAAGH@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll, COMDAT
; _this$ = ecx

; 215  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 216  : 		if(m_aT != NULL)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 0b		 je	 SHORT $LN5@RemoveAll

; 217  : 		{
; 218  : 			for(int i = 0; i < m_nSize; i++)
; 219  : 				m_aT[i].~T();
; 220  : 			free(m_aT);

  00008	ff 36		 push	 DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 _free

; 221  : 			m_aT = NULL;

  0000f	83 26 00	 and	 DWORD PTR [esi], 0
  00012	59		 pop	 ecx
$LN5@RemoveAll:

; 222  : 		}
; 223  : 		m_nSize = 0;

  00013	83 66 04 00	 and	 DWORD PTR [esi+4], 0

; 224  : 		m_nAllocSize = 0;

  00017	83 66 08 00	 and	 DWORD PTR [esi+8], 0
  0001b	5e		 pop	 esi

; 225  :     }

  0001c	c3		 ret	 0
?RemoveAll@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlsimpcoll.h
;	COMDAT ?Add@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEHABG@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?Add@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEHABG@Z PROC ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::Add, COMDAT
; _this$ = ecx

; 166  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 167  : 		if(m_nSize == m_nAllocSize)

  00008	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000b	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000e	3b ca		 cmp	 ecx, edx
  00010	75 40		 jne	 SHORT $LN28@Add

; 168  : 		{
; 169  : 			// Make sure newElement is not a reference to an element in the array.
; 170  : 			// Or else, it will be invalidated by the reallocation.
; 171  : 			ATLENSURE(	(&t < m_aT) ||

  00012	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00014	8b 7d 08	 mov	 edi, DWORD PTR _t$[ebp]
  00017	3b fb		 cmp	 edi, ebx
  00019	72 07		 jb	 SHORT $LN2@Add
  0001b	8d 04 53	 lea	 eax, DWORD PTR [ebx+edx*2]
  0001e	3b f8		 cmp	 edi, eax
  00020	72 57		 jb	 SHORT $LN31@Add
$LN2@Add:

; 172  : 						(&t >= (m_aT + m_nAllocSize) ) );
; 173  : 
; 174  : 			T* aT;
; 175  : 			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);

  00022	85 d2		 test	 edx, edx
  00024	75 05		 jne	 SHORT $LN16@Add
  00026	33 ff		 xor	 edi, edi
  00028	47		 inc	 edi
  00029	eb 0f		 jmp	 SHORT $LN26@Add
$LN16@Add:
  0002b	8d 3c 09	 lea	 edi, DWORD PTR [ecx+ecx]

; 176  : 
; 177  : 			if (nNewAllocSize<0||nNewAllocSize>INT_MAX/sizeof(T))

  0002e	85 ff		 test	 edi, edi
  00030	78 43		 js	 SHORT $LN11@Add
  00032	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  00038	77 3b		 ja	 SHORT $LN11@Add
$LN26@Add:

; 180  : 			}
; 181  : 
; 182  : 			aT = (T*)_recalloc(m_aT, nNewAllocSize, sizeof(T));

  0003a	6a 02		 push	 2
  0003c	57		 push	 edi
  0003d	53		 push	 ebx
  0003e	e8 00 00 00 00	 call	 __recalloc
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH

; 183  : 			if(aT == NULL)

  00046	85 c0		 test	 eax, eax
  00048	74 2b		 je	 SHORT $LN11@Add

; 184  : 				return FALSE;
; 185  : 			m_nAllocSize = nNewAllocSize;
; 186  : 			m_aT = aT;

  0004a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00050	89 06		 mov	 DWORD PTR [esi], eax
$LN28@Add:

; 298  : 		new(m_aT + nIndex) Wrapper(t);

  00052	8b 06		 mov	 eax, DWORD PTR [esi]
  00054	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  00057	85 d2		 test	 edx, edx
  00059	74 0c		 je	 SHORT $LN20@Add

; 274  : 		Wrapper(_In_ const T& _t) : t(_t)

  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0005e	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00061	66 89 0a	 mov	 WORD PTR [edx], cx
  00064	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
$LN20@Add:

; 187  : 		}
; 188  : 		InternalSetAtIndex(m_nSize, t);
; 189  : 		m_nSize++;

  00067	41		 inc	 ecx

; 190  : 		return TRUE;

  00068	33 c0		 xor	 eax, eax
  0006a	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0006d	40		 inc	 eax
$LN1@Add:

; 191  : 	}

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	5b		 pop	 ebx
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
$LN11@Add:

; 178  : 			{
; 179  : 				return FALSE;

  00075	33 c0		 xor	 eax, eax
  00077	eb f5		 jmp	 SHORT $LN1@Add
$LN31@Add:

; 168  : 		{
; 169  : 			// Make sure newElement is not a reference to an element in the array.
; 170  : 			// Or else, it will be invalidated by the reallocation.
; 171  : 			ATLENSURE(	(&t < m_aT) ||

  00079	68 05 40 00 80	 push	 -2147467259		; 80004005H
  0007e	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN29@Add:
  00083	cc		 int	 3
?Add@?$CSimpleArray@GV?$CSimpleArrayEqualHelper@G@ATL@@@ATL@@QAEHABG@Z ENDP ; ATL::CSimpleArray<unsigned short,ATL::CSimpleArrayEqualHelper<unsigned short> >::Add
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atltransactionmanager.h
;	COMDAT ?RegDeleteKeyW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_W@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_lpSubKey$ = 12						; size = 4
?RegDeleteKeyW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_W@Z PROC ; ATL::CAtlTransactionManager::RegDeleteKeyW, COMDAT
; _this$ = ecx

; 664  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 665  : 	if (m_hTransaction != NULL)

  00007	33 ff		 xor	 edi, edi
  00009	39 3e		 cmp	 DWORD PTR [esi], edi
  0000b	74 2e		 je	 SHORT $LN2@RegDeleteK

; 666  : 	{
; 667  : 		HMODULE hAdvAPI32 = ::GetModuleHandle(_T("Advapi32.dll"));

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@BIGILECK@?$AAA?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4

; 668  : 		ATLASSERT(hAdvAPI32 != NULL);
; 669  : 		if (hAdvAPI32 == NULL)

  00018	85 c0		 test	 eax, eax
  0001a	74 2d		 je	 SHORT $LN6@RegDeleteK

; 670  : 		{
; 671  : 			return ERROR_INVALID_FUNCTION;
; 672  : 		}
; 673  : 
; 674  : #ifdef _UNICODE
; 675  : 		typedef LSTATUS (WINAPI* PFNREGDELETEKEYTRANSACTED)(HKEY, LPCWSTR, REGSAM, DWORD, HANDLE, PVOID);
; 676  : 		PFNREGDELETEKEYTRANSACTED pfRegDeleteKeyTransacted = (PFNREGDELETEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegDeleteKeyTransactedW");

  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HAKLOOGP@RegDeleteKeyTransactedW@
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 677  : #else
; 678  : 		typedef LSTATUS (WINAPI* PFNREGDELETEKEYTRANSACTED)(HKEY, LPCSTR, REGSAM, DWORD, HANDLE, PVOID);
; 679  : 		PFNREGDELETEKEYTRANSACTED pfRegDeleteKeyTransacted = (PFNREGDELETEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegDeleteKeyTransactedA");
; 680  : #endif
; 681  : 		if (pfRegDeleteKeyTransacted != NULL)

  00028	85 c0		 test	 eax, eax
  0002a	74 1d		 je	 SHORT $LN6@RegDeleteK

; 682  : 		{
; 683  : 			return (*pfRegDeleteKeyTransacted)(hKey, lpSubKey, 0, 0, m_hTransaction, NULL);

  0002c	57		 push	 edi
  0002d	ff 36		 push	 DWORD PTR [esi]
  0002f	57		 push	 edi
  00030	57		 push	 edi
  00031	ff 75 0c	 push	 DWORD PTR _lpSubKey$[ebp]
  00034	ff 75 08	 push	 DWORD PTR _hKey$[ebp]
  00037	ff d0		 call	 eax
  00039	eb 11		 jmp	 SHORT $LN1@RegDeleteK
$LN2@RegDeleteK:

; 684  : 		}
; 685  : 	}
; 686  : 	else if (m_bFallback)

  0003b	39 7e 04	 cmp	 DWORD PTR [esi+4], edi
  0003e	74 09		 je	 SHORT $LN6@RegDeleteK

; 692  : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5d		 pop	 ebp

; 687  : 	{
; 688  : 		return ::RegDeleteKey(hKey, lpSubKey);

  00043	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__RegDeleteKeyW@8
$LN6@RegDeleteK:

; 689  : 	}
; 690  : 
; 691  : 	return ERROR_INVALID_FUNCTION;

  00049	33 c0		 xor	 eax, eax
  0004b	40		 inc	 eax
$LN1@RegDeleteK:

; 692  : }

  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi
  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?RegDeleteKeyW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_W@Z ENDP ; ATL::CAtlTransactionManager::RegDeleteKeyW
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atltransactionmanager.h
;	COMDAT ?RegOpenKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKKPAPAU3@@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_lpSubKey$ = 12						; size = 4
_ulOptions$ = 16					; size = 4
_samDesired$ = 20					; size = 4
_phkResult$ = 24					; size = 4
?RegOpenKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKKPAPAU3@@Z PROC ; ATL::CAtlTransactionManager::RegOpenKeyExW, COMDAT
; _this$ = ecx

; 593  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 594  : 	if (m_hTransaction != NULL)

  00006	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00009	74 36		 je	 SHORT $LN2@RegOpenKey

; 595  : 	{
; 596  : 		HMODULE hAdvAPI32 = ::GetModuleHandle(_T("Advapi32.dll"));

  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@BIGILECK@?$AAA?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4

; 597  : 		ATLASSERT(hAdvAPI32 != NULL);
; 598  : 		if (hAdvAPI32 == NULL)

  00016	85 c0		 test	 eax, eax
  00018	74 35		 je	 SHORT $LN6@RegOpenKey

; 599  : 		{
; 600  : 			return ERROR_INVALID_FUNCTION;
; 601  : 		}
; 602  : 
; 603  : #ifdef _UNICODE
; 604  : 		typedef LSTATUS (WINAPI* PFNREGOPENKEYTRANSACTED)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY, HANDLE, PVOID);
; 605  : 		PFNREGOPENKEYTRANSACTED pfRegOpenKeyTransacted = (PFNREGOPENKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegOpenKeyTransactedW");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EKFFMJIO@RegOpenKeyTransactedW@
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 606  : #else
; 607  : 		typedef LSTATUS (WINAPI* PFNREGOPENKEYTRANSACTED)(HKEY, LPCSTR, DWORD, REGSAM, PHKEY, HANDLE, PVOID);
; 608  : 		PFNREGOPENKEYTRANSACTED pfRegOpenKeyTransacted = (PFNREGOPENKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegOpenKeyTransactedA");
; 609  : #endif
; 610  : 		if (pfRegOpenKeyTransacted != NULL)

  00026	85 c0		 test	 eax, eax
  00028	74 25		 je	 SHORT $LN6@RegOpenKey

; 611  : 		{
; 612  : 			return (*pfRegOpenKeyTransacted)(hKey, lpSubKey, ulOptions, samDesired, phkResult, m_hTransaction, NULL);

  0002a	6a 00		 push	 0
  0002c	ff 36		 push	 DWORD PTR [esi]
  0002e	ff 75 18	 push	 DWORD PTR _phkResult$[ebp]
  00031	ff 75 14	 push	 DWORD PTR _samDesired$[ebp]
  00034	ff 75 10	 push	 DWORD PTR _ulOptions$[ebp]
  00037	ff 75 0c	 push	 DWORD PTR _lpSubKey$[ebp]
  0003a	ff 75 08	 push	 DWORD PTR _hKey$[ebp]
  0003d	ff d0		 call	 eax
  0003f	eb 11		 jmp	 SHORT $LN1@RegOpenKey
$LN2@RegOpenKey:

; 613  : 		}
; 614  : 	}
; 615  : 	else if (m_bFallback)

  00041	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00045	74 08		 je	 SHORT $LN6@RegOpenKey
  00047	5e		 pop	 esi

; 621  : }

  00048	5d		 pop	 ebp

; 616  : 	{
; 617  : 		return ::RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

  00049	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__RegOpenKeyExW@20
$LN6@RegOpenKey:

; 618  : 	}
; 619  : 
; 620  : 	return ERROR_INVALID_FUNCTION;

  0004f	33 c0		 xor	 eax, eax
  00051	40		 inc	 eax
$LN1@RegOpenKey:
  00052	5e		 pop	 esi

; 621  : }

  00053	5d		 pop	 ebp
  00054	c2 14 00	 ret	 20			; 00000014H
?RegOpenKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKKPAPAU3@@Z ENDP ; ATL::CAtlTransactionManager::RegOpenKeyExW
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atltransactionmanager.h
;	COMDAT ?RegCreateKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKPA_WKKQAU_SECURITY_ATTRIBUTES@@PAPAU3@PAK@Z
_TEXT	SEGMENT
_hKey$ = 8						; size = 4
_lpSubKey$ = 12						; size = 4
_dwReserved$ = 16					; size = 4
_lpClass$ = 20						; size = 4
_dwOptions$ = 24					; size = 4
_samDesired$ = 28					; size = 4
_lpSecurityAttributes$ = 32				; size = 4
_phkResult$ = 36					; size = 4
_lpdwDisposition$ = 40					; size = 4
?RegCreateKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKPA_WKKQAU_SECURITY_ATTRIBUTES@@PAPAU3@PAK@Z PROC ; ATL::CAtlTransactionManager::RegCreateKeyExW, COMDAT
; _this$ = ecx

; 633  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 634  : 	if (m_hTransaction != NULL)

  00006	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00009	74 42		 je	 SHORT $LN2@RegCreateK

; 635  : 	{
; 636  : 		HMODULE hAdvAPI32 = ::GetModuleHandle(_T("Advapi32.dll"));

  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@BIGILECK@?$AAA?$AAd?$AAv?$AAa?$AAp?$AAi?$AA3?$AA2?$AA?4?$AAd?$AAl?$AAl@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4

; 637  : 		ATLASSERT(hAdvAPI32 != NULL);
; 638  : 		if (hAdvAPI32 == NULL)

  00016	85 c0		 test	 eax, eax
  00018	74 41		 je	 SHORT $LN6@RegCreateK

; 639  : 		{
; 640  : 			return ERROR_INVALID_FUNCTION;
; 641  : 		}
; 642  : 
; 643  : #ifdef _UNICODE
; 644  : 		typedef LSTATUS (WINAPI* PFNREGCREATEKEYTRANSACTED)(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, CONST LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD, HANDLE, PVOID);
; 645  : 		PFNREGCREATEKEYTRANSACTED pfRegCreateKeyTransacted = (PFNREGCREATEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegCreateKeyTransactedW");

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MNCFCPFK@RegCreateKeyTransactedW@
  0001f	50		 push	 eax
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetProcAddress@8

; 646  : #else
; 647  : 		typedef LSTATUS (WINAPI* PFNREGCREATEKEYTRANSACTED)(HKEY, LPCSTR, DWORD, LPSTR, DWORD, REGSAM, CONST LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD, HANDLE, PVOID);
; 648  : 		PFNREGCREATEKEYTRANSACTED pfRegCreateKeyTransacted = (PFNREGCREATEKEYTRANSACTED)GetProcAddress(hAdvAPI32, "RegCreateKeyTransactedA");
; 649  : #endif
; 650  : 		if (pfRegCreateKeyTransacted != NULL)

  00026	85 c0		 test	 eax, eax
  00028	74 31		 je	 SHORT $LN6@RegCreateK

; 651  : 		{
; 652  : 			return (*pfRegCreateKeyTransacted)(hKey, lpSubKey, dwReserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, m_hTransaction, NULL);

  0002a	6a 00		 push	 0
  0002c	ff 36		 push	 DWORD PTR [esi]
  0002e	ff 75 28	 push	 DWORD PTR _lpdwDisposition$[ebp]
  00031	ff 75 24	 push	 DWORD PTR _phkResult$[ebp]
  00034	ff 75 20	 push	 DWORD PTR _lpSecurityAttributes$[ebp]
  00037	ff 75 1c	 push	 DWORD PTR _samDesired$[ebp]
  0003a	ff 75 18	 push	 DWORD PTR _dwOptions$[ebp]
  0003d	ff 75 14	 push	 DWORD PTR _lpClass$[ebp]
  00040	ff 75 10	 push	 DWORD PTR _dwReserved$[ebp]
  00043	ff 75 0c	 push	 DWORD PTR _lpSubKey$[ebp]
  00046	ff 75 08	 push	 DWORD PTR _hKey$[ebp]
  00049	ff d0		 call	 eax
  0004b	eb 11		 jmp	 SHORT $LN1@RegCreateK
$LN2@RegCreateK:

; 653  : 		}
; 654  : 	}
; 655  : 	else if (m_bFallback)

  0004d	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00051	74 08		 je	 SHORT $LN6@RegCreateK
  00053	5e		 pop	 esi

; 661  : }

  00054	5d		 pop	 ebp

; 656  : 	{
; 657  : 		return ::RegCreateKeyEx(hKey, lpSubKey, dwReserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

  00055	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__RegCreateKeyExW@36
$LN6@RegCreateK:

; 658  : 	}
; 659  : 
; 660  : 	return ERROR_INVALID_FUNCTION;

  0005b	33 c0		 xor	 eax, eax
  0005d	40		 inc	 eax
$LN1@RegCreateK:
  0005e	5e		 pop	 esi

; 661  : }

  0005f	5d		 pop	 ebp
  00060	c2 24 00	 ret	 36			; 00000024H
?RegCreateKeyExW@CAtlTransactionManager@ATL@@QAEJPAUHKEY__@@PB_WKPA_WKKQAU_SECURITY_ATTRIBUTES@@PAPAU3@PAK@Z ENDP ; ATL::CAtlTransactionManager::RegCreateKeyExW
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@_K@ATL@@YAJPA_K_K1@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 8
_tRight$ = 20						; size = 8
??$AtlAdd@_K@ATL@@YAJPA_K_K1@Z PROC			; ATL::AtlAdd<unsigned __int64>, COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 85   : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	8b 55 10	 mov	 edx, DWORD PTR _tLeft$[ebp+4]
  00006	8b c2		 mov	 eax, edx
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  0000b	f7 d0		 not	 eax
  0000d	56		 push	 esi
  0000e	8b f1		 mov	 esi, ecx
  00010	f7 d6		 not	 esi
  00012	3b 45 18	 cmp	 eax, DWORD PTR _tRight$[ebp+4]
  00015	77 0e		 ja	 SHORT $LN2@AtlAdd
  00017	72 05		 jb	 SHORT $LN6@AtlAdd
  00019	3b 75 14	 cmp	 esi, DWORD PTR _tRight$[ebp]
  0001c	73 07		 jae	 SHORT $LN2@AtlAdd
$LN6@AtlAdd:

; 86   : 	{
; 87   : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001e	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H
  00023	eb 10		 jmp	 SHORT $LN1@AtlAdd
$LN2@AtlAdd:

; 88   : 	}
; 89   : 	*ptResult= tLeft + tRight;

  00025	03 4d 14	 add	 ecx, DWORD PTR _tRight$[ebp]
  00028	8b 45 08	 mov	 eax, DWORD PTR _ptResult$[ebp]
  0002b	13 55 18	 adc	 edx, DWORD PTR _tRight$[ebp+4]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 90   : 	return S_OK;

  00033	33 c0		 xor	 eax, eax
$LN1@AtlAdd:
  00035	5e		 pop	 esi

; 91   : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$AtlAdd@_K@ATL@@YAJPA_K_K1@Z ENDP			; ATL::AtlAdd<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?GetSizeMax@CComVariant@ATL@@QBEJPAT_ULARGE_INTEGER@@@Z
_TEXT	SEGMENT
_varBSTR$1 = -36					; size = 16
_nPersistSize$2 = -28					; size = 8
_nSize$ = -20						; size = 8
_bstr$2$ = -16						; size = 4
_nSize$2$ = -12						; size = 4
_this$1$ = -8						; size = 4
_vtTmp$1$ = -4						; size = 4
_spStream$3 = -4					; size = 4
_pcbSize$ = 8						; size = 4
?GetSizeMax@CComVariant@ATL@@QBEJPAT_ULARGE_INTEGER@@@Z PROC ; ATL::CComVariant::GetSizeMax, COMDAT
; _this$ = ecx

; 3226 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 3227 :     ATLASSERT(pcbSize != NULL);
; 3228 :     if (pcbSize == NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _pcbSize$[ebp], 0
  0000a	89 4d f8	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000d	75 0a		 jne	 SHORT $LN4@GetSizeMax

; 3229 :     {
; 3230 :         return E_INVALIDARG;

  0000f	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00014	e9 76 01 00 00	 jmp	 $LN1@GetSizeMax
$LN4@GetSizeMax:

; 3231 :     }
; 3232 : 
; 3233 :     HRESULT hr = S_OK;
; 3234 :     ULARGE_INTEGER nSize;
; 3235 :     nSize.QuadPart = sizeof(VARTYPE);
; 3236 : 
; 3237 :     switch (vt)

  00019	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0001c	53		 push	 ebx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	33 ff		 xor	 edi, edi
  00021	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  00024	89 7d f4	 mov	 DWORD PTR _nSize$2$[ebp], edi
  00027	8b df		 mov	 ebx, edi
  00029	89 7d f0	 mov	 DWORD PTR _nSize$[ebp+4], edi
  0002c	6a 02		 push	 2
  0002e	5e		 pop	 esi
  0002f	83 f8 15	 cmp	 eax, 21			; 00000015H
  00032	0f 87 c8 00 00
	00		 ja	 $LN15@GetSizeMax
  00038	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN47@GetSizeMax[eax]
  0003f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN48@GetSizeMax[eax*4]
$LN5@GetSizeMax:

; 3238 :     {
; 3239 :     case VT_UNKNOWN:
; 3240 :     case VT_DISPATCH:
; 3241 :         {
; 3242 :             nSize.LowPart += sizeof(CLSID);
; 3243 : 
; 3244 :             if (punkVal != NULL)

  00046	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00049	6a 12		 push	 18			; 00000012H
  0004b	5e		 pop	 esi
  0004c	89 75 ec	 mov	 DWORD PTR _nSize$[ebp], esi
  0004f	85 c9		 test	 ecx, ecx
  00051	0f 84 2b 01 00
	00		 je	 $LN45@GetSizeMax

; 3245 :             {
; 3246 :                 CComPtr<IPersistStream> spStream;
; 3247 : 
; 3248 :                 hr = punkVal->QueryInterface(__uuidof(IPersistStream), (void**)&spStream);

  00057	8d 55 fc	 lea	 edx, DWORD PTR _spStream$3[ebp]

; 165  :         p = NULL;

  0005a	89 7d fc	 mov	 DWORD PTR _spStream$3[ebp], edi

; 3245 :             {
; 3246 :                 CComPtr<IPersistStream> spStream;
; 3247 : 
; 3248 :                 hr = punkVal->QueryInterface(__uuidof(IPersistStream), (void**)&spStream);

  0005d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005f	52		 push	 edx
  00060	68 00 00 00 00	 push	 OFFSET __GUID_00000109_0000_0000_c000_000000000046
  00065	51		 push	 ecx
  00066	ff 10		 call	 DWORD PTR [eax]

; 3249 :                 if (FAILED(hr))

  00068	85 c0		 test	 eax, eax
  0006a	79 30		 jns	 SHORT $LN8@GetSizeMax

; 3250 :                 {
; 3251 :                     hr = punkVal->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spStream);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]
  0006f	8d 55 fc	 lea	 edx, DWORD PTR _spStream$3[ebp]
  00072	52		 push	 edx
  00073	68 00 00 00 00	 push	 OFFSET __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
  00078	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007b	50		 push	 eax
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	ff 11		 call	 DWORD PTR [ecx]
  00080	8b d8		 mov	 ebx, eax

; 3252 :                     if (FAILED(hr))

  00082	85 db		 test	 ebx, ebx
  00084	79 16		 jns	 SHORT $LN8@GetSizeMax

; 183  :         if (p)

  00086	8b 4d fc	 mov	 ecx, DWORD PTR _spStream$3[ebp]
  00089	85 c9		 test	 ecx, ecx
  0008b	0f 84 f9 00 00
	00		 je	 $LN20@GetSizeMax

; 184  :             p->Release();

  00091	8b 11		 mov	 edx, DWORD PTR [ecx]
  00093	51		 push	 ecx
  00094	ff 52 08	 call	 DWORD PTR [edx+8]

; 3253 :                     {
; 3254 :                         break;

  00097	e9 ee 00 00 00	 jmp	 $LN20@GetSizeMax
$LN8@GetSizeMax:

; 3255 :                     }
; 3256 :                 }
; 3257 : 
; 3258 :                 ULARGE_INTEGER nPersistSize;
; 3259 :                 nPersistSize.QuadPart = 0;
; 3260 : 
; 3261 :                 ATLASSERT(spStream != NULL);
; 3262 :                 hr = spStream->GetSizeMax(&nPersistSize);

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _spStream$3[ebp]
  0009f	8d 55 e4	 lea	 edx, DWORD PTR _nPersistSize$2[ebp]
  000a2	0f 57 c0	 xorps	 xmm0, xmm0
  000a5	66 0f 13 45 e4	 movlpd	 QWORD PTR _nPersistSize$2[ebp], xmm0
  000aa	52		 push	 edx
  000ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ad	50		 push	 eax
  000ae	ff 51 1c	 call	 DWORD PTR [ecx+28]
  000b1	8b d8		 mov	 ebx, eax

; 3263 :                 if (SUCCEEDED(hr))

  000b3	85 db		 test	 ebx, ebx
  000b5	78 1f		 js	 SHORT $LN9@GetSizeMax

; 3264 :                 {
; 3265 :                     hr = AtlAdd(&nSize.QuadPart, nSize.QuadPart, nPersistSize.QuadPart);

  000b7	ff 75 e8	 push	 DWORD PTR _nPersistSize$2[ebp+4]
  000ba	8d 45 ec	 lea	 eax, DWORD PTR _nSize$[ebp]
  000bd	ff 75 e4	 push	 DWORD PTR _nPersistSize$2[ebp]
  000c0	57		 push	 edi
  000c1	56		 push	 esi
  000c2	50		 push	 eax
  000c3	e8 00 00 00 00	 call	 ??$AtlAdd@_K@ATL@@YAJPA_K_K1@Z ; ATL::AtlAdd<unsigned __int64>
  000c8	8b 75 ec	 mov	 esi, DWORD PTR _nSize$[ebp]
  000cb	8b d8		 mov	 ebx, eax
  000cd	8b 45 f0	 mov	 eax, DWORD PTR _nSize$[ebp+4]
  000d0	83 c4 14	 add	 esp, 20			; 00000014H
  000d3	89 45 f4	 mov	 DWORD PTR _nSize$2$[ebp], eax
$LN9@GetSizeMax:

; 183  :         if (p)

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _spStream$3[ebp]
  000d9	85 c0		 test	 eax, eax
  000db	0f 84 9a 00 00
	00		 je	 $LN2@GetSizeMax

; 184  :             p->Release();

  000e1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e3	50		 push	 eax
  000e4	ff 51 08	 call	 DWORD PTR [ecx+8]

; 3266 :                 }
; 3267 :             }
; 3268 :         }
; 3269 :         break;

  000e7	e9 8f 00 00 00	 jmp	 $LN2@GetSizeMax
$LN10@GetSizeMax:

; 3270 :     case VT_UI1:
; 3271 :     case VT_I1:
; 3272 :         nSize.LowPart += sizeof(BYTE);

  000ec	6a 03		 push	 3
$LN50@GetSizeMax:

; 3324 :     {
; 3325 :         pcbSize->QuadPart = nSize.QuadPart;

  000ee	5e		 pop	 esi
  000ef	e9 8e 00 00 00	 jmp	 $LN45@GetSizeMax
$LN11@GetSizeMax:

; 3273 :         break;
; 3274 :     case VT_I2:
; 3275 :     case VT_UI2:
; 3276 :     case VT_BOOL:
; 3277 :         nSize.LowPart += sizeof(short);

  000f4	6a 04		 push	 4

; 3278 :         break;

  000f6	eb f6		 jmp	 SHORT $LN50@GetSizeMax
$LN12@GetSizeMax:

; 3279 :     case VT_I4:
; 3280 :     case VT_UI4:
; 3281 :     case VT_R4:
; 3282 :     case VT_INT:
; 3283 :     case VT_UINT:
; 3284 :     case VT_ERROR:
; 3285 :         nSize.LowPart += sizeof(long);

  000f8	6a 06		 push	 6

; 3286 :         break;

  000fa	eb f2		 jmp	 SHORT $LN50@GetSizeMax
$LN13@GetSizeMax:

; 3324 :     {
; 3325 :         pcbSize->QuadPart = nSize.QuadPart;

  000fc	6a 0a		 push	 10			; 0000000aH
  000fe	eb ee		 jmp	 SHORT $LN50@GetSizeMax
$LN15@GetSizeMax:

; 3287 :     case VT_I8:
; 3288 :     case VT_UI8:
; 3289 :         nSize.LowPart += sizeof(LONGLONG);
; 3290 :         break;
; 3291 :     case VT_R8:
; 3292 :     case VT_CY:
; 3293 :     case VT_DATE:
; 3294 :         nSize.LowPart += sizeof(double);
; 3295 :         break;
; 3296 :     default:
; 3297 :         {
; 3298 :             VARTYPE vtTmp = vt;

  00100	8b c2		 mov	 eax, edx

; 3299 :             BSTR bstr = NULL;

  00102	89 7d f0	 mov	 DWORD PTR _bstr$2$[ebp], edi
  00105	89 45 fc	 mov	 DWORD PTR _vtTmp$1$[ebp], eax

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  00108	8d 7d dc	 lea	 edi, DWORD PTR _varBSTR$1[ebp]
  0010b	33 c0		 xor	 eax, eax
  0010d	ab		 stosd
  0010e	ab		 stosd
  0010f	ab		 stosd
  00110	ab		 stosd

; 2161 :         ::VariantInit(this);

  00111	8d 45 dc	 lea	 eax, DWORD PTR _varBSTR$1[ebp]
  00114	50		 push	 eax
  00115	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4

; 3300 :             CComVariant varBSTR;
; 3301 :             if (vtTmp != VT_BSTR)

  0011b	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]
  0011e	6a 08		 push	 8
  00120	5f		 pop	 edi
  00121	66 39 7d fc	 cmp	 WORD PTR _vtTmp$1$[ebp], di
  00125	74 2b		 je	 SHORT $LN16@GetSizeMax

; 3302 :             {
; 3303 :                 hr = VariantChangeType(&varBSTR, const_cast<VARIANT*>((const VARIANT*)this), VARIANT_NOVALUEPROP, VT_BSTR);

  00127	57		 push	 edi
  00128	6a 01		 push	 1
  0012a	50		 push	 eax
  0012b	8d 45 dc	 lea	 eax, DWORD PTR _varBSTR$1[ebp]
  0012e	50		 push	 eax
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantChangeType@16
  00135	8b d8		 mov	 ebx, eax

; 3304 :                 if (SUCCEEDED(hr))

  00137	85 db		 test	 ebx, ebx
  00139	78 07		 js	 SHORT $LN49@GetSizeMax

; 3305 :                 {
; 3306 :                     bstr = varBSTR.bstrVal;

  0013b	8b 4d e4	 mov	 ecx, DWORD PTR _varBSTR$1[ebp+8]

; 3307 :                     vtTmp = VT_BSTR;

  0013e	8b c7		 mov	 eax, edi
  00140	eb 06		 jmp	 SHORT $LN18@GetSizeMax
$LN49@GetSizeMax:

; 3304 :                 if (SUCCEEDED(hr))

  00142	8b 4d f0	 mov	 ecx, DWORD PTR _bstr$2$[ebp]
  00145	8b 45 fc	 mov	 eax, DWORD PTR _vtTmp$1$[ebp]
$LN18@GetSizeMax:

; 3308 :                 }
; 3309 :             }

  00148	0f b7 c0	 movzx	 eax, ax

; 3313 :             }
; 3314 : 
; 3315 :             if (vtTmp == VT_BSTR)

  0014b	66 3b c7	 cmp	 ax, di
  0014e	75 21		 jne	 SHORT $LN19@GetSizeMax
  00150	eb 03		 jmp	 SHORT $LN46@GetSizeMax
$LN16@GetSizeMax:

; 3310 :             else
; 3311 :             {
; 3312 :                 bstr = bstrVal;

  00152	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
$LN46@GetSizeMax:

; 1662 :         ULONG ulSize = sizeof(ULONG);

  00155	6a 04		 push	 4
  00157	5a		 pop	 edx

; 1663 :         if (bstr != NULL)

  00158	85 c9		 test	 ecx, ecx
  0015a	74 0a		 je	 SHORT $LN39@GetSizeMax

; 1664 :         {
; 1665 :             ulSize += SysStringByteLen(bstr) + sizeof(OLECHAR);

  0015c	51		 push	 ecx
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysStringByteLen@4
  00163	8d 50 06	 lea	 edx, DWORD PTR [eax+6]
$LN39@GetSizeMax:

; 3316 :             {
; 3317 :                 // Add the size of the length + string (in bytes) + NULL terminator.
; 3318 :                 nSize.QuadPart += CComBSTR::GetStreamSize(bstr);

  00166	33 c9		 xor	 ecx, ecx
  00168	03 f2		 add	 esi, edx
  0016a	51		 push	 ecx
  0016b	58		 pop	 eax
  0016c	13 c1		 adc	 eax, ecx
  0016e	89 45 f4	 mov	 DWORD PTR _nSize$2$[ebp], eax
$LN19@GetSizeMax:

; 2865 :         return ::VariantClear(this);

  00171	8d 45 dc	 lea	 eax, DWORD PTR _varBSTR$1[ebp]
  00174	50		 push	 eax
  00175	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4
$LN2@GetSizeMax:

; 3319 :             }
; 3320 :         }
; 3321 :     }
; 3322 : 
; 3323 :     if (SUCCEEDED(hr))

  0017b	85 db		 test	 ebx, ebx
  0017d	78 0b		 js	 SHORT $LN20@GetSizeMax
  0017f	8b 7d f4	 mov	 edi, DWORD PTR _nSize$2$[ebp]
$LN45@GetSizeMax:

; 3324 :     {
; 3325 :         pcbSize->QuadPart = nSize.QuadPart;

  00182	8b 45 08	 mov	 eax, DWORD PTR _pcbSize$[ebp]
  00185	89 30		 mov	 DWORD PTR [eax], esi
  00187	89 78 04	 mov	 DWORD PTR [eax+4], edi
$LN20@GetSizeMax:

; 3326 :     }
; 3327 : 
; 3328 :     return hr;

  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	8b c3		 mov	 eax, ebx
  0018e	5b		 pop	 ebx
$LN1@GetSizeMax:

; 3329 : }

  0018f	c9		 leave
  00190	c2 04 00	 ret	 4
  00193	90		 npad	 1
$LN48@GetSizeMax:
  00194	00 00 00 00	 DD	 $LN11@GetSizeMax
  00198	00 00 00 00	 DD	 $LN12@GetSizeMax
  0019c	00 00 00 00	 DD	 $LN13@GetSizeMax
  001a0	00 00 00 00	 DD	 $LN5@GetSizeMax
  001a4	00 00 00 00	 DD	 $LN10@GetSizeMax
  001a8	00 00 00 00	 DD	 $LN15@GetSizeMax
$LN47@GetSizeMax:
  001ac	00		 DB	 0
  001ad	01		 DB	 1
  001ae	01		 DB	 1
  001af	02		 DB	 2
  001b0	02		 DB	 2
  001b1	02		 DB	 2
  001b2	05		 DB	 5
  001b3	03		 DB	 3
  001b4	01		 DB	 1
  001b5	00		 DB	 0
  001b6	05		 DB	 5
  001b7	03		 DB	 3
  001b8	05		 DB	 5
  001b9	05		 DB	 5
  001ba	04		 DB	 4
  001bb	04		 DB	 4
  001bc	00		 DB	 0
  001bd	01		 DB	 1
  001be	02		 DB	 2
  001bf	02		 DB	 2
  001c0	01		 DB	 1
  001c1	01		 DB	 1
?GetSizeMax@CComVariant@ATL@@QBEJPAT_ULARGE_INTEGER@@@Z ENDP ; ATL::CComVariant::GetSizeMax
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?ReadFromStream@CComVariant@ATL@@QAEJPAUIStream@@GTClassesAllowedInStream@2@K@Z
_TEXT	SEGMENT
_vtRead$ = -8						; size = 2
_cbRead$ = -4						; size = 4
_hr$2$ = 8						; size = 4
_pStream$ = 8						; size = 4
_bstrRead$ = 12						; size = 4
_vtExpected$ = 12					; size = 2
_rgclsidAllowed$ = 16					; size = 4
_cclsidAllowed$ = 20					; size = 4
?ReadFromStream@CComVariant@ATL@@QAEJPAUIStream@@GTClassesAllowedInStream@2@K@Z PROC ; ATL::CComVariant::ReadFromStream, COMDAT
; _this$ = ecx

; 3130 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 3131 :     ATLASSERT(pStream != NULL);
; 3132 :     if(pStream == NULL)

  00005	83 7d 08 00	 cmp	 DWORD PTR _pStream$[ebp], 0
  00009	53		 push	 ebx
  0000a	8b d9		 mov	 ebx, ecx
  0000c	75 0a		 jne	 SHORT $LN4@ReadFromSt

; 3133 :         return E_INVALIDARG;

  0000e	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00013	e9 3e 01 00 00	 jmp	 $LN1@ReadFromSt
$LN4@ReadFromSt:

; 3134 : 
; 3135 :     HRESULT hr;
; 3136 :     hr = VariantClear(this);

  00018	53		 push	 ebx
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 3137 :     if (FAILED(hr))

  0001f	85 c0		 test	 eax, eax
  00021	0f 88 2f 01 00
	00		 js	 $LN1@ReadFromSt

; 3138 :         return hr;
; 3139 :     VARTYPE vtRead = VT_EMPTY;
; 3140 :     ULONG cbRead = 0;
; 3141 : 
; 3142 :     hr = pStream->Read(&vtRead, sizeof(VARTYPE), &cbRead);

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _pStream$[ebp]
  0002a	8d 55 fc	 lea	 edx, DWORD PTR _cbRead$[ebp]
  0002d	56		 push	 esi
  0002e	57		 push	 edi
  0002f	52		 push	 edx
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	8d 55 f8	 lea	 edx, DWORD PTR _vtRead$[ebp]
  00035	6a 02		 push	 2
  00037	5f		 pop	 edi
  00038	57		 push	 edi
  00039	52		 push	 edx
  0003a	33 f6		 xor	 esi, esi
  0003c	51		 push	 ecx
  0003d	89 75 f8	 mov	 DWORD PTR _vtRead$[ebp], esi
  00040	89 75 fc	 mov	 DWORD PTR _cbRead$[ebp], esi
  00043	ff 50 0c	 call	 DWORD PTR [eax+12]

; 3143 : ATLPREFAST_SUPPRESS(6102)
; 3144 :     if (hr == S_FALSE || (cbRead != sizeof(VARTYPE) && hr == S_OK))

  00046	83 f8 01	 cmp	 eax, 1
  00049	0f 84 00 01 00
	00		 je	 $LN7@ReadFromSt
  0004f	39 7d fc	 cmp	 DWORD PTR _cbRead$[ebp], edi
  00052	74 08		 je	 SHORT $LN6@ReadFromSt
  00054	85 c0		 test	 eax, eax
  00056	0f 84 f3 00 00
	00		 je	 $LN7@ReadFromSt
$LN6@ReadFromSt:

; 3146 : ATLPREFAST_UNSUPPRESS()
; 3147 :     if (FAILED(hr))

  0005c	85 c0		 test	 eax, eax
  0005e	0f 88 f0 00 00
	00		 js	 $LN40@ReadFromSt

; 3148 :         return hr;
; 3149 :     if (vtExpected != VT_EMPTY && vtRead != vtExpected)

  00064	8b 55 f8	 mov	 edx, DWORD PTR _vtRead$[ebp]
  00067	66 39 75 0c	 cmp	 WORD PTR _vtExpected$[ebp], si
  0006b	74 0a		 je	 SHORT $LN9@ReadFromSt
  0006d	66 3b 55 0c	 cmp	 dx, WORD PTR _vtExpected$[ebp]
  00071	0f 85 d8 00 00
	00		 jne	 $LN7@ReadFromSt
$LN9@ReadFromSt:

; 3150 :         return E_FAIL;
; 3151 : 
; 3152 :     vt = vtRead;
; 3153 :     cbRead = 0;
; 3154 :     switch (vtRead)

  00077	0f b7 c2	 movzx	 eax, dx
  0007a	83 c0 fe	 add	 eax, -2			; fffffffeH
  0007d	66 89 13	 mov	 WORD PTR [ebx], dx
  00080	89 75 fc	 mov	 DWORD PTR _cbRead$[ebp], esi
  00083	83 f8 15	 cmp	 eax, 21			; 00000015H
  00086	77 6c		 ja	 SHORT $LN18@ReadFromSt
  00088	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN37@ReadFromSt[eax]
  0008f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN38@ReadFromSt[eax*4]
$LN10@ReadFromSt:

; 3155 :     {
; 3156 :     case VT_UNKNOWN:
; 3157 :     case VT_DISPATCH:
; 3158 :         {
; 3159 :             punkVal = NULL;
; 3160 :             hr = AtlInternalOleLoadFromStream(pStream,

  00096	ff 75 14	 push	 DWORD PTR _cclsidAllowed$[ebp]
  00099	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  0009c	66 83 fa 0d	 cmp	 dx, 13			; 0000000dH
  000a0	ff 75 10	 push	 DWORD PTR _rgclsidAllowed$[ebp]
  000a3	8b 55 08	 mov	 edx, DWORD PTR _pStream$[ebp]
  000a6	b8 00 00 00 00	 mov	 eax, OFFSET __GUID_00000000_0000_0000_c000_000000000046
  000ab	89 31		 mov	 DWORD PTR [ecx], esi
  000ad	be 00 00 00 00	 mov	 esi, OFFSET __GUID_00020400_0000_0000_c000_000000000046
  000b2	51		 push	 ecx
  000b3	0f 45 c6	 cmovne	 eax, esi
  000b6	50		 push	 eax
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 ?AtlInternalOleLoadFromStream@ATL@@YAJPAUIStream@@ABU_GUID@@PAPAXTClassesAllowedInStream@1@K@Z ; ATL::AtlInternalOleLoadFromStream
  000bd	83 c4 14	 add	 esp, 20			; 00000014H

; 3161 :                 (vtRead == VT_UNKNOWN) ? __uuidof(IUnknown) : __uuidof(IDispatch),
; 3162 :                 (void**)&punkVal, rgclsidAllowed, cclsidAllowed);
; 3163 :             // If IPictureDisp or IFontDisp property is not set,
; 3164 :             // OleLoadFromStream() will return REGDB_E_CLASSNOTREG.
; 3165 :             if (hr == REGDB_E_CLASSNOTREG)

  000c0	33 c9		 xor	 ecx, ecx
  000c2	3d 54 01 04 80	 cmp	 eax, -2147221164	; 80040154H

; 3166 :                 hr = S_OK;
; 3167 :             return hr;

  000c7	eb 26		 jmp	 SHORT $LN44@ReadFromSt
$LN12@ReadFromSt:

; 3168 :         }
; 3169 :     case VT_UI1:
; 3170 :     case VT_I1:
; 3171 :         cbRead = sizeof(BYTE);

  000c9	33 ff		 xor	 edi, edi
  000cb	47		 inc	 edi

; 3172 :         break;

  000cc	eb 07		 jmp	 SHORT $LN42@ReadFromSt
$LN14@ReadFromSt:

; 3173 :     case VT_I2:
; 3174 :     case VT_UI2:
; 3175 :     case VT_BOOL:
; 3176 :         cbRead = sizeof(short);
; 3177 :         break;
; 3178 :     case VT_I4:
; 3179 :     case VT_UI4:
; 3180 :     case VT_R4:
; 3181 :     case VT_INT:
; 3182 :     case VT_UINT:
; 3183 :     case VT_ERROR:
; 3184 :         cbRead = sizeof(long);

  000ce	6a 04		 push	 4

; 3185 :         break;

  000d0	eb 02		 jmp	 SHORT $LN43@ReadFromSt
$LN16@ReadFromSt:

; 3186 :     case VT_I8:
; 3187 :     case VT_UI8:
; 3188 :         cbRead = sizeof(LONGLONG);
; 3189 :         break;
; 3190 :     case VT_R8:
; 3191 :     case VT_CY:
; 3192 :     case VT_DATE:
; 3193 :         cbRead = sizeof(double);

  000d2	6a 08		 push	 8
$LN43@ReadFromSt:

; 3194 :         break;
; 3195 :     default:
; 3196 :         break;
; 3197 :     }
; 3198 :     if (cbRead != 0)
; 3199 :     {
; 3200 :         hr = pStream->Read((void*) &bVal, cbRead, NULL);

  000d4	5f		 pop	 edi
$LN42@ReadFromSt:
  000d5	8b 55 08	 mov	 edx, DWORD PTR _pStream$[ebp]
  000d8	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  000db	56		 push	 esi
  000dc	57		 push	 edi
  000dd	50		 push	 eax
  000de	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000e0	52		 push	 edx
  000e1	89 7d fc	 mov	 DWORD PTR _cbRead$[ebp], edi
  000e4	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 3201 :         if (hr == S_FALSE)

  000e7	b9 05 40 00 80	 mov	 ecx, -2147467259	; 80004005H
  000ec	83 f8 01	 cmp	 eax, 1
$LN44@ReadFromSt:
  000ef	0f 44 c1	 cmove	 eax, ecx

; 3202 :             hr = E_FAIL;
; 3203 :         return hr;

  000f2	eb 60		 jmp	 SHORT $LN40@ReadFromSt
$LN18@ReadFromSt:

; 3204 :     }
; 3205 :     CComBSTR bstrRead;
; 3206 : 
; 3207 :     hr = bstrRead.ReadFromStream(pStream);

  000f4	8b 7d 08	 mov	 edi, DWORD PTR _pStream$[ebp]
  000f7	8d 4d 0c	 lea	 ecx, DWORD PTR _bstrRead$[ebp]
  000fa	57		 push	 edi

; 728  :         m_str = NULL;

  000fb	89 75 0c	 mov	 DWORD PTR _bstrRead$[ebp], esi

; 3204 :     }
; 3205 :     CComBSTR bstrRead;
; 3206 : 
; 3207 :     hr = bstrRead.ReadFromStream(pStream);

  000fe	e8 00 00 00 00	 call	 ?ReadFromStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z ; ATL::CComBSTR::ReadFromStream
  00103	89 45 08	 mov	 DWORD PTR _hr$2$[ebp], eax

; 3208 :     if (FAILED(hr))

  00106	85 c0		 test	 eax, eax
  00108	79 23		 jns	 SHORT $LN20@ReadFromSt

; 3209 :     {
; 3210 :         // If CComBSTR::ReadFromStream failed, reset seek pointer to start of
; 3211 :         // variant type.
; 3212 :         LARGE_INTEGER nOffset;
; 3213 :         nOffset.QuadPart = -(static_cast<LONGLONG>(sizeof(VARTYPE)));
; 3214 :         pStream->Seek(nOffset, STREAM_SEEK_CUR, NULL);

  0010a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0010c	56		 push	 esi
  0010d	6a 01		 push	 1
  0010f	6a ff		 push	 -1
  00111	6a fe		 push	 -2			; fffffffeH
  00113	57		 push	 edi
  00114	ff 51 14	 call	 DWORD PTR [ecx+20]
  00117	8b 75 0c	 mov	 esi, DWORD PTR _bstrRead$[ebp]

; 3215 :         vt = VT_EMPTY;

  0011a	33 c0		 xor	 eax, eax
  0011c	66 89 03	 mov	 WORD PTR [ebx], ax
$LN39@ReadFromSt:

; 1674 :     ::SysFreeString(m_str);

  0011f	8b 7d 08	 mov	 edi, DWORD PTR _hr$2$[ebp]
$LN21@ReadFromSt:
  00122	56		 push	 esi
  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 3222 :     return hr;

  00129	8b c7		 mov	 eax, edi
  0012b	eb 27		 jmp	 SHORT $LN40@ReadFromSt
$LN20@ReadFromSt:

; 973  :         BSTR s = m_str;

  0012d	8b 45 0c	 mov	 eax, DWORD PTR _bstrRead$[ebp]

; 3216 :         return hr;
; 3217 :     }
; 3218 :     vt = VT_BSTR;

  00130	6a 08		 push	 8
  00132	59		 pop	 ecx
  00133	66 89 0b	 mov	 WORD PTR [ebx], cx

; 3219 :     bstrVal = bstrRead.Detach();

  00136	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 3220 :     if (vtRead != VT_BSTR)

  00139	66 39 4d f8	 cmp	 WORD PTR _vtRead$[ebp], cx
  0013d	74 e0		 je	 SHORT $LN39@ReadFromSt

; 2937 :         return ::VariantChangeType(this, pVar, 0, vtNew);

  0013f	ff 75 f8	 push	 DWORD PTR _vtRead$[ebp]
  00142	56		 push	 esi
  00143	53		 push	 ebx
  00144	53		 push	 ebx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantChangeType@16

; 3221 :         hr = ChangeType(vtRead);

  0014b	8b f8		 mov	 edi, eax
  0014d	eb d3		 jmp	 SHORT $LN21@ReadFromSt
$LN7@ReadFromSt:

; 3145 :         hr = E_FAIL;

  0014f	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
$LN40@ReadFromSt:
  00154	5f		 pop	 edi
  00155	5e		 pop	 esi
$LN1@ReadFromSt:
  00156	5b		 pop	 ebx

; 3223 : }

  00157	c9		 leave
  00158	c2 10 00	 ret	 16			; 00000010H
  0015b	90		 npad	 1
$LN38@ReadFromSt:
  0015c	00 00 00 00	 DD	 $LN42@ReadFromSt
  00160	00 00 00 00	 DD	 $LN14@ReadFromSt
  00164	00 00 00 00	 DD	 $LN16@ReadFromSt
  00168	00 00 00 00	 DD	 $LN10@ReadFromSt
  0016c	00 00 00 00	 DD	 $LN12@ReadFromSt
  00170	00 00 00 00	 DD	 $LN18@ReadFromSt
$LN37@ReadFromSt:
  00174	00		 DB	 0
  00175	01		 DB	 1
  00176	01		 DB	 1
  00177	02		 DB	 2
  00178	02		 DB	 2
  00179	02		 DB	 2
  0017a	05		 DB	 5
  0017b	03		 DB	 3
  0017c	01		 DB	 1
  0017d	00		 DB	 0
  0017e	05		 DB	 5
  0017f	03		 DB	 3
  00180	05		 DB	 5
  00181	05		 DB	 5
  00182	04		 DB	 4
  00183	04		 DB	 4
  00184	00		 DB	 0
  00185	01		 DB	 1
  00186	02		 DB	 2
  00187	02		 DB	 2
  00188	01		 DB	 1
  00189	01		 DB	 1
?ReadFromStream@CComVariant@ATL@@QAEJPAUIStream@@GTClassesAllowedInStream@2@K@Z ENDP ; ATL::CComVariant::ReadFromStream
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@G@Z
_TEXT	SEGMENT
_varConv$1 = -16					; size = 16
_pStream$ = 8						; size = 4
_vtWrite$ = 12						; size = 2
?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@G@Z PROC ; ATL::CComVariant::WriteToStream, COMDAT
; _this$ = ecx

; 2953 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2954 :         if (vtWrite != VT_EMPTY && vtWrite != vt)

  00008	8b 75 0c	 mov	 esi, DWORD PTR _vtWrite$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	66 85 f6	 test	 si, si
  00010	74 49		 je	 SHORT $LN2@WriteToStr
  00012	66 3b 33	 cmp	 si, WORD PTR [ebx]
  00015	74 44		 je	 SHORT $LN2@WriteToStr

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  00017	57		 push	 edi
  00018	33 c0		 xor	 eax, eax
  0001a	8d 7d f0	 lea	 edi, DWORD PTR _varConv$1[ebp]
  0001d	ab		 stosd
  0001e	ab		 stosd
  0001f	ab		 stosd
  00020	ab		 stosd

; 2161 :         ::VariantInit(this);

  00021	8d 45 f0	 lea	 eax, DWORD PTR _varConv$1[ebp]
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4

; 2937 :         return ::VariantChangeType(this, pVar, 0, vtNew);

  0002b	56		 push	 esi
  0002c	6a 00		 push	 0
  0002e	53		 push	 ebx
  0002f	8d 45 f0	 lea	 eax, DWORD PTR _varConv$1[ebp]
  00032	50		 push	 eax
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantChangeType@16

; 2955 :         {
; 2956 :             CComVariant varConv;
; 2957 :             HRESULT hr = varConv.ChangeType(vtWrite, this);

  00039	8b f0		 mov	 esi, eax

; 2958 :             if (FAILED(hr))

  0003b	5f		 pop	 edi
  0003c	85 f6		 test	 esi, esi
  0003e	78 0d		 js	 SHORT $LN5@WriteToStr

; 2959 :             {
; 2960 :                 return hr;
; 2961 :             }
; 2962 :             return varConv.WriteToStream(pStream);

  00040	ff 75 08	 push	 DWORD PTR _pStream$[ebp]
  00043	8d 4d f0	 lea	 ecx, DWORD PTR _varConv$1[ebp]
  00046	e8 00 00 00 00	 call	 ?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@@Z ; ATL::CComVariant::WriteToStream
  0004b	8b f0		 mov	 esi, eax
$LN5@WriteToStr:

; 2865 :         return ::VariantClear(this);

  0004d	8d 45 f0	 lea	 eax, DWORD PTR _varConv$1[ebp]
  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 2959 :             {
; 2960 :                 return hr;
; 2961 :             }
; 2962 :             return varConv.WriteToStream(pStream);

  00057	8b c6		 mov	 eax, esi
  00059	eb 08		 jmp	 SHORT $LN1@WriteToStr
$LN2@WriteToStr:

; 2963 :         }
; 2964 :         return WriteToStream(pStream);

  0005b	ff 75 08	 push	 DWORD PTR _pStream$[ebp]
  0005e	e8 00 00 00 00	 call	 ?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@@Z ; ATL::CComVariant::WriteToStream
$LN1@WriteToStr:

; 2965 :     }

  00063	5e		 pop	 esi
  00064	5b		 pop	 ebx
  00065	c9		 leave
  00066	c2 08 00	 ret	 8
?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@G@Z ENDP ; ATL::CComVariant::WriteToStream
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT
_varBSTR$ = -20						; size = 16
_this$1$ = -4						; size = 4
_bstrWrite$ = 8						; size = 4
_spStream$1 = 8						; size = 4
_pStream$ = 8						; size = 4
?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@@Z PROC	; ATL::CComVariant::WriteToStream, COMDAT
; _this$ = ecx

; 3032 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 3033 :     if(pStream == NULL)

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _pStream$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi
  00010	85 db		 test	 ebx, ebx
  00012	75 0a		 jne	 SHORT $LN4@WriteToStr

; 3034 :         return E_INVALIDARG;

  00014	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00019	e9 27 01 00 00	 jmp	 $LN1@WriteToStr
$LN4@WriteToStr:

; 3035 : 
; 3036 :     HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);

  0001e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00020	56		 push	 esi
  00021	33 f6		 xor	 esi, esi
  00023	56		 push	 esi
  00024	6a 02		 push	 2
  00026	57		 push	 edi
  00027	53		 push	 ebx
  00028	ff 50 10	 call	 DWORD PTR [eax+16]

; 3037 :     if (FAILED(hr))

  0002b	85 c0		 test	 eax, eax
  0002d	0f 88 11 01 00
	00		 js	 $LN77@WriteToStr

; 3038 :         return hr;
; 3039 : 
; 3040 :     int cbWrite = 0;
; 3041 :     switch (vt)

  00033	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00036	83 c0 fe	 add	 eax, -2			; fffffffeH
  00039	83 f8 15	 cmp	 eax, 21			; 00000015H
  0003c	0f 87 99 00 00
	00		 ja	 $LN17@WriteToStr
  00042	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN75@WriteToStr[eax]
  00049	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN76@WriteToStr[eax*4]
$LN6@WriteToStr:

; 3042 :     {
; 3043 :     case VT_UNKNOWN:
; 3044 :     case VT_DISPATCH:
; 3045 :         {
; 3046 :             CComPtr<IPersistStream> spStream;
; 3047 :             if (punkVal != NULL)

  00050	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]

; 165  :         p = NULL;

  00053	89 75 08	 mov	 DWORD PTR _spStream$1[ebp], esi

; 3042 :     {
; 3043 :     case VT_UNKNOWN:
; 3044 :     case VT_DISPATCH:
; 3045 :         {
; 3046 :             CComPtr<IPersistStream> spStream;
; 3047 :             if (punkVal != NULL)

  00056	85 c9		 test	 ecx, ecx
  00058	74 3f		 je	 SHORT $LN10@WriteToStr

; 3048 :             {
; 3049 :                 hr = punkVal->QueryInterface(__uuidof(IPersistStream), (void**)&spStream);

  0005a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005c	8d 55 08	 lea	 edx, DWORD PTR _spStream$1[ebp]
  0005f	52		 push	 edx
  00060	68 00 00 00 00	 push	 OFFSET __GUID_00000109_0000_0000_c000_000000000046
  00065	51		 push	 ecx
  00066	ff 10		 call	 DWORD PTR [eax]

; 3050 :                 if (FAILED(hr))

  00068	85 c0		 test	 eax, eax
  0006a	79 1c		 jns	 SHORT $LN9@WriteToStr

; 3051 :                 {
; 3052 :                     hr = punkVal->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spStream);

  0006c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0006f	8d 55 08	 lea	 edx, DWORD PTR _spStream$1[ebp]
  00072	52		 push	 edx
  00073	68 00 00 00 00	 push	 OFFSET __GUID_7fd52380_4e07_101b_ae2d_08002b2ec713
  00078	50		 push	 eax
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	ff 11		 call	 DWORD PTR [ecx]
  0007d	8b f8		 mov	 edi, eax

; 3053 :                     if (FAILED(hr))

  0007f	85 ff		 test	 edi, edi
  00081	79 05		 jns	 SHORT $LN9@WriteToStr

; 256  :         p = NULL;

  00083	89 75 08	 mov	 DWORD PTR _spStream$1[ebp], esi
  00086	eb 22		 jmp	 SHORT $LN23@WriteToStr
$LN9@WriteToStr:

; 223  :         return p == pT;

  00088	39 75 08	 cmp	 DWORD PTR _spStream$1[ebp], esi

; 3054 :                     {
; 3055 :                         spStream.Detach();
; 3056 :                         return hr;
; 3057 :                     }
; 3058 :                 }
; 3059 :             }
; 3060 :             if (spStream != NULL)

  0008b	74 0c		 je	 SHORT $LN10@WriteToStr

; 3061 :                 return OleSaveToStream(spStream, pStream);

  0008d	53		 push	 ebx
  0008e	ff 75 08	 push	 DWORD PTR _spStream$1[ebp]
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OleSaveToStream@8
  00097	eb 0c		 jmp	 SHORT $LN78@WriteToStr
$LN10@WriteToStr:

; 3062 :             return WriteClassStm(pStream, CLSID_NULL);

  00099	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  0009e	53		 push	 ebx
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteClassStm@8
$LN78@WriteToStr:

; 183  :         if (p)

  000a5	8b 75 08	 mov	 esi, DWORD PTR _spStream$1[ebp]
  000a8	8b f8		 mov	 edi, eax
$LN23@WriteToStr:
  000aa	85 f6		 test	 esi, esi
  000ac	0f 84 90 00 00
	00		 je	 $LN48@WriteToStr

; 184  :             p->Release();

  000b2	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b4	56		 push	 esi
  000b5	ff 51 08	 call	 DWORD PTR [ecx+8]

; 3062 :             return WriteClassStm(pStream, CLSID_NULL);

  000b8	e9 85 00 00 00	 jmp	 $LN48@WriteToStr
$LN11@WriteToStr:

; 3063 :         }
; 3064 :     case VT_UI1:
; 3065 :     case VT_I1:
; 3066 :         cbWrite = sizeof(BYTE);

  000bd	33 c0		 xor	 eax, eax
  000bf	40		 inc	 eax

; 3067 :         break;

  000c0	eb 0b		 jmp	 SHORT $LN16@WriteToStr
$LN12@WriteToStr:

; 3068 :     case VT_I2:
; 3069 :     case VT_UI2:
; 3070 :     case VT_BOOL:
; 3071 :         cbWrite = sizeof(short);
; 3072 :         break;

  000c2	6a 02		 push	 2
  000c4	eb 06		 jmp	 SHORT $LN79@WriteToStr
$LN13@WriteToStr:

; 3073 :     case VT_I4:
; 3074 :     case VT_UI4:
; 3075 :     case VT_R4:
; 3076 :     case VT_INT:
; 3077 :     case VT_UINT:
; 3078 :     case VT_ERROR:
; 3079 :         cbWrite = sizeof(long);

  000c6	6a 04		 push	 4

; 3080 :         break;

  000c8	eb 02		 jmp	 SHORT $LN79@WriteToStr
$LN15@WriteToStr:

; 3081 :     case VT_I8:
; 3082 :     case VT_UI8:
; 3083 :         cbWrite = sizeof(LONGLONG);
; 3084 :         break;
; 3085 :     case VT_R8:
; 3086 :     case VT_CY:
; 3087 :     case VT_DATE:
; 3088 :         cbWrite = sizeof(double);
; 3089 :         break;
; 3090 :     default:
; 3091 :         break;
; 3092 :     }
; 3093 :     if (cbWrite != 0)
; 3094 :         return pStream->Write((void*) &bVal, cbWrite, NULL);

  000ca	6a 08		 push	 8
$LN79@WriteToStr:
  000cc	58		 pop	 eax
$LN16@WriteToStr:
  000cd	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000cf	56		 push	 esi
  000d0	50		 push	 eax
  000d1	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  000d4	50		 push	 eax
  000d5	53		 push	 ebx
  000d6	ff 51 10	 call	 DWORD PTR [ecx+16]
  000d9	eb 69		 jmp	 SHORT $LN77@WriteToStr
$LN17@WriteToStr:

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  000db	33 c0		 xor	 eax, eax

; 728  :         m_str = NULL;

  000dd	89 75 08	 mov	 DWORD PTR _bstrWrite$[ebp], esi

; 2160 :         memset(this, 0, sizeof(tagVARIANT));

  000e0	8d 7d ec	 lea	 edi, DWORD PTR _varBSTR$[ebp]
  000e3	ab		 stosd
  000e4	ab		 stosd
  000e5	ab		 stosd
  000e6	ab		 stosd

; 2161 :         ::VariantInit(this);

  000e7	8d 45 ec	 lea	 eax, DWORD PTR _varBSTR$[ebp]
  000ea	50		 push	 eax
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantInit@4

; 3095 : 
; 3096 :     CComBSTR bstrWrite;
; 3097 :     CComVariant varBSTR;
; 3098 :     if (vt != VT_BSTR)

  000f1	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
  000f4	6a 08		 push	 8
  000f6	59		 pop	 ecx
  000f7	66 39 08	 cmp	 WORD PTR [eax], cx
  000fa	74 19		 je	 SHORT $LN18@WriteToStr

; 3099 :     {
; 3100 :         hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);

  000fc	51		 push	 ecx
  000fd	6a 01		 push	 1
  000ff	50		 push	 eax
  00100	8d 45 ec	 lea	 eax, DWORD PTR _varBSTR$[ebp]
  00103	50		 push	 eax
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantChangeType@16
  0010a	8b f8		 mov	 edi, eax

; 3101 :         if (FAILED(hr))

  0010c	85 ff		 test	 edi, edi
  0010e	78 21		 js	 SHORT $LN24@WriteToStr

; 3102 :             return hr;
; 3103 :         bstrWrite.Attach(varBSTR.bstrVal);

  00110	8b 7d f4	 mov	 edi, DWORD PTR _varBSTR$[ebp+8]

; 3104 :     }

  00113	eb 03		 jmp	 SHORT $LN80@WriteToStr
$LN18@WriteToStr:

; 3105 :     else
; 3106 :         bstrWrite.Attach(bstrVal);

  00115	8b 78 08	 mov	 edi, DWORD PTR [eax+8]
$LN80@WriteToStr:

; 3107 : 
; 3108 :     hr = bstrWrite.WriteToStream(pStream);

  00118	85 ff		 test	 edi, edi
  0011a	74 0a		 je	 SHORT $LN64@WriteToStr
  0011c	56		 push	 esi
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
  00123	89 7d 08	 mov	 DWORD PTR _bstrWrite$[ebp], edi
$LN64@WriteToStr:
  00126	53		 push	 ebx
  00127	8d 4d 08	 lea	 ecx, DWORD PTR _bstrWrite$[ebp]
  0012a	e8 00 00 00 00	 call	 ?WriteToStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z ; ATL::CComBSTR::WriteToStream
  0012f	8b f8		 mov	 edi, eax
$LN24@WriteToStr:

; 2865 :         return ::VariantClear(this);

  00131	8d 45 ec	 lea	 eax, DWORD PTR _varBSTR$[ebp]
  00134	50		 push	 eax
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 1674 :     ::SysFreeString(m_str);

  0013b	56		 push	 esi
  0013c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN48@WriteToStr:

; 3109 :     bstrWrite.Detach();
; 3110 :     return hr;

  00142	8b c7		 mov	 eax, edi
$LN77@WriteToStr:
  00144	5e		 pop	 esi
$LN1@WriteToStr:
  00145	5f		 pop	 edi

; 3111 : }

  00146	5b		 pop	 ebx
  00147	c9		 leave
  00148	c2 04 00	 ret	 4
  0014b	90		 npad	 1
$LN76@WriteToStr:
  0014c	00 00 00 00	 DD	 $LN12@WriteToStr
  00150	00 00 00 00	 DD	 $LN13@WriteToStr
  00154	00 00 00 00	 DD	 $LN15@WriteToStr
  00158	00 00 00 00	 DD	 $LN6@WriteToStr
  0015c	00 00 00 00	 DD	 $LN11@WriteToStr
  00160	00 00 00 00	 DD	 $LN17@WriteToStr
$LN75@WriteToStr:
  00164	00		 DB	 0
  00165	01		 DB	 1
  00166	01		 DB	 1
  00167	02		 DB	 2
  00168	02		 DB	 2
  00169	02		 DB	 2
  0016a	05		 DB	 5
  0016b	03		 DB	 3
  0016c	01		 DB	 1
  0016d	00		 DB	 0
  0016e	05		 DB	 5
  0016f	03		 DB	 3
  00170	05		 DB	 5
  00171	05		 DB	 5
  00172	04		 DB	 4
  00173	04		 DB	 4
  00174	00		 DB	 0
  00175	01		 DB	 1
  00176	02		 DB	 2
  00177	02		 DB	 2
  00178	01		 DB	 1
  00179	01		 DB	 1
?WriteToStream@CComVariant@ATL@@QAEJPAUIStream@@@Z ENDP	; ATL::CComVariant::WriteToStream
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??1CComVariant@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CComVariant@ATL@@QAE@XZ PROC				; ATL::CComVariant::~CComVariant, COMDAT
; _this$ = ecx

; 2865 :         return ::VariantClear(this);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 2165 :         HRESULT hr = Clear();
; 2166 :         ATLASSERT(SUCCEEDED(hr));
; 2167 :         (hr);
; 2168 :     }

  00007	c3		 ret	 0
??1CComVariant@ATL@@QAE@XZ ENDP				; ATL::CComVariant::~CComVariant
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?ReadFromStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT
_nBegOffset$ = -24					; size = 8
_nZeroOffset$1 = -16					; size = 8
_hrSeek$1$ = -12					; size = 4
_cbStrLen$ = -8						; size = 4
_cbRead$ = -4						; size = 4
_ch$2 = 8						; size = 2
_pStream$ = 8						; size = 4
?ReadFromStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z PROC	; ATL::CComBSTR::ReadFromStream, COMDAT
; _this$ = ecx

; 1495 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 1496 :         ATLASSERT(pStream != NULL);
; 1497 :         if(pStream == NULL)

  00008	8b 7d 08	 mov	 edi, DWORD PTR _pStream$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	85 ff		 test	 edi, edi
  0000f	75 0a		 jne	 SHORT $LN2@ReadFromSt

; 1498 :         {
; 1499 :             return E_INVALIDARG;

  00011	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00016	e9 02 01 00 00	 jmp	 $LN1@ReadFromSt
$LN2@ReadFromSt:
  0001b	56		 push	 esi

; 980  :         ::SysFreeString(m_str);

  0001c	ff 33		 push	 DWORD PTR [ebx]
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 1500 :         }
; 1501 : 
; 1502 :         ATLASSERT(!*this); // should be empty
; 1503 :         Empty();
; 1504 : 
; 1505 :         HRESULT hrSeek;
; 1506 :         ULARGE_INTEGER nBegOffset;
; 1507 :         {
; 1508 :             LARGE_INTEGER nZeroOffset;
; 1509 :             nZeroOffset.QuadPart = 0L;
; 1510 :             hrSeek = pStream->Seek(nZeroOffset, STREAM_SEEK_CUR, &nBegOffset);

  00024	8d 4d e8	 lea	 ecx, DWORD PTR _nBegOffset$[ebp]
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	51		 push	 ecx
  0002b	6a 01		 push	 1
  0002d	66 0f 13 45 f0	 movlpd	 QWORD PTR _nZeroOffset$1[ebp], xmm0

; 981  :         m_str = NULL;

  00032	33 f6		 xor	 esi, esi

; 1500 :         }
; 1501 : 
; 1502 :         ATLASSERT(!*this); // should be empty
; 1503 :         Empty();
; 1504 : 
; 1505 :         HRESULT hrSeek;
; 1506 :         ULARGE_INTEGER nBegOffset;
; 1507 :         {
; 1508 :             LARGE_INTEGER nZeroOffset;
; 1509 :             nZeroOffset.QuadPart = 0L;
; 1510 :             hrSeek = pStream->Seek(nZeroOffset, STREAM_SEEK_CUR, &nBegOffset);

  00034	ff 75 f4	 push	 DWORD PTR _nZeroOffset$1[ebp+4]

; 981  :         m_str = NULL;

  00037	89 33		 mov	 DWORD PTR [ebx], esi

; 1500 :         }
; 1501 : 
; 1502 :         ATLASSERT(!*this); // should be empty
; 1503 :         Empty();
; 1504 : 
; 1505 :         HRESULT hrSeek;
; 1506 :         ULARGE_INTEGER nBegOffset;
; 1507 :         {
; 1508 :             LARGE_INTEGER nZeroOffset;
; 1509 :             nZeroOffset.QuadPart = 0L;
; 1510 :             hrSeek = pStream->Seek(nZeroOffset, STREAM_SEEK_CUR, &nBegOffset);

  00039	ff 75 f0	 push	 DWORD PTR _nZeroOffset$1[ebp]
  0003c	8b 07		 mov	 eax, DWORD PTR [edi]
  0003e	57		 push	 edi
  0003f	ff 50 14	 call	 DWORD PTR [eax+20]

; 1511 :         }
; 1512 : 
; 1513 :         ULONG cbRead = 0;
; 1514 :         ULONG cbStrLen = 0;
; 1515 :         HRESULT hr = pStream->Read(reinterpret_cast<void*>(&cbStrLen), sizeof(cbStrLen), &cbRead);

  00042	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00044	89 45 f4	 mov	 DWORD PTR _hrSeek$1$[ebp], eax
  00047	8d 45 fc	 lea	 eax, DWORD PTR _cbRead$[ebp]
  0004a	50		 push	 eax
  0004b	6a 04		 push	 4
  0004d	8d 45 f8	 lea	 eax, DWORD PTR _cbStrLen$[ebp]
  00050	89 75 fc	 mov	 DWORD PTR _cbRead$[ebp], esi
  00053	50		 push	 eax
  00054	57		 push	 edi
  00055	89 75 f8	 mov	 DWORD PTR _cbStrLen$[ebp], esi
  00058	ff 51 0c	 call	 DWORD PTR [ecx+12]
  0005b	8b f0		 mov	 esi, eax

; 1516 : 
; 1517 :         if (SUCCEEDED(hr))

  0005d	85 f6		 test	 esi, esi
  0005f	0f 88 9f 00 00
	00		 js	 $LN28@ReadFromSt

; 1518 :         {
; 1519 :             // invalid data size
; 1520 :             if (sizeof(cbStrLen) != cbRead)

  00065	83 7d fc 04	 cmp	 DWORD PTR _cbRead$[ebp], 4
  00069	74 0a		 je	 SHORT $LN4@ReadFromSt
$LN29@ReadFromSt:

; 1588 :                     }
; 1589 :                 }
; 1590 :             }
; 1591 :         }
; 1592 : 
; 1593 :         // If SysAllocStringByteLen or IStream::Read failed, reset seek
; 1594 :         // pointer to start of BSTR size.
; 1595 :         if (FAILED(hr) && SUCCEEDED(hrSeek))

  0006b	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
  00070	e9 8f 00 00 00	 jmp	 $LN28@ReadFromSt
$LN4@ReadFromSt:

; 1521 :             {
; 1522 :                 ATLTRACE(atlTraceCOM, 0, _T("Input stream is corrupted."));
; 1523 :                 hr = E_FAIL;
; 1524 :             }
; 1525 :             // read NULL string
; 1526 :             else if (cbStrLen == 0)

  00075	8b 45 f8	 mov	 eax, DWORD PTR _cbStrLen$[ebp]
  00078	85 c0		 test	 eax, eax
  0007a	0f 84 9a 00 00
	00		 je	 $LN21@ReadFromSt

; 1527 :             {
; 1528 :             }
; 1529 :             // invalid data length
; 1530 :             else if (cbStrLen < sizeof(OLECHAR))

  00080	83 f8 02	 cmp	 eax, 2
  00083	72 e6		 jb	 SHORT $LN29@ReadFromSt

; 1531 :             {
; 1532 :                 ATLTRACE(atlTraceCOM, 0, _T("Input stream is corrupted."));
; 1533 :                 hr = E_FAIL;
; 1534 :             }
; 1535 :             // security checks for huge stream of data
; 1536 :             else if (cbStrLen > _ATL_STREAM_MAX_SIZE)

  00085	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  0008a	76 07		 jbe	 SHORT $LN10@ReadFromSt

; 1537 :             {
; 1538 :                 ATLTRACE(atlTraceCOM, 0, _T("String exceeded the maximum allowed size see _ATL_STREAM_MAX_SIZE."));
; 1539 :                 hr = E_ACCESSDENIED;

  0008c	be 05 00 07 80	 mov	 esi, -2147024891	; 80070005H

; 1540 :             }

  00091	eb 71		 jmp	 SHORT $LN28@ReadFromSt
$LN10@ReadFromSt:

; 1541 :             else
; 1542 :             {
; 1543 :                 //subtract size for terminating NULL which we wrote out
; 1544 :                 cbStrLen -= sizeof(OLECHAR);

  00093	83 e8 02	 sub	 eax, 2

; 1545 : 
; 1546 :                 m_str = ::SysAllocStringByteLen(NULL, cbStrLen);

  00096	50		 push	 eax
  00097	6a 00		 push	 0
  00099	89 45 f8	 mov	 DWORD PTR _cbStrLen$[ebp], eax
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysAllocStringByteLen@8
  000a2	8b c8		 mov	 ecx, eax
  000a4	89 0b		 mov	 DWORD PTR [ebx], ecx

; 986  :         return (m_str == NULL);

  000a6	85 c9		 test	 ecx, ecx

; 1547 :                 if (!*this)

  000a8	75 07		 jne	 SHORT $LN12@ReadFromSt

; 1548 :                 {
; 1549 :                     hr = E_OUTOFMEMORY;

  000aa	be 0e 00 07 80	 mov	 esi, -2147024882	; 8007000eH

; 1550 :                 }

  000af	eb 53		 jmp	 SHORT $LN28@ReadFromSt
$LN12@ReadFromSt:

; 1551 :                 else
; 1552 :                 {
; 1553 :                     hr = pStream->Read(reinterpret_cast<void*>(m_str), cbStrLen, &cbRead);

  000b1	8b 07		 mov	 eax, DWORD PTR [edi]
  000b3	8d 55 fc	 lea	 edx, DWORD PTR _cbRead$[ebp]
  000b6	52		 push	 edx
  000b7	ff 75 f8	 push	 DWORD PTR _cbStrLen$[ebp]
  000ba	51		 push	 ecx
  000bb	57		 push	 edi
  000bc	ff 50 0c	 call	 DWORD PTR [eax+12]
  000bf	8b f0		 mov	 esi, eax

; 1554 : 
; 1555 :                     if (SUCCEEDED(hr))

  000c1	85 f6		 test	 esi, esi
  000c3	78 30		 js	 SHORT $LN27@ReadFromSt

; 1556 :                     {
; 1557 :                         if (cbRead != cbStrLen)

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _cbRead$[ebp]
  000c8	3b 45 f8	 cmp	 eax, DWORD PTR _cbStrLen$[ebp]
  000cb	75 23		 jne	 SHORT $LN19@ReadFromSt

; 1558 :                         {
; 1559 :                             ATLTRACE(atlTraceCOM, 0, _T("Length of string data is different than expected."));
; 1560 :                             hr = E_FAIL;
; 1561 :                         }
; 1562 :                         else
; 1563 :                         {
; 1564 :                             OLECHAR ch;
; 1565 :                             hr = pStream->Read(reinterpret_cast<void*>(&ch), sizeof(OLECHAR), &cbRead);

  000cd	8b 07		 mov	 eax, DWORD PTR [edi]
  000cf	8d 4d fc	 lea	 ecx, DWORD PTR _cbRead$[ebp]
  000d2	51		 push	 ecx
  000d3	6a 02		 push	 2
  000d5	8d 4d 08	 lea	 ecx, DWORD PTR _ch$2[ebp]
  000d8	51		 push	 ecx
  000d9	57		 push	 edi
  000da	ff 50 0c	 call	 DWORD PTR [eax+12]
  000dd	8b f0		 mov	 esi, eax

; 1566 : 
; 1567 :                             if (SUCCEEDED(hr))

  000df	85 f6		 test	 esi, esi
  000e1	78 12		 js	 SHORT $LN27@ReadFromSt

; 1568 :                             {
; 1569 : #ifndef _ATL_CCOMBSTR_READFROMSTREAM_INSECURE
; 1570 :                                 if (cbRead != sizeof(OLECHAR) || ch != L'\0')

  000e3	83 7d fc 02	 cmp	 DWORD PTR _cbRead$[ebp], 2
  000e7	75 07		 jne	 SHORT $LN19@ReadFromSt
  000e9	66 83 7d 08 00	 cmp	 WORD PTR _ch$2[ebp], 0
  000ee	74 2a		 je	 SHORT $LN21@ReadFromSt
$LN19@ReadFromSt:

; 1571 : #else
; 1572 :                                 if (cbRead != sizeof(OLECHAR))
; 1573 : #endif
; 1574 :                                 {
; 1575 :                                     ATLTRACE(atlTraceCOM, 0, _T("Cannot read NULL terminator from stream."));
; 1576 :                                     hr = E_FAIL;
; 1577 :                                 }
; 1578 :                             }
; 1579 :                         }
; 1580 :                     }
; 1581 : 
; 1582 :                     if (FAILED(hr))
; 1583 :                     {
; 1584 : ATLPREFAST_SUPPRESS(6102)
; 1585 :                         ::SysFreeString(m_str);

  000f0	be 05 40 00 80	 mov	 esi, -2147467259	; 80004005H
$LN27@ReadFromSt:
  000f5	ff 33		 push	 DWORD PTR [ebx]
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4

; 1586 : ATLPREFAST_UNSUPPRESS()
; 1587 :                         m_str = NULL;

  000fd	83 23 00	 and	 DWORD PTR [ebx], 0

; 1588 :                     }
; 1589 :                 }
; 1590 :             }
; 1591 :         }
; 1592 : 
; 1593 :         // If SysAllocStringByteLen or IStream::Read failed, reset seek
; 1594 :         // pointer to start of BSTR size.
; 1595 :         if (FAILED(hr) && SUCCEEDED(hrSeek))

  00100	85 f6		 test	 esi, esi
  00102	79 16		 jns	 SHORT $LN21@ReadFromSt
$LN28@ReadFromSt:
  00104	83 7d f4 00	 cmp	 DWORD PTR _hrSeek$1$[ebp], 0
  00108	7c 10		 jl	 SHORT $LN21@ReadFromSt

; 1596 :         {
; 1597 :             LARGE_INTEGER nOffset;
; 1598 :             nOffset.QuadPart = static_cast<LONGLONG>(nBegOffset.QuadPart);
; 1599 :             pStream->Seek(nOffset, STREAM_SEEK_SET, NULL);

  0010a	8b 07		 mov	 eax, DWORD PTR [edi]
  0010c	6a 00		 push	 0
  0010e	6a 00		 push	 0
  00110	ff 75 ec	 push	 DWORD PTR _nBegOffset$[ebp+4]
  00113	ff 75 e8	 push	 DWORD PTR _nBegOffset$[ebp]
  00116	57		 push	 edi
  00117	ff 50 14	 call	 DWORD PTR [eax+20]
$LN21@ReadFromSt:

; 1600 :         }
; 1601 : 
; 1602 :         return hr;

  0011a	8b c6		 mov	 eax, esi
  0011c	5e		 pop	 esi
$LN1@ReadFromSt:

; 1603 :     }

  0011d	5f		 pop	 edi
  0011e	5b		 pop	 ebx
  0011f	c9		 leave
  00120	c2 04 00	 ret	 4
?ReadFromStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z ENDP	; ATL::CComBSTR::ReadFromStream
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?WriteToStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z
_TEXT	SEGMENT
_cb$ = -4						; size = 4
_cbStrLen$ = 8						; size = 4
_pStream$ = 8						; size = 4
?WriteToStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z PROC	; ATL::CComBSTR::WriteToStream, COMDAT
; _this$ = ecx

; 1469 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1470 :         ATLASSERT(pStream != NULL);
; 1471 :         if(pStream == NULL)

  00005	8b 75 08	 mov	 esi, DWORD PTR _pStream$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	85 f6		 test	 esi, esi
  0000d	75 07		 jne	 SHORT $LN2@WriteToStr

; 1472 :         {
; 1473 :             return E_INVALIDARG;

  0000f	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00014	eb 46		 jmp	 SHORT $LN1@WriteToStr
$LN2@WriteToStr:

; 1663 :         if (bstr != NULL)

  00016	83 3f 00	 cmp	 DWORD PTR [edi], 0
  00019	6a 04		 push	 4
  0001b	58		 pop	 eax
  0001c	74 0b		 je	 SHORT $LN7@WriteToStr

; 1664 :         {
; 1665 :             ulSize += SysStringByteLen(bstr) + sizeof(OLECHAR);

  0001e	ff 37		 push	 DWORD PTR [edi]
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysStringByteLen@4
  00026	83 c0 06	 add	 eax, 6
$LN7@WriteToStr:

; 1474 :         }
; 1475 : 
; 1476 :         ULONG cb;
; 1477 :         ULONG cbStrLen = CComBSTR::GetStreamSize(m_str);
; 1478 :         ATLASSERT(cbStrLen >= sizeof(ULONG));
; 1479 :         cbStrLen -= sizeof(ULONG);
; 1480 : 
; 1481 :         HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);

  00029	8d 4d fc	 lea	 ecx, DWORD PTR _cb$[ebp]
  0002c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002f	51		 push	 ecx
  00030	6a 04		 push	 4
  00032	89 45 08	 mov	 DWORD PTR _cbStrLen$[ebp], eax
  00035	8d 4d 08	 lea	 ecx, DWORD PTR _cbStrLen$[ebp]
  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	51		 push	 ecx
  0003b	56		 push	 esi
  0003c	ff 50 10	 call	 DWORD PTR [eax+16]

; 1482 :         if (FAILED(hr))

  0003f	85 c0		 test	 eax, eax
  00041	78 19		 js	 SHORT $LN1@WriteToStr

; 1483 :         {
; 1484 :             return hr;
; 1485 :         }
; 1486 : 
; 1487 :         if (cbStrLen == 0)

  00043	83 7d 08 00	 cmp	 DWORD PTR _cbStrLen$[ebp], 0
  00047	75 04		 jne	 SHORT $LN4@WriteToStr

; 1488 :         {
; 1489 :             return S_OK;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 0f		 jmp	 SHORT $LN1@WriteToStr
$LN4@WriteToStr:

; 1490 :         }
; 1491 :         return pStream->Write((void*) m_str, cbStrLen, &cb);

  0004d	8b 06		 mov	 eax, DWORD PTR [esi]
  0004f	8d 4d fc	 lea	 ecx, DWORD PTR _cb$[ebp]
  00052	51		 push	 ecx
  00053	ff 75 08	 push	 DWORD PTR _cbStrLen$[ebp]
  00056	ff 37		 push	 DWORD PTR [edi]
  00058	56		 push	 esi
  00059	ff 50 10	 call	 DWORD PTR [eax+16]
$LN1@WriteToStr:

; 1492 :     }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	c9		 leave
  0005f	c2 04 00	 ret	 4
?WriteToStream@CComBSTR@ATL@@QAEJPAUIStream@@@Z ENDP	; ATL::CComBSTR::WriteToStream
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z
_TEXT	SEGMENT
_lp$ = 8						; size = 4
??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z PROC ; ATL::CComPtr<IUnknown>::operator=, COMDAT
; _this$ = ecx

; 328  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 329  :         if(this->p!=lp)

  00004	8b 75 08	 mov	 esi, DWORD PTR _lp$[ebp]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 07		 mov	 eax, DWORD PTR [edi]
  0000c	3b c6		 cmp	 eax, esi
  0000e	74 1e		 je	 SHORT $LN14@operator

; 169  :         p = lp;

  00010	8b d0		 mov	 edx, eax

; 170  :         if (p != NULL)

  00012	85 f6		 test	 esi, esi
  00014	74 08		 je	 SHORT $LN7@operator

; 171  :             p->AddRef();

  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	56		 push	 esi
  00019	ff 50 04	 call	 DWORD PTR [eax+4]
  0001c	8b 17		 mov	 edx, DWORD PTR [edi]
$LN7@operator:

; 177  :         other.p = pTemp;

  0001e	89 37		 mov	 DWORD PTR [edi], esi
  00020	8b c6		 mov	 eax, esi

; 183  :         if (p)

  00022	85 d2		 test	 edx, edx
  00024	74 08		 je	 SHORT $LN14@operator

; 184  :             p->Release();

  00026	8b 02		 mov	 eax, DWORD PTR [edx]
  00028	52		 push	 edx
  00029	ff 50 08	 call	 DWORD PTR [eax+8]
  0002c	8b 07		 mov	 eax, DWORD PTR [edi]
$LN14@operator:

; 330  :         {
; 331  :             CComPtr(lp).Swap(*this);
; 332  :         }
; 333  :         return *this;

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi

; 334  :     }

  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
??4?$CComPtr@UIUnknown@@@ATL@@QAEPAUIUnknown@@PAU2@@Z ENDP ; ATL::CComPtr<IUnknown>::operator=
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?GetProperty@?$CComPtr@UIDispatch@@@ATL@@SAJPAUIDispatch@@JPAUtagVARIANT@@@Z
_TEXT	SEGMENT
_dispparamsNoArgs$ = -16				; size = 16
_pDispatch$ = 8						; size = 4
_dwDispID$ = 12						; size = 4
_pVar$ = 16						; size = 4
?GetProperty@?$CComPtr@UIDispatch@@@ATL@@SAJPAUIDispatch@@JPAUtagVARIANT@@@Z PROC ; ATL::CComPtr<IDispatch>::GetProperty, COMDAT

; 577  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 578  :         ATLASSERT(pDispatch);
; 579  :         ATLASSERT(pVar != NULL);
; 580  :         if (pVar == NULL)

  00006	83 7d 10 00	 cmp	 DWORD PTR _pVar$[ebp], 0
  0000a	75 07		 jne	 SHORT $LN2@GetPropert

; 581  :             return E_POINTER;

  0000c	b8 03 40 00 80	 mov	 eax, -2147467261	; 80004003H

; 589  :                 LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
; 590  :                 &dispparamsNoArgs, pVar, NULL, NULL);
; 591  :     }

  00011	c9		 leave
  00012	c3		 ret	 0
$LN2@GetPropert:

; 582  : 
; 583  :         if (pDispatch == NULL)

  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pDispatch$[ebp]
  00016	85 c9		 test	 ecx, ecx
  00018	75 07		 jne	 SHORT $LN3@GetPropert

; 584  :             return E_INVALIDARG;

  0001a	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H

; 589  :                 LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
; 590  :                 &dispparamsNoArgs, pVar, NULL, NULL);
; 591  :     }

  0001f	c9		 leave
  00020	c3		 ret	 0
$LN3@GetPropert:

; 585  : 
; 586  :         ATLTRACE(atlTraceCOM, 2, _T("CPropertyHelper::GetProperty\n"));
; 587  :         DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
; 588  :         return pDispatch->Invoke(dwDispID, IID_NULL,

  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	33 d2		 xor	 edx, edx
  00025	52		 push	 edx
  00026	52		 push	 edx
  00027	ff 75 10	 push	 DWORD PTR _pVar$[ebp]
  0002a	89 55 f0	 mov	 DWORD PTR _dispparamsNoArgs$[ebp], edx
  0002d	89 55 f4	 mov	 DWORD PTR _dispparamsNoArgs$[ebp+4], edx
  00030	89 55 f8	 mov	 DWORD PTR _dispparamsNoArgs$[ebp+8], edx
  00033	89 55 fc	 mov	 DWORD PTR _dispparamsNoArgs$[ebp+12], edx
  00036	8d 55 f0	 lea	 edx, DWORD PTR _dispparamsNoArgs$[ebp]
  00039	52		 push	 edx
  0003a	6a 02		 push	 2
  0003c	68 00 04 00 00	 push	 1024			; 00000400H
  00041	68 00 00 00 00	 push	 OFFSET _GUID_NULL
  00046	ff 75 0c	 push	 DWORD PTR _dwDispID$[ebp]
  00049	51		 push	 ecx
  0004a	ff 50 18	 call	 DWORD PTR [eax+24]

; 589  :                 LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
; 590  :                 &dispparamsNoArgs, pVar, NULL, NULL);
; 591  :     }

  0004d	c9		 leave
  0004e	c3		 ret	 0
?GetProperty@?$CComPtr@UIDispatch@@@ATL@@SAJPAUIDispatch@@JPAUtagVARIANT@@@Z ENDP ; ATL::CComPtr<IDispatch>::GetProperty
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\unknwnbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\unknwnbase.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?AtlInternalOleLoadFromStream@ATL@@YAJPAUIStream@@ABU_GUID@@PAPAXTClassesAllowedInStream@1@K@Z
_TEXT	SEGMENT
_ppvObj$GSCopy$1$ = -44					; size = 4
_pStm$GSCopy$1$ = -40					; size = 4
_iidInterface$GSCopy$1$ = -36				; size = 4
_i$1$ = -32						; size = 4
_pPersistStm$ = -28					; size = 4
_punkVal$ = -24						; size = 4
_clsid$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_pStm$ = 8						; size = 4
_iidInterface$ = 12					; size = 4
_ppvObj$ = 16						; size = 4
_rgclsidAllowed$ = 20					; size = 4
_cclsidAllowed$ = 24					; size = 4
?AtlInternalOleLoadFromStream@ATL@@YAJPAUIStream@@ABU_GUID@@PAPAXTClassesAllowedInStream@1@K@Z PROC ; ATL::AtlInternalOleLoadFromStream, COMDAT

; 3413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _ppvObj$[ebp]
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _pStm$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _iidInterface$[ebp]
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	8b 7d 14	 mov	 edi, DWORD PTR _rgclsidAllowed$[ebp]

; 3414 :     ATLASSUME(pStm != NULL);
; 3415 :     *ppvObj = NULL;

  0001f	33 f6		 xor	 esi, esi
  00021	89 45 d4	 mov	 DWORD PTR _ppvObj$GSCopy$1$[ebp], eax
  00024	89 30		 mov	 DWORD PTR [eax], esi

; 3416 :     CLSID clsid;
; 3417 : 
; 3418 :     HRESULT hr = ReadClassStm(pStm, &clsid);

  00026	8d 45 ec	 lea	 eax, DWORD PTR _clsid$[ebp]
  00029	50		 push	 eax
  0002a	51		 push	 ecx
  0002b	89 4d d8	 mov	 DWORD PTR _pStm$GSCopy$1$[ebp], ecx
  0002e	89 5d dc	 mov	 DWORD PTR _iidInterface$GSCopy$1$[ebp], ebx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadClassStm@8

; 3419 : 
; 3420 :     if (FAILED(hr))

  00037	85 c0		 test	 eax, eax
  00039	0f 88 d0 00 00
	00		 js	 $LN1@AtlInterna

; 3421 :     {
; 3422 :         return hr;
; 3423 :     }
; 3424 : 
; 3425 :     CComPtr<IUnknown> punkVal;
; 3426 : 
; 3427 :     if (cclsidAllowed != 0)

  0003f	8b 55 18	 mov	 edx, DWORD PTR _cclsidAllowed$[ebp]

; 165  :         p = NULL;

  00042	8b c6		 mov	 eax, esi
  00044	89 45 e8	 mov	 DWORD PTR _punkVal$[ebp], eax

; 3421 :     {
; 3422 :         return hr;
; 3423 :     }
; 3424 : 
; 3425 :     CComPtr<IUnknown> punkVal;
; 3426 : 
; 3427 :     if (cclsidAllowed != 0)

  00047	85 d2		 test	 edx, edx
  00049	74 30		 je	 SHORT $LN12@AtlInterna

; 3428 :     {
; 3429 :         ATLASSUME(rgclsidAllowed.rgclsidAllowed != NULL);
; 3430 :         hr = E_ACCESSDENIED;

  0004b	bb 05 00 07 80	 mov	 ebx, -2147024891	; 80070005H

; 3432 :         for(DWORD i = 0; i < cclsidAllowed; i++)

  00050	89 75 e0	 mov	 DWORD PTR _i$1$[ebp], esi
$LL10@AtlInterna:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00053	8b ce		 mov	 ecx, esi
$LN74@AtlInterna:
  00055	8d 45 ec	 lea	 eax, DWORD PTR _clsid$[ebp]
  00058	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0005b	3b 04 8f	 cmp	 eax, DWORD PTR [edi+ecx*4]
  0005e	75 08		 jne	 SHORT $LN69@AtlInterna
  00060	41		 inc	 ecx
  00061	83 f9 04	 cmp	 ecx, 4
  00064	74 34		 je	 SHORT $LN66@AtlInterna
  00066	eb ed		 jmp	 SHORT $LN74@AtlInterna
$LN69@AtlInterna:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 3432 :         for(DWORD i = 0; i < cclsidAllowed; i++)

  00068	8b 45 e0	 mov	 eax, DWORD PTR _i$1$[ebp]
  0006b	83 c7 10	 add	 edi, 16			; 00000010H
  0006e	40		 inc	 eax
  0006f	89 45 e0	 mov	 DWORD PTR _i$1$[ebp], eax
  00072	3b c2		 cmp	 eax, edx
  00074	72 dd		 jb	 SHORT $LL10@AtlInterna

; 3433 :         {
; 3434 :             if (IsEqualCLSID(clsid, rgclsidAllowed.rgclsidAllowed[i]))

  00076	e9 92 00 00 00	 jmp	 $LN58@AtlInterna
$LN12@AtlInterna:

; 3435 :             {
; 3436 :                 hr = S_OK;
; 3437 :                 break;
; 3438 :             }
; 3439 :         }
; 3440 :     }
; 3441 :     else if (rgclsidAllowed.pfnClsidAllowed != NULL)

  0007b	85 ff		 test	 edi, edi
  0007d	74 17		 je	 SHORT $LN67@AtlInterna

; 3442 :     {
; 3443 :         hr = rgclsidAllowed.pfnClsidAllowed(clsid, iidInterface, reinterpret_cast<void**>(&punkVal));

  0007f	8d 45 e8	 lea	 eax, DWORD PTR _punkVal$[ebp]
  00082	50		 push	 eax
  00083	8d 45 ec	 lea	 eax, DWORD PTR _clsid$[ebp]
  00086	53		 push	 ebx
  00087	50		 push	 eax
  00088	ff d7		 call	 edi
  0008a	8b d8		 mov	 ebx, eax
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3444 :     }
; 3445 : 
; 3446 :     if (FAILED(hr))

  0008f	85 db		 test	 ebx, ebx
  00091	78 6d		 js	 SHORT $LN73@AtlInterna
  00093	8b 45 e8	 mov	 eax, DWORD PTR _punkVal$[ebp]
$LN67@AtlInterna:

; 223  :         return p == pT;

  00096	85 c0		 test	 eax, eax

; 3447 :     {
; 3448 :         return hr;
; 3449 :     }
; 3450 : 
; 3451 :     if (punkVal == NULL)

  00098	75 20		 jne	 SHORT $LN18@AtlInterna
$LN66@AtlInterna:

; 3452 :     {
; 3453 :         hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, iidInterface, reinterpret_cast<void**>(&punkVal));

  0009a	8d 45 e8	 lea	 eax, DWORD PTR _punkVal$[ebp]
  0009d	50		 push	 eax
  0009e	ff 75 dc	 push	 DWORD PTR _iidInterface$GSCopy$1$[ebp]
  000a1	8d 45 ec	 lea	 eax, DWORD PTR _clsid$[ebp]
  000a4	68 15 04 00 00	 push	 1045			; 00000415H
  000a9	56		 push	 esi
  000aa	50		 push	 eax
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
  000b1	8b d8		 mov	 ebx, eax

; 3454 :         if (FAILED(hr))

  000b3	85 db		 test	 ebx, ebx
  000b5	78 49		 js	 SHORT $LN73@AtlInterna
  000b7	8b 45 e8	 mov	 eax, DWORD PTR _punkVal$[ebp]
$LN18@AtlInterna:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\unknwnbase.h

; 130  :                 return QueryInterface(__uuidof(Q), (void **)pp);

  000ba	8d 55 e4	 lea	 edx, DWORD PTR _pPersistStm$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 165  :         p = NULL;

  000bd	89 75 e4	 mov	 DWORD PTR _pPersistStm$[ebp], esi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\um\unknwnbase.h

; 130  :                 return QueryInterface(__uuidof(Q), (void **)pp);

  000c0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c2	52		 push	 edx
  000c3	68 00 00 00 00	 push	 OFFSET __GUID_00000109_0000_0000_c000_000000000046
  000c8	50		 push	 eax
  000c9	ff 11		 call	 DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 3461 :     hr = punkVal->QueryInterface(&pPersistStm);

  000cb	8b d8		 mov	 ebx, eax

; 3462 : 
; 3463 :     if (SUCCEEDED(hr))

  000cd	85 db		 test	 ebx, ebx
  000cf	78 1f		 js	 SHORT $LN72@AtlInterna

; 3464 :     {
; 3465 :         hr = pPersistStm->Load(pStm);

  000d1	8b 45 e4	 mov	 eax, DWORD PTR _pPersistStm$[ebp]
  000d4	ff 75 d8	 push	 DWORD PTR _pStm$GSCopy$1$[ebp]
  000d7	50		 push	 eax
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	ff 51 14	 call	 DWORD PTR [ecx+20]
  000dd	8b d8		 mov	 ebx, eax

; 3466 : 
; 3467 :         if (SUCCEEDED(hr))

  000df	85 db		 test	 ebx, ebx
  000e1	78 0d		 js	 SHORT $LN72@AtlInterna

; 3468 :         {
; 3469 :             *ppvObj = punkVal.Detach();

  000e3	8b 4d d4	 mov	 ecx, DWORD PTR _ppvObj$GSCopy$1$[ebp]

; 255  :         T* pt = p;

  000e6	8b 45 e8	 mov	 eax, DWORD PTR _punkVal$[ebp]

; 256  :         p = NULL;

  000e9	89 75 e8	 mov	 DWORD PTR _punkVal$[ebp], esi

; 3468 :         {
; 3469 :             *ppvObj = punkVal.Detach();

  000ec	89 01		 mov	 DWORD PTR [ecx], eax
  000ee	eb 03		 jmp	 SHORT $LN20@AtlInterna
$LN72@AtlInterna:

; 3466 : 
; 3467 :         if (SUCCEEDED(hr))

  000f0	8b 75 e8	 mov	 esi, DWORD PTR _punkVal$[ebp]
$LN20@AtlInterna:

; 183  :         if (p)

  000f3	8b 45 e4	 mov	 eax, DWORD PTR _pPersistStm$[ebp]
  000f6	85 c0		 test	 eax, eax
  000f8	74 09		 je	 SHORT $LN53@AtlInterna

; 184  :             p->Release();

  000fa	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fc	50		 push	 eax
  000fd	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN73@AtlInterna:

; 183  :         if (p)

  00100	8b 75 e8	 mov	 esi, DWORD PTR _punkVal$[ebp]
$LN53@AtlInterna:
  00103	85 f6		 test	 esi, esi
  00105	74 06		 je	 SHORT $LN58@AtlInterna

; 184  :             p->Release();

  00107	8b 06		 mov	 eax, DWORD PTR [esi]
  00109	56		 push	 esi
  0010a	ff 50 08	 call	 DWORD PTR [eax+8]
$LN58@AtlInterna:

; 3470 :         }
; 3471 :     }
; 3472 : 
; 3473 :     return hr;

  0010d	8b c3		 mov	 eax, ebx
$LN1@AtlInterna:

; 3474 : }

  0010f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	33 cd		 xor	 ecx, ebp
  00116	5b		 pop	 ebx
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	c9		 leave
  0011d	c3		 ret	 0
?AtlInternalOleLoadFromStream@ATL@@YAJPAUIStream@@ABU_GUID@@PAPAXTClassesAllowedInStream@1@K@Z ENDP ; ATL::AtlInternalOleLoadFromStream
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?AtlComQIPtrAssign2@ATL@@YAXPAPAUIUnknown@@PAU2@ABU_GUID@@@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_lp$ = 12						; size = 4
_riid$ = 16						; size = 4
?AtlComQIPtrAssign2@ATL@@YAXPAPAUIUnknown@@PAU2@ABU_GUID@@@Z PROC ; ATL::AtlComQIPtrAssign2, COMDAT

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   :     IUnknown* pTemp = *pp; // takes ownership
; 57   : 
; 58   :     if (lp == NULL || FAILED(lp->QueryInterface(riid, (void**)pp)))

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _lp$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR _pp$[ebp]
  0000b	8b 37		 mov	 esi, DWORD PTR [edi]
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 0d		 je	 SHORT $LN3@AtlComQIPt
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	57		 push	 edi
  00014	ff 75 10	 push	 DWORD PTR _riid$[ebp]
  00017	51		 push	 ecx
  00018	ff 10		 call	 DWORD PTR [eax]
  0001a	85 c0		 test	 eax, eax
  0001c	79 03		 jns	 SHORT $LN2@AtlComQIPt
$LN3@AtlComQIPt:

; 59   :         *pp = NULL;

  0001e	83 27 00	 and	 DWORD PTR [edi], 0
$LN2@AtlComQIPt:

; 60   : 
; 61   :     if (pTemp)

  00021	85 f6		 test	 esi, esi
  00023	74 06		 je	 SHORT $LN4@AtlComQIPt

; 62   :         pTemp->Release();

  00025	8b 06		 mov	 eax, DWORD PTR [esi]
  00027	56		 push	 esi
  00028	ff 50 08	 call	 DWORD PTR [eax+8]
$LN4@AtlComQIPt:

; 63   : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?AtlComQIPtrAssign2@ATL@@YAXPAPAUIUnknown@@PAU2@ABU_GUID@@@Z ENDP ; ATL::AtlComQIPtrAssign2
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\winerror.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?AtlHresultFromWin32@ATL@@YAJK@Z
_TEXT	SEGMENT
_nError$ = 8						; size = 4
?AtlHresultFromWin32@ATL@@YAJK@Z PROC			; ATL::AtlHresultFromWin32, COMDAT

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\winerror.h

; 29051: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _nError$[ebp]
  00006	0f b7 c1	 movzx	 eax, cx
  00009	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
  0000e	85 c9		 test	 ecx, ecx
  00010	0f 4e c1	 cmovle	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 46   : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?AtlHresultFromWin32@ATL@@YAJK@Z ENDP			; ATL::AtlHresultFromWin32
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\winerror.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h
;	COMDAT ?AtlHresultFromLastError@ATL@@YAJXZ
_TEXT	SEGMENT
?AtlHresultFromLastError@ATL@@YAJXZ PROC		; ATL::AtlHresultFromLastError, COMDAT

; 37   :     DWORD dwErr = ::GetLastError();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\winerror.h

; 29051: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00006	0f b7 c8	 movzx	 ecx, ax
  00009	81 c9 00 00 07
	80		 or	 ecx, -2147024896	; 80070000H
  0000f	85 c0		 test	 eax, eax
  00011	0f 4e c8	 cmovle	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcomcli.h

; 38   :     return HRESULT_FROM_WIN32(dwErr);

  00014	8b c1		 mov	 eax, ecx

; 39   : }

  00016	c3		 ret	 0
?AtlHresultFromLastError@ATL@@YAJXZ ENDP		; ATL::AtlHresultFromLastError
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp
;	COMDAT _DllUnregisterServer@0
_TEXT	SEGMENT
_DllUnregisterServer@0 PROC				; COMDAT

; 91   :     return _Module.UnregisterServer(TRUE);

  00000	6a 00		 push	 0
  00002	6a 01		 push	 1
  00004	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Module@@3VCComModule@ATL@@A ; _Module
  00009	e8 00 00 00 00	 call	 ?UnregisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CComModule::UnregisterServer

; 92   : }

  0000e	c3		 ret	 0
_DllUnregisterServer@0 ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp
;	COMDAT _DllRegisterServer@0
_TEXT	SEGMENT
_DllRegisterServer@0 PROC				; COMDAT

; 82   :     // registers object, typelib and all interfaces in typelib
; 83   :     return _Module.RegisterServer(TRUE);

  00000	6a 00		 push	 0
  00002	6a 01		 push	 1
  00004	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Module@@3VCComModule@ATL@@A ; _Module
  00009	e8 00 00 00 00	 call	 ?RegisterServer@CComModule@ATL@@QAEJHPBU_GUID@@@Z ; ATL::CComModule::RegisterServer

; 84   : }

  0000e	c3		 ret	 0
_DllRegisterServer@0 ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwinverapi.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\winerror.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT
?Init@CComCriticalSection@ATL@@QAEJXZ PROC		; ATL::CComCriticalSection::Init, COMDAT
; _this$ = ecx

; 143  : 	{

  00000	56		 push	 esi

; 144  : 		HRESULT hRes = S_OK;

  00001	33 f6		 xor	 esi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwinverapi.h

; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00003	56		 push	 esi
  00004	56		 push	 esi
  00005	51		 push	 ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 145  : 		if (!_AtlInitializeCriticalSectionEx(&m_sec, 0, 0))

  0000c	85 c0		 test	 eax, eax
  0000e	75 14		 jne	 SHORT $LN2@Init

; 146  : 		{
; 147  : 			hRes = HRESULT_FROM_WIN32(GetLastError());

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\winerror.h

; 29051: FORCEINLINE _Translates_Win32_to_HRESULT_(x) HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00016	0f b7 f0	 movzx	 esi, ax
  00019	81 ce 00 00 07
	80		 or	 esi, -2147024896	; 80070000H
  0001f	85 c0		 test	 eax, eax
  00021	0f 4e f0	 cmovle	 esi, eax
$LN2@Init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlcore.h

; 150  : 		return hRes;

  00024	8b c6		 mov	 eax, esi
  00026	5e		 pop	 esi

; 151  : 	}

  00027	c3		 ret	 0
?Init@CComCriticalSection@ATL@@QAEJXZ ENDP		; ATL::CComCriticalSection::Init
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlwinverapi.h
;	COMDAT ?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z
_TEXT	SEGMENT
_lpCriticalSection$ = 8					; size = 4
_dwSpinCount$ = 12					; size = 4
_Flags$ = 16						; size = 4
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z PROC ; ATL::_AtlInitializeCriticalSectionEx, COMDAT

; 727  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 728  : #if (NTDDI_VERSION >= NTDDI_VISTA) && !defined(_USING_V110_SDK71_) && !defined(_ATL_XP_TARGETING)
; 729  : 	// InitializeCriticalSectionEx is available in Vista or later, desktop or store apps
; 730  : 	return ::InitializeCriticalSectionEx(lpCriticalSection, dwSpinCount, Flags);

  00003	ff 75 10	 push	 DWORD PTR _Flags$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _dwSpinCount$[ebp]
  00009	ff 75 08	 push	 DWORD PTR _lpCriticalSection$[ebp]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSectionEx@12

; 731  : #else
; 732  : 	UNREFERENCED_PARAMETER(Flags);
; 733  : 
; 734  : 	// ...otherwise fall back to using InitializeCriticalSectionAndSpinCount.
; 735  : 	return ::InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
; 736  : #endif
; 737  : }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_AtlInitializeCriticalSectionEx@ATL@@YAHPAU_RTL_CRITICAL_SECTION@@KK@Z ENDP ; ATL::_AtlInitializeCriticalSectionEx
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
;	COMDAT ?wcscpy_s@Checked@ATL@@YAXPA_WIPB_W@Z
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S1max$ = 12						; size = 4
__S2$ = 16						; size = 4
?wcscpy_s@Checked@ATL@@YAXPA_WIPB_W@Z PROC		; ATL::Checked::wcscpy_s, COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 103  : 	ATLMFC_CRT_ERRORCHECK(::wcscpy_s(_S1, _S1max, _S2));

  00003	ff 75 10	 push	 DWORD PTR __S2$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __S1max$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __S1$[ebp]
  0000c	e8 00 00 00 00	 call	 _wcscpy_s
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  00017	83 c4 10	 add	 esp, 16			; 00000010H

; 104  : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?wcscpy_s@Checked@ATL@@YAXPA_WIPB_W@Z ENDP		; ATL::Checked::wcscpy_s
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
;	COMDAT ?AtlCrtErrorCheck@ATL@@YAHH@Z
_TEXT	SEGMENT
_nError$ = 8						; size = 4
?AtlCrtErrorCheck@ATL@@YAHH@Z PROC			; ATL::AtlCrtErrorCheck, COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 32   : 	switch(nError)

  00003	8b 45 08	 mov	 eax, DWORD PTR _nError$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 24		 je	 SHORT $LN8@AtlCrtErro
  0000a	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0000d	74 18		 je	 SHORT $LN4@AtlCrtErro
  0000f	83 f8 16	 cmp	 eax, 22			; 00000016H
  00012	74 0c		 je	 SHORT $LN5@AtlCrtErro
  00014	83 f8 22	 cmp	 eax, 34			; 00000022H
  00017	74 07		 je	 SHORT $LN5@AtlCrtErro
  00019	83 f8 50	 cmp	 eax, 80			; 00000050H
  0001c	75 12		 jne	 SHORT $LN12@AtlCrtErro
  0001e	eb 0e		 jmp	 SHORT $LN8@AtlCrtErro
$LN5@AtlCrtErro:

; 36   : 		break;
; 37   : 	case EINVAL:
; 38   : 	case ERANGE:
; 39   : 		AtlThrow(E_INVALIDARG);

  00020	68 57 00 07 80	 push	 -2147024809		; 80070057H
  00025	eb 0e		 jmp	 SHORT $LN10@AtlCrtErro
$LN4@AtlCrtErro:

; 33   : 	{
; 34   : 	case ENOMEM:
; 35   : 		AtlThrow(E_OUTOFMEMORY);

  00027	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0002c	eb 07		 jmp	 SHORT $LN10@AtlCrtErro
$LN8@AtlCrtErro:

; 46   : 		break;
; 47   : 	}
; 48   : 	return nError;
; 49   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN12@AtlCrtErro:

; 40   : 		break;
; 41   : 	case 0:
; 42   : 	case STRUNCATE:
; 43   : 		break;
; 44   : 	default:
; 45   : 		AtlThrow(E_FAIL);

  00030	68 05 40 00 80	 push	 -2147467259		; 80004005H
$LN10@AtlCrtErro:

; 46   : 		break;
; 47   : 	}
; 48   : 	return nError;
; 49   : }

  00035	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN9@AtlCrtErro:
  0003a	cc		 int	 3
?AtlCrtErrorCheck@ATL@@YAHH@Z ENDP			; ATL::AtlCrtErrorCheck
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	ff 75 0c	 push	 DWORD PTR _dwExceptionFlags$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _dwExceptionCode$[ebp]
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16

; 32   : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 678  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 679  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(::ATL::AtlAddThrow(nRequestedSize, static_cast<SIZE_T>(sizeof(CAtlSafeAllocBufferNode))));

  00004	6a 08		 push	 8
  00006	ff 75 08	 push	 DWORD PTR _nRequestedSize$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??$AtlAddThrow@K@ATL@@YAKKK@Z ; ATL::AtlAddThrow<unsigned long>

; 262  : 		return malloc(nBytes);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 _malloc

; 679  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(::ATL::AtlAddThrow(nRequestedSize, static_cast<SIZE_T>(sizeof(CAtlSafeAllocBufferNode))));

  00016	8b c8		 mov	 ecx, eax

; 262  : 		return malloc(nBytes);

  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 680  : 		if (p == NULL)

  0001b	85 c9		 test	 ecx, ecx
  0001d	74 09		 je	 SHORT $LN1@Allocate
$LN2@Allocate:

; 681  : 			return NULL;
; 682  : 
; 683  : 		// Add buffer to the list
; 684  : 		p->m_pNext = m_pHead;

  0001f	8b 06		 mov	 eax, DWORD PTR [esi]
  00021	89 01		 mov	 DWORD PTR [ecx], eax

; 685  : 		m_pHead = p;
; 686  : 
; 687  : 		return p->GetData();

  00023	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]
  00026	89 0e		 mov	 DWORD PTR [esi], ecx
$LN1@Allocate:
  00028	5e		 pop	 esi

; 688  : 	}

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlconv.h
;	COMDAT ?ocscpy_s@@YA_NPA_WIPB_W@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_maxSize$ = 12						; size = 4
_src$ = 16						; size = 4
?ocscpy_s@@YA_NPA_WIPB_W@Z PROC				; ocscpy_s, COMDAT

; 745  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 732  : 	if (x == NULL)

  00003	8b 55 10	 mov	 edx, DWORD PTR _src$[ebp]
  00006	85 d2		 test	 edx, edx
  00008	75 04		 jne	 SHORT $LN4@ocscpy_s

; 733  : 	{
; 734  : 		return 0;

  0000a	33 c9		 xor	 ecx, ecx
  0000c	eb 1a		 jmp	 SHORT $LN3@ocscpy_s
$LN4@ocscpy_s:

; 735  : 	}
; 736  : 
; 737  : 	return static_cast<int>(wcslen(x));

  0000e	8b ca		 mov	 ecx, edx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	33 ff		 xor	 edi, edi
  00014	8d 71 02	 lea	 esi, DWORD PTR [ecx+2]
$LL6@ocscpy_s:
  00017	66 8b 01	 mov	 ax, WORD PTR [ecx]
  0001a	83 c1 02	 add	 ecx, 2
  0001d	66 3b c7	 cmp	 ax, di
  00020	75 f5		 jne	 SHORT $LL6@ocscpy_s
  00022	2b ce		 sub	 ecx, esi
  00024	5f		 pop	 edi
  00025	d1 f9		 sar	 ecx, 1
  00027	5e		 pop	 esi
$LN3@ocscpy_s:

; 746  : 	return 0 == memcpy_s(dest, maxSize*sizeof(WCHAR), src, (ocslen(src)+1)*sizeof(WCHAR));

  00028	8d 04 4d 02 00
	00 00		 lea	 eax, DWORD PTR [ecx*2+2]
  0002f	50		 push	 eax
  00030	8b 45 0c	 mov	 eax, DWORD PTR _maxSize$[ebp]
  00033	52		 push	 edx
  00034	03 c0		 add	 eax, eax
  00036	50		 push	 eax
  00037	ff 75 08	 push	 DWORD PTR _dest$[ebp]
  0003a	e8 00 00 00 00	 call	 _memcpy_s
  0003f	83 c4 10	 add	 esp, 16			; 00000010H
  00042	f7 d8		 neg	 eax
  00044	1a c0		 sbb	 al, al
  00046	fe c0		 inc	 al

; 747  : }

  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
?ocscpy_s@@YA_NPA_WIPB_W@Z ENDP				; ocscpy_s
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlAdd@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_ptResult$ = 8						; size = 4
_tLeft$ = 12						; size = 4
_tRight$ = 16						; size = 4
??$AtlAdd@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlAdd<unsigned long>, COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 85   : 	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _tLeft$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	8b 55 10	 mov	 edx, DWORD PTR _tRight$[ebp]
  0000b	f7 d0		 not	 eax
  0000d	3b c2		 cmp	 eax, edx
  0000f	73 07		 jae	 SHORT $LN2@AtlAdd

; 86   : 	{
; 87   : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  00011	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H

; 91   : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
$LN2@AtlAdd:

; 88   : 	}
; 89   : 	*ptResult= tLeft + tRight;

  00018	8b 45 08	 mov	 eax, DWORD PTR _ptResult$[ebp]
  0001b	03 ca		 add	 ecx, edx
  0001d	89 08		 mov	 DWORD PTR [eax], ecx

; 90   : 	return S_OK;

  0001f	33 c0		 xor	 eax, eax

; 91   : }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??$AtlAdd@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlAdd<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
_size$2 = -36						; size = 4
_bStackAvailable$ = -29					; size = 1
__$ArrayPad$ = -28					; size = 4
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 617  : {

  00000	6a 14		 push	 20			; 00000014H
  00002	68 00 00 00 00	 push	 OFFSET __sehtable$?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
  00007	e8 00 00 00 00	 call	 __SEH_prolog4_GS

; 618  :     bool bStackAvailable = true;

  0000c	b3 01		 mov	 bl, 1

; 619  : 
; 620  :     __try

  0000e	83 65 fc 00	 and	 DWORD PTR __$SEHRec$[ebp+20], 0

; 621  :     {
; 622  : 		SIZE_T size=0;

  00012	83 65 dc 00	 and	 DWORD PTR _size$2[ebp], 0

; 623  : 		HRESULT hrAdd=::ATL::AtlAdd(&size, Size, static_cast<SIZE_T>(_ATL_STACK_MARGIN));

  00016	68 00 20 00 00	 push	 8192			; 00002000H
  0001b	ff 75 08	 push	 DWORD PTR _Size$[ebp]
  0001e	8d 45 dc	 lea	 eax, DWORD PTR _size$2[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$AtlAdd@K@ATL@@YAJPAKKK@Z ; ATL::AtlAdd<unsigned long>
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 624  : 		if(FAILED(hrAdd))

  0002a	85 c0		 test	 eax, eax
  0002c	79 07		 jns	 SHORT $LN3@AtlVerifyS

; 625  : 		{
; 626  : 			ATLASSERT(FALSE);
; 627  : 			bStackAvailable = false;

  0002e	32 db		 xor	 bl, bl
  00030	88 5d e3	 mov	 BYTE PTR _bStackAvailable$[ebp], bl

; 628  : 		}

  00033	eb 2d		 jmp	 SHORT $LN4@AtlVerifyS
$LN3@AtlVerifyS:

; 629  : 		else
; 630  : 		{
; 631  : 			PVOID p = _alloca(size);

  00035	8b 45 dc	 mov	 eax, DWORD PTR _size$2[ebp]
  00038	e8 00 00 00 00	 call	 __alloca_probe_16
  0003d	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 632  : 			(p);
; 633  : 		}
; 634  :     }

  00040	eb 20		 jmp	 SHORT $LN4@AtlVerifyS
$LN7@AtlVerifyS:
$LN13@AtlVerifyS:

; 635  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?

  00042	8b 45 ec	 mov	 eax, DWORD PTR __$SEHRec$[ebp+4]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	33 c9		 xor	 ecx, ecx
  00049	81 38 fd 00 00
	c0		 cmp	 DWORD PTR [eax], -1073741571 ; c00000fdH
  0004f	0f 94 c1	 sete	 cl
  00052	8b c1		 mov	 eax, ecx
$LN11@AtlVerifyS:
$LN9@AtlVerifyS:
  00054	c3		 ret	 0
$LN8@AtlVerifyS:
  00055	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 636  :                    EXCEPTION_EXECUTE_HANDLER :
; 637  :                    EXCEPTION_CONTINUE_SEARCH)
; 638  :     {
; 639  :         bStackAvailable = false;

  00058	32 db		 xor	 bl, bl
  0005a	88 5d e3	 mov	 BYTE PTR _bStackAvailable$[ebp], bl

; 640  :         _resetstkoflw();

  0005d	e8 00 00 00 00	 call	 __resetstkoflw
$LN4@AtlVerifyS:

; 641  :     }
; 642  :     return bStackAvailable;

  00062	c7 45 fc fe ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -2 ; fffffffeH
  00069	8a c3		 mov	 al, bl

; 643  : }

  0006b	8d 65 cc	 lea	 esp, DWORD PTR [ebp-52]
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00071	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00078	59		 pop	 ecx
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx
  0007c	c9		 leave
  0007d	c3		 ret	 0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlchecked.h
;	COMDAT ?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S1max$ = 12						; size = 4
__S2$ = 16						; size = 4
__N$ = 20						; size = 4
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z PROC		; ATL::Checked::memcpy_s, COMDAT

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 69   : 	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));

  00003	ff 75 14	 push	 DWORD PTR __N$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __S2$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __S1max$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __S1$[ebp]
  0000f	e8 00 00 00 00	 call	 _memcpy_s
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AtlCrtErrorCheck@ATL@@YAHH@Z ; ATL::AtlCrtErrorCheck
  0001a	83 c4 14	 add	 esp, 20			; 00000014H

; 70   : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?memcpy_s@Checked@ATL@@YAXPAXIPBXI@Z ENDP		; ATL::Checked::memcpy_s
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z
_TEXT	SEGMENT
_nBytes$ = -4						; size = 4
_pvMemory$ = 8						; size = 4
_nCount$ = 12						; size = 4
_nSize$ = 16						; size = 4
?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z PROC		; ATL::AtlCoTaskMemRecalloc, COMDAT

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 221  : 	HRESULT hr;
; 222  : 	ULONG nBytes=0;
; 223  : 	if( FAILED(hr=::ATL::AtlMultiply(&nBytes, nCount, nSize)))

  00004	ff 75 10	 push	 DWORD PTR _nSize$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR _nBytes$[ebp], 0
  0000b	8d 45 fc	 lea	 eax, DWORD PTR _nBytes$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR _nCount$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$AtlMultiply@K@ATL@@YAJPAKKK@Z ; ATL::AtlMultiply<unsigned long>
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	85 c0		 test	 eax, eax
  0001c	79 04		 jns	 SHORT $LN2@AtlCoTaskM

; 224  : 	{
; 225  : 		return NULL;

  0001e	33 c0		 xor	 eax, eax

; 228  : }

  00020	c9		 leave
  00021	c3		 ret	 0
$LN2@AtlCoTaskM:

; 226  : 	}
; 227  : 	return ::CoTaskMemRealloc(pvMemory, nBytes);

  00022	ff 75 fc	 push	 DWORD PTR _nBytes$[ebp]
  00025	ff 75 08	 push	 DWORD PTR _pvMemory$[ebp]
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemRealloc@8

; 228  : }

  0002e	c9		 leave
  0002f	c3		 ret	 0
?AtlCoTaskMemRecalloc@ATL@@YAPAXPAXKK@Z ENDP		; ATL::AtlCoTaskMemRecalloc
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z
_TEXT	SEGMENT
_nBytes$ = -4						; size = 4
_nCount$ = 8						; size = 4
_nSize$ = 12						; size = 4
?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z PROC			; ATL::AtlCoTaskMemCAlloc, COMDAT

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 207  : 	HRESULT hr;
; 208  : 	ULONG nBytes=0;
; 209  : 	if( FAILED(hr=::ATL::AtlMultiply(&nBytes, nCount, nSize)))

  00004	ff 75 0c	 push	 DWORD PTR _nSize$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR _nBytes$[ebp], 0
  0000b	8d 45 fc	 lea	 eax, DWORD PTR _nBytes$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR _nCount$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$AtlMultiply@K@ATL@@YAJPAKKK@Z ; ATL::AtlMultiply<unsigned long>
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	85 c0		 test	 eax, eax
  0001c	79 04		 jns	 SHORT $LN2@AtlCoTaskM

; 210  : 	{
; 211  : 		return NULL;

  0001e	33 c0		 xor	 eax, eax

; 214  : }

  00020	c9		 leave
  00021	c3		 ret	 0
$LN2@AtlCoTaskM:

; 212  : 	}
; 213  : 	return ::CoTaskMemAlloc(nBytes);

  00022	ff 75 fc	 push	 DWORD PTR _nBytes$[ebp]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoTaskMemAlloc@4

; 214  : }

  0002b	c9		 leave
  0002c	c3		 ret	 0
?AtlCoTaskMemCAlloc@ATL@@YAPAXKK@Z ENDP			; ATL::AtlCoTaskMemCAlloc
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@K@ATL@@YAJPAKKK@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@K@ATL@@YAJPAKKK@Z PROC			; ATL::AtlMultiply<unsigned long>, COMDAT

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 166  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00006	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]

; 167  : 	if(i64Result>ULONG_MAX)

  00009	85 d2		 test	 edx, edx
  0000b	75 0e		 jne	 SHORT $LN6@AtlMultipl
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 09		 ja	 SHORT $LN6@AtlMultipl

; 170  : 	}
; 171  : 	*piResult=static_cast<unsigned long>(i64Result);

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 172  : 	return S_OK;

  00017	33 c0		 xor	 eax, eax

; 173  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN6@AtlMultipl:

; 168  : 	{
; 169  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001b	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H

; 173  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$AtlMultiply@K@ATL@@YAJPAKKK@Z ENDP			; ATL::AtlMultiply<unsigned long>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00006	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]

; 137  : 	if(i64Result>UINT_MAX)

  00009	85 d2		 test	 edx, edx
  0000b	75 0e		 jne	 SHORT $LN6@AtlMultipl
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 09		 ja	 SHORT $LN6@AtlMultipl

; 140  : 	}
; 141  : 	*piResult=static_cast<unsigned int>(i64Result);

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 142  : 	return S_OK;

  00017	33 c0		 xor	 eax, eax

; 143  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN6@AtlMultipl:

; 138  : 	{
; 139  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001b	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H

; 143  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@H@ATL@@YAJPAHHH@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@H@ATL@@YAJPAHHH@Z PROC			; ATL::AtlMultiply<int>, COMDAT

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 121  : 	__int64 i64Result=static_cast<__int64>(iLeft) * static_cast<__int64>(iRight);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00006	f7 6d 10	 imul	 DWORD PTR _iRight$[ebp]
  00009	8b c8		 mov	 ecx, eax

; 122  : 	if(i64Result>INT_MAX || i64Result < INT_MIN)

  0000b	85 d2		 test	 edx, edx
  0000d	7f 22		 jg	 SHORT $LN3@AtlMultipl
  0000f	7c 08		 jl	 SHORT $LN7@AtlMultipl
  00011	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00017	77 18		 ja	 SHORT $LN3@AtlMultipl
$LN7@AtlMultipl:
  00019	83 fa ff	 cmp	 edx, -1
  0001c	7c 13		 jl	 SHORT $LN3@AtlMultipl
  0001e	7f 08		 jg	 SHORT $LN8@AtlMultipl
  00020	81 f9 00 00 00
	80		 cmp	 ecx, -2147483648	; 80000000H
  00026	72 09		 jb	 SHORT $LN3@AtlMultipl
$LN8@AtlMultipl:

; 125  : 	}
; 126  : 	*piResult=static_cast<int>(i64Result);

  00028	8b 45 08	 mov	 eax, DWORD PTR _piResult$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 127  : 	return S_OK;

  0002d	33 c0		 xor	 eax, eax

; 128  : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
$LN3@AtlMultipl:

; 123  : 	{
; 124  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  00031	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H

; 128  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$AtlMultiply@H@ATL@@YAJPAHHH@Z ENDP			; ATL::AtlMultiply<int>
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_wstdio.h
;	COMDAT _swprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_swprintf_s PROC					; COMDAT

; 1523 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1524 :             int _Result;
; 1525 :             va_list _ArgList;
; 1526 :             __crt_va_start(_ArgList, _Format);
; 1527 :             _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 __vswprintf_s_l
  00017	83 c4 14	 add	 esp, 20			; 00000014H

; 1528 :             __crt_va_end(_ArgList);
; 1529 :             return _Result;
; 1530 :         }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_swprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_s_l PROC					; COMDAT

; 1256 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1257 :         int const _Result = __stdio_common_vswprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	e8 00 00 00 00	 call	 ___stdio_common_vswprintf_s

; 1258 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1259 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1260 : 
; 1261 :         return _Result < 0 ? -1 : _Result;

  00021	83 c9 ff	 or	 ecx, -1
  00024	83 c4 1c	 add	 esp, 28			; 0000001cH
  00027	85 c0		 test	 eax, eax
  00029	0f 48 c1	 cmovs	 eax, ecx

; 1262 :     }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
__vswprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 96   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 97   : 	ATLASSERT( false );
; 98   : 	DWORD dwExceptionCode;
; 99   : 	switch(hr)
; 100  : 	{
; 101  : 	case E_OUTOFMEMORY:
; 102  : 		dwExceptionCode = STATUS_NO_MEMORY;
; 103  : 		break;
; 104  : 	default:
; 105  : 		dwExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
; 106  : 	}
; 107  : 	_AtlRaiseException((DWORD)dwExceptionCode);

  00003	81 7d 08 0e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  0000a	b8 1d 00 00 c0	 mov	 eax, -1073741795	; c000001dH
  0000f	6a 01		 push	 1
  00011	8d 48 fa	 lea	 ecx, DWORD PTR [eax-6]
  00014	0f 44 c1	 cmove	 eax, ecx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN7@AtlThrowIm:
  0001d	cc		 int	 3
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp
;	COMDAT _DllCanUnloadNow@0
_TEXT	SEGMENT
_DllCanUnloadNow@0 PROC					; COMDAT

; 66   :     return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 08 00 00
	00		 cmp	 DWORD PTR ?_Module@@3VCComModule@ATL@@A+8, eax
  00008	0f 95 c0	 setne	 al

; 67   : }

  0000b	c3		 ret	 0
_DllCanUnloadNow@0 ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Develop\OPOS-CCO\zDeviceMonitor\DeviceMonitor.cpp
;	COMDAT _DllGetClassObject@12
_TEXT	SEGMENT
_rclsid$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppv$ = 16						; size = 4
_DllGetClassObject@12 PROC				; COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 74   :     return _Module.GetClassObject(rclsid, riid, ppv);

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Module@@3VCComModule@ATL@@A ; _Module

; 75   : }

  00008	5d		 pop	 ebp

; 74   :     return _Module.GetClassObject(rclsid, riid, ppv);

  00009	e9 00 00 00 00	 jmp	 ?GetClassObject@CComModule@ATL@@QAEJABU_GUID@@0PAPAX@Z ; ATL::CComModule::GetClassObject
_DllGetClassObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\shared\guiddef.h
;	COMDAT _InlineIsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_InlineIsEqualGUID PROC					; COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 152  :    return (

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _rguid1$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR _rguid2$[ebp]
  00009	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000b	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000d	75 1d		 jne	 SHORT $LN3@InlineIsEq
  0000f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00012	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00015	75 15		 jne	 SHORT $LN3@InlineIsEq
  00017	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0001a	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  0001d	75 0d		 jne	 SHORT $LN3@InlineIsEq
  0001f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00022	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00025	75 05		 jne	 SHORT $LN3@InlineIsEq
  00027	33 c0		 xor	 eax, eax
  00029	40		 inc	 eax

; 153  :       ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
; 154  :       ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
; 155  :       ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
; 156  :       ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
; 157  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN3@InlineIsEq:

; 152  :    return (

  0002c	33 c0		 xor	 eax, eax

; 153  :       ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
; 154  :       ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
; 155  :       ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
; 156  :       ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
; 157  : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_InlineIsEqualGUID ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_memcpy_s.h
;	COMDAT _memcpy_s
_TEXT	SEGMENT
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memcpy_s PROC						; COMDAT

; 45   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 46   :         if (_SourceSize == 0)

  00004	8b 75 14	 mov	 esi, DWORD PTR __SourceSize$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 04		 jne	 SHORT $LN2@memcpy_s

; 47   :         {
; 48   :             return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	eb 6d		 jmp	 SHORT $LN1@memcpy_s
$LN2@memcpy_s:

; 49   :         }
; 50   : 
; 51   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  0000f	8b 45 08	 mov	 eax, DWORD PTR __Destination$[ebp]
  00012	85 c0		 test	 eax, eax
  00014	75 13		 jne	 SHORT $LN3@memcpy_s
  00016	e8 00 00 00 00	 call	 __errno
  0001b	6a 16		 push	 22			; 00000016H
  0001d	5e		 pop	 esi
  0001e	89 30		 mov	 DWORD PTR [eax], esi
  00020	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00025	8b c6		 mov	 eax, esi
  00027	eb 53		 jmp	 SHORT $LN1@memcpy_s
$LN3@memcpy_s:
  00029	57		 push	 edi

; 52   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  0002a	8b 7d 10	 mov	 edi, DWORD PTR __Source$[ebp]
  0002d	85 ff		 test	 edi, edi
  0002f	74 14		 je	 SHORT $LN5@memcpy_s
  00031	39 75 0c	 cmp	 DWORD PTR __DestinationSize$[ebp], esi
  00034	72 0f		 jb	 SHORT $LN5@memcpy_s

; 61   :         }
; 62   :         memcpy(_Destination, _Source, _SourceSize);

  00036	56		 push	 esi
  00037	57		 push	 edi
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 _memcpy
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 63   :         return 0;

  00041	33 c0		 xor	 eax, eax
  00043	eb 36		 jmp	 SHORT $LN10@memcpy_s
$LN5@memcpy_s:

; 53   :         {
; 54   :             memset(_Destination, 0, _DestinationSize);

  00045	ff 75 0c	 push	 DWORD PTR __DestinationSize$[ebp]
  00048	6a 00		 push	 0
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _memset
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00053	85 ff		 test	 edi, edi
  00055	75 09		 jne	 SHORT $LN6@memcpy_s
  00057	e8 00 00 00 00	 call	 __errno
  0005c	6a 16		 push	 22			; 00000016H
  0005e	eb 0c		 jmp	 SHORT $LN11@memcpy_s
$LN6@memcpy_s:

; 57   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  00060	39 75 0c	 cmp	 DWORD PTR __DestinationSize$[ebp], esi
  00063	73 13		 jae	 SHORT $LN7@memcpy_s
  00065	e8 00 00 00 00	 call	 __errno
  0006a	6a 22		 push	 34			; 00000022H
$LN11@memcpy_s:

; 55   : 
; 56   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  0006c	5e		 pop	 esi
  0006d	89 30		 mov	 DWORD PTR [eax], esi
  0006f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00074	8b c6		 mov	 eax, esi
  00076	eb 03		 jmp	 SHORT $LN10@memcpy_s
$LN7@memcpy_s:

; 58   : 
; 59   :             // Unreachable, but required to suppress /analyze warnings:
; 60   :             return EINVAL;

  00078	6a 16		 push	 22			; 00000016H
  0007a	58		 pop	 eax
$LN10@memcpy_s:
  0007b	5f		 pop	 edi
$LN1@memcpy_s:
  0007c	5e		 pop	 esi

; 64   :     }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
_memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_I@YGXPAXIIP6EX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_I@YGXPAXIIP6EX0@Z@Z PROC				; `vector destructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR ___s$[ebp]
  00006	56		 push	 esi
  00007	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  0000a	0f af c6	 imul	 eax, esi
  0000d	57		 push	 edi
  0000e	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
  00011	03 f8		 add	 edi, eax
  00013	85 f6		 test	 esi, esi
  00015	74 0d		 je	 SHORT $LN6@vector
$LL2@vector:
  00017	2b 7d 0c	 sub	 edi, DWORD PTR ___s$[ebp]
  0001a	8b cf		 mov	 ecx, edi
  0001c	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001f	83 ee 01	 sub	 esi, 1
  00022	75 f3		 jne	 SHORT $LL2@vector
$LN6@vector:
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5d		 pop	 ebp
  00027	c2 10 00	 ret	 16			; 00000010H
??_I@YGXPAXIIP6EX0@Z@Z ENDP				; `vector destructor iterator'
_TEXT	ENDS
; Function compile flags: /Ogsp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 12		 je	 SHORT $LN6@vector
  0000b	57		 push	 edi
  0000c	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  0000f	8b cf		 mov	 ecx, edi
  00011	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  00014	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  00017	83 ee 01	 sub	 esi, 1
  0001a	75 f3		 jne	 SHORT $LL2@vector
  0001c	5f		 pop	 edi
$LN6@vector:
  0001d	5e		 pop	 esi
  0001e	5d		 pop	 ebp
  0001f	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
