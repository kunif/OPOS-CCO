; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29336.0 

	TITLE	C:\Develop\OPOS-CCO\Common\CWString.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?cw_memcpy@@YGHPADPB_WH@Z			; cw_memcpy
PUBLIC	?cw_memcpy@@YGHPA_WPBDH@Z			; cw_memcpy
PUBLIC	?cw_memcpy@@YGHPADPBDH@Z			; cw_memcpy
PUBLIC	?cw_memcpy@@YGHPA_WPB_WH@Z			; cw_memcpy
PUBLIC	?cw_memset@@YAXPADDH@Z				; cw_memset
PUBLIC	?cw_memset@@YAXPA_W_WH@Z			; cw_memset
PUBLIC	?cw_strlen@@YAHPBD@Z				; cw_strlen
PUBLIC	?cw_strlen@@YAHPB_W@Z				; cw_strlen
PUBLIC	?cw_strcpy@@YAHPADPB_W@Z			; cw_strcpy
PUBLIC	?cw_strcpy@@YAHPA_WPBD@Z			; cw_strcpy
PUBLIC	?cw_strcpy@@YAHPADPBD@Z				; cw_strcpy
PUBLIC	?cw_strcpy@@YAHPA_WPB_W@Z			; cw_strcpy
PUBLIC	?cw_strcat@@YAHPADPB_W@Z			; cw_strcat
PUBLIC	?cw_strcat@@YAHPA_WPBD@Z			; cw_strcat
PUBLIC	?cw_strcat@@YAHPADPBD@Z				; cw_strcat
PUBLIC	?cw_strcat@@YAHPA_WPB_W@Z			; cw_strcat
PUBLIC	?cw_dup@@YGXPBDAAHAAPA_W1@Z			; cw_dup
PUBLIC	?cw_dup@@YGXPB_WAAHAAPAD1@Z			; cw_dup
PUBLIC	?DupChar@_CW@@AAEXXZ				; _CW::DupChar
PUBLIC	?DupWide@_CW@@AAEXXZ				; _CW::DupWide
PUBLIC	?GetCharsMbcs@_CW@@QAEHXZ			; _CW::GetCharsMbcs
PUBLIC	?GetCharsWide@_CW@@QAEHXZ			; _CW::GetCharsWide
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCharsWide@_CW@@QAEHXZ PROC				; _CW::GetCharsWide
; _this$ = ecx

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 439  :     if (m_pWide == (wchar_t*)-1)

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 78 04 ff	 cmp	 DWORD PTR [eax+4], -1
  00015	75 0a		 jne	 SHORT $LN2@GetCharsWi

; 440  :         DupWide();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?DupWide@_CW@@AAEXXZ	; _CW::DupWide
  0001f	eb 1e		 jmp	 SHORT $LN3@GetCharsWi
$LN2@GetCharsWi:

; 441  :     else if ( m_nCharsWide < 0 )

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  00028	7d 15		 jge	 SHORT $LN3@GetCharsWi

; 442  :         m_nCharsWide = cw_strlen( m_pWide );

  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00036	83 c4 04	 add	 esp, 4
  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
$LN3@GetCharsWi:

; 443  :     return m_nCharsWide;

  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]

; 444  : }

  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
?GetCharsWide@_CW@@QAEHXZ ENDP				; _CW::GetCharsWide
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetCharsMbcs@_CW@@QAEHXZ PROC				; _CW::GetCharsMbcs
; _this$ = ecx

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 430  :     if (m_pChar == (char*)-1)

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00014	75 0a		 jne	 SHORT $LN2@GetCharsMb

; 431  :         DupChar();

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?DupChar@_CW@@AAEXXZ	; _CW::DupChar
  0001e	eb 1d		 jmp	 SHORT $LN3@GetCharsMb
$LN2@GetCharsMb:

; 432  :     else if ( m_nChars < 0 )

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00027	7d 14		 jge	 SHORT $LN3@GetCharsMb

; 433  :         m_nChars = cw_strlen( m_pChar );

  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 02		 mov	 eax, DWORD PTR [edx]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00034	83 c4 04	 add	 esp, 4
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN3@GetCharsMb:

; 434  :     return m_nChars;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00040	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 435  : }

  00043	83 c4 04	 add	 esp, 4
  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?GetCharsMbcs@_CW@@QAEHXZ ENDP				; _CW::GetCharsMbcs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DupWide@_CW@@AAEXXZ PROC				; _CW::DupWide
; _this$ = ecx

; 423  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 424  :     cw_dup(m_pChar, m_nChars, m_pWide, m_nCharsWide);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 0c	 add	 eax, 12			; 0000000cH
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 04	 add	 ecx, 4
  0001b	51		 push	 ecx
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	83 c2 08	 add	 edx, 8
  00022	52		 push	 edx
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?cw_dup@@YGXPBDAAHAAPA_W1@Z ; cw_dup

; 425  :     m_nDupFlag = 'w';

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00031	c6 42 10 77	 mov	 BYTE PTR [edx+16], 119	; 00000077H

; 426  : }

  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
?DupWide@_CW@@AAEXXZ ENDP				; _CW::DupWide
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DupChar@_CW@@AAEXXZ PROC				; _CW::DupChar
; _this$ = ecx

; 417  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 418  :     cw_dup(m_pWide, m_nCharsWide, m_pChar, m_nChars);

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 08	 add	 eax, 8
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	51		 push	 ecx
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	83 c2 0c	 add	 edx, 12			; 0000000cH
  0001f	52		 push	 edx
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00026	51		 push	 ecx
  00027	e8 00 00 00 00	 call	 ?cw_dup@@YGXPB_WAAHAAPAD1@Z ; cw_dup

; 419  :     m_nDupFlag = 'c';

  0002c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002f	c6 42 10 63	 mov	 BYTE PTR [edx+16], 99	; 00000063H

; 420  : }

  00033	83 c4 04	 add	 esp, 4
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?DupChar@_CW@@AAEXXZ ENDP				; _CW::DupChar
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcChars$ = 12					; size = 4
_pTarget$ = 16						; size = 4
_nTargetChars$ = 20					; size = 4
?cw_dup@@YGXPB_WAAHAAPAD1@Z PROC			; cw_dup

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 383  :     if ( pSrc == 0 )

  0000b	83 7d 08 00	 cmp	 DWORD PTR _pSrc$[ebp], 0
  0000f	75 1d		 jne	 SHORT $LN2@cw_dup

; 384  :     {
; 385  :         nSrcChars = nTargetChars = 0;

  00011	8b 45 14	 mov	 eax, DWORD PTR _nTargetChars$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSrcChars$[ebp]
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 386  :         pTarget = 0;

  00023	8b 55 10	 mov	 edx, DWORD PTR _pTarget$[ebp]
  00026	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 387  :         return;

  0002c	eb 66		 jmp	 SHORT $LN1@cw_dup
$LN2@cw_dup:

; 388  :     }
; 389  : 
; 390  :     if ( nSrcChars < 0 )

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _nSrcChars$[ebp]
  00031	83 38 00	 cmp	 DWORD PTR [eax], 0
  00034	7d 11		 jge	 SHORT $LN3@cw_dup

; 391  :         nSrcChars = cw_strlen( pSrc );

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  0003f	83 c4 04	 add	 esp, 4
  00042	8b 55 0c	 mov	 edx, DWORD PTR _nSrcChars$[ebp]
  00045	89 02		 mov	 DWORD PTR [edx], eax
$LN3@cw_dup:

; 392  :     /* ==> Implementation one -- minimize memory.
; 393  :     nTargetChars = cw_memcpy( (char*) NULL, pSrc, nSrcChars );
; 394  :         // Determine how many characters are needed.
; 395  :         //   Can't assume one-to-one (some wide chars may need 2 multibyte chars),
; 396  :         //   but don't want to waste a bunch of bytes either.
; 397  :     pTarget = new char[nTargetChars+1];
; 398  :     */
; 399  :     /* ==> Implementation two -- maximize speed, with side effect of allocating up
; 400  :     **      to twice the memory needed (worst case when no multibyte chars needed).
; 401  :     **     Chose this because most converted strings will be short-lived.
; 402  :     */
; 403  :     pTarget = new char[(nSrcChars+1)*2];

  00047	8b 45 0c	 mov	 eax, DWORD PTR _nSrcChars$[ebp]
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	8d 54 09 02	 lea	 edx, DWORD PTR [ecx+ecx+2]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00056	83 c4 04	 add	 esp, 4
  00059	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0005c	8b 45 10	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00062	89 08		 mov	 DWORD PTR [eax], ecx

; 404  :     if (pTarget)

  00064	8b 55 10	 mov	 edx, DWORD PTR _pTarget$[ebp]
  00067	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0006a	74 28		 je	 SHORT $LN1@cw_dup

; 405  :     {
; 406  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  0006c	8b 45 0c	 mov	 eax, DWORD PTR _nSrcChars$[ebp]
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	51		 push	 ecx
  00072	8b 55 08	 mov	 edx, DWORD PTR _pSrc$[ebp]
  00075	52		 push	 edx
  00076	8b 45 10	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00079	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPB_WH@Z ; cw_memcpy
  00081	8b 55 14	 mov	 edx, DWORD PTR _nTargetChars$[ebp]
  00084	89 02		 mov	 DWORD PTR [edx], eax

; 407  :         pTarget[nTargetChars] = 0;

  00086	8b 45 14	 mov	 eax, DWORD PTR _nTargetChars$[ebp]
  00089	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008b	8b 55 10	 mov	 edx, DWORD PTR _pTarget$[ebp]
  0008e	8b 02		 mov	 eax, DWORD PTR [edx]
  00090	c6 04 08 00	 mov	 BYTE PTR [eax+ecx], 0
$LN1@cw_dup:

; 408  :     }
; 409  : }

  00094	83 c4 04	 add	 esp, 4
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 10 00	 ret	 16			; 00000010H
?cw_dup@@YGXPB_WAAHAAPAD1@Z ENDP			; cw_dup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_pSrc$ = 8						; size = 4
_nSrcChars$ = 12					; size = 4
_pTarget$ = 16						; size = 4
_nTargetChars$ = 20					; size = 4
?cw_dup@@YGXPBDAAHAAPA_W1@Z PROC			; cw_dup

; 359  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 360  :     if ( pSrc == 0 )

  0000b	83 7d 08 00	 cmp	 DWORD PTR _pSrc$[ebp], 0
  0000f	75 1d		 jne	 SHORT $LN2@cw_dup

; 361  :     {
; 362  :         nSrcChars = nTargetChars = 0;

  00011	8b 45 14	 mov	 eax, DWORD PTR _nTargetChars$[ebp]
  00014	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _nSrcChars$[ebp]
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 363  :         pTarget = 0;

  00023	8b 55 10	 mov	 edx, DWORD PTR _pTarget$[ebp]
  00026	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 364  :         return;

  0002c	eb 77		 jmp	 SHORT $LN1@cw_dup
$LN2@cw_dup:

; 365  :     }
; 366  : 
; 367  :     if ( nSrcChars < 0 )

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _nSrcChars$[ebp]
  00031	83 38 00	 cmp	 DWORD PTR [eax], 0
  00034	7d 11		 jge	 SHORT $LN3@cw_dup

; 368  :         nSrcChars = cw_strlen( pSrc );

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  0003f	83 c4 04	 add	 esp, 4
  00042	8b 55 0c	 mov	 edx, DWORD PTR _nSrcChars$[ebp]
  00045	89 02		 mov	 DWORD PTR [edx], eax
$LN3@cw_dup:

; 369  :     pTarget = new wchar_t[nSrcChars+1];

  00047	8b 45 0c	 mov	 eax, DWORD PTR _nSrcChars$[ebp]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	83 c0 01	 add	 eax, 1
  0004f	33 c9		 xor	 ecx, ecx
  00051	ba 02 00 00 00	 mov	 edx, 2
  00056	f7 e2		 mul	 edx
  00058	0f 90 c1	 seto	 cl
  0005b	f7 d9		 neg	 ecx
  0005d	0b c8		 or	 ecx, eax
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00065	83 c4 04	 add	 esp, 4
  00068	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0006b	8b 45 10	 mov	 eax, DWORD PTR _pTarget$[ebp]
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 08		 mov	 DWORD PTR [eax], ecx

; 370  :         // We allow one wide char for each multibyte char;
; 371  :         //   this may be too many for some countries, but no harm.
; 372  :     if (pTarget)

  00073	8b 55 10	 mov	 edx, DWORD PTR _pTarget$[ebp]
  00076	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00079	74 2a		 je	 SHORT $LN1@cw_dup

; 373  :     {
; 374  :         nTargetChars = cw_memcpy( pTarget, pSrc, nSrcChars );

  0007b	8b 45 0c	 mov	 eax, DWORD PTR _nSrcChars$[ebp]
  0007e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00080	51		 push	 ecx
  00081	8b 55 08	 mov	 edx, DWORD PTR _pSrc$[ebp]
  00084	52		 push	 edx
  00085	8b 45 10	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00088	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPA_WPBDH@Z ; cw_memcpy
  00090	8b 55 14	 mov	 edx, DWORD PTR _nTargetChars$[ebp]
  00093	89 02		 mov	 DWORD PTR [edx], eax

; 375  :         pTarget[nTargetChars] = 0;

  00095	8b 45 14	 mov	 eax, DWORD PTR _nTargetChars$[ebp]
  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	8b 55 10	 mov	 edx, DWORD PTR _pTarget$[ebp]
  0009d	8b 02		 mov	 eax, DWORD PTR [edx]
  0009f	33 d2		 xor	 edx, edx
  000a1	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
$LN1@cw_dup:

; 376  :     }
; 377  : }

  000a5	83 c4 04	 add	 esp, 4
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 10 00	 ret	 16			; 00000010H
?cw_dup@@YGXPBDAAHAAPA_W1@Z ENDP			; cw_dup
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcat@@YAHPA_WPB_W@Z PROC				; cw_strcat

; 347  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 348  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00003	6a ff		 push	 -1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pszTarget$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00012	83 c4 04	 add	 esp, 4
  00015	8b 55 08	 mov	 edx, DWORD PTR _pszTarget$[ebp]
  00018	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPA_WPB_WH@Z ; cw_memcpy
  00021	83 e8 01	 sub	 eax, 1

; 349  : }       //   Return chars copied (not including NUL).

  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?cw_strcat@@YAHPA_WPB_W@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcat@@YAHPADPBD@Z PROC				; cw_strcat

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 343  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00003	6a ff		 push	 -1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pszTarget$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00012	83 c4 04	 add	 esp, 4
  00015	03 45 08	 add	 eax, DWORD PTR _pszTarget$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPBDH@Z ; cw_memcpy
  0001e	83 e8 01	 sub	 eax, 1

; 344  : }       //   Return chars copied (not including NUL).

  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?cw_strcat@@YAHPADPBD@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcat@@YAHPA_WPBD@Z PROC				; cw_strcat

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 338  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00003	6a ff		 push	 -1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pszTarget$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00012	83 c4 04	 add	 esp, 4
  00015	8b 55 08	 mov	 edx, DWORD PTR _pszTarget$[ebp]
  00018	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPA_WPBDH@Z ; cw_memcpy
  00021	83 e8 01	 sub	 eax, 1

; 339  : }       //   Return chars copied (not including NUL).

  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?cw_strcat@@YAHPA_WPBD@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcat@@YAHPADPB_W@Z PROC				; cw_strcat

; 332  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 333  :     return cw_memcpy(pszTarget + cw_strlen(pszTarget), pszSrc, -1) - 1;

  00003	6a ff		 push	 -1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pszTarget$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00012	83 c4 04	 add	 esp, 4
  00015	03 45 08	 add	 eax, DWORD PTR _pszTarget$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPB_WH@Z ; cw_memcpy
  0001e	83 e8 01	 sub	 eax, 1

; 334  : }       //   Return chars copied (not including NUL).

  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?cw_strcat@@YAHPADPB_W@Z ENDP				; cw_strcat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcpy@@YAHPA_WPB_W@Z PROC				; cw_strcpy

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 323  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00003	6a ff		 push	 -1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pszTarget$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPA_WPB_WH@Z ; cw_memcpy
  00012	83 e8 01	 sub	 eax, 1

; 324  : }

  00015	3b ec		 cmp	 ebp, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?cw_strcpy@@YAHPA_WPB_W@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcpy@@YAHPADPBD@Z PROC				; cw_strcpy

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 318  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00003	6a ff		 push	 -1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pszTarget$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPBDH@Z ; cw_memcpy
  00012	83 e8 01	 sub	 eax, 1

; 319  : }

  00015	3b ec		 cmp	 ebp, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?cw_strcpy@@YAHPADPBD@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcpy@@YAHPA_WPBD@Z PROC				; cw_strcpy

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00003	6a ff		 push	 -1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pszTarget$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPA_WPBDH@Z ; cw_memcpy
  00012	83 e8 01	 sub	 eax, 1

; 314  : }

  00015	3b ec		 cmp	 ebp, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?cw_strcpy@@YAHPA_WPBD@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pszTarget$ = 8						; size = 4
_pszSrc$ = 12						; size = 4
?cw_strcpy@@YAHPADPB_W@Z PROC				; cw_strcpy

; 307  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :     return cw_memcpy(pszTarget, pszSrc, -1) - 1;            //   Return chars copied (not including NUL).

  00003	6a ff		 push	 -1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _pszSrc$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pszTarget$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPB_WH@Z ; cw_memcpy
  00012	83 e8 01	 sub	 eax, 1

; 309  : }

  00015	3b ec		 cmp	 ebp, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?cw_strcpy@@YAHPADPB_W@Z ENDP				; cw_strcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_nCount$ = -4						; size = 4
_pChar$ = 8						; size = 4
?cw_strlen@@YAHPB_W@Z PROC				; cw_strlen

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 126  : #if defined(_M_IX86) || defined(_M_X64)
; 127  :     int nCount = 0;

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nCount$[ebp], 0

; 128  :     if ( pChar && *pChar )

  00012	83 7d 08 00	 cmp	 DWORD PTR _pChar$[ebp], 0
  00016	74 26		 je	 SHORT $LN5@cw_strlen
  00018	8b 45 08	 mov	 eax, DWORD PTR _pChar$[ebp]
  0001b	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0001e	85 c9		 test	 ecx, ecx
  00020	74 1c		 je	 SHORT $LN5@cw_strlen
$LN4@cw_strlen:

; 129  :     {
; 130  :         do nCount++;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _nCount$[ebp]
  00025	83 c2 01	 add	 edx, 1
  00028	89 55 fc	 mov	 DWORD PTR _nCount$[ebp], edx

; 131  :         while (*++pChar);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _pChar$[ebp]
  0002e	83 c0 02	 add	 eax, 2
  00031	89 45 08	 mov	 DWORD PTR _pChar$[ebp], eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _pChar$[ebp]
  00037	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0003a	85 d2		 test	 edx, edx
  0003c	75 e4		 jne	 SHORT $LN4@cw_strlen
$LN5@cw_strlen:

; 132  :     }
; 133  :     return nCount;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _nCount$[ebp]

; 134  : 
; 135  : #else
; 136  :     int nCount = 0;
; 137  :     const char* pNChar = (const char*) pChar;
; 138  :     if ( pNChar && ( pNChar[0] | pNChar[1] ) != 0 )
; 139  :     {
; 140  :         do
; 141  :         {
; 142  :             nCount++;
; 143  :             pNChar += 2;
; 144  :         }
; 145  :         while ( ( pNChar[0] | pNChar[1] ) != 0 );
; 146  :     }
; 147  :     return nCount;
; 148  : #endif
; 149  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?cw_strlen@@YAHPB_W@Z ENDP				; cw_strlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_nCount$ = -4						; size = 4
_pChar$ = 8						; size = 4
?cw_strlen@@YAHPBD@Z PROC				; cw_strlen

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH

; 115  :     int nCount = 0;

  0000b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _nCount$[ebp], 0

; 116  :     if ( pChar && *pChar )

  00012	83 7d 08 00	 cmp	 DWORD PTR _pChar$[ebp], 0
  00016	74 26		 je	 SHORT $LN5@cw_strlen
  00018	8b 45 08	 mov	 eax, DWORD PTR _pChar$[ebp]
  0001b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0001e	85 c9		 test	 ecx, ecx
  00020	74 1c		 je	 SHORT $LN5@cw_strlen
$LN4@cw_strlen:

; 117  :     {
; 118  :         do nCount++;

  00022	8b 55 fc	 mov	 edx, DWORD PTR _nCount$[ebp]
  00025	83 c2 01	 add	 edx, 1
  00028	89 55 fc	 mov	 DWORD PTR _nCount$[ebp], edx

; 119  :         while (*++pChar);

  0002b	8b 45 08	 mov	 eax, DWORD PTR _pChar$[ebp]
  0002e	83 c0 01	 add	 eax, 1
  00031	89 45 08	 mov	 DWORD PTR _pChar$[ebp], eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _pChar$[ebp]
  00037	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0003a	85 d2		 test	 edx, edx
  0003c	75 e4		 jne	 SHORT $LN4@cw_strlen
$LN5@cw_strlen:

; 120  :     }
; 121  :     return nCount;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _nCount$[ebp]

; 122  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?cw_strlen@@YAHPBD@Z ENDP				; cw_strlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_cChar$ = 12						; size = 2
_nCount$ = 16						; size = 4
?cw_memset@@YAXPA_W_WH@Z PROC				; cw_memset

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 80   :     // If Intel x86, resort to assembly...
; 81   : #if defined(_M_IX86)
; 82   :     _asm
; 83   :     {
; 84   :         mov ecx, nCount                 // Get count.

  00004	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]

; 85   :         jcxz L2                         //   If zero, then jump: Nothing to do.

  00007	67 e3 0a	 jcxz	 $L2$3

; 86   : 
; 87   :         mov edi, pTarget                // Get pointer to destination.

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _pTarget$[ebp]

; 88   :         mov ax, cChar                   // Get wide character to set.

  0000d	66 8b 45 0c	 mov	 ax, WORD PTR _cChar$[ebp]

; 89   :         rep stosw                       // Set wide character for ECX times.

  00011	f3 66 ab	 rep	  stosw
$L2$3:

; 90   : 
; 91   :     L2:
; 92   :     }
; 93   : 
; 94   :     // If not Intel or alignment required, then set low and high bytes separately.
; 95   : #else
; 96   :     if ( nCount > 0 )
; 97   :     {
; 98   :         int n = nCount;
; 99   :         char* pCharTarget = (char*) pTarget;
; 100  :         do {
; 101  :             *pCharTarget++ = LOBYTE(cChar);
; 102  :             *pCharTarget++ = HIBYTE(cChar);
; 103  :         } while ( --n );
; 104  :     }
; 105  : #endif
; 106  : }

  00014	5f		 pop	 edi
  00015	3b ec		 cmp	 ebp, esp
  00017	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?cw_memset@@YAXPA_W_WH@Z ENDP				; cw_memset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_cChar$ = 12						; size = 1
_nCount$ = 16						; size = 4
?cw_memset@@YAXPADDH@Z PROC				; cw_memset

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 52   :     // If Intel x86, resort to assembly...
; 53   : #if defined(_M_IX86)
; 54   :     _asm
; 55   :     {
; 56   :         mov ecx, nCount                 // Get count.

  00004	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]

; 57   :         jcxz L2                         //   If zero, then jump: Nothing to do.

  00007	67 e3 08	 jcxz	 $L2$3

; 58   : 
; 59   :         mov edi, pTarget                // Get pointer to destination.

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _pTarget$[ebp]

; 60   :         mov al, cChar                   // Get character to set.

  0000d	8a 45 0c	 mov	 al, BYTE PTR _cChar$[ebp]

; 61   :         rep stosb                       // Set character for ECX times.

  00010	f3 aa		 rep	  stosb
$L2$3:

; 62   : 
; 63   :     L2:
; 64   :     }
; 65   : 
; 66   :     // If not Intel, use tight loop.
; 67   : #else
; 68   :     if ( nCount > 0 )
; 69   :     {
; 70   :         int n = nCount;
; 71   :         do {
; 72   :             *pTarget++ = cChar;
; 73   :         } while ( --n );
; 74   :     }
; 75   : #endif
; 76   : }

  00012	5f		 pop	 edi
  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?cw_memset@@YAXPADDH@Z ENDP				; cw_memset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nCount$ = 16						; size = 4
?cw_memcpy@@YGHPA_WPB_WH@Z PROC				; cw_memcpy

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 295  :     if ( nCount < 0 )

  00003	83 7d 10 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00007	7d 12		 jge	 SHORT $LN2@cw_memcpy

; 296  :         nCount = cw_strlen(pSrc) + 1;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pSrc$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  00012	83 c4 04	 add	 esp, 4
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 10	 mov	 DWORD PTR _nCount$[ebp], eax
$LN2@cw_memcpy:

; 297  :     cw_memcpy( (char*) pTarget, (const char*) pSrc, nCount * sizeof(wchar_t) );

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]
  0001e	d1 e1		 shl	 ecx, 1
  00020	51		 push	 ecx
  00021	8b 55 0c	 mov	 edx, DWORD PTR _pSrc$[ebp]
  00024	52		 push	 edx
  00025	8b 45 08	 mov	 eax, DWORD PTR _pTarget$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ?cw_memcpy@@YGHPADPBDH@Z ; cw_memcpy

; 298  :     return nCount;

  0002e	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]

; 299  : }

  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	5d		 pop	 ebp
  00039	c2 0c 00	 ret	 12			; 0000000cH
?cw_memcpy@@YGHPA_WPB_WH@Z ENDP				; cw_memcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nCount$ = 16						; size = 4
?cw_memcpy@@YGHPADPBDH@Z PROC				; cw_memcpy

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 258  :     if ( nCount < 0 )

  00005	83 7d 10 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00009	7d 12		 jge	 SHORT $LN2@cw_memcpy

; 259  :         nCount = cw_strlen(pSrc) + 1;

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _pSrc$[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  00014	83 c4 04	 add	 esp, 4
  00017	83 c0 01	 add	 eax, 1
  0001a	89 45 10	 mov	 DWORD PTR _nCount$[ebp], eax
$LN2@cw_memcpy:

; 260  :     if ( pTarget && nCount )

  0001d	83 7d 08 00	 cmp	 DWORD PTR _pTarget$[ebp], 0
  00021	74 14		 je	 SHORT $LN3@cw_memcpy
  00023	83 7d 10 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00027	74 0e		 je	 SHORT $LN3@cw_memcpy

; 261  :     {
; 262  :         // If Intel x86, resort to assembly...
; 263  : #if defined(_M_IX86)
; 264  :         _asm
; 265  :         {
; 266  :             mov ecx, nCount                 // Get count.

  00029	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]

; 267  :             jcxz L2                         //   If zero, then jump: Nothing to do.

  0002c	67 e3 08	 jcxz	 $L2$5

; 268  : 
; 269  :             mov esi, pSrc                   // Get pointer to source.

  0002f	8b 75 0c	 mov	 esi, DWORD PTR _pSrc$[ebp]

; 270  :             mov edi, pTarget                // Get pointer to destination.

  00032	8b 7d 08	 mov	 edi, DWORD PTR _pTarget$[ebp]

; 271  :             rep movsb                       // Move characters from ESI to EDI for ECX times.

  00035	f3 a4		 rep	  movsb
$L2$5:
$LN3@cw_memcpy:

; 272  : 
; 273  :         L2:
; 274  :         }
; 275  : 
; 276  :         // If not Intel, use tight loop.
; 277  : #else
; 278  :         int n = nCount;
; 279  :         do {
; 280  :             *pTarget++ = *pSrc++;
; 281  :         } while ( --n );
; 282  : #endif
; 283  :     }
; 284  :     return nCount;

  00037	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]

; 285  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	5d		 pop	 ebp
  00044	c2 0c 00	 ret	 12			; 0000000cH
?cw_memcpy@@YGHPADPBDH@Z ENDP				; cw_memcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nCount$ = 16						; size = 4
?cw_memcpy@@YGHPA_WPBDH@Z PROC				; cw_memcpy

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 163  :     if ( nCount == 0 )

  00004	83 7d 10 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00008	75 04		 jne	 SHORT $LN2@cw_memcpy

; 164  :         return 0;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 3b		 jmp	 SHORT $LN1@cw_memcpy
$LN2@cw_memcpy:

; 165  :     if ( nCount < 0 )

  0000e	83 7d 10 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00012	7d 12		 jge	 SHORT $LN3@cw_memcpy

; 166  :         nCount = cw_strlen( pSrc ) + 1;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _pSrc$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPBD@Z	; cw_strlen
  0001d	83 c4 04	 add	 esp, 4
  00020	83 c0 01	 add	 eax, 1
  00023	89 45 10	 mov	 DWORD PTR _nCount$[ebp], eax
$LN3@cw_memcpy:

; 167  : 
; 168  : #if defined(_M_IX86) || defined(_M_X64)
; 169  :     return MultiByteToWideChar(

  00026	8b f4		 mov	 esi, esp
  00028	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR _pTarget$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  00037	51		 push	 ecx
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@cw_memcpy:

; 170  :         CP_ACP,         // code page
; 171  :         0,              // character-type options
; 172  :         pSrc,           // address of string to map
; 173  :         nCount,         // number of characters in string
; 174  :         pTarget,        // address of wide-character buffer
; 175  :         nCount );       // size of buffer.
; 176  :                         //   This is worst case (no multi-byte chars).
; 177  :                         //   We assume that the caller passed a big enough buffer.
; 178  : 
; 179  : #else
; 180  :     wchar_t* pWide = pTarget;
; 181  :     if ( (DWORD) pWide & 1 )
; 182  :         pWide = new wchar_t[nCount];
; 183  :     nCount = MultiByteToWideChar(
; 184  :         CP_ACP,         // code page
; 185  :         0,              // character-type options
; 186  :         pSrc,           // address of string to map
; 187  :         nCount,         // number of characters in string
; 188  :         pWide,          // address of wide-character buffer
; 189  :         nCount );       // size of buffer.
; 190  :                         //   This is worst case (no multi-byte chars).
; 191  :                         //   We assume that the caller passed a big enough buffer.
; 192  :     if ( pTarget != pWide )
; 193  :     {
; 194  :         cw_memcpy( (char*) pTarget, (const char*) pWide, nCount * sizeof(wchar_t) );
; 195  :         delete [] pWide;
; 196  :     }
; 197  :     return nCount;
; 198  : #endif
; 199  : }

  00049	5e		 pop	 esi
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	5d		 pop	 ebp
  00052	c2 0c 00	 ret	 12			; 0000000cH
?cw_memcpy@@YGHPA_WPBDH@Z ENDP				; cw_memcpy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Develop\OPOS-CCO\Common\CWString.cpp
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_nCount$ = 16						; size = 4
?cw_memcpy@@YGHPADPB_WH@Z PROC				; cw_memcpy

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 208  :     if ( nCount == 0 )

  00004	83 7d 10 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00008	75 04		 jne	 SHORT $LN2@cw_memcpy

; 209  :         return 0;

  0000a	33 c0		 xor	 eax, eax
  0000c	eb 41		 jmp	 SHORT $LN1@cw_memcpy
$LN2@cw_memcpy:

; 210  :     if ( nCount < 0 )

  0000e	83 7d 10 00	 cmp	 DWORD PTR _nCount$[ebp], 0
  00012	7d 12		 jge	 SHORT $LN3@cw_memcpy

; 211  :         nCount = cw_strlen( pSrc ) + 1;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _pSrc$[ebp]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?cw_strlen@@YAHPB_W@Z	; cw_strlen
  0001d	83 c4 04	 add	 esp, 4
  00020	83 c0 01	 add	 eax, 1
  00023	89 45 10	 mov	 DWORD PTR _nCount$[ebp], eax
$LN3@cw_memcpy:

; 212  : 
; 213  : #if defined(_M_IX86) || defined(_M_X64)
; 214  :     return WideCharToMultiByte(

  00026	8b f4		 mov	 esi, esp
  00028	6a 00		 push	 0
  0002a	6a 00		 push	 0
  0002c	8b 4d 10	 mov	 ecx, DWORD PTR _nCount$[ebp]
  0002f	d1 e1		 shl	 ecx, 1
  00031	51		 push	 ecx
  00032	8b 55 08	 mov	 edx, DWORD PTR _pTarget$[ebp]
  00035	52		 push	 edx
  00036	8b 45 10	 mov	 eax, DWORD PTR _nCount$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR _pSrc$[ebp]
  0003d	51		 push	 ecx
  0003e	6a 00		 push	 0
  00040	6a 00		 push	 0
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@cw_memcpy:

; 215  :         CP_ACP,         // code page
; 216  :         0,              // performance and mapping flags
; 217  :         pSrc,           // address of wide character string
; 218  :         nCount,         // number of characters in string
; 219  :         pTarget,        // address of buffer for new string
; 220  :         nCount*2,       // size of buffer
; 221  :                         //   This is worst case (every wide -> multi-byte char).
; 222  :                         //   We assume that the caller passed a big enough buffer.
; 223  :         NULL,           // address of default for unmappable characters
; 224  :         NULL );         // address of flag set when default char.
; 225  : 
; 226  : #else
; 227  :     wchar_t* pWide = (wchar_t*) pSrc;
; 228  :     if ( (DWORD) pWide & 1 )
; 229  :     {
; 230  :         pWide = new wchar_t[nCount];
; 231  :         cw_memcpy( (char*) pWide, (const char*) pSrc, nCount * sizeof(wchar_t) );
; 232  :     }
; 233  :     nCount = WideCharToMultiByte(
; 234  :         CP_ACP,         // code page
; 235  :         0,              // performance and mapping flags
; 236  :         pWide,          // address of wide character string
; 237  :         nCount,         // number of characters in string
; 238  :         pTarget,        // address of buffer for new string
; 239  :         nCount*2,       // size of buffer
; 240  :                         //   This is worst case (every wide -> multi-byte char).
; 241  :                         //   We assume that the caller passed a big enough buffer.
; 242  :         NULL,           // address of default for unmappable characters
; 243  :         NULL );         // address of flag set when default char.
; 244  :     if ( pSrc != pWide )
; 245  :         delete [] pWide;
; 246  :     return nCount;
; 247  : #endif
; 248  : }

  0004f	5e		 pop	 esi
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
?cw_memcpy@@YGHPADPB_WH@Z ENDP				; cw_memcpy
_TEXT	ENDS
END
